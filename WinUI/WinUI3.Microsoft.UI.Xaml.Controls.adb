--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Microsoft.UI.Composition;
with WinUI3.Microsoft.UI.Input;
with WinUI3.Microsoft.UI.Text;
with WinUI3.Microsoft.UI.Xaml.Controls.Primitives;
with WinUI3.Microsoft.UI.Xaml.Data;
with WinUI3.Microsoft.UI.Xaml.Documents;
with WinUI3.Microsoft.UI.Xaml.Input;
with WinUI3.Microsoft.UI.Xaml.Interop;
with WinUI3.Microsoft.UI.Xaml.Media;
with WinUI3.Microsoft.UI.Xaml.Media.Animation;
with WinUI3.Microsoft.UI.Xaml.Navigation;
with WinUI3.Microsoft.Web.WebView2.Core;
with WinUI3.Windows.ApplicationModel.Contacts;
with WinUI3.Windows.ApplicationModel.DataTransfer;
with WinUI3.Windows.Devices.Geolocation;
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with WinUI3.Windows.Globalization;
with WinUI3.Windows.Globalization.NumberFormatting;
with WinUI3.Windows.Media.Casting;
with WinUI3.Windows.Media.Playback;
with WinUI3.Windows.UI;
with WinUI3.Windows.UI.Text;
with WinUI3.Windows.UI.Xaml.Interop;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Microsoft.UI.Xaml.Controls is

   package IVector_IColumnDefinition is new WinUI3.Windows.Foundation.Collections.IVector (IColumnDefinition);
   package IIterable_IColumnDefinition is new WinUI3.Windows.Foundation.Collections.IIterable (IColumnDefinition);
   package IAsyncOperation_ContentDialogResult is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogResult);
   package AsyncOperationCompletedHandler_ContentDialogResult is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogResult);

   package IAsyncOperation_GenericObject is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.GenericObject);
   package AsyncOperationCompletedHandler_GenericObject is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.GenericObject);

   package IAsyncOperation_LoadMoreItemsResult is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.Microsoft.UI.Xaml.Data.LoadMoreItemsResult);
   package AsyncOperationCompletedHandler_LoadMoreItemsResult is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.Microsoft.UI.Xaml.Data.LoadMoreItemsResult);

   package IAsyncOperation_Boolean is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.Boolean);
   package AsyncOperationCompletedHandler_Boolean is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.Boolean);

   package IIterable_IHubSection is new WinUI3.Windows.Foundation.Collections.IIterable (IHubSection);
   package IIterable_IInspectable is new WinUI3.Windows.Foundation.Collections.IIterable (WinUI3.IInspectable);
   package IVector_IRowDefinition is new WinUI3.Windows.Foundation.Collections.IVector (IRowDefinition);
   package IIterable_IRowDefinition is new WinUI3.Windows.Foundation.Collections.IIterable (IRowDefinition);
   package IVector_ISwipeItem is new WinUI3.Windows.Foundation.Collections.IVector (ISwipeItem);
   package IIterable_ISwipeItem is new WinUI3.Windows.Foundation.Collections.IIterable (ISwipeItem);
   package IIterable_IUIElement is new WinUI3.Windows.Foundation.Collections.IIterable (WinUI3.Microsoft.UI.Xaml.IUIElement);
   package IAsyncOperation_HString is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.HString);
   package AsyncOperationCompletedHandler_HString is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.HString);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AnchorRequestedEventArgs

   procedure Initialize (this : in out AnchorRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AnchorRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAnchorRequestedEventArgs, IAnchorRequestedEventArgs_Ptr);
   begin
      if this.m_IAnchorRequestedEventArgs /= null then
         if this.m_IAnchorRequestedEventArgs.all /= null then
            temp := this.m_IAnchorRequestedEventArgs.all.Release;
            Free (this.m_IAnchorRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AnchorRequestedEventArgs

   function get_Anchor
   (
      this : in out AnchorRequestedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IAnchorRequestedEventArgs.all.get_Anchor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Anchor
   (
      this : in out AnchorRequestedEventArgs;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnchorRequestedEventArgs.all.put_Anchor (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AnchorCandidates
   (
      this : in out AnchorRequestedEventArgs
   )
   return IVector_IUIElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IUIElement.Kind;
   begin
      Hr := this.m_IAnchorRequestedEventArgs.all.get_AnchorCandidates (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IUIElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for IconElement

   procedure Initialize (this : in out IconElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out IconElement) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IIconElement, IIconElement_Ptr);
   begin
      if this.m_IIconElement /= null then
         if this.m_IIconElement.all /= null then
            temp := this.m_IIconElement.all.Release;
            Free (this.m_IIconElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for IconElement

   -----------------------------------------------------------------------------
   -- Static Interfaces for IconElement

   function get_ForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IconElement");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IIconElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IIconElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for IconElement

   function get_Foreground
   (
      this : in out IconElement
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IIconElement.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out IconElement;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IIconElement.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AnimatedIcon

   procedure Initialize (this : in out AnimatedIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out AnimatedIcon) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAnimatedIcon, IAnimatedIcon_Ptr);
   begin
      if this.m_IAnimatedIcon /= null then
         if this.m_IAnimatedIcon.all /= null then
            temp := this.m_IAnimatedIcon.all.Release;
            Free (this.m_IAnimatedIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AnimatedIcon

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AnimatedIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAnimatedIcon");
      m_Factory    : access IAnimatedIconFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIcon;
   begin
      return RetVal : AnimatedIcon do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedIconFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAnimatedIcon := new WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIcon;
            Retval.m_IAnimatedIcon.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AnimatedIcon

   function get_StateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetState
   (
      object : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAnimatedIconStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetState (object.m_IDependencyObject.all, HStr_value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_value);
   end;

   function GetState
   (
      object : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAnimatedIconStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetState (object.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_SourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FallbackIconSourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FallbackIconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MirroredWhenRightToLeftProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MirroredWhenRightToLeftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AnimatedIcon

   function get_Source
   (
      this : in out AnimatedIcon
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualSource2 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualSource2;
   begin
      Hr := this.m_IAnimatedIcon.all.get_Source (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Source
   (
      this : in out AnimatedIcon;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualSource2
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedIcon.all.put_Source (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FallbackIconSource
   (
      this : in out AnimatedIcon
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconSource do
         Hr := this.m_IAnimatedIcon.all.get_FallbackIconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_FallbackIconSource
   (
      this : in out AnimatedIcon;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedIcon.all.put_FallbackIconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MirroredWhenRightToLeft
   (
      this : in out AnimatedIcon
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAnimatedIcon.all.get_MirroredWhenRightToLeft (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MirroredWhenRightToLeft
   (
      this : in out AnimatedIcon;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedIcon.all.put_MirroredWhenRightToLeft (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for IconSource

   procedure Initialize (this : in out IconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out IconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IIconSource, IIconSource_Ptr);
   begin
      if this.m_IIconSource /= null then
         if this.m_IIconSource.all /= null then
            temp := this.m_IIconSource.all.Release;
            Free (this.m_IIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for IconSource

   -----------------------------------------------------------------------------
   -- Static Interfaces for IconSource

   function get_ForegroundProperty_IconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for IconSource

   function get_Foreground
   (
      this : in out IconSource
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IIconSource.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out IconSource;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IIconSource.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CreateIconElement
   (
      this : in out IconSource
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_IIconSource.all.CreateIconElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   function CreateIconElementCore
   (
      this : in out IconSource
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IIconSourceOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IIconSource_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IIconSourceOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IIconSourceOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         m_Interface := QInterface (this.m_IIconSource.all);
         Hr := m_Interface.CreateIconElementCore (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   function GetIconElementPropertyCore
   (
      this : in out IconSource;
      iconSourceProperty : WinUI3.Microsoft.UI.Xaml.DependencyProperty'Class
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IIconSourceOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IIconSource_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IIconSourceOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IIconSourceOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         m_Interface := QInterface (this.m_IIconSource.all);
         Hr := m_Interface.GetIconElementPropertyCore (iconSourceProperty.m_IDependencyProperty.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
         Retval.m_IDependencyProperty.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AnimatedIconSource

   procedure Initialize (this : in out AnimatedIconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out AnimatedIconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAnimatedIconSource, IAnimatedIconSource_Ptr);
   begin
      if this.m_IAnimatedIconSource /= null then
         if this.m_IAnimatedIconSource.all /= null then
            temp := this.m_IAnimatedIconSource.all.Release;
            Free (this.m_IAnimatedIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AnimatedIconSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AnimatedIconSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAnimatedIconSource");
      m_Factory    : access IAnimatedIconSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIconSource;
   begin
      return RetVal : AnimatedIconSource do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedIconSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAnimatedIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIconSource;
            Retval.m_IAnimatedIconSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AnimatedIconSource

   function get_SourceProperty_AnimatedIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FallbackIconSourceProperty_AnimatedIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FallbackIconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MirroredWhenRightToLeftProperty_AnimatedIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MirroredWhenRightToLeftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AnimatedIconSource

   function get_Source
   (
      this : in out AnimatedIconSource
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualSource2 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualSource2;
   begin
      Hr := this.m_IAnimatedIconSource.all.get_Source (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Source
   (
      this : in out AnimatedIconSource;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualSource2
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedIconSource.all.put_Source (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FallbackIconSource
   (
      this : in out AnimatedIconSource
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconSource do
         Hr := this.m_IAnimatedIconSource.all.get_FallbackIconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_FallbackIconSource
   (
      this : in out AnimatedIconSource;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedIconSource.all.put_FallbackIconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MirroredWhenRightToLeft
   (
      this : in out AnimatedIconSource
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAnimatedIconSource.all.get_MirroredWhenRightToLeft (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MirroredWhenRightToLeft
   (
      this : in out AnimatedIconSource;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedIconSource.all.put_MirroredWhenRightToLeft (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AnimatedVisualPlayer

   procedure Initialize (this : in out AnimatedVisualPlayer) is
   begin
      null;
   end;

   procedure Finalize (this : in out AnimatedVisualPlayer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAnimatedVisualPlayer, IAnimatedVisualPlayer_Ptr);
   begin
      if this.m_IAnimatedVisualPlayer /= null then
         if this.m_IAnimatedVisualPlayer.all /= null then
            temp := this.m_IAnimatedVisualPlayer.all.Release;
            Free (this.m_IAnimatedVisualPlayer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AnimatedVisualPlayer

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AnimatedVisualPlayer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayer");
      m_Factory    : access IAnimatedVisualPlayerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayer;
   begin
      return RetVal : AnimatedVisualPlayer do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedVisualPlayerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAnimatedVisualPlayer := new WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayer;
            Retval.m_IAnimatedVisualPlayer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AnimatedVisualPlayer

   function get_AutoPlayProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedVisualPlayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoPlayProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DiagnosticsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedVisualPlayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DiagnosticsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DurationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedVisualPlayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DurationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FallbackContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedVisualPlayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FallbackContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsAnimatedVisualLoadedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedVisualPlayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsAnimatedVisualLoadedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPlayingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedVisualPlayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPlayingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaybackRateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedVisualPlayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaybackRateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SourceProperty_AnimatedVisualPlayer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedVisualPlayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedVisualPlayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AnimationOptimizationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnimatedVisualPlayer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnimatedVisualPlayerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AnimationOptimizationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AnimatedVisualPlayer

   function get_Diagnostics
   (
      this : in out AnimatedVisualPlayer
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.get_Diagnostics (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Duration
   (
      this : in out AnimatedVisualPlayer
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.get_Duration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Source
   (
      this : in out AnimatedVisualPlayer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualSource is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualSource;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.get_Source (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Source
   (
      this : in out AnimatedVisualPlayer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualSource
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.put_Source (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FallbackContent
   (
      this : in out AnimatedVisualPlayer
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IAnimatedVisualPlayer.all.get_FallbackContent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_FallbackContent
   (
      this : in out AnimatedVisualPlayer;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.put_FallbackContent (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AutoPlay
   (
      this : in out AnimatedVisualPlayer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.get_AutoPlay (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutoPlay
   (
      this : in out AnimatedVisualPlayer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.put_AutoPlay (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsAnimatedVisualLoaded
   (
      this : in out AnimatedVisualPlayer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.get_IsAnimatedVisualLoaded (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsPlaying
   (
      this : in out AnimatedVisualPlayer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.get_IsPlaying (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PlaybackRate
   (
      this : in out AnimatedVisualPlayer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.get_PlaybackRate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PlaybackRate
   (
      this : in out AnimatedVisualPlayer;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.put_PlaybackRate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ProgressObject
   (
      this : in out AnimatedVisualPlayer
   )
   return WinUI3.Microsoft.UI.Composition.CompositionObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.ICompositionObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.CompositionObject do
         Hr := this.m_IAnimatedVisualPlayer.all.get_ProgressObject (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionObject := new WinUI3.Microsoft.UI.Composition.ICompositionObject;
         Retval.m_ICompositionObject.all := m_ComRetVal;
      end return;
   end;

   function get_Stretch
   (
      this : in out AnimatedVisualPlayer
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.Stretch;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out AnimatedVisualPlayer;
      value : WinUI3.Microsoft.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Pause
   (
      this : in out AnimatedVisualPlayer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.Pause;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PlayAsync
   (
      this : in out AnimatedVisualPlayer;
      fromProgress : WinUI3.Double;
      toProgress : WinUI3.Double;
      looped : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IAnimatedVisualPlayer.all.PlayAsync (fromProgress, toProgress, looped, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   procedure Resume
   (
      this : in out AnimatedVisualPlayer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.Resume;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetProgress
   (
      this : in out AnimatedVisualPlayer;
      progress : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.SetProgress (progress);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out AnimatedVisualPlayer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnimatedVisualPlayer.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AnimationOptimization
   (
      this : in out AnimatedVisualPlayer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PlayerAnimationOptimization is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayer2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.PlayerAnimationOptimization;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayer_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayer2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IAnimatedVisualPlayer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAnimatedVisualPlayer.all);
      Hr := m_Interface.get_AnimationOptimization (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AnimationOptimization
   (
      this : in out AnimatedVisualPlayer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.PlayerAnimationOptimization
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayer2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayer_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IAnimatedVisualPlayer2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IAnimatedVisualPlayer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAnimatedVisualPlayer.all);
      Hr := m_Interface.put_AnimationOptimization (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Control

   procedure Initialize (this : in out Control) is
   begin
      null;
   end;

   procedure Finalize (this : in out Control) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IControl, IControl_Ptr);
   begin
      if this.m_IControl /= null then
         if this.m_IControl.all /= null then
            temp := this.m_IControl.all.Release;
            Free (this.m_IControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Control

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Control is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IControl");
      m_Factory    : access IControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IControl;
   begin
      return RetVal : Control do
         Hr := RoGetActivationFactory (m_hString, IID_IControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IControl := new WinUI3.Microsoft.UI.Xaml.Controls.IControl;
            Retval.m_IControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Control

   function get_IsFocusEngagementEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFocusEngagementEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFocusEngagedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFocusEngagedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RequiresPointerProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RequiresPointerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontSizeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStretchProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterSpacingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForegroundProperty_Control
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextScaleFactorEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabNavigationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabNavigationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalContentAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalContentAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundSizingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultStyleKeyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultStyleKeyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultStyleResourceUriProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultStyleResourceUriProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ElementSoundModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ElementSoundModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTemplateFocusTargetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTemplateFocusTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsTemplateFocusTarget
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsTemplateFocusTarget (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsTemplateFocusTarget
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsTemplateFocusTarget (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsTemplateKeyTipTargetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTemplateKeyTipTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsTemplateKeyTipTarget
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsTemplateKeyTipTarget (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsTemplateKeyTipTarget
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsTemplateKeyTipTarget (element.m_IDependencyObject.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Control

   function get_IsFocusEngagementEnabled
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IControl.all.get_IsFocusEngagementEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFocusEngagementEnabled
   (
      this : in out Control;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_IsFocusEngagementEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFocusEngaged
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IControl.all.get_IsFocusEngaged (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFocusEngaged
   (
      this : in out Control;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_IsFocusEngaged (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RequiresPointer
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RequiresPointer is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.RequiresPointer;
   begin
      Hr := this.m_IControl.all.get_RequiresPointer (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RequiresPointer
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RequiresPointer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_RequiresPointer (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontSize
   (
      this : in out Control
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IControl.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out Control;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.FontFamily do
         Hr := this.m_IControl.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_IControl.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_IControl.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStretch
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Text.FontStretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStretch;
   begin
      Hr := this.m_IControl.all.get_FontStretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStretch
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Text.FontStretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_FontStretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterSpacing
   (
      this : in out Control
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IControl.all.get_CharacterSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterSpacing
   (
      this : in out Control;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_CharacterSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Foreground
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IControl.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IControl.all.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out Control;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_IsTextScaleFactorEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsEnabled
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IControl.all.get_IsEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsEnabled
   (
      this : in out Control;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_IsEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabNavigation
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.Input.KeyboardNavigationMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.KeyboardNavigationMode;
   begin
      Hr := this.m_IControl.all.get_TabNavigation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TabNavigation
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.Input.KeyboardNavigationMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_TabNavigation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Template
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ControlTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IControlTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ControlTemplate do
         Hr := this.m_IControl.all.get_Template (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IControlTemplate := new WinUI3.Microsoft.UI.Xaml.Controls.IControlTemplate;
         Retval.m_IControlTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_Template
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ControlTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_Template (value.m_IControlTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IControl.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalContentAlignment
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_IControl.all.get_HorizontalContentAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalContentAlignment
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_HorizontalContentAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalContentAlignment
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_IControl.all.get_VerticalContentAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalContentAlignment
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_VerticalContentAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Background
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IControl.all.get_Background (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_Background (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundSizing
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing;
   begin
      Hr := this.m_IControl.all.get_BackgroundSizing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_BackgroundSizing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IControl.all.get_BorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_BorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderBrush
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IControl.all.get_BorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_BorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DefaultStyleResourceUri
   (
      this : in out Control
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IControl.all.get_DefaultStyleResourceUri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_DefaultStyleResourceUri
   (
      this : in out Control;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_DefaultStyleResourceUri (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ElementSoundMode
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.ElementSoundMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.ElementSoundMode;
   begin
      Hr := this.m_IControl.all.get_ElementSoundMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ElementSoundMode
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.ElementSoundMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_ElementSoundMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out Control
   )
   return WinUI3.Microsoft.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_IControl.all.get_CornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out Control;
      value : WinUI3.Microsoft.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_CornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_FocusEngaged
   (
      this : in out Control;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IControl.all.add_FocusEngaged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_FocusEngaged
   (
      this : in out Control;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.remove_FocusEngaged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_FocusDisengaged
   (
      this : in out Control;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IControl.all.add_FocusDisengaged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_FocusDisengaged
   (
      this : in out Control;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.remove_FocusDisengaged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_IsEnabledChanged
   (
      this : in out Control;
      handler : WinUI3.Microsoft.UI.Xaml.DependencyPropertyChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IControl.all.add_IsEnabledChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsEnabledChanged
   (
      this : in out Control;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.remove_IsEnabledChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveFocusEngagement
   (
      this : in out Control
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.RemoveFocusEngagement;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ApplyTemplate
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IControl.all.ApplyTemplate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DefaultStyleKey
   (
      this : in out Control
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlProtected := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlProtected, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.get_DefaultStyleKey (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultStyleKey
   (
      this : in out Control;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlProtected, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_DefaultStyleKey (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetTemplateChild
   (
      this : in out Control;
      childName : WinUI3.WString
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlProtected := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
      HStr_childName : constant WinUI3.HString := To_HString (childName);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlProtected, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlProtected'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IControl.all);
         Hr := m_Interface.GetTemplateChild (HStr_childName, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
         tmp := WindowsDeleteString (HStr_childName);
      end return;
   end;

   procedure OnPointerEntered
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerEntered (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerPressed
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerPressed (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerMoved
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerMoved (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerReleased
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerReleased (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerExited
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerExited (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerCaptureLost
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerCaptureLost (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerCanceled
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerCanceled (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerWheelChanged
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerWheelChanged (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnTapped
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.TappedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnTapped (e.m_ITappedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDoubleTapped
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.DoubleTappedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnDoubleTapped (e.m_IDoubleTappedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnHolding
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.HoldingRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnHolding (e.m_IHoldingRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnRightTapped
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.RightTappedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnRightTapped (e.m_IRightTappedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnManipulationStarting
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.ManipulationStartingRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnManipulationStarting (e.m_IManipulationStartingRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnManipulationInertiaStarting
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnManipulationInertiaStarting (e.m_IManipulationInertiaStartingRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnManipulationStarted
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.ManipulationStartedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnManipulationStarted (e.m_IManipulationStartedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnManipulationDelta
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnManipulationDelta (e.m_IManipulationDeltaRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnManipulationCompleted
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnManipulationCompleted (e.m_IManipulationCompletedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnKeyUp
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.KeyRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnKeyUp (e.m_IKeyRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnKeyDown
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.KeyRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnKeyDown (e.m_IKeyRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPreviewKeyDown
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.KeyRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPreviewKeyDown (e.m_IKeyRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPreviewKeyUp
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.KeyRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPreviewKeyUp (e.m_IKeyRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnGotFocus
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.RoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnGotFocus (e.m_IRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnLostFocus
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.RoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnLostFocus (e.m_IRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnCharacterReceived
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.Input.CharacterReceivedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnCharacterReceived (e.m_ICharacterReceivedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDragEnter
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.DragEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnDragEnter (e.m_IDragEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDragLeave
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.DragEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnDragLeave (e.m_IDragEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDragOver
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.DragEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnDragOver (e.m_IDragEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDrop
   (
      this : in out Control;
      e : WinUI3.Microsoft.UI.Xaml.DragEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnDrop (e.m_IDragEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AnnotatedScrollBar

   procedure Initialize (this : in out AnnotatedScrollBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out AnnotatedScrollBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAnnotatedScrollBar, IAnnotatedScrollBar_Ptr);
   begin
      if this.m_IAnnotatedScrollBar /= null then
         if this.m_IAnnotatedScrollBar.all /= null then
            temp := this.m_IAnnotatedScrollBar.all.Release;
            Free (this.m_IAnnotatedScrollBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AnnotatedScrollBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AnnotatedScrollBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAnnotatedScrollBar");
      m_Factory    : access IAnnotatedScrollBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAnnotatedScrollBar;
   begin
      return RetVal : AnnotatedScrollBar do
         Hr := RoGetActivationFactory (m_hString, IID_IAnnotatedScrollBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAnnotatedScrollBar := new WinUI3.Microsoft.UI.Xaml.Controls.IAnnotatedScrollBar;
            Retval.m_IAnnotatedScrollBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AnnotatedScrollBar

   function get_LabelsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnnotatedScrollBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnnotatedScrollBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnnotatedScrollBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LabelsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LabelTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnnotatedScrollBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnnotatedScrollBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnnotatedScrollBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LabelTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DetailLabelTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnnotatedScrollBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnnotatedScrollBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnnotatedScrollBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DetailLabelTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SmallChangeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AnnotatedScrollBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAnnotatedScrollBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAnnotatedScrollBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SmallChangeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AnnotatedScrollBar

   function get_ScrollController
   (
      this : in out AnnotatedScrollBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollController is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollController;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.get_ScrollController (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Labels
   (
      this : in out AnnotatedScrollBar
   )
   return IVector_IAnnotatedScrollBarLabel.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IAnnotatedScrollBarLabel.Kind;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.get_Labels (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IAnnotatedScrollBarLabel (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_Labels
   (
      this : in out AnnotatedScrollBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.put_Labels (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LabelTemplate
   (
      this : in out AnnotatedScrollBar
   )
   return WinUI3.Microsoft.UI.Xaml.IElementFactory is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IElementFactory;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.get_LabelTemplate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LabelTemplate
   (
      this : in out AnnotatedScrollBar;
      value : WinUI3.Microsoft.UI.Xaml.IElementFactory
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.put_LabelTemplate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DetailLabelTemplate
   (
      this : in out AnnotatedScrollBar
   )
   return WinUI3.Microsoft.UI.Xaml.IElementFactory is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IElementFactory;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.get_DetailLabelTemplate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DetailLabelTemplate
   (
      this : in out AnnotatedScrollBar;
      value : WinUI3.Microsoft.UI.Xaml.IElementFactory
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.put_DetailLabelTemplate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SmallChange
   (
      this : in out AnnotatedScrollBar
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.get_SmallChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SmallChange
   (
      this : in out AnnotatedScrollBar;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.put_SmallChange (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Scrolling
   (
      this : in out AnnotatedScrollBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.add_Scrolling (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Scrolling
   (
      this : in out AnnotatedScrollBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.remove_Scrolling (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DetailLabelRequested
   (
      this : in out AnnotatedScrollBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.add_DetailLabelRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DetailLabelRequested
   (
      this : in out AnnotatedScrollBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnnotatedScrollBar.all.remove_DetailLabelRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AnnotatedScrollBarDetailLabelRequestedEventArgs

   procedure Initialize (this : in out AnnotatedScrollBarDetailLabelRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AnnotatedScrollBarDetailLabelRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAnnotatedScrollBarDetailLabelRequestedEventArgs, IAnnotatedScrollBarDetailLabelRequestedEventArgs_Ptr);
   begin
      if this.m_IAnnotatedScrollBarDetailLabelRequestedEventArgs /= null then
         if this.m_IAnnotatedScrollBarDetailLabelRequestedEventArgs.all /= null then
            temp := this.m_IAnnotatedScrollBarDetailLabelRequestedEventArgs.all.Release;
            Free (this.m_IAnnotatedScrollBarDetailLabelRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AnnotatedScrollBarDetailLabelRequestedEventArgs

   function get_Content
   (
      this : in out AnnotatedScrollBarDetailLabelRequestedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IAnnotatedScrollBarDetailLabelRequestedEventArgs.all.get_Content (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Content
   (
      this : in out AnnotatedScrollBarDetailLabelRequestedEventArgs;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnnotatedScrollBarDetailLabelRequestedEventArgs.all.put_Content (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScrollOffset
   (
      this : in out AnnotatedScrollBarDetailLabelRequestedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAnnotatedScrollBarDetailLabelRequestedEventArgs.all.get_ScrollOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AnnotatedScrollBarLabel

   procedure Initialize (this : in out AnnotatedScrollBarLabel) is
   begin
      null;
   end;

   procedure Finalize (this : in out AnnotatedScrollBarLabel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAnnotatedScrollBarLabel, IAnnotatedScrollBarLabel_Ptr);
   begin
      if this.m_IAnnotatedScrollBarLabel /= null then
         if this.m_IAnnotatedScrollBarLabel.all /= null then
            temp := this.m_IAnnotatedScrollBarLabel.all.Release;
            Free (this.m_IAnnotatedScrollBarLabel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AnnotatedScrollBarLabel

   function Constructor
   (
      content : WinUI3.IInspectable;
      scrollOffset : WinUI3.Double
   )
   return AnnotatedScrollBarLabel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAnnotatedScrollBarLabel");
      m_Factory    : access IAnnotatedScrollBarLabelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAnnotatedScrollBarLabel;
   begin
      return RetVal : AnnotatedScrollBarLabel do
         Hr := RoGetActivationFactory (m_hString, IID_IAnnotatedScrollBarLabelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (content, scrollOffset, m_ComRetVal'Access);
            Retval.m_IAnnotatedScrollBarLabel := new WinUI3.Microsoft.UI.Xaml.Controls.IAnnotatedScrollBarLabel;
            Retval.m_IAnnotatedScrollBarLabel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AnnotatedScrollBarLabel

   function get_Content
   (
      this : in out AnnotatedScrollBarLabel
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IAnnotatedScrollBarLabel.all.get_Content (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollOffset
   (
      this : in out AnnotatedScrollBarLabel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAnnotatedScrollBarLabel.all.get_ScrollOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AnnotatedScrollBarScrollingEventArgs

   procedure Initialize (this : in out AnnotatedScrollBarScrollingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AnnotatedScrollBarScrollingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAnnotatedScrollBarScrollingEventArgs, IAnnotatedScrollBarScrollingEventArgs_Ptr);
   begin
      if this.m_IAnnotatedScrollBarScrollingEventArgs /= null then
         if this.m_IAnnotatedScrollBarScrollingEventArgs.all /= null then
            temp := this.m_IAnnotatedScrollBarScrollingEventArgs.all.Release;
            Free (this.m_IAnnotatedScrollBarScrollingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AnnotatedScrollBarScrollingEventArgs

   function get_ScrollOffset
   (
      this : in out AnnotatedScrollBarScrollingEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAnnotatedScrollBarScrollingEventArgs.all.get_ScrollOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollingEventKind
   (
      this : in out AnnotatedScrollBarScrollingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.AnnotatedScrollBarScrollingEventKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.AnnotatedScrollBarScrollingEventKind;
   begin
      Hr := this.m_IAnnotatedScrollBarScrollingEventArgs.all.get_ScrollingEventKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out AnnotatedScrollBarScrollingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAnnotatedScrollBarScrollingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out AnnotatedScrollBarScrollingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnnotatedScrollBarScrollingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentControl

   procedure Initialize (this : in out ContentControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentControl, IContentControl_Ptr);
   begin
      if this.m_IContentControl /= null then
         if this.m_IContentControl.all /= null then
            temp := this.m_IContentControl.all.Release;
            Free (this.m_IContentControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContentControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ContentControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IContentControl");
      m_Factory    : access IContentControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IContentControl;
   begin
      return RetVal : ContentControl do
         Hr := RoGetActivationFactory (m_hString, IID_IContentControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IContentControl := new WinUI3.Microsoft.UI.Xaml.Controls.IContentControl;
            Retval.m_IContentControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ContentControl

   function get_ContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTemplateSelectorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTransitionsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentControl

   function get_Content
   (
      this : in out ContentControl
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContentControl.all.get_Content (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Content
   (
      this : in out ContentControl;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentControl.all.put_Content (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplate
   (
      this : in out ContentControl
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IContentControl.all.get_ContentTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTemplate
   (
      this : in out ContentControl;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentControl.all.put_ContentTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplateSelector
   (
      this : in out ContentControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_IContentControl.all.get_ContentTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTemplateSelector
   (
      this : in out ContentControl;
      value : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentControl.all.put_ContentTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTransitions
   (
      this : in out ContentControl
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IContentControl.all.get_ContentTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTransitions
   (
      this : in out ContentControl;
      value : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentControl.all.put_ContentTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplateRoot
   (
      this : in out ContentControl
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IContentControl.all.get_ContentTemplateRoot (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure OnContentChanged
   (
      this : in out ContentControl;
      oldContent : WinUI3.IInspectable;
      newContent : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IContentControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IContentControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IContentControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IContentControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentControl.all);
      Hr := m_Interface.OnContentChanged (oldContent, newContent);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnContentTemplateChanged
   (
      this : in out ContentControl;
      oldContentTemplate : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class;
      newContentTemplate : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IContentControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IContentControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IContentControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IContentControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentControl.all);
      Hr := m_Interface.OnContentTemplateChanged (oldContentTemplate.m_IDataTemplate.all, newContentTemplate.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnContentTemplateSelectorChanged
   (
      this : in out ContentControl;
      oldContentTemplateSelector : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class;
      newContentTemplateSelector : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IContentControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IContentControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IContentControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IContentControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentControl.all);
      Hr := m_Interface.OnContentTemplateSelectorChanged (oldContentTemplateSelector.m_IDataTemplateSelector.all, newContentTemplateSelector.m_IDataTemplateSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBar

   procedure Initialize (this : in out AppBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBar, IAppBar_Ptr);
   begin
      if this.m_IAppBar /= null then
         if this.m_IAppBar.all /= null then
            temp := this.m_IAppBar.all.Release;
            Free (this.m_IAppBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AppBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAppBar");
      m_Factory    : access IAppBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAppBar;
   begin
      return RetVal : AppBar do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAppBar := new WinUI3.Microsoft.UI.Xaml.Controls.IAppBar;
            Retval.m_IAppBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppBar

   function get_IsOpenProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsStickyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStickyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClosedDisplayModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClosedDisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBar

   function get_IsOpen
   (
      this : in out AppBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppBar.all.get_IsOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOpen
   (
      this : in out AppBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.put_IsOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSticky
   (
      this : in out AppBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppBar.all.get_IsSticky (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSticky
   (
      this : in out AppBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.put_IsSticky (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ClosedDisplayMode
   (
      this : in out AppBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.AppBarClosedDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.AppBarClosedDisplayMode;
   begin
      Hr := this.m_IAppBar.all.get_ClosedDisplayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ClosedDisplayMode
   (
      this : in out AppBar;
      value : WinUI3.Microsoft.UI.Xaml.Controls.AppBarClosedDisplayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.put_ClosedDisplayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out AppBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IAppBarTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.AppBarTemplateSettings do
         Hr := this.m_IAppBar.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppBarTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IAppBarTemplateSettings;
         Retval.m_IAppBarTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out AppBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode;
   begin
      Hr := this.m_IAppBar.all.get_LightDismissOverlayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out AppBar;
      value : WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.put_LightDismissOverlayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opening
   (
      this : in out AppBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppBar.all.add_Opening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opening
   (
      this : in out AppBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.remove_Opening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opened
   (
      this : in out AppBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppBar.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out AppBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closing
   (
      this : in out AppBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppBar.all.add_Closing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closing
   (
      this : in out AppBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.remove_Closing (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out AppBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppBar.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out AppBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnClosed
   (
      this : in out AppBar;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IAppBarOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IAppBarOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IAppBarOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.OnClosed (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnOpened
   (
      this : in out AppBar;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IAppBarOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IAppBarOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IAppBarOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.OnOpened (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnClosing
   (
      this : in out AppBar;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IAppBarOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IAppBarOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IAppBarOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.OnClosing (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnOpening
   (
      this : in out AppBar;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IAppBarOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IAppBarOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IAppBarOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.OnOpening (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Button

   procedure Initialize (this : in out Button) is
   begin
      null;
   end;

   procedure Finalize (this : in out Button) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IButton, IButton_Ptr);
   begin
      if this.m_IButton /= null then
         if this.m_IButton.all /= null then
            temp := this.m_IButton.all.Release;
            Free (this.m_IButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Button

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Button is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IButton");
      m_Factory    : access IButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IButton;
   begin
      return RetVal : Button do
         Hr := RoGetActivationFactory (m_hString, IID_IButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IButton := new WinUI3.Microsoft.UI.Xaml.Controls.IButton;
            Retval.m_IButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Button

   function get_FlyoutProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Button");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Button

   function get_Flyout
   (
      this : in out Button
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := this.m_IButton.all.get_Flyout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_Flyout
   (
      this : in out Button;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IButton.all.put_Flyout (value.m_IFlyoutBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBarButton

   procedure Initialize (this : in out AppBarButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBarButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBarButton, IAppBarButton_Ptr);
   begin
      if this.m_IAppBarButton /= null then
         if this.m_IAppBarButton.all /= null then
            temp := this.m_IAppBarButton.all.Release;
            Free (this.m_IAppBarButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppBarButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AppBarButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAppBarButton");
      m_Factory    : access IAppBarButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButton;
   begin
      return RetVal : AppBarButton do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAppBarButton := new WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButton;
            Retval.m_IAppBarButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppBarButton

   function get_LabelProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LabelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LabelPositionProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LabelPositionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyboardAcceleratorTextOverrideProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyboardAcceleratorTextOverrideProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCompactProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsInOverflowProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsInOverflowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DynamicOverflowOrderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DynamicOverflowOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBarButton

   function get_Label
   (
      this : in out AppBarButton
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAppBarButton.all.get_Label (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Label
   (
      this : in out AppBarButton;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAppBarButton.all.put_Label (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Icon
   (
      this : in out AppBarButton
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_IAppBarButton.all.get_Icon (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out AppBarButton;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBarButton.all.put_Icon (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LabelPosition
   (
      this : in out AppBarButton
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CommandBarLabelPosition is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CommandBarLabelPosition;
   begin
      Hr := this.m_IAppBarButton.all.get_LabelPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LabelPosition
   (
      this : in out AppBarButton;
      value : WinUI3.Microsoft.UI.Xaml.Controls.CommandBarLabelPosition
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBarButton.all.put_LabelPosition (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyboardAcceleratorTextOverride
   (
      this : in out AppBarButton
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAppBarButton.all.get_KeyboardAcceleratorTextOverride (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_KeyboardAcceleratorTextOverride
   (
      this : in out AppBarButton;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAppBarButton.all.put_KeyboardAcceleratorTextOverride (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_TemplateSettings
   (
      this : in out AppBarButton
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.AppBarButtonTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IAppBarButtonTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.AppBarButtonTemplateSettings do
         Hr := this.m_IAppBarButton.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppBarButtonTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IAppBarButtonTemplateSettings;
         Retval.m_IAppBarButtonTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_IsCompact
   (
      this : in out AppBarButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.get_IsCompact (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompact
   (
      this : in out AppBarButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.put_IsCompact (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInOverflow
   (
      this : in out AppBarButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.get_IsInOverflow (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DynamicOverflowOrder
   (
      this : in out AppBarButton
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.get_DynamicOverflowOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DynamicOverflowOrder
   (
      this : in out AppBarButton;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.put_DynamicOverflowOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBarElementContainer

   procedure Initialize (this : in out AppBarElementContainer) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBarElementContainer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBarElementContainer, IAppBarElementContainer_Ptr);
   begin
      if this.m_IAppBarElementContainer /= null then
         if this.m_IAppBarElementContainer.all /= null then
            temp := this.m_IAppBarElementContainer.all.Release;
            Free (this.m_IAppBarElementContainer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppBarElementContainer

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AppBarElementContainer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAppBarElementContainer");
      m_Factory    : access IAppBarElementContainerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAppBarElementContainer;
   begin
      return RetVal : AppBarElementContainer do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarElementContainerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAppBarElementContainer := new WinUI3.Microsoft.UI.Xaml.Controls.IAppBarElementContainer;
            Retval.m_IAppBarElementContainer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppBarElementContainer

   function get_IsCompactProperty_AppBarElementContainer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarElementContainer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarElementContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarElementContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsInOverflowProperty_AppBarElementContainer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarElementContainer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarElementContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarElementContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsInOverflowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DynamicOverflowOrderProperty_AppBarElementContainer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarElementContainer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarElementContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarElementContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DynamicOverflowOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBarElementContainer

   function get_IsCompact
   (
      this : in out AppBarElementContainer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarElementContainer_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarElementContainer.all);
      Hr := m_Interface.get_IsCompact (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompact
   (
      this : in out AppBarElementContainer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarElementContainer_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarElementContainer.all);
      Hr := m_Interface.put_IsCompact (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInOverflow
   (
      this : in out AppBarElementContainer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarElementContainer_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarElementContainer.all);
      Hr := m_Interface.get_IsInOverflow (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DynamicOverflowOrder
   (
      this : in out AppBarElementContainer
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarElementContainer_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarElementContainer.all);
      Hr := m_Interface.get_DynamicOverflowOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DynamicOverflowOrder
   (
      this : in out AppBarElementContainer;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarElementContainer_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarElementContainer.all);
      Hr := m_Interface.put_DynamicOverflowOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBarSeparator

   procedure Initialize (this : in out AppBarSeparator) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBarSeparator) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBarSeparator, IAppBarSeparator_Ptr);
   begin
      if this.m_IAppBarSeparator /= null then
         if this.m_IAppBarSeparator.all /= null then
            temp := this.m_IAppBarSeparator.all.Release;
            Free (this.m_IAppBarSeparator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppBarSeparator

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AppBarSeparator is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAppBarSeparator");
      m_Factory    : access IAppBarSeparatorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAppBarSeparator;
   begin
      return RetVal : AppBarSeparator do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarSeparatorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAppBarSeparator := new WinUI3.Microsoft.UI.Xaml.Controls.IAppBarSeparator;
            Retval.m_IAppBarSeparator.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppBarSeparator

   function get_IsCompactProperty_AppBarSeparator
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarSeparator");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarSeparatorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarSeparatorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsInOverflowProperty_AppBarSeparator
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarSeparator");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarSeparatorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarSeparatorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsInOverflowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DynamicOverflowOrderProperty_AppBarSeparator
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarSeparator");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarSeparatorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarSeparatorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DynamicOverflowOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBarSeparator

   function get_IsCompact
   (
      this : in out AppBarSeparator
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarSeparator_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarSeparator.all);
      Hr := m_Interface.get_IsCompact (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompact
   (
      this : in out AppBarSeparator;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarSeparator_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarSeparator.all);
      Hr := m_Interface.put_IsCompact (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInOverflow
   (
      this : in out AppBarSeparator
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarSeparator_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarSeparator.all);
      Hr := m_Interface.get_IsInOverflow (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DynamicOverflowOrder
   (
      this : in out AppBarSeparator
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarSeparator_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarSeparator.all);
      Hr := m_Interface.get_DynamicOverflowOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DynamicOverflowOrder
   (
      this : in out AppBarSeparator;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarSeparator_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarSeparator.all);
      Hr := m_Interface.put_DynamicOverflowOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBarToggleButton

   procedure Initialize (this : in out AppBarToggleButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBarToggleButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBarToggleButton, IAppBarToggleButton_Ptr);
   begin
      if this.m_IAppBarToggleButton /= null then
         if this.m_IAppBarToggleButton.all /= null then
            temp := this.m_IAppBarToggleButton.all.Release;
            Free (this.m_IAppBarToggleButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppBarToggleButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AppBarToggleButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAppBarToggleButton");
      m_Factory    : access IAppBarToggleButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButton;
   begin
      return RetVal : AppBarToggleButton do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAppBarToggleButton := new WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButton;
            Retval.m_IAppBarToggleButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppBarToggleButton

   function get_LabelProperty_AppBarToggleButton
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LabelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty_AppBarToggleButton
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LabelPositionProperty_AppBarToggleButton
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LabelPositionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyboardAcceleratorTextOverrideProperty_AppBarToggleButton
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyboardAcceleratorTextOverrideProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCompactProperty_AppBarToggleButton
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsInOverflowProperty_AppBarToggleButton
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsInOverflowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DynamicOverflowOrderProperty_AppBarToggleButton
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DynamicOverflowOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBarToggleButton

   function get_Label
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAppBarToggleButton.all.get_Label (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Label
   (
      this : in out AppBarToggleButton;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAppBarToggleButton.all.put_Label (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Icon
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_IAppBarToggleButton.all.get_Icon (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out AppBarToggleButton;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBarToggleButton.all.put_Icon (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LabelPosition
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CommandBarLabelPosition is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CommandBarLabelPosition;
   begin
      Hr := this.m_IAppBarToggleButton.all.get_LabelPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LabelPosition
   (
      this : in out AppBarToggleButton;
      value : WinUI3.Microsoft.UI.Xaml.Controls.CommandBarLabelPosition
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBarToggleButton.all.put_LabelPosition (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyboardAcceleratorTextOverride
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAppBarToggleButton.all.get_KeyboardAcceleratorTextOverride (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_KeyboardAcceleratorTextOverride
   (
      this : in out AppBarToggleButton;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAppBarToggleButton.all.put_KeyboardAcceleratorTextOverride (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_TemplateSettings
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.AppBarToggleButtonTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IAppBarToggleButtonTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.AppBarToggleButtonTemplateSettings do
         Hr := this.m_IAppBarToggleButton.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppBarToggleButtonTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IAppBarToggleButtonTemplateSettings;
         Retval.m_IAppBarToggleButtonTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_IsCompact
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.get_IsCompact (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompact
   (
      this : in out AppBarToggleButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.put_IsCompact (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInOverflow
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.get_IsInOverflow (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DynamicOverflowOrder
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.get_DynamicOverflowOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DynamicOverflowOrder
   (
      this : in out AppBarToggleButton;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarElement, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.put_DynamicOverflowOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsControl

   procedure Initialize (this : in out ItemsControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsControl, IItemsControl_Ptr);
   begin
      if this.m_IItemsControl /= null then
         if this.m_IItemsControl.all /= null then
            temp := this.m_IItemsControl.all.Release;
            Free (this.m_IItemsControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ItemsControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemsControl");
      m_Factory    : access IItemsControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl;
   begin
      return RetVal : ItemsControl do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IItemsControl := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl;
            Retval.m_IItemsControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ItemsControl

   function get_ItemsSourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateSelectorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsPanelProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayMemberPathProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayMemberPathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerStyleSelectorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerStyleSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerTransitionsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GroupStyleSelectorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupStyleSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsGroupingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsGroupingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetItemsOwner
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemsControl is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemsControl do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetItemsOwner (element.m_IDependencyObject.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IItemsControl := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl;
            Retval.m_IItemsControl.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function ItemsControlFromItemContainer
   (
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemsControl is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemsControl do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.ItemsControlFromItemContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IItemsControl := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl;
            Retval.m_IItemsControl.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsControl

   function get_ItemsSource
   (
      this : in out ItemsControl
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemsControl.all.get_ItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out ItemsControl;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Items
   (
      this : in out ItemsControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollection do
         Hr := this.m_IItemsControl.all.get_Items (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_ItemTemplate
   (
      this : in out ItemsControl
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IItemsControl.all.get_ItemTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplate
   (
      this : in out ItemsControl;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTemplateSelector
   (
      this : in out ItemsControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_IItemsControl.all.get_ItemTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplateSelector
   (
      this : in out ItemsControl;
      value : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsPanel
   (
      this : in out ItemsControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemsPanelTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsPanelTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemsPanelTemplate do
         Hr := this.m_IItemsControl.all.get_ItemsPanel (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemsPanelTemplate := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsPanelTemplate;
         Retval.m_IItemsPanelTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemsPanel
   (
      this : in out ItemsControl;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ItemsPanelTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemsPanel (value.m_IItemsPanelTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMemberPath
   (
      this : in out ItemsControl
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IItemsControl.all.get_DisplayMemberPath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DisplayMemberPath
   (
      this : in out ItemsControl;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IItemsControl.all.put_DisplayMemberPath (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ItemsPanelRoot
   (
      this : in out ItemsControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Panel'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPanel;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Panel do
         Hr := this.m_IItemsControl.all.get_ItemsPanelRoot (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPanel := new WinUI3.Microsoft.UI.Xaml.Controls.IPanel;
         Retval.m_IPanel.all := m_ComRetVal;
      end return;
   end;

   function get_ItemContainerStyle
   (
      this : in out ItemsControl
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IItemsControl.all.get_ItemContainerStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerStyle
   (
      this : in out ItemsControl;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemContainerStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemContainerStyleSelector
   (
      this : in out ItemsControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelector;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector do
         Hr := this.m_IItemsControl.all.get_ItemContainerStyleSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyleSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelector;
         Retval.m_IStyleSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerStyleSelector
   (
      this : in out ItemsControl;
      value : WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemContainerStyleSelector (value.m_IStyleSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemContainerGenerator
   (
      this : in out ItemsControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemContainerGenerator'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerGenerator;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemContainerGenerator do
         Hr := this.m_IItemsControl.all.get_ItemContainerGenerator (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemContainerGenerator := new WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerGenerator;
         Retval.m_IItemContainerGenerator.all := m_ComRetVal;
      end return;
   end;

   function get_ItemContainerTransitions
   (
      this : in out ItemsControl
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IItemsControl.all.get_ItemContainerTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerTransitions
   (
      this : in out ItemsControl;
      value : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemContainerTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GroupStyle
   (
      this : in out ItemsControl
   )
   return IObservableVector_IGroupStyle.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_IGroupStyle.Kind;
   begin
      Hr := this.m_IItemsControl.all.get_GroupStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_IGroupStyle (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_GroupStyleSelector
   (
      this : in out ItemsControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.GroupStyleSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyleSelector;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.GroupStyleSelector do
         Hr := this.m_IItemsControl.all.get_GroupStyleSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGroupStyleSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyleSelector;
         Retval.m_IGroupStyleSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_GroupStyleSelector
   (
      this : in out ItemsControl;
      value : WinUI3.Microsoft.UI.Xaml.Controls.GroupStyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_GroupStyleSelector (value.m_IGroupStyleSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsGrouping
   (
      this : in out ItemsControl
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IItemsControl.all.get_IsGrouping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GroupHeaderContainerFromItemContainer
   (
      this : in out ItemsControl;
      itemContainer_p : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         Hr := this.m_IItemsControl.all.GroupHeaderContainerFromItemContainer (itemContainer_p.m_IDependencyObject.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function IsItemItsOwnContainerOverride
   (
      this : in out ItemsControl;
      item : WinUI3.IInspectable
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.IsItemItsOwnContainerOverride (item, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetContainerForItemOverride
   (
      this : in out ItemsControl
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IItemsControl.all);
         Hr := m_Interface.GetContainerForItemOverride (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure ClearContainerForItemOverride
   (
      this : in out ItemsControl;
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      item : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.ClearContainerForItemOverride (element.m_IDependencyObject.all, item);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PrepareContainerForItemOverride
   (
      this : in out ItemsControl;
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      item : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.PrepareContainerForItemOverride (element.m_IDependencyObject.all, item);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemsChanged
   (
      this : in out ItemsControl;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnItemsChanged (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemContainerStyleChanged
   (
      this : in out ItemsControl;
      oldItemContainerStyle : WinUI3.Microsoft.UI.Xaml.Style'Class;
      newItemContainerStyle : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnItemContainerStyleChanged (oldItemContainerStyle.m_IStyle.all, newItemContainerStyle.m_IStyle.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemContainerStyleSelectorChanged
   (
      this : in out ItemsControl;
      oldItemContainerStyleSelector : WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector'Class;
      newItemContainerStyleSelector : WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnItemContainerStyleSelectorChanged (oldItemContainerStyleSelector.m_IStyleSelector.all, newItemContainerStyleSelector.m_IStyleSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemTemplateChanged
   (
      this : in out ItemsControl;
      oldItemTemplate : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class;
      newItemTemplate : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnItemTemplateChanged (oldItemTemplate.m_IDataTemplate.all, newItemTemplate.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemTemplateSelectorChanged
   (
      this : in out ItemsControl;
      oldItemTemplateSelector : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class;
      newItemTemplateSelector : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnItemTemplateSelectorChanged (oldItemTemplateSelector.m_IDataTemplateSelector.all, newItemTemplateSelector.m_IDataTemplateSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnGroupStyleSelectorChanged
   (
      this : in out ItemsControl;
      oldGroupStyleSelector : WinUI3.Microsoft.UI.Xaml.Controls.GroupStyleSelector'Class;
      newGroupStyleSelector : WinUI3.Microsoft.UI.Xaml.Controls.GroupStyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnGroupStyleSelectorChanged (oldGroupStyleSelector.m_IGroupStyleSelector.all, newGroupStyleSelector.m_IGroupStyleSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ItemFromContainer
   (
      this : in out ItemsControl;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerMapping := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerMapping, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemContainerMapping'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.ItemFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromItem
   (
      this : in out ItemsControl;
      item : WinUI3.IInspectable
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerMapping := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerMapping, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemContainerMapping'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IItemsControl.all);
         Hr := m_Interface.ContainerFromItem (item, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function IndexFromContainer
   (
      this : in out ItemsControl;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerMapping := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerMapping, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemContainerMapping'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.IndexFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromIndex
   (
      this : in out ItemsControl;
      index : WinUI3.Int32
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerMapping := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerMapping, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemContainerMapping'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IItemsControl.all);
         Hr := m_Interface.ContainerFromIndex (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AutoSuggestBox

   procedure Initialize (this : in out AutoSuggestBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out AutoSuggestBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAutoSuggestBox, IAutoSuggestBox_Ptr);
   begin
      if this.m_IAutoSuggestBox /= null then
         if this.m_IAutoSuggestBox.all /= null then
            temp := this.m_IAutoSuggestBox.all.Release;
            Free (this.m_IAutoSuggestBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AutoSuggestBox

   function Constructor return AutoSuggestBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAutoSuggestBox");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBox;
   begin
      return RetVal : AutoSuggestBox do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAutoSuggestBox := new WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBox;
            Retval.m_IAutoSuggestBox.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AutoSuggestBox

   function get_MaxSuggestionListHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxSuggestionListHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSuggestionListOpenProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSuggestionListOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextMemberPathProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextMemberPathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_UpdateTextOnSelectProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UpdateTextOnSelectProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AutoMaximizeSuggestionAreaProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoMaximizeSuggestionAreaProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextBoxStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextBoxStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_QueryIconProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_QueryIconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty_AutoSuggestBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AutoSuggestBox

   function get_MaxSuggestionListHeight
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_MaxSuggestionListHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxSuggestionListHeight
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_MaxSuggestionListHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSuggestionListOpen
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_IsSuggestionListOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSuggestionListOpen
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_IsSuggestionListOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextMemberPath
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_TextMemberPath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TextMemberPath
   (
      this : in out AutoSuggestBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAutoSuggestBox.all.put_TextMemberPath (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Text
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out AutoSuggestBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAutoSuggestBox.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_UpdateTextOnSelect
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_UpdateTextOnSelect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_UpdateTextOnSelect
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_UpdateTextOnSelect (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderText
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_PlaceholderText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out AutoSuggestBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAutoSuggestBox.all.put_PlaceholderText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Header
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out AutoSuggestBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AutoMaximizeSuggestionArea
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_AutoMaximizeSuggestionArea (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutoMaximizeSuggestionArea
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_AutoMaximizeSuggestionArea (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextBoxStyle
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IAutoSuggestBox.all.get_TextBoxStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_TextBoxStyle
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_TextBoxStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_QueryIcon
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_IAutoSuggestBox.all.get_QueryIcon (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_QueryIcon
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_QueryIcon (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_LightDismissOverlayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_LightDismissOverlayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Description
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_Description (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out AutoSuggestBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_Description (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SuggestionChosen
   (
      this : in out AutoSuggestBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAutoSuggestBox.all.add_SuggestionChosen (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SuggestionChosen
   (
      this : in out AutoSuggestBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.remove_SuggestionChosen (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextChanged
   (
      this : in out AutoSuggestBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAutoSuggestBox.all.add_TextChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextChanged
   (
      this : in out AutoSuggestBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.remove_TextChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_QuerySubmitted
   (
      this : in out AutoSuggestBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAutoSuggestBox.all.add_QuerySubmitted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_QuerySubmitted
   (
      this : in out AutoSuggestBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.remove_QuerySubmitted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AutoSuggestBoxQuerySubmittedEventArgs

   procedure Initialize (this : in out AutoSuggestBoxQuerySubmittedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AutoSuggestBoxQuerySubmittedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAutoSuggestBoxQuerySubmittedEventArgs, IAutoSuggestBoxQuerySubmittedEventArgs_Ptr);
   begin
      if this.m_IAutoSuggestBoxQuerySubmittedEventArgs /= null then
         if this.m_IAutoSuggestBoxQuerySubmittedEventArgs.all /= null then
            temp := this.m_IAutoSuggestBoxQuerySubmittedEventArgs.all.Release;
            Free (this.m_IAutoSuggestBoxQuerySubmittedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AutoSuggestBoxQuerySubmittedEventArgs

   function Constructor return AutoSuggestBoxQuerySubmittedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAutoSuggestBoxQuerySubmittedEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxQuerySubmittedEventArgs;
   begin
      return RetVal : AutoSuggestBoxQuerySubmittedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAutoSuggestBoxQuerySubmittedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxQuerySubmittedEventArgs;
            Retval.m_IAutoSuggestBoxQuerySubmittedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AutoSuggestBoxQuerySubmittedEventArgs

   function get_QueryText
   (
      this : in out AutoSuggestBoxQuerySubmittedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAutoSuggestBoxQuerySubmittedEventArgs.all.get_QueryText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ChosenSuggestion
   (
      this : in out AutoSuggestBoxQuerySubmittedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IAutoSuggestBoxQuerySubmittedEventArgs.all.get_ChosenSuggestion (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AutoSuggestBoxSuggestionChosenEventArgs

   procedure Initialize (this : in out AutoSuggestBoxSuggestionChosenEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AutoSuggestBoxSuggestionChosenEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAutoSuggestBoxSuggestionChosenEventArgs, IAutoSuggestBoxSuggestionChosenEventArgs_Ptr);
   begin
      if this.m_IAutoSuggestBoxSuggestionChosenEventArgs /= null then
         if this.m_IAutoSuggestBoxSuggestionChosenEventArgs.all /= null then
            temp := this.m_IAutoSuggestBoxSuggestionChosenEventArgs.all.Release;
            Free (this.m_IAutoSuggestBoxSuggestionChosenEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AutoSuggestBoxSuggestionChosenEventArgs

   function Constructor return AutoSuggestBoxSuggestionChosenEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAutoSuggestBoxSuggestionChosenEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxSuggestionChosenEventArgs;
   begin
      return RetVal : AutoSuggestBoxSuggestionChosenEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAutoSuggestBoxSuggestionChosenEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxSuggestionChosenEventArgs;
            Retval.m_IAutoSuggestBoxSuggestionChosenEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AutoSuggestBoxSuggestionChosenEventArgs

   function get_SelectedItem
   (
      this : in out AutoSuggestBoxSuggestionChosenEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IAutoSuggestBoxSuggestionChosenEventArgs.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AutoSuggestBoxTextChangedEventArgs

   procedure Initialize (this : in out AutoSuggestBoxTextChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AutoSuggestBoxTextChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAutoSuggestBoxTextChangedEventArgs, IAutoSuggestBoxTextChangedEventArgs_Ptr);
   begin
      if this.m_IAutoSuggestBoxTextChangedEventArgs /= null then
         if this.m_IAutoSuggestBoxTextChangedEventArgs.all /= null then
            temp := this.m_IAutoSuggestBoxTextChangedEventArgs.all.Release;
            Free (this.m_IAutoSuggestBoxTextChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AutoSuggestBoxTextChangedEventArgs

   function Constructor return AutoSuggestBoxTextChangedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgs;
   begin
      return RetVal : AutoSuggestBoxTextChangedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAutoSuggestBoxTextChangedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgs;
            Retval.m_IAutoSuggestBoxTextChangedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AutoSuggestBoxTextChangedEventArgs

   function get_ReasonProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.AutoSuggestBoxTextChangedEventArgs");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxTextChangedEventArgsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ReasonProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AutoSuggestBoxTextChangedEventArgs

   function get_Reason
   (
      this : in out AutoSuggestBoxTextChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.AutoSuggestionBoxTextChangeReason is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.AutoSuggestionBoxTextChangeReason;
   begin
      Hr := this.m_IAutoSuggestBoxTextChangedEventArgs.all.get_Reason (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Reason
   (
      this : in out AutoSuggestBoxTextChangedEventArgs;
      value : WinUI3.Microsoft.UI.Xaml.Controls.AutoSuggestionBoxTextChangeReason
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBoxTextChangedEventArgs.all.put_Reason (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CheckCurrent
   (
      this : in out AutoSuggestBoxTextChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAutoSuggestBoxTextChangedEventArgs.all.CheckCurrent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BitmapIcon

   procedure Initialize (this : in out BitmapIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out BitmapIcon) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBitmapIcon, IBitmapIcon_Ptr);
   begin
      if this.m_IBitmapIcon /= null then
         if this.m_IBitmapIcon.all /= null then
            temp := this.m_IBitmapIcon.all.Release;
            Free (this.m_IBitmapIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BitmapIcon

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return BitmapIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IBitmapIcon");
      m_Factory    : access IBitmapIconFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IBitmapIcon;
   begin
      return RetVal : BitmapIcon do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBitmapIcon := new WinUI3.Microsoft.UI.Xaml.Controls.IBitmapIcon;
            Retval.m_IBitmapIcon.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BitmapIcon

   function get_UriSourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.BitmapIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBitmapIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UriSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShowAsMonochromeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.BitmapIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBitmapIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowAsMonochromeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BitmapIcon

   function get_UriSource
   (
      this : in out BitmapIcon
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IBitmapIcon.all.get_UriSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_UriSource
   (
      this : in out BitmapIcon;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapIcon.all.put_UriSource (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowAsMonochrome
   (
      this : in out BitmapIcon
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IBitmapIcon.all.get_ShowAsMonochrome (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowAsMonochrome
   (
      this : in out BitmapIcon;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapIcon.all.put_ShowAsMonochrome (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BitmapIconSource

   procedure Initialize (this : in out BitmapIconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out BitmapIconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBitmapIconSource, IBitmapIconSource_Ptr);
   begin
      if this.m_IBitmapIconSource /= null then
         if this.m_IBitmapIconSource.all /= null then
            temp := this.m_IBitmapIconSource.all.Release;
            Free (this.m_IBitmapIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BitmapIconSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return BitmapIconSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IBitmapIconSource");
      m_Factory    : access IBitmapIconSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IBitmapIconSource;
   begin
      return RetVal : BitmapIconSource do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBitmapIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IBitmapIconSource;
            Retval.m_IBitmapIconSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BitmapIconSource

   function get_UriSourceProperty_BitmapIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.BitmapIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBitmapIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UriSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShowAsMonochromeProperty_BitmapIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.BitmapIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBitmapIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowAsMonochromeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BitmapIconSource

   function get_UriSource
   (
      this : in out BitmapIconSource
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IBitmapIconSource.all.get_UriSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_UriSource
   (
      this : in out BitmapIconSource;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapIconSource.all.put_UriSource (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowAsMonochrome
   (
      this : in out BitmapIconSource
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IBitmapIconSource.all.get_ShowAsMonochrome (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowAsMonochrome
   (
      this : in out BitmapIconSource;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapIconSource.all.put_ShowAsMonochrome (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Border

   procedure Initialize (this : in out Border) is
   begin
      null;
   end;

   procedure Finalize (this : in out Border) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBorder, IBorder_Ptr);
   begin
      if this.m_IBorder /= null then
         if this.m_IBorder.all /= null then
            temp := this.m_IBorder.all.Release;
            Free (this.m_IBorder);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Border

   function Constructor return Border is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IBorder");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IBorder;
   begin
      return RetVal : Border do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IBorder := new WinUI3.Microsoft.UI.Xaml.Controls.IBorder;
            Retval.m_IBorder.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Border

   function get_BorderBrushProperty_Border
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty_Border
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundProperty_Border
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundSizingProperty_Border
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty_Border
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_Border
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ChildTransitionsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Border

   function get_BorderBrush
   (
      this : in out Border
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IBorder.all.get_BorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out Border;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_BorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out Border
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IBorder.all.get_BorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out Border;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_BorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Background
   (
      this : in out Border
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IBorder.all.get_Background (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out Border;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_Background (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundSizing
   (
      this : in out Border
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing;
   begin
      Hr := this.m_IBorder.all.get_BackgroundSizing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out Border;
      value : WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_BackgroundSizing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out Border
   )
   return WinUI3.Microsoft.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_IBorder.all.get_CornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out Border;
      value : WinUI3.Microsoft.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_CornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out Border
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IBorder.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out Border;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Child
   (
      this : in out Border
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IBorder.all.get_Child (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Child
   (
      this : in out Border;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_Child (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChildTransitions
   (
      this : in out Border
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IBorder.all.get_ChildTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ChildTransitions
   (
      this : in out Border;
      value : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_ChildTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundTransition
   (
      this : in out Border
   )
   return WinUI3.Microsoft.UI.Xaml.BrushTransition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IBrushTransition;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.BrushTransition do
         Hr := this.m_IBorder.all.get_BackgroundTransition (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrushTransition := new WinUI3.Microsoft.UI.Xaml.IBrushTransition;
         Retval.m_IBrushTransition.all := m_ComRetVal;
      end return;
   end;

   procedure put_BackgroundTransition
   (
      this : in out Border;
      value : WinUI3.Microsoft.UI.Xaml.BrushTransition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_BackgroundTransition (value.m_IBrushTransition.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BreadcrumbBar

   procedure Initialize (this : in out BreadcrumbBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out BreadcrumbBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBreadcrumbBar, IBreadcrumbBar_Ptr);
   begin
      if this.m_IBreadcrumbBar /= null then
         if this.m_IBreadcrumbBar.all /= null then
            temp := this.m_IBreadcrumbBar.all.Release;
            Free (this.m_IBreadcrumbBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BreadcrumbBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return BreadcrumbBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IBreadcrumbBar");
      m_Factory    : access IBreadcrumbBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IBreadcrumbBar;
   begin
      return RetVal : BreadcrumbBar do
         Hr := RoGetActivationFactory (m_hString, IID_IBreadcrumbBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBreadcrumbBar := new WinUI3.Microsoft.UI.Xaml.Controls.IBreadcrumbBar;
            Retval.m_IBreadcrumbBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BreadcrumbBar

   function get_ItemsSourceProperty_BreadcrumbBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.BreadcrumbBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBreadcrumbBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBreadcrumbBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty_BreadcrumbBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.BreadcrumbBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IBreadcrumbBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBreadcrumbBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BreadcrumbBar

   function get_ItemsSource
   (
      this : in out BreadcrumbBar
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IBreadcrumbBar.all.get_ItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out BreadcrumbBar;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBreadcrumbBar.all.put_ItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTemplate
   (
      this : in out BreadcrumbBar
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IBreadcrumbBar.all.get_ItemTemplate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemTemplate
   (
      this : in out BreadcrumbBar;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBreadcrumbBar.all.put_ItemTemplate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ItemClicked
   (
      this : in out BreadcrumbBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IBreadcrumbBar.all.add_ItemClicked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemClicked
   (
      this : in out BreadcrumbBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBreadcrumbBar.all.remove_ItemClicked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BreadcrumbBarItem

   procedure Initialize (this : in out BreadcrumbBarItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out BreadcrumbBarItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBreadcrumbBarItem, IBreadcrumbBarItem_Ptr);
   begin
      if this.m_IBreadcrumbBarItem /= null then
         if this.m_IBreadcrumbBarItem.all /= null then
            temp := this.m_IBreadcrumbBarItem.all.Release;
            Free (this.m_IBreadcrumbBarItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BreadcrumbBarItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return BreadcrumbBarItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IBreadcrumbBarItem");
      m_Factory    : access IBreadcrumbBarItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IBreadcrumbBarItem;
   begin
      return RetVal : BreadcrumbBarItem do
         Hr := RoGetActivationFactory (m_hString, IID_IBreadcrumbBarItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBreadcrumbBarItem := new WinUI3.Microsoft.UI.Xaml.Controls.IBreadcrumbBarItem;
            Retval.m_IBreadcrumbBarItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BreadcrumbBarItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BreadcrumbBarItemClickedEventArgs

   procedure Initialize (this : in out BreadcrumbBarItemClickedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out BreadcrumbBarItemClickedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBreadcrumbBarItemClickedEventArgs, IBreadcrumbBarItemClickedEventArgs_Ptr);
   begin
      if this.m_IBreadcrumbBarItemClickedEventArgs /= null then
         if this.m_IBreadcrumbBarItemClickedEventArgs.all /= null then
            temp := this.m_IBreadcrumbBarItemClickedEventArgs.all.Release;
            Free (this.m_IBreadcrumbBarItemClickedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BreadcrumbBarItemClickedEventArgs

   function get_Index
   (
      this : in out BreadcrumbBarItemClickedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IBreadcrumbBarItemClickedEventArgs.all.get_Index (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Item
   (
      this : in out BreadcrumbBarItemClickedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IBreadcrumbBarItemClickedEventArgs.all.get_Item (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarDatePicker

   procedure Initialize (this : in out CalendarDatePicker) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarDatePicker) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarDatePicker, ICalendarDatePicker_Ptr);
   begin
      if this.m_ICalendarDatePicker /= null then
         if this.m_ICalendarDatePicker.all /= null then
            temp := this.m_ICalendarDatePicker.all.Release;
            Free (this.m_ICalendarDatePicker);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CalendarDatePicker

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CalendarDatePicker is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ICalendarDatePicker");
      m_Factory    : access ICalendarDatePickerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePicker;
   begin
      return RetVal : CalendarDatePicker do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICalendarDatePicker := new WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePicker;
            Retval.m_ICalendarDatePicker.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CalendarDatePicker

   function get_DateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCalendarOpenProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCalendarOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DateFormatProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DateFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_CalendarDatePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_CalendarDatePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarViewStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarViewStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty_CalendarDatePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty_CalendarDatePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinDateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinDateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxDateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxDateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTodayHighlightedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTodayHighlightedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstDayOfWeekProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstDayOfWeekProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayOfWeekFormatProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayOfWeekFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarIdentifierProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsOutOfScopeEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOutOfScopeEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsGroupLabelVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsGroupLabelVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarDatePicker

   function get_Date
   (
      this : in out CalendarDatePicker
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_Date (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_Date
   (
      this : in out CalendarDatePicker;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_Date (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsCalendarOpen
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_IsCalendarOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCalendarOpen
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_IsCalendarOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DateFormat
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_DateFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DateFormat
   (
      this : in out CalendarDatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarDatePicker.all.put_DateFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PlaceholderText
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_PlaceholderText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out CalendarDatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarDatePicker.all.put_PlaceholderText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Header
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out CalendarDatePicker;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_ICalendarDatePicker.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarViewStyle
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_ICalendarDatePicker.all.get_CalendarViewStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarViewStyle
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_CalendarViewStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_LightDismissOverlayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_LightDismissOverlayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Description
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_Description (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out CalendarDatePicker;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_Description (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinDate
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_MinDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinDate
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_MinDate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxDate
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_MaxDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxDate
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_MaxDate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTodayHighlighted
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_IsTodayHighlighted (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTodayHighlighted
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_IsTodayHighlighted (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMode
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewDisplayMode;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_DisplayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DisplayMode
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewDisplayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_DisplayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstDayOfWeek
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Windows.Globalization.DayOfWeek is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Globalization.DayOfWeek;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_FirstDayOfWeek (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstDayOfWeek
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Windows.Globalization.DayOfWeek
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_FirstDayOfWeek (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayOfWeekFormat
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_DayOfWeekFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DayOfWeekFormat
   (
      this : in out CalendarDatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarDatePicker.all.put_DayOfWeekFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_CalendarIdentifier
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_CalendarIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CalendarIdentifier
   (
      this : in out CalendarDatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarDatePicker.all.put_CalendarIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsOutOfScopeEnabled
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_IsOutOfScopeEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOutOfScopeEnabled
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_IsOutOfScopeEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsGroupLabelVisible
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_IsGroupLabelVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsGroupLabelVisible
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_IsGroupLabelVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CalendarViewDayItemChanging
   (
      this : in out CalendarDatePicker;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewDayItemChangingEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarDatePicker.all.add_CalendarViewDayItemChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CalendarViewDayItemChanging
   (
      this : in out CalendarDatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.remove_CalendarViewDayItemChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DateChanged
   (
      this : in out CalendarDatePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarDatePicker.all.add_DateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DateChanged
   (
      this : in out CalendarDatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.remove_DateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opened
   (
      this : in out CalendarDatePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarDatePicker.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out CalendarDatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out CalendarDatePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarDatePicker.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out CalendarDatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetDisplayDate
   (
      this : in out CalendarDatePicker;
      date : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.SetDisplayDate (date);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetYearDecadeDisplayDimensions
   (
      this : in out CalendarDatePicker;
      columns : WinUI3.Int32;
      rows : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.SetYearDecadeDisplayDimensions (columns, rows);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarDatePickerDateChangedEventArgs

   procedure Initialize (this : in out CalendarDatePickerDateChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarDatePickerDateChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarDatePickerDateChangedEventArgs, ICalendarDatePickerDateChangedEventArgs_Ptr);
   begin
      if this.m_ICalendarDatePickerDateChangedEventArgs /= null then
         if this.m_ICalendarDatePickerDateChangedEventArgs.all /= null then
            temp := this.m_ICalendarDatePickerDateChangedEventArgs.all.Release;
            Free (this.m_ICalendarDatePickerDateChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarDatePickerDateChangedEventArgs

   function get_NewDate
   (
      this : in out CalendarDatePickerDateChangedEventArgs
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
   begin
      Hr := this.m_ICalendarDatePickerDateChangedEventArgs.all.get_NewDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_OldDate
   (
      this : in out CalendarDatePickerDateChangedEventArgs
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
   begin
      Hr := this.m_ICalendarDatePickerDateChangedEventArgs.all.get_OldDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarView

   procedure Initialize (this : in out CalendarView) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarView, ICalendarView_Ptr);
   begin
      if this.m_ICalendarView /= null then
         if this.m_ICalendarView.all /= null then
            temp := this.m_ICalendarView.all.Release;
            Free (this.m_ICalendarView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CalendarView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CalendarView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ICalendarView");
      m_Factory    : access ICalendarViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ICalendarView;
   begin
      return RetVal : CalendarView do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICalendarView := new WinUI3.Microsoft.UI.Xaml.Controls.ICalendarView;
            Retval.m_ICalendarView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CalendarView

   function get_CalendarIdentifierProperty_CalendarView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayOfWeekFormatProperty_CalendarView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayOfWeekFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsGroupLabelVisibleProperty_CalendarView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsGroupLabelVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayModeProperty_CalendarView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstDayOfWeekProperty_CalendarView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstDayOfWeekProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsOutOfScopeEnabledProperty_CalendarView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOutOfScopeEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTodayHighlightedProperty_CalendarView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTodayHighlightedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxDateProperty_CalendarView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxDateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinDateProperty_CalendarView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinDateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NumberOfWeeksInViewProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NumberOfWeeksInViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedDatesProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedDatesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateSettingsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedHoverBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedHoverBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPressedBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPressedBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedDisabledBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedDisabledBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HoverBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HoverBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PressedBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PressedBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodaySelectedInnerBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodaySelectedInnerBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BlackoutStrikethroughBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BlackoutStrikethroughBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BlackoutBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BlackoutBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OutOfScopeBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OutOfScopeBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemHoverBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemHoverBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemPressedBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemPressedBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemDisabledBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemDisabledBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayBlackoutBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayBlackoutBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayHoverBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayHoverBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayPressedBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayPressedBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayDisabledBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayDisabledBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PressedForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PressedForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BlackoutForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BlackoutForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayBlackoutForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayBlackoutForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedHoverForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedHoverForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPressedForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPressedForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedDisabledForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedDisabledForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OutOfScopeForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OutOfScopeForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OutOfScopeHoverForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OutOfScopeHoverForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OutOfScopePressedForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OutOfScopePressedForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisabledForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayItemFontFamilyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayItemFontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayItemFontSizeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayItemFontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayItemFontStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayItemFontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayItemFontWeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayItemFontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayFontWeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayFontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfMonthLabelFontFamilyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfMonthLabelFontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfMonthLabelFontSizeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfMonthLabelFontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfMonthLabelFontStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfMonthLabelFontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfMonthLabelFontWeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfMonthLabelFontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthYearItemFontFamilyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthYearItemFontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthYearItemFontSizeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthYearItemFontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthYearItemFontStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthYearItemFontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthYearItemFontWeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthYearItemFontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfYearDecadeLabelFontFamilyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfYearDecadeLabelFontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfYearDecadeLabelFontSizeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfYearDecadeLabelFontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfYearDecadeLabelFontStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfYearDecadeLabelFontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfYearDecadeLabelFontWeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfYearDecadeLabelFontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayItemMarginProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayItemMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthYearItemMarginProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthYearItemMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfMonthLabelMarginProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfMonthLabelMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfYearDecadeLabelMarginProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfYearDecadeLabelMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalDayItemAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalDayItemAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalDayItemAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalDayItemAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalFirstOfMonthLabelAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalFirstOfMonthLabelAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalFirstOfMonthLabelAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalFirstOfMonthLabelAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemBorderThicknessProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemBorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarViewDayItemStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarViewDayItemStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemCornerRadiusProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemCornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarView

   function get_CalendarIdentifier
   (
      this : in out CalendarView
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarView.all.get_CalendarIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CalendarIdentifier
   (
      this : in out CalendarView;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarView.all.put_CalendarIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_DayOfWeekFormat
   (
      this : in out CalendarView
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarView.all.get_DayOfWeekFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DayOfWeekFormat
   (
      this : in out CalendarView;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarView.all.put_DayOfWeekFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsGroupLabelVisible
   (
      this : in out CalendarView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarView.all.get_IsGroupLabelVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsGroupLabelVisible
   (
      this : in out CalendarView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_IsGroupLabelVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMode
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewDisplayMode;
   begin
      Hr := this.m_ICalendarView.all.get_DisplayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DisplayMode
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewDisplayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DisplayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstDayOfWeek
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.Globalization.DayOfWeek is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Globalization.DayOfWeek;
   begin
      Hr := this.m_ICalendarView.all.get_FirstDayOfWeek (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstDayOfWeek
   (
      this : in out CalendarView;
      value : WinUI3.Windows.Globalization.DayOfWeek
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstDayOfWeek (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsOutOfScopeEnabled
   (
      this : in out CalendarView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarView.all.get_IsOutOfScopeEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOutOfScopeEnabled
   (
      this : in out CalendarView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_IsOutOfScopeEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTodayHighlighted
   (
      this : in out CalendarView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarView.all.get_IsTodayHighlighted (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTodayHighlighted
   (
      this : in out CalendarView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_IsTodayHighlighted (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxDate
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICalendarView.all.get_MaxDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxDate
   (
      this : in out CalendarView;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MaxDate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinDate
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICalendarView.all.get_MinDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinDate
   (
      this : in out CalendarView;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MinDate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NumberOfWeeksInView
   (
      this : in out CalendarView
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ICalendarView.all.get_NumberOfWeeksInView (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NumberOfWeeksInView
   (
      this : in out CalendarView;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_NumberOfWeeksInView (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedDates
   (
      this : in out CalendarView
   )
   return IVector_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_DateTime.Kind;
   begin
      Hr := this.m_ICalendarView.all.get_SelectedDates (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SelectionMode
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewSelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewSelectionMode;
   begin
      Hr := this.m_ICalendarView.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionMode
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewSelectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICalendarViewTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings do
         Hr := this.m_ICalendarView.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICalendarViewTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICalendarViewTemplateSettings;
         Retval.m_ICalendarViewTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_FocusBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_FocusBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_FocusBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FocusBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedHoverBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedHoverBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedHoverBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedHoverBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPressedBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedPressedBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedPressedBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedPressedBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedDisabledBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedDisabledBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedDisabledBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedDisabledBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HoverBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_HoverBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_HoverBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_HoverBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PressedBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_PressedBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PressedBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_PressedBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodaySelectedInnerBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_TodaySelectedInnerBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodaySelectedInnerBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_TodaySelectedInnerBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BlackoutStrikethroughBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_BlackoutStrikethroughBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BlackoutStrikethroughBrush
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_BlackoutStrikethroughBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_CalendarItemBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BlackoutBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_BlackoutBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BlackoutBackground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_BlackoutBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OutOfScopeBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_OutOfScopeBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_OutOfScopeBackground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_OutOfScopeBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_CalendarItemBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemBackground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemHoverBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_CalendarItemHoverBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemHoverBackground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemHoverBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemPressedBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_CalendarItemPressedBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemPressedBackground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemPressedBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemDisabledBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_CalendarItemDisabledBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemDisabledBackground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemDisabledBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_TodayBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayBackground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_TodayBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayBlackoutBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_TodayBlackoutBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayBlackoutBackground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_TodayBlackoutBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayHoverBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_TodayHoverBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayHoverBackground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_TodayHoverBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayPressedBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_TodayPressedBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayPressedBackground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_TodayPressedBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayDisabledBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_TodayDisabledBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayDisabledBackground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_TodayDisabledBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PressedForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_PressedForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PressedForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_PressedForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_TodayForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_TodayForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BlackoutForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_BlackoutForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BlackoutForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_BlackoutForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayBlackoutForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_TodayBlackoutForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayBlackoutForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_TodayBlackoutForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedHoverForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedHoverForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedHoverForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedHoverForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPressedForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedPressedForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedPressedForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedPressedForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedDisabledForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedDisabledForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedDisabledForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedDisabledForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OutOfScopeForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_OutOfScopeForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_OutOfScopeForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_OutOfScopeForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OutOfScopeHoverForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_OutOfScopeHoverForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_OutOfScopeHoverForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_OutOfScopeHoverForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OutOfScopePressedForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_OutOfScopePressedForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_OutOfScopePressedForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_OutOfScopePressedForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_CalendarItemForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisabledForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_DisabledForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_DisabledForeground
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DisabledForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayItemFontFamily
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.FontFamily do
         Hr := this.m_ICalendarView.all.get_DayItemFontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_DayItemFontFamily
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DayItemFontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayItemFontSize
   (
      this : in out CalendarView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICalendarView.all.get_DayItemFontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayItemFontSize
   (
      this : in out CalendarView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DayItemFontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayItemFontStyle
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_ICalendarView.all.get_DayItemFontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayItemFontStyle
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DayItemFontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayItemFontWeight
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ICalendarView.all.get_DayItemFontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayItemFontWeight
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DayItemFontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayFontWeight
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ICalendarView.all.get_TodayFontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TodayFontWeight
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_TodayFontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfMonthLabelFontFamily
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.FontFamily do
         Hr := this.m_ICalendarView.all.get_FirstOfMonthLabelFontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FirstOfMonthLabelFontFamily
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfMonthLabelFontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfMonthLabelFontSize
   (
      this : in out CalendarView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfMonthLabelFontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfMonthLabelFontSize
   (
      this : in out CalendarView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfMonthLabelFontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfMonthLabelFontStyle
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfMonthLabelFontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfMonthLabelFontStyle
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfMonthLabelFontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfMonthLabelFontWeight
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfMonthLabelFontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfMonthLabelFontWeight
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfMonthLabelFontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthYearItemFontFamily
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.FontFamily do
         Hr := this.m_ICalendarView.all.get_MonthYearItemFontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_MonthYearItemFontFamily
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MonthYearItemFontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthYearItemFontSize
   (
      this : in out CalendarView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICalendarView.all.get_MonthYearItemFontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthYearItemFontSize
   (
      this : in out CalendarView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MonthYearItemFontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthYearItemFontStyle
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_ICalendarView.all.get_MonthYearItemFontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthYearItemFontStyle
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MonthYearItemFontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthYearItemFontWeight
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ICalendarView.all.get_MonthYearItemFontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthYearItemFontWeight
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MonthYearItemFontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfYearDecadeLabelFontFamily
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.FontFamily do
         Hr := this.m_ICalendarView.all.get_FirstOfYearDecadeLabelFontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FirstOfYearDecadeLabelFontFamily
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfYearDecadeLabelFontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfYearDecadeLabelFontSize
   (
      this : in out CalendarView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfYearDecadeLabelFontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfYearDecadeLabelFontSize
   (
      this : in out CalendarView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfYearDecadeLabelFontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfYearDecadeLabelFontStyle
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfYearDecadeLabelFontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfYearDecadeLabelFontStyle
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfYearDecadeLabelFontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfYearDecadeLabelFontWeight
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfYearDecadeLabelFontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfYearDecadeLabelFontWeight
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfYearDecadeLabelFontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayItemMargin
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_ICalendarView.all.get_DayItemMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayItemMargin
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DayItemMargin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthYearItemMargin
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_ICalendarView.all.get_MonthYearItemMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthYearItemMargin
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MonthYearItemMargin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfMonthLabelMargin
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfMonthLabelMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfMonthLabelMargin
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfMonthLabelMargin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfYearDecadeLabelMargin
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfYearDecadeLabelMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfYearDecadeLabelMargin
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfYearDecadeLabelMargin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalDayItemAlignment
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_ICalendarView.all.get_HorizontalDayItemAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalDayItemAlignment
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_HorizontalDayItemAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalDayItemAlignment
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_ICalendarView.all.get_VerticalDayItemAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalDayItemAlignment
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_VerticalDayItemAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalFirstOfMonthLabelAlignment
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_ICalendarView.all.get_HorizontalFirstOfMonthLabelAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalFirstOfMonthLabelAlignment
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_HorizontalFirstOfMonthLabelAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalFirstOfMonthLabelAlignment
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_ICalendarView.all.get_VerticalFirstOfMonthLabelAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalFirstOfMonthLabelAlignment
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_VerticalFirstOfMonthLabelAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemBorderThickness
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_ICalendarView.all.get_CalendarItemBorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CalendarItemBorderThickness
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemBorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarViewDayItemStyle
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_ICalendarView.all.get_CalendarViewDayItemStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarViewDayItemStyle
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarViewDayItemStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemCornerRadius
   (
      this : in out CalendarView
   )
   return WinUI3.Microsoft.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_ICalendarView.all.get_CalendarItemCornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CalendarItemCornerRadius
   (
      this : in out CalendarView;
      value : WinUI3.Microsoft.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemCornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CalendarViewDayItemChanging
   (
      this : in out CalendarView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarView.all.add_CalendarViewDayItemChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CalendarViewDayItemChanging
   (
      this : in out CalendarView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.remove_CalendarViewDayItemChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectedDatesChanged
   (
      this : in out CalendarView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarView.all.add_SelectedDatesChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectedDatesChanged
   (
      this : in out CalendarView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.remove_SelectedDatesChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetDisplayDate
   (
      this : in out CalendarView;
      date : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.SetDisplayDate (date);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetYearDecadeDisplayDimensions
   (
      this : in out CalendarView;
      columns : WinUI3.Int32;
      rows : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.SetYearDecadeDisplayDimensions (columns, rows);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarViewDayItem

   procedure Initialize (this : in out CalendarViewDayItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarViewDayItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarViewDayItem, ICalendarViewDayItem_Ptr);
   begin
      if this.m_ICalendarViewDayItem /= null then
         if this.m_ICalendarViewDayItem.all /= null then
            temp := this.m_ICalendarViewDayItem.all.Release;
            Free (this.m_ICalendarViewDayItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CalendarViewDayItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CalendarViewDayItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ICalendarViewDayItem");
      m_Factory    : access ICalendarViewDayItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewDayItem;
   begin
      return RetVal : CalendarViewDayItem do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewDayItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICalendarViewDayItem := new WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewDayItem;
            Retval.m_ICalendarViewDayItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CalendarViewDayItem

   function get_IsBlackoutProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarViewDayItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewDayItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewDayItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsBlackoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DateProperty_CalendarViewDayItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CalendarViewDayItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewDayItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewDayItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarViewDayItem

   function get_IsBlackout
   (
      this : in out CalendarViewDayItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarViewDayItem.all.get_IsBlackout (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsBlackout
   (
      this : in out CalendarViewDayItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarViewDayItem.all.put_IsBlackout (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Date
   (
      this : in out CalendarViewDayItem
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICalendarViewDayItem.all.get_Date (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetDensityColors
   (
      this : in out CalendarViewDayItem;
      colors : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarViewDayItem.all.SetDensityColors (colors);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarViewDayItemChangingEventArgs

   procedure Initialize (this : in out CalendarViewDayItemChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarViewDayItemChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarViewDayItemChangingEventArgs, ICalendarViewDayItemChangingEventArgs_Ptr);
   begin
      if this.m_ICalendarViewDayItemChangingEventArgs /= null then
         if this.m_ICalendarViewDayItemChangingEventArgs.all /= null then
            temp := this.m_ICalendarViewDayItemChangingEventArgs.all.Release;
            Free (this.m_ICalendarViewDayItemChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarViewDayItemChangingEventArgs

   function get_InRecycleQueue
   (
      this : in out CalendarViewDayItemChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarViewDayItemChangingEventArgs.all.get_InRecycleQueue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Item
   (
      this : in out CalendarViewDayItemChangingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewDayItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewDayItem;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.CalendarViewDayItem do
         Hr := this.m_ICalendarViewDayItemChangingEventArgs.all.get_Item (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICalendarViewDayItem := new WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewDayItem;
         Retval.m_ICalendarViewDayItem.all := m_ComRetVal;
      end return;
   end;

   function get_Phase
   (
      this : in out CalendarViewDayItemChangingEventArgs
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_ICalendarViewDayItemChangingEventArgs.all.get_Phase (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure RegisterUpdateCallback
   (
      this : in out CalendarViewDayItemChangingEventArgs;
      callback : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarViewDayItemChangingEventArgs.all.RegisterUpdateCallback (callback);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RegisterUpdateCallback
   (
      this : in out CalendarViewDayItemChangingEventArgs;
      callbackPhase : WinUI3.UInt32;
      callback : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarViewDayItemChangingEventArgs.all.RegisterUpdateCallback (callbackPhase, callback);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate CalendarViewDayItemChangingEventHandler

   function Invoke
   (
      this : access CalendarViewDayItemChangingEventHandler_Delegate;
      sender : WinUI3.Microsoft.UI.Xaml.Controls.ICalendarView;
      e : WinUI3.Microsoft.UI.Xaml.Controls.ICalendarViewDayItemChangingEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarViewSelectedDatesChangedEventArgs

   procedure Initialize (this : in out CalendarViewSelectedDatesChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarViewSelectedDatesChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarViewSelectedDatesChangedEventArgs, ICalendarViewSelectedDatesChangedEventArgs_Ptr);
   begin
      if this.m_ICalendarViewSelectedDatesChangedEventArgs /= null then
         if this.m_ICalendarViewSelectedDatesChangedEventArgs.all /= null then
            temp := this.m_ICalendarViewSelectedDatesChangedEventArgs.all.Release;
            Free (this.m_ICalendarViewSelectedDatesChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarViewSelectedDatesChangedEventArgs

   function get_AddedDates
   (
      this : in out CalendarViewSelectedDatesChangedEventArgs
   )
   return IVectorView_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_DateTime.Kind;
   begin
      Hr := this.m_ICalendarViewSelectedDatesChangedEventArgs.all.get_AddedDates (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_RemovedDates
   (
      this : in out CalendarViewSelectedDatesChangedEventArgs
   )
   return IVectorView_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_DateTime.Kind;
   begin
      Hr := this.m_ICalendarViewSelectedDatesChangedEventArgs.all.get_RemovedDates (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CandidateWindowBoundsChangedEventArgs

   procedure Initialize (this : in out CandidateWindowBoundsChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CandidateWindowBoundsChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICandidateWindowBoundsChangedEventArgs, ICandidateWindowBoundsChangedEventArgs_Ptr);
   begin
      if this.m_ICandidateWindowBoundsChangedEventArgs /= null then
         if this.m_ICandidateWindowBoundsChangedEventArgs.all /= null then
            temp := this.m_ICandidateWindowBoundsChangedEventArgs.all.Release;
            Free (this.m_ICandidateWindowBoundsChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CandidateWindowBoundsChangedEventArgs

   function get_Bounds
   (
      this : in out CandidateWindowBoundsChangedEventArgs
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_ICandidateWindowBoundsChangedEventArgs.all.get_Bounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Panel

   procedure Initialize (this : in out Panel) is
   begin
      null;
   end;

   procedure Finalize (this : in out Panel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPanel, IPanel_Ptr);
   begin
      if this.m_IPanel /= null then
         if this.m_IPanel.all /= null then
            temp := this.m_IPanel.all.Release;
            Free (this.m_IPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Panel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Panel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPanel");
      m_Factory    : access IPanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPanel;
   begin
      return RetVal : Panel do
         Hr := RoGetActivationFactory (m_hString, IID_IPanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPanel := new WinUI3.Microsoft.UI.Xaml.Controls.IPanel;
            Retval.m_IPanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Panel

   function get_BackgroundProperty_Panel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Panel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsItemsHostProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Panel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsItemsHostProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ChildrenTransitionsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Panel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildrenTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Panel

   function get_Children
   (
      this : in out Panel
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.UIElementCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.UIElementCollection do
         Hr := this.m_IPanel.all.get_Children (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_Background
   (
      this : in out Panel
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IPanel.all.get_Background (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out Panel;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPanel.all.put_Background (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsItemsHost
   (
      this : in out Panel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPanel.all.get_IsItemsHost (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ChildrenTransitions
   (
      this : in out Panel
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IPanel.all.get_ChildrenTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ChildrenTransitions
   (
      this : in out Panel;
      value : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPanel.all.put_ChildrenTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundTransition
   (
      this : in out Panel
   )
   return WinUI3.Microsoft.UI.Xaml.BrushTransition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IBrushTransition;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.BrushTransition do
         Hr := this.m_IPanel.all.get_BackgroundTransition (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrushTransition := new WinUI3.Microsoft.UI.Xaml.IBrushTransition;
         Retval.m_IBrushTransition.all := m_ComRetVal;
      end return;
   end;

   procedure put_BackgroundTransition
   (
      this : in out Panel;
      value : WinUI3.Microsoft.UI.Xaml.BrushTransition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPanel.all.put_BackgroundTransition (value.m_IBrushTransition.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Canvas

   procedure Initialize (this : in out Canvas) is
   begin
      null;
   end;

   procedure Finalize (this : in out Canvas) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICanvas, ICanvas_Ptr);
   begin
      if this.m_ICanvas /= null then
         if this.m_ICanvas.all /= null then
            temp := this.m_ICanvas.all.Release;
            Free (this.m_ICanvas);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Canvas

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Canvas is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ICanvas");
      m_Factory    : access ICanvasFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ICanvas;
   begin
      return RetVal : Canvas do
         Hr := RoGetActivationFactory (m_hString, IID_ICanvasFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICanvas := new WinUI3.Microsoft.UI.Xaml.Controls.ICanvas;
            Retval.m_ICanvas.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Canvas

   function get_LeftProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetLeft
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetLeft (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetLeft
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      length : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetLeft (element.m_IUIElement.all, length);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_TopProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetTop
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetTop (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetTop
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      length : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetTop (element.m_IUIElement.all, length);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ZIndexProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetZIndex
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetZIndex (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetZIndex
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetZIndex (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Canvas

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CheckBox

   procedure Initialize (this : in out CheckBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out CheckBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICheckBox, ICheckBox_Ptr);
   begin
      if this.m_ICheckBox /= null then
         if this.m_ICheckBox.all /= null then
            temp := this.m_ICheckBox.all.Release;
            Free (this.m_ICheckBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CheckBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CheckBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ICheckBox");
      m_Factory    : access ICheckBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ICheckBox;
   begin
      return RetVal : CheckBox do
         Hr := RoGetActivationFactory (m_hString, IID_ICheckBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICheckBox := new WinUI3.Microsoft.UI.Xaml.Controls.ICheckBox;
            Retval.m_ICheckBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CheckBox

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ChoosingGroupHeaderContainerEventArgs

   procedure Initialize (this : in out ChoosingGroupHeaderContainerEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ChoosingGroupHeaderContainerEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IChoosingGroupHeaderContainerEventArgs, IChoosingGroupHeaderContainerEventArgs_Ptr);
   begin
      if this.m_IChoosingGroupHeaderContainerEventArgs /= null then
         if this.m_IChoosingGroupHeaderContainerEventArgs.all /= null then
            temp := this.m_IChoosingGroupHeaderContainerEventArgs.all.Release;
            Free (this.m_IChoosingGroupHeaderContainerEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ChoosingGroupHeaderContainerEventArgs

   function Constructor return ChoosingGroupHeaderContainerEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IChoosingGroupHeaderContainerEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IChoosingGroupHeaderContainerEventArgs;
   begin
      return RetVal : ChoosingGroupHeaderContainerEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IChoosingGroupHeaderContainerEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IChoosingGroupHeaderContainerEventArgs;
            Retval.m_IChoosingGroupHeaderContainerEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ChoosingGroupHeaderContainerEventArgs

   function get_GroupHeaderContainer
   (
      this : in out ChoosingGroupHeaderContainerEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ListViewBaseHeaderItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseHeaderItem;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ListViewBaseHeaderItem do
         Hr := this.m_IChoosingGroupHeaderContainerEventArgs.all.get_GroupHeaderContainer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IListViewBaseHeaderItem := new WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseHeaderItem;
         Retval.m_IListViewBaseHeaderItem.all := m_ComRetVal;
      end return;
   end;

   procedure put_GroupHeaderContainer
   (
      this : in out ChoosingGroupHeaderContainerEventArgs;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ListViewBaseHeaderItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IChoosingGroupHeaderContainerEventArgs.all.put_GroupHeaderContainer (value.m_IListViewBaseHeaderItem.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GroupIndex
   (
      this : in out ChoosingGroupHeaderContainerEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IChoosingGroupHeaderContainerEventArgs.all.get_GroupIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Group
   (
      this : in out ChoosingGroupHeaderContainerEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IChoosingGroupHeaderContainerEventArgs.all.get_Group (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ChoosingItemContainerEventArgs

   procedure Initialize (this : in out ChoosingItemContainerEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ChoosingItemContainerEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IChoosingItemContainerEventArgs, IChoosingItemContainerEventArgs_Ptr);
   begin
      if this.m_IChoosingItemContainerEventArgs /= null then
         if this.m_IChoosingItemContainerEventArgs.all /= null then
            temp := this.m_IChoosingItemContainerEventArgs.all.Release;
            Free (this.m_IChoosingItemContainerEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ChoosingItemContainerEventArgs

   function Constructor return ChoosingItemContainerEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IChoosingItemContainerEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IChoosingItemContainerEventArgs;
   begin
      return RetVal : ChoosingItemContainerEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IChoosingItemContainerEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IChoosingItemContainerEventArgs;
            Retval.m_IChoosingItemContainerEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ChoosingItemContainerEventArgs

   function get_ItemIndex
   (
      this : in out ChoosingItemContainerEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IChoosingItemContainerEventArgs.all.get_ItemIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Item
   (
      this : in out ChoosingItemContainerEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IChoosingItemContainerEventArgs.all.get_Item (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ItemContainer
   (
      this : in out ChoosingItemContainerEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SelectorItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorItem;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SelectorItem do
         Hr := this.m_IChoosingItemContainerEventArgs.all.get_ItemContainer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISelectorItem := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorItem;
         Retval.m_ISelectorItem.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainer
   (
      this : in out ChoosingItemContainerEventArgs;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SelectorItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IChoosingItemContainerEventArgs.all.put_ItemContainer (value.m_ISelectorItem.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsContainerPrepared
   (
      this : in out ChoosingItemContainerEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IChoosingItemContainerEventArgs.all.get_IsContainerPrepared (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsContainerPrepared
   (
      this : in out ChoosingItemContainerEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IChoosingItemContainerEventArgs.all.put_IsContainerPrepared (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CleanUpVirtualizedItemEventArgs

   procedure Initialize (this : in out CleanUpVirtualizedItemEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CleanUpVirtualizedItemEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICleanUpVirtualizedItemEventArgs, ICleanUpVirtualizedItemEventArgs_Ptr);
   begin
      if this.m_ICleanUpVirtualizedItemEventArgs /= null then
         if this.m_ICleanUpVirtualizedItemEventArgs.all /= null then
            temp := this.m_ICleanUpVirtualizedItemEventArgs.all.Release;
            Free (this.m_ICleanUpVirtualizedItemEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CleanUpVirtualizedItemEventArgs

   function get_Value
   (
      this : in out CleanUpVirtualizedItemEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ICleanUpVirtualizedItemEventArgs.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_UIElement
   (
      this : in out CleanUpVirtualizedItemEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_ICleanUpVirtualizedItemEventArgs.all.get_UIElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_Cancel
   (
      this : in out CleanUpVirtualizedItemEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICleanUpVirtualizedItemEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out CleanUpVirtualizedItemEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICleanUpVirtualizedItemEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate CleanUpVirtualizedItemEventHandler

   function Invoke
   (
      this : access CleanUpVirtualizedItemEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.ICleanUpVirtualizedItemEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorChangedEventArgs

   procedure Initialize (this : in out ColorChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColorChangedEventArgs, IColorChangedEventArgs_Ptr);
   begin
      if this.m_IColorChangedEventArgs /= null then
         if this.m_IColorChangedEventArgs.all /= null then
            temp := this.m_IColorChangedEventArgs.all.Release;
            Free (this.m_IColorChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorChangedEventArgs

   function get_OldColor
   (
      this : in out ColorChangedEventArgs
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IColorChangedEventArgs.all.get_OldColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewColor
   (
      this : in out ColorChangedEventArgs
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IColorChangedEventArgs.all.get_NewColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorPicker

   procedure Initialize (this : in out ColorPicker) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorPicker) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColorPicker, IColorPicker_Ptr);
   begin
      if this.m_IColorPicker /= null then
         if this.m_IColorPicker.all /= null then
            temp := this.m_IColorPicker.all.Release;
            Free (this.m_IColorPicker);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColorPicker

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ColorPicker is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IColorPicker");
      m_Factory    : access IColorPickerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IColorPicker;
   begin
      return RetVal : ColorPicker do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IColorPicker := new WinUI3.Microsoft.UI.Xaml.Controls.IColorPicker;
            Retval.m_IColorPicker.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ColorPicker

   function get_ColorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreviousColorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreviousColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsAlphaEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsAlphaEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorSpectrumVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorSpectrumVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorPreviewVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorPreviewVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorSliderVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorSliderVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsAlphaSliderVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsAlphaSliderVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsMoreButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsMoreButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorChannelTextInputVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorChannelTextInputVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsAlphaTextInputVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsAlphaTextInputVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHexInputVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHexInputVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinHueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinHueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxHueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxHueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinSaturationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinSaturationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxSaturationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxSaturationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinValueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxValueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ColorSpectrumShapeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorSpectrumShapeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ColorSpectrumComponentsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorSpectrumComponentsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColorPickerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorPicker

   function get_Color
   (
      this : in out ColorPicker
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IColorPicker.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out ColorPicker;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreviousColor
   (
      this : in out ColorPicker
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IColorPicker.all.get_PreviousColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreviousColor
   (
      this : in out ColorPicker;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_PreviousColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsAlphaEnabled
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsAlphaEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsAlphaEnabled
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsAlphaEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorSpectrumVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsColorSpectrumVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorSpectrumVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsColorSpectrumVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorPreviewVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsColorPreviewVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorPreviewVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsColorPreviewVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorSliderVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsColorSliderVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorSliderVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsColorSliderVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsAlphaSliderVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsAlphaSliderVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsAlphaSliderVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsAlphaSliderVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsMoreButtonVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsMoreButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsMoreButtonVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsMoreButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorChannelTextInputVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsColorChannelTextInputVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorChannelTextInputVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsColorChannelTextInputVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsAlphaTextInputVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsAlphaTextInputVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsAlphaTextInputVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsAlphaTextInputVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHexInputVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsHexInputVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHexInputVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsHexInputVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinHue
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MinHue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinHue
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MinHue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxHue
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MaxHue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxHue
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MaxHue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinSaturation
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MinSaturation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinSaturation
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MinSaturation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxSaturation
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MaxSaturation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxSaturation
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MaxSaturation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinValue
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MinValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinValue
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MinValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxValue
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MaxValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxValue
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MaxValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ColorSpectrumShape
   (
      this : in out ColorPicker
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumShape is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumShape;
   begin
      Hr := this.m_IColorPicker.all.get_ColorSpectrumShape (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ColorSpectrumShape
   (
      this : in out ColorPicker;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumShape
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_ColorSpectrumShape (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ColorSpectrumComponents
   (
      this : in out ColorPicker
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumComponents is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumComponents;
   begin
      Hr := this.m_IColorPicker.all.get_ColorSpectrumComponents (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ColorSpectrumComponents
   (
      this : in out ColorPicker;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumComponents
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_ColorSpectrumComponents (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ColorChanged
   (
      this : in out ColorPicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IColorPicker.all.add_ColorChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ColorChanged
   (
      this : in out ColorPicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.remove_ColorChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out ColorPicker
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IColorPicker2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IColorPicker_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IColorPicker2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IColorPicker2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IColorPicker.all);
      Hr := m_Interface.get_Orientation (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out ColorPicker;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IColorPicker2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IColorPicker_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IColorPicker2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IColorPicker2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IColorPicker.all);
      Hr := m_Interface.put_Orientation (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColumnDefinition

   procedure Initialize (this : in out ColumnDefinition) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColumnDefinition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColumnDefinition, IColumnDefinition_Ptr);
   begin
      if this.m_IColumnDefinition /= null then
         if this.m_IColumnDefinition.all /= null then
            temp := this.m_IColumnDefinition.all.Release;
            Free (this.m_IColumnDefinition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColumnDefinition

   function Constructor return ColumnDefinition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IColumnDefinition");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinition;
   begin
      return RetVal : ColumnDefinition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IColumnDefinition := new WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinition;
            Retval.m_IColumnDefinition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ColumnDefinition

   function get_WidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColumnDefinition");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColumnDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_WidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColumnDefinition");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColumnDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ColumnDefinition");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColumnDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColumnDefinition

   function get_Width
   (
      this : in out ColumnDefinition
   )
   return WinUI3.Microsoft.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.GridLength;
   begin
      Hr := this.m_IColumnDefinition.all.get_Width (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Width
   (
      this : in out ColumnDefinition;
      value : WinUI3.Microsoft.UI.Xaml.GridLength
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColumnDefinition.all.put_Width (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxWidth
   (
      this : in out ColumnDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IColumnDefinition.all.get_MaxWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxWidth
   (
      this : in out ColumnDefinition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColumnDefinition.all.put_MaxWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinWidth
   (
      this : in out ColumnDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IColumnDefinition.all.get_MinWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinWidth
   (
      this : in out ColumnDefinition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColumnDefinition.all.put_MinWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActualWidth
   (
      this : in out ColumnDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IColumnDefinition.all.get_ActualWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColumnDefinitionCollection

   procedure Initialize (this : in out ColumnDefinitionCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColumnDefinitionCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColumnDefinitionCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Controls.ColumnDefinition>
   function GetAt
   (
      this : in out ColumnDefinitionCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinition;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IColumnDefinition := new WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinition;
         Retval.m_IColumnDefinition.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out ColumnDefinitionCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out ColumnDefinitionCollection
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinition;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IColumnDefinition := new WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinition;
         Retval.m_IColumnDefinition.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out ColumnDefinitionCollection;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinition'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IColumnDefinition.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out ColumnDefinitionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IColumnDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out ColumnDefinitionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IColumnDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out ColumnDefinitionCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out ColumnDefinitionCollection;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IColumnDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out ColumnDefinitionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out ColumnDefinitionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out ColumnDefinitionCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinition_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out ColumnDefinitionCollection;
      items : WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinition_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1956365436, 5955, 23585, (156, 237, 200, 161, 19, 76, 123, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.ColumnDefinition>
   function First
   (
      this : in out ColumnDefinitionCollection
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinition;
      m_GenericIID     : aliased WinUI3.IID := (2155093135, 41985, 23651, (182, 196, 21, 209, 101, 229, 65, 199 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IColumnDefinition := new WinUI3.Microsoft.UI.Xaml.Controls.IColumnDefinition;
         Retval.m_IColumnDefinition.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ComboBox

   procedure Initialize (this : in out ComboBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out ComboBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IComboBox, IComboBox_Ptr);
   begin
      if this.m_IComboBox /= null then
         if this.m_IComboBox.all /= null then
            temp := this.m_IComboBox.all.Release;
            Free (this.m_IComboBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ComboBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ComboBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IComboBox");
      m_Factory    : access IComboBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IComboBox;
   begin
      return RetVal : ComboBox do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IComboBox := new WinUI3.Microsoft.UI.Xaml.Controls.IComboBox;
            Retval.m_IComboBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ComboBox

   function get_IsEditableProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsEditableProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsDropDownOpenProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDropDownOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxDropDownHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxDropDownHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_ComboBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_ComboBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_ComboBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty_ComboBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextSearchEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextSearchEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionChangedTriggerProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionChangedTriggerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextProperty_ComboBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextBoxStyleProperty_ComboBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextBoxStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty_ComboBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ComboBox

   function get_IsDropDownOpen
   (
      this : in out ComboBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IComboBox.all.get_IsDropDownOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDropDownOpen
   (
      this : in out ComboBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_IsDropDownOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsEditable
   (
      this : in out ComboBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IComboBox.all.get_IsEditable (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsEditable
   (
      this : in out ComboBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_IsEditable (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSelectionBoxHighlighted
   (
      this : in out ComboBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IComboBox.all.get_IsSelectionBoxHighlighted (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MaxDropDownHeight
   (
      this : in out ComboBox
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IComboBox.all.get_MaxDropDownHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxDropDownHeight
   (
      this : in out ComboBox;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_MaxDropDownHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionBoxItem
   (
      this : in out ComboBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IComboBox.all.get_SelectionBoxItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionBoxItemTemplate
   (
      this : in out ComboBox
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IComboBox.all.get_SelectionBoxItemTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   function get_TemplateSettings
   (
      this : in out ComboBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IComboBoxTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings do
         Hr := this.m_IComboBox.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IComboBoxTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IComboBoxTemplateSettings;
         Retval.m_IComboBoxTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_Header
   (
      this : in out ComboBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IComboBox.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out ComboBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out ComboBox
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IComboBox.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out ComboBox;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderText
   (
      this : in out ComboBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IComboBox.all.get_PlaceholderText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out ComboBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IComboBox.all.put_PlaceholderText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_LightDismissOverlayMode
   (
      this : in out ComboBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode;
   begin
      Hr := this.m_IComboBox.all.get_LightDismissOverlayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out ComboBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_LightDismissOverlayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextSearchEnabled
   (
      this : in out ComboBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IComboBox.all.get_IsTextSearchEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextSearchEnabled
   (
      this : in out ComboBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_IsTextSearchEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionChangedTrigger
   (
      this : in out ComboBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ComboBoxSelectionChangedTrigger is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ComboBoxSelectionChangedTrigger;
   begin
      Hr := this.m_IComboBox.all.get_SelectionChangedTrigger (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionChangedTrigger
   (
      this : in out ComboBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ComboBoxSelectionChangedTrigger
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_SelectionChangedTrigger (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderForeground
   (
      this : in out ComboBox
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IComboBox.all.get_PlaceholderForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlaceholderForeground
   (
      this : in out ComboBox;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_PlaceholderForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Text
   (
      this : in out ComboBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IComboBox.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out ComboBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IComboBox.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_TextBoxStyle
   (
      this : in out ComboBox
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IComboBox.all.get_TextBoxStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_TextBoxStyle
   (
      this : in out ComboBox;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_TextBoxStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Description
   (
      this : in out ComboBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IComboBox.all.get_Description (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out ComboBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_Description (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DropDownClosed
   (
      this : in out ComboBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IComboBox.all.add_DropDownClosed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DropDownClosed
   (
      this : in out ComboBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.remove_DropDownClosed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DropDownOpened
   (
      this : in out ComboBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IComboBox.all.add_DropDownOpened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DropDownOpened
   (
      this : in out ComboBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.remove_DropDownOpened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextSubmitted
   (
      this : in out ComboBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IComboBox.all.add_TextSubmitted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextSubmitted
   (
      this : in out ComboBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.remove_TextSubmitted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDropDownClosed
   (
      this : in out ComboBox;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IComboBoxOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.OnDropDownClosed (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDropDownOpened
   (
      this : in out ComboBox;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IComboBoxOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.OnDropDownOpened (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ComboBoxItem

   procedure Initialize (this : in out ComboBoxItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ComboBoxItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IComboBoxItem, IComboBoxItem_Ptr);
   begin
      if this.m_IComboBoxItem /= null then
         if this.m_IComboBoxItem.all /= null then
            temp := this.m_IComboBoxItem.all.Release;
            Free (this.m_IComboBoxItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ComboBoxItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ComboBoxItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IComboBoxItem");
      m_Factory    : access IComboBoxItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxItem;
   begin
      return RetVal : ComboBoxItem do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IComboBoxItem := new WinUI3.Microsoft.UI.Xaml.Controls.IComboBoxItem;
            Retval.m_IComboBoxItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ComboBoxItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ComboBoxTextSubmittedEventArgs

   procedure Initialize (this : in out ComboBoxTextSubmittedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ComboBoxTextSubmittedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IComboBoxTextSubmittedEventArgs, IComboBoxTextSubmittedEventArgs_Ptr);
   begin
      if this.m_IComboBoxTextSubmittedEventArgs /= null then
         if this.m_IComboBoxTextSubmittedEventArgs.all /= null then
            temp := this.m_IComboBoxTextSubmittedEventArgs.all.Release;
            Free (this.m_IComboBoxTextSubmittedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ComboBoxTextSubmittedEventArgs

   function get_Text
   (
      this : in out ComboBoxTextSubmittedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IComboBoxTextSubmittedEventArgs.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Handled
   (
      this : in out ComboBoxTextSubmittedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IComboBoxTextSubmittedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ComboBoxTextSubmittedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBoxTextSubmittedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CommandBar

   procedure Initialize (this : in out CommandBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out CommandBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICommandBar, ICommandBar_Ptr);
   begin
      if this.m_ICommandBar /= null then
         if this.m_ICommandBar.all /= null then
            temp := this.m_ICommandBar.all.Release;
            Free (this.m_ICommandBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CommandBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CommandBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ICommandBar");
      m_Factory    : access ICommandBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ICommandBar;
   begin
      return RetVal : CommandBar do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICommandBar := new WinUI3.Microsoft.UI.Xaml.Controls.ICommandBar;
            Retval.m_ICommandBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CommandBar

   function get_PrimaryCommandsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryCommandsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryCommandsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryCommandsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandBarOverflowPresenterStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandBarOverflowPresenterStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultLabelPositionProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultLabelPositionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OverflowButtonVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OverflowButtonVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsDynamicOverflowEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDynamicOverflowEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CommandBar

   function get_PrimaryCommands
   (
      this : in out CommandBar
   )
   return IObservableVector_ICommandBarElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_ICommandBarElement.Kind;
   begin
      Hr := this.m_ICommandBar.all.get_PrimaryCommands (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_ICommandBarElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SecondaryCommands
   (
      this : in out CommandBar
   )
   return IObservableVector_ICommandBarElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_ICommandBarElement.Kind;
   begin
      Hr := this.m_ICommandBar.all.get_SecondaryCommands (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_ICommandBarElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_CommandBarOverflowPresenterStyle
   (
      this : in out CommandBar
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_ICommandBar.all.get_CommandBarOverflowPresenterStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_CommandBarOverflowPresenterStyle
   (
      this : in out CommandBar;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICommandBar.all.put_CommandBarOverflowPresenterStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CommandBarTemplateSettings
   (
      this : in out CommandBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings do
         Hr := this.m_ICommandBar.all.get_CommandBarTemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICommandBarTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarTemplateSettings;
         Retval.m_ICommandBarTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_DefaultLabelPosition
   (
      this : in out CommandBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CommandBarDefaultLabelPosition is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CommandBarDefaultLabelPosition;
   begin
      Hr := this.m_ICommandBar.all.get_DefaultLabelPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultLabelPosition
   (
      this : in out CommandBar;
      value : WinUI3.Microsoft.UI.Xaml.Controls.CommandBarDefaultLabelPosition
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICommandBar.all.put_DefaultLabelPosition (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OverflowButtonVisibility
   (
      this : in out CommandBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CommandBarOverflowButtonVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CommandBarOverflowButtonVisibility;
   begin
      Hr := this.m_ICommandBar.all.get_OverflowButtonVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OverflowButtonVisibility
   (
      this : in out CommandBar;
      value : WinUI3.Microsoft.UI.Xaml.Controls.CommandBarOverflowButtonVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICommandBar.all.put_OverflowButtonVisibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsDynamicOverflowEnabled
   (
      this : in out CommandBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICommandBar.all.get_IsDynamicOverflowEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDynamicOverflowEnabled
   (
      this : in out CommandBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICommandBar.all.put_IsDynamicOverflowEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DynamicOverflowItemsChanging
   (
      this : in out CommandBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICommandBar.all.add_DynamicOverflowItemsChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DynamicOverflowItemsChanging
   (
      this : in out CommandBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICommandBar.all.remove_DynamicOverflowItemsChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CommandBarFlyout

   procedure Initialize (this : in out CommandBarFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out CommandBarFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICommandBarFlyout, ICommandBarFlyout_Ptr);
   begin
      if this.m_ICommandBarFlyout /= null then
         if this.m_ICommandBarFlyout.all /= null then
            temp := this.m_ICommandBarFlyout.all.Release;
            Free (this.m_ICommandBarFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CommandBarFlyout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CommandBarFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ICommandBarFlyout");
      m_Factory    : access ICommandBarFlyoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarFlyout;
   begin
      return RetVal : CommandBarFlyout do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICommandBarFlyout := new WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarFlyout;
            Retval.m_ICommandBarFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CommandBarFlyout

   function get_PrimaryCommands
   (
      this : in out CommandBarFlyout
   )
   return IObservableVector_ICommandBarElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_ICommandBarElement.Kind;
   begin
      Hr := this.m_ICommandBarFlyout.all.get_PrimaryCommands (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_ICommandBarElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SecondaryCommands
   (
      this : in out CommandBarFlyout
   )
   return IObservableVector_ICommandBarElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_ICommandBarElement.Kind;
   begin
      Hr := this.m_ICommandBarFlyout.all.get_SecondaryCommands (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_ICommandBarElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_AlwaysExpanded
   (
      this : in out CommandBarFlyout
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarFlyout2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarFlyout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarFlyout2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarFlyout2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBarFlyout.all);
      Hr := m_Interface.get_AlwaysExpanded (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AlwaysExpanded
   (
      this : in out CommandBarFlyout;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarFlyout2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarFlyout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarFlyout2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ICommandBarFlyout2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBarFlyout.all);
      Hr := m_Interface.put_AlwaysExpanded (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CommandBarOverflowPresenter

   procedure Initialize (this : in out CommandBarOverflowPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out CommandBarOverflowPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICommandBarOverflowPresenter, ICommandBarOverflowPresenter_Ptr);
   begin
      if this.m_ICommandBarOverflowPresenter /= null then
         if this.m_ICommandBarOverflowPresenter.all /= null then
            temp := this.m_ICommandBarOverflowPresenter.all.Release;
            Free (this.m_ICommandBarOverflowPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CommandBarOverflowPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CommandBarOverflowPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ICommandBarOverflowPresenter");
      m_Factory    : access ICommandBarOverflowPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarOverflowPresenter;
   begin
      return RetVal : CommandBarOverflowPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarOverflowPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICommandBarOverflowPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.ICommandBarOverflowPresenter;
            Retval.m_ICommandBarOverflowPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CommandBarOverflowPresenter

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContainerContentChangingEventArgs

   procedure Initialize (this : in out ContainerContentChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContainerContentChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContainerContentChangingEventArgs, IContainerContentChangingEventArgs_Ptr);
   begin
      if this.m_IContainerContentChangingEventArgs /= null then
         if this.m_IContainerContentChangingEventArgs.all /= null then
            temp := this.m_IContainerContentChangingEventArgs.all.Release;
            Free (this.m_IContainerContentChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContainerContentChangingEventArgs

   function Constructor return ContainerContentChangingEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IContainerContentChangingEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IContainerContentChangingEventArgs;
   begin
      return RetVal : ContainerContentChangingEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IContainerContentChangingEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IContainerContentChangingEventArgs;
            Retval.m_IContainerContentChangingEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContainerContentChangingEventArgs

   function get_ItemContainer
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SelectorItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorItem;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SelectorItem do
         Hr := this.m_IContainerContentChangingEventArgs.all.get_ItemContainer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISelectorItem := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorItem;
         Retval.m_ISelectorItem.all := m_ComRetVal;
      end return;
   end;

   function get_InRecycleQueue
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.get_InRecycleQueue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ItemIndex
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.get_ItemIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Item
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.get_Item (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Phase
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.get_Phase (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ContainerContentChangingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RegisterUpdateCallback
   (
      this : in out ContainerContentChangingEventArgs;
      callback : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.RegisterUpdateCallback (callback);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RegisterUpdateCallback
   (
      this : in out ContainerContentChangingEventArgs;
      callbackPhase : WinUI3.UInt32;
      callback : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.RegisterUpdateCallback (callbackPhase, callback);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialog

   procedure Initialize (this : in out ContentDialog) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialog) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialog, IContentDialog_Ptr);
   begin
      if this.m_IContentDialog /= null then
         if this.m_IContentDialog.all /= null then
            temp := this.m_IContentDialog.all.Release;
            Free (this.m_IContentDialog);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContentDialog

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ContentDialog is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IContentDialog");
      m_Factory    : access IContentDialogFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IContentDialog;
   begin
      return RetVal : ContentDialog do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IContentDialog := new WinUI3.Microsoft.UI.Xaml.Controls.IContentDialog;
            Retval.m_IContentDialog.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ContentDialog

   function get_TitleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TitleTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FullSizeDesiredProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FullSizeDesiredProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PrimaryButtonTextProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryButtonTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryButtonTextProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryButtonTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonTextProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PrimaryButtonCommandProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryButtonCommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryButtonCommandProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryButtonCommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonCommandProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonCommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PrimaryButtonCommandParameterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryButtonCommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryButtonCommandParameterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryButtonCommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonCommandParameterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonCommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPrimaryButtonEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPrimaryButtonEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSecondaryButtonEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSecondaryButtonEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PrimaryButtonStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryButtonStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultButtonProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultButtonProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialog

   function get_Title
   (
      this : in out ContentDialog
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContentDialog.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Title
   (
      this : in out ContentDialog;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_Title (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TitleTemplate
   (
      this : in out ContentDialog
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IContentDialog.all.get_TitleTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_TitleTemplate
   (
      this : in out ContentDialog;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_TitleTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FullSizeDesired
   (
      this : in out ContentDialog
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContentDialog.all.get_FullSizeDesired (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FullSizeDesired
   (
      this : in out ContentDialog;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_FullSizeDesired (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PrimaryButtonText
   (
      this : in out ContentDialog
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IContentDialog.all.get_PrimaryButtonText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PrimaryButtonText
   (
      this : in out ContentDialog;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IContentDialog.all.put_PrimaryButtonText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SecondaryButtonText
   (
      this : in out ContentDialog
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IContentDialog.all.get_SecondaryButtonText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SecondaryButtonText
   (
      this : in out ContentDialog;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IContentDialog.all.put_SecondaryButtonText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_CloseButtonText
   (
      this : in out ContentDialog
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IContentDialog.all.get_CloseButtonText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CloseButtonText
   (
      this : in out ContentDialog;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IContentDialog.all.put_CloseButtonText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PrimaryButtonCommand
   (
      this : in out ContentDialog
   )
   return WinUI3.Microsoft.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_IContentDialog.all.get_PrimaryButtonCommand (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PrimaryButtonCommand
   (
      this : in out ContentDialog;
      value : WinUI3.Microsoft.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_PrimaryButtonCommand (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SecondaryButtonCommand
   (
      this : in out ContentDialog
   )
   return WinUI3.Microsoft.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_IContentDialog.all.get_SecondaryButtonCommand (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SecondaryButtonCommand
   (
      this : in out ContentDialog;
      value : WinUI3.Microsoft.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_SecondaryButtonCommand (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonCommand
   (
      this : in out ContentDialog
   )
   return WinUI3.Microsoft.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_IContentDialog.all.get_CloseButtonCommand (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CloseButtonCommand
   (
      this : in out ContentDialog;
      value : WinUI3.Microsoft.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_CloseButtonCommand (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PrimaryButtonCommandParameter
   (
      this : in out ContentDialog
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContentDialog.all.get_PrimaryButtonCommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PrimaryButtonCommandParameter
   (
      this : in out ContentDialog;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_PrimaryButtonCommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SecondaryButtonCommandParameter
   (
      this : in out ContentDialog
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContentDialog.all.get_SecondaryButtonCommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SecondaryButtonCommandParameter
   (
      this : in out ContentDialog;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_SecondaryButtonCommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonCommandParameter
   (
      this : in out ContentDialog
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContentDialog.all.get_CloseButtonCommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CloseButtonCommandParameter
   (
      this : in out ContentDialog;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_CloseButtonCommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPrimaryButtonEnabled
   (
      this : in out ContentDialog
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContentDialog.all.get_IsPrimaryButtonEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPrimaryButtonEnabled
   (
      this : in out ContentDialog;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_IsPrimaryButtonEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSecondaryButtonEnabled
   (
      this : in out ContentDialog
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContentDialog.all.get_IsSecondaryButtonEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSecondaryButtonEnabled
   (
      this : in out ContentDialog;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_IsSecondaryButtonEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PrimaryButtonStyle
   (
      this : in out ContentDialog
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IContentDialog.all.get_PrimaryButtonStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_PrimaryButtonStyle
   (
      this : in out ContentDialog;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_PrimaryButtonStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SecondaryButtonStyle
   (
      this : in out ContentDialog
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IContentDialog.all.get_SecondaryButtonStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_SecondaryButtonStyle
   (
      this : in out ContentDialog;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_SecondaryButtonStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonStyle
   (
      this : in out ContentDialog
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IContentDialog.all.get_CloseButtonStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_CloseButtonStyle
   (
      this : in out ContentDialog;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_CloseButtonStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DefaultButton
   (
      this : in out ContentDialog
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogButton is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogButton;
   begin
      Hr := this.m_IContentDialog.all.get_DefaultButton (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultButton
   (
      this : in out ContentDialog;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogButton
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_DefaultButton (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closing
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IContentDialog.all.add_Closing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closing
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.remove_Closing (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IContentDialog.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opened
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IContentDialog.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PrimaryButtonClick
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IContentDialog.all.add_PrimaryButtonClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PrimaryButtonClick
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.remove_PrimaryButtonClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SecondaryButtonClick
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IContentDialog.all.add_SecondaryButtonClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SecondaryButtonClick
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.remove_SecondaryButtonClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CloseButtonClick
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IContentDialog.all.add_CloseButtonClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CloseButtonClick
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.remove_CloseButtonClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Hide
   (
      this : in out ContentDialog
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.Hide;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAsync
   (
      this : in out ContentDialog
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_ContentDialogResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_ContentDialogResult.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogResult;
      m_IID            : aliased WinUI3.IID := (3551344193, 33319, 23006, (186, 200, 133, 211, 121, 92, 102, 16 )); -- Microsoft.UI.Xaml.Controls.ContentDialogResult;
      m_HandlerIID     : aliased WinUI3.IID := (3310137581, 42195, 24462, (181, 188, 145, 245, 9, 138, 38, 125 ));
      m_Handler        : AsyncOperationCompletedHandler_ContentDialogResult.Kind := new AsyncOperationCompletedHandler_ContentDialogResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_ContentDialogResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_ContentDialogResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_ContentDialogResult.Kind_Delegate, AsyncOperationCompletedHandler_ContentDialogResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IContentDialog.all.ShowAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function ShowAsync
   (
      this : in out ContentDialog;
      placement : WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogPlacement
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_ContentDialogResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_ContentDialogResult.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogResult;
      m_IID            : aliased WinUI3.IID := (3551344193, 33319, 23006, (186, 200, 133, 211, 121, 92, 102, 16 )); -- Microsoft.UI.Xaml.Controls.ContentDialogResult;
      m_HandlerIID     : aliased WinUI3.IID := (3310137581, 42195, 24462, (181, 188, 145, 245, 9, 138, 38, 125 ));
      m_Handler        : AsyncOperationCompletedHandler_ContentDialogResult.Kind := new AsyncOperationCompletedHandler_ContentDialogResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_ContentDialogResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_ContentDialogResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_ContentDialogResult.Kind_Delegate, AsyncOperationCompletedHandler_ContentDialogResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IContentDialog.all.ShowAsync (placement, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogButtonClickDeferral

   procedure Initialize (this : in out ContentDialogButtonClickDeferral) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogButtonClickDeferral) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogButtonClickDeferral, IContentDialogButtonClickDeferral_Ptr);
   begin
      if this.m_IContentDialogButtonClickDeferral /= null then
         if this.m_IContentDialogButtonClickDeferral.all /= null then
            temp := this.m_IContentDialogButtonClickDeferral.all.Release;
            Free (this.m_IContentDialogButtonClickDeferral);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogButtonClickDeferral

   procedure Complete
   (
      this : in out ContentDialogButtonClickDeferral
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialogButtonClickDeferral.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogButtonClickEventArgs

   procedure Initialize (this : in out ContentDialogButtonClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogButtonClickEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogButtonClickEventArgs, IContentDialogButtonClickEventArgs_Ptr);
   begin
      if this.m_IContentDialogButtonClickEventArgs /= null then
         if this.m_IContentDialogButtonClickEventArgs.all /= null then
            temp := this.m_IContentDialogButtonClickEventArgs.all.Release;
            Free (this.m_IContentDialogButtonClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogButtonClickEventArgs

   function get_Cancel
   (
      this : in out ContentDialogButtonClickEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContentDialogButtonClickEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out ContentDialogButtonClickEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialogButtonClickEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out ContentDialogButtonClickEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogButtonClickDeferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogButtonClickDeferral;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogButtonClickDeferral do
         Hr := this.m_IContentDialogButtonClickEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IContentDialogButtonClickDeferral := new WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogButtonClickDeferral;
         Retval.m_IContentDialogButtonClickDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogClosedEventArgs

   procedure Initialize (this : in out ContentDialogClosedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogClosedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogClosedEventArgs, IContentDialogClosedEventArgs_Ptr);
   begin
      if this.m_IContentDialogClosedEventArgs /= null then
         if this.m_IContentDialogClosedEventArgs.all /= null then
            temp := this.m_IContentDialogClosedEventArgs.all.Release;
            Free (this.m_IContentDialogClosedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogClosedEventArgs

   function get_Result
   (
      this : in out ContentDialogClosedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogResult;
   begin
      Hr := this.m_IContentDialogClosedEventArgs.all.get_Result (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogClosingDeferral

   procedure Initialize (this : in out ContentDialogClosingDeferral) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogClosingDeferral) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogClosingDeferral, IContentDialogClosingDeferral_Ptr);
   begin
      if this.m_IContentDialogClosingDeferral /= null then
         if this.m_IContentDialogClosingDeferral.all /= null then
            temp := this.m_IContentDialogClosingDeferral.all.Release;
            Free (this.m_IContentDialogClosingDeferral);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogClosingDeferral

   procedure Complete
   (
      this : in out ContentDialogClosingDeferral
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialogClosingDeferral.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogClosingEventArgs

   procedure Initialize (this : in out ContentDialogClosingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogClosingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogClosingEventArgs, IContentDialogClosingEventArgs_Ptr);
   begin
      if this.m_IContentDialogClosingEventArgs /= null then
         if this.m_IContentDialogClosingEventArgs.all /= null then
            temp := this.m_IContentDialogClosingEventArgs.all.Release;
            Free (this.m_IContentDialogClosingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogClosingEventArgs

   function get_Result
   (
      this : in out ContentDialogClosingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogResult;
   begin
      Hr := this.m_IContentDialogClosingEventArgs.all.get_Result (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out ContentDialogClosingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContentDialogClosingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out ContentDialogClosingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialogClosingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out ContentDialogClosingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogClosingDeferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogClosingDeferral;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ContentDialogClosingDeferral do
         Hr := this.m_IContentDialogClosingEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IContentDialogClosingDeferral := new WinUI3.Microsoft.UI.Xaml.Controls.IContentDialogClosingDeferral;
         Retval.m_IContentDialogClosingDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogOpenedEventArgs

   procedure Initialize (this : in out ContentDialogOpenedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogOpenedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogOpenedEventArgs, IContentDialogOpenedEventArgs_Ptr);
   begin
      if this.m_IContentDialogOpenedEventArgs /= null then
         if this.m_IContentDialogOpenedEventArgs.all /= null then
            temp := this.m_IContentDialogOpenedEventArgs.all.Release;
            Free (this.m_IContentDialogOpenedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogOpenedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentPresenter

   procedure Initialize (this : in out ContentPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentPresenter, IContentPresenter_Ptr);
   begin
      if this.m_IContentPresenter /= null then
         if this.m_IContentPresenter.all /= null then
            temp := this.m_IContentPresenter.all.Release;
            Free (this.m_IContentPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContentPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ContentPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IContentPresenter");
      m_Factory    : access IContentPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenter;
   begin
      return RetVal : ContentPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IContentPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenter;
            Retval.m_IContentPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ContentPresenter

   function get_ContentProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTemplateProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTemplateSelectorProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTransitionsProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontSizeProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStretchProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterSpacingProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForegroundProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpticalMarginAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpticalMarginAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextLineBoundsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextLineBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextScaleFactorEnabledProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextWrappingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextWrappingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLinesProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLinesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineStackingStrategyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineStackingStrategyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderBrushProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundSizingProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalContentAlignmentProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalContentAlignmentProperty_ContentPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentPresenter

   function get_Content
   (
      this : in out ContentPresenter
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContentPresenter.all.get_Content (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Content
   (
      this : in out ContentPresenter;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_Content (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplate
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IContentPresenter.all.get_ContentTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTemplate
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_ContentTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplateSelector
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_IContentPresenter.all.get_ContentTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTemplateSelector
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_ContentTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTransitions
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IContentPresenter.all.get_ContentTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTransitions
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_ContentTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontSize
   (
      this : in out ContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IContentPresenter.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out ContentPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.FontFamily do
         Hr := this.m_IContentPresenter.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_IContentPresenter.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_IContentPresenter.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStretch
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Text.FontStretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStretch;
   begin
      Hr := this.m_IContentPresenter.all.get_FontStretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStretch
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Text.FontStretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_FontStretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterSpacing
   (
      this : in out ContentPresenter
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IContentPresenter.all.get_CharacterSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterSpacing
   (
      this : in out ContentPresenter;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_CharacterSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Foreground
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IContentPresenter.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpticalMarginAlignment
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.OpticalMarginAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.OpticalMarginAlignment;
   begin
      Hr := this.m_IContentPresenter.all.get_OpticalMarginAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpticalMarginAlignment
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.OpticalMarginAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_OpticalMarginAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextLineBounds
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.TextLineBounds is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextLineBounds;
   begin
      Hr := this.m_IContentPresenter.all.get_TextLineBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextLineBounds
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.TextLineBounds
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_TextLineBounds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out ContentPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContentPresenter.all.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out ContentPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_IsTextScaleFactorEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundTransition
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.BrushTransition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IBrushTransition;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.BrushTransition do
         Hr := this.m_IContentPresenter.all.get_BackgroundTransition (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrushTransition := new WinUI3.Microsoft.UI.Xaml.IBrushTransition;
         Retval.m_IBrushTransition.all := m_ComRetVal;
      end return;
   end;

   procedure put_BackgroundTransition
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.BrushTransition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_BackgroundTransition (value.m_IBrushTransition.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextWrapping
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.TextWrapping is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextWrapping;
   begin
      Hr := this.m_IContentPresenter.all.get_TextWrapping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextWrapping
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.TextWrapping
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_TextWrapping (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxLines
   (
      this : in out ContentPresenter
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IContentPresenter.all.get_MaxLines (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLines
   (
      this : in out ContentPresenter;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_MaxLines (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineStackingStrategy
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.LineStackingStrategy is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.LineStackingStrategy;
   begin
      Hr := this.m_IContentPresenter.all.get_LineStackingStrategy (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineStackingStrategy
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.LineStackingStrategy
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_LineStackingStrategy (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineHeight
   (
      this : in out ContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IContentPresenter.all.get_LineHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineHeight
   (
      this : in out ContentPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_LineHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderBrush
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IContentPresenter.all.get_BorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_BorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IContentPresenter.all.get_BorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_BorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_IContentPresenter.all.get_CornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_CornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IContentPresenter.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Background
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IContentPresenter.all.get_Background (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_Background (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundSizing
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing;
   begin
      Hr := this.m_IContentPresenter.all.get_BackgroundSizing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_BackgroundSizing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalContentAlignment
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_IContentPresenter.all.get_HorizontalContentAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalContentAlignment
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_HorizontalContentAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalContentAlignment
   (
      this : in out ContentPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_IContentPresenter.all.get_VerticalContentAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalContentAlignment
   (
      this : in out ContentPresenter;
      value : WinUI3.Microsoft.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_VerticalContentAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnContentTemplateChanged
   (
      this : in out ContentPresenter;
      oldContentTemplate : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class;
      newContentTemplate : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IContentPresenterOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.OnContentTemplateChanged (oldContentTemplate.m_IDataTemplate.all, newContentTemplate.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnContentTemplateSelectorChanged
   (
      this : in out ContentPresenter;
      oldContentTemplateSelector : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class;
      newContentTemplateSelector : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IContentPresenterOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IContentPresenterOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.OnContentTemplateSelectorChanged (oldContentTemplateSelector.m_IDataTemplateSelector.all, newContentTemplateSelector.m_IDataTemplateSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContextMenuEventArgs

   procedure Initialize (this : in out ContextMenuEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContextMenuEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContextMenuEventArgs, IContextMenuEventArgs_Ptr);
   begin
      if this.m_IContextMenuEventArgs /= null then
         if this.m_IContextMenuEventArgs.all /= null then
            temp := this.m_IContextMenuEventArgs.all.Release;
            Free (this.m_IContextMenuEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContextMenuEventArgs

   function get_Handled
   (
      this : in out ContextMenuEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContextMenuEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ContextMenuEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContextMenuEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CursorLeft
   (
      this : in out ContextMenuEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IContextMenuEventArgs.all.get_CursorLeft (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CursorTop
   (
      this : in out ContextMenuEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IContextMenuEventArgs.all.get_CursorTop (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ContextMenuOpeningEventHandler

   function Invoke
   (
      this : access ContextMenuOpeningEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.IContextMenuEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ControlTemplate

   procedure Initialize (this : in out ControlTemplate) is
   begin
      null;
   end;

   procedure Finalize (this : in out ControlTemplate) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IControlTemplate, IControlTemplate_Ptr);
   begin
      if this.m_IControlTemplate /= null then
         if this.m_IControlTemplate.all /= null then
            temp := this.m_IControlTemplate.all.Release;
            Free (this.m_IControlTemplate);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ControlTemplate

   function Constructor return ControlTemplate is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IControlTemplate");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IControlTemplate;
   begin
      return RetVal : ControlTemplate do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IControlTemplate := new WinUI3.Microsoft.UI.Xaml.Controls.IControlTemplate;
            Retval.m_IControlTemplate.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ControlTemplate

   function get_TargetType
   (
      this : in out ControlTemplate
   )
   return WinUI3.Windows.UI.Xaml.Interop.TypeName is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Interop.TypeName;
   begin
      Hr := this.m_IControlTemplate.all.get_TargetType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TargetType
   (
      this : in out ControlTemplate;
      value : WinUI3.Windows.UI.Xaml.Interop.TypeName
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControlTemplate.all.put_TargetType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreWebView2InitializedEventArgs

   procedure Initialize (this : in out CoreWebView2InitializedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreWebView2InitializedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreWebView2InitializedEventArgs, ICoreWebView2InitializedEventArgs_Ptr);
   begin
      if this.m_ICoreWebView2InitializedEventArgs /= null then
         if this.m_ICoreWebView2InitializedEventArgs.all /= null then
            temp := this.m_ICoreWebView2InitializedEventArgs.all.Release;
            Free (this.m_ICoreWebView2InitializedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreWebView2InitializedEventArgs

   function get_Exception
   (
      this : in out CoreWebView2InitializedEventArgs
   )
   return WinUI3.Windows.Foundation.HResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.HResult;
   begin
      Hr := this.m_ICoreWebView2InitializedEventArgs.all.get_Exception (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DataTemplateSelector

   procedure Initialize (this : in out DataTemplateSelector) is
   begin
      null;
   end;

   procedure Finalize (this : in out DataTemplateSelector) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDataTemplateSelector, IDataTemplateSelector_Ptr);
   begin
      if this.m_IDataTemplateSelector /= null then
         if this.m_IDataTemplateSelector.all /= null then
            temp := this.m_IDataTemplateSelector.all.Release;
            Free (this.m_IDataTemplateSelector);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DataTemplateSelector

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DataTemplateSelector is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IDataTemplateSelector");
      m_Factory    : access IDataTemplateSelectorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : DataTemplateSelector do
         Hr := RoGetActivationFactory (m_hString, IID_IDataTemplateSelectorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDataTemplateSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
            Retval.m_IDataTemplateSelector.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DataTemplateSelector

   function SelectTemplate
   (
      this : in out DataTemplateSelector;
      item : WinUI3.IInspectable;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IDataTemplateSelector.all.SelectTemplate (item, container.m_IDependencyObject.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   function SelectTemplate
   (
      this : in out DataTemplateSelector;
      item : WinUI3.IInspectable
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IDataTemplateSelector.all.SelectTemplate (item, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   function SelectTemplateCore
   (
      this : in out DataTemplateSelector;
      item : WinUI3.IInspectable;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelectorOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelectorOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IDataTemplateSelectorOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IDataTemplateSelector.all);
         Hr := m_Interface.SelectTemplateCore (item, container.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   function SelectTemplateCore
   (
      this : in out DataTemplateSelector;
      item : WinUI3.IInspectable
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelectorOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelectorOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IDataTemplateSelectorOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IDataTemplateSelector.all);
         Hr := m_Interface.SelectTemplateCore (item, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   function GetElement
   (
      this : in out DataTemplateSelector;
      args : WinUI3.Microsoft.UI.Xaml.ElementFactoryGetArgs'Class
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.IElementFactory := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector_Interface, WinUI3.Microsoft.UI.Xaml.IElementFactory, WinUI3.Microsoft.UI.Xaml.IID_IElementFactory'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IDataTemplateSelector.all);
         Hr := m_Interface.GetElement (args.m_IElementFactoryGetArgs.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure RecycleElement
   (
      this : in out DataTemplateSelector;
      args : WinUI3.Microsoft.UI.Xaml.ElementFactoryRecycleArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.IElementFactory := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector_Interface, WinUI3.Microsoft.UI.Xaml.IElementFactory, WinUI3.Microsoft.UI.Xaml.IID_IElementFactory'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDataTemplateSelector.all);
      Hr := m_Interface.RecycleElement (args.m_IElementFactoryRecycleArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickedEventArgs

   procedure Initialize (this : in out DatePickedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickedEventArgs, IDatePickedEventArgs_Ptr);
   begin
      if this.m_IDatePickedEventArgs /= null then
         if this.m_IDatePickedEventArgs.all /= null then
            temp := this.m_IDatePickedEventArgs.all.Release;
            Free (this.m_IDatePickedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DatePickedEventArgs

   function Constructor return DatePickedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IDatePickedEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDatePickedEventArgs;
   begin
      return RetVal : DatePickedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDatePickedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IDatePickedEventArgs;
            Retval.m_IDatePickedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickedEventArgs

   function get_OldDate
   (
      this : in out DatePickedEventArgs
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickedEventArgs.all.get_OldDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewDate
   (
      this : in out DatePickedEventArgs
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickedEventArgs.all.get_NewDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePicker

   procedure Initialize (this : in out DatePicker) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePicker) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePicker, IDatePicker_Ptr);
   begin
      if this.m_IDatePicker /= null then
         if this.m_IDatePicker.all /= null then
            temp := this.m_IDatePicker.all.Release;
            Free (this.m_IDatePicker);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DatePicker

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DatePicker is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IDatePicker");
      m_Factory    : access IDatePickerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDatePicker;
   begin
      return RetVal : DatePicker do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDatePicker := new WinUI3.Microsoft.UI.Xaml.Controls.IDatePicker;
            Retval.m_IDatePicker.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DatePicker

   function get_HeaderProperty_DatePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_DatePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarIdentifierProperty_DatePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DateProperty_DatePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_YearVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_YearVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayFormatProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthFormatProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_YearFormatProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_YearFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinYearProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinYearProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxYearProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxYearProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_DatePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty_DatePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedDateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedDateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePicker

   function get_Header
   (
      this : in out DatePicker
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IDatePicker.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out DatePicker;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out DatePicker
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IDatePicker.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out DatePicker;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarIdentifier
   (
      this : in out DatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePicker.all.get_CalendarIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CalendarIdentifier
   (
      this : in out DatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePicker.all.put_CalendarIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Date
   (
      this : in out DatePicker
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePicker.all.get_Date (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Date
   (
      this : in out DatePicker;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_Date (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayVisible
   (
      this : in out DatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePicker.all.get_DayVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayVisible
   (
      this : in out DatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_DayVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthVisible
   (
      this : in out DatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePicker.all.get_MonthVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthVisible
   (
      this : in out DatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_MonthVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_YearVisible
   (
      this : in out DatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePicker.all.get_YearVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_YearVisible
   (
      this : in out DatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_YearVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayFormat
   (
      this : in out DatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePicker.all.get_DayFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DayFormat
   (
      this : in out DatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePicker.all.put_DayFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_MonthFormat
   (
      this : in out DatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePicker.all.get_MonthFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_MonthFormat
   (
      this : in out DatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePicker.all.put_MonthFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_YearFormat
   (
      this : in out DatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePicker.all.get_YearFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_YearFormat
   (
      this : in out DatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePicker.all.put_YearFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_MinYear
   (
      this : in out DatePicker
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePicker.all.get_MinYear (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinYear
   (
      this : in out DatePicker;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_MinYear (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxYear
   (
      this : in out DatePicker
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePicker.all.get_MaxYear (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxYear
   (
      this : in out DatePicker;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_MaxYear (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out DatePicker
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IDatePicker.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out DatePicker;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out DatePicker
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode;
   begin
      Hr := this.m_IDatePicker.all.get_LightDismissOverlayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out DatePicker;
      value : WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_LightDismissOverlayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedDate
   (
      this : in out DatePicker
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
   begin
      Hr := this.m_IDatePicker.all.get_SelectedDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_SelectedDate
   (
      this : in out DatePicker;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_SelectedDate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DateChanged
   (
      this : in out DatePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDatePicker.all.add_DateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DateChanged
   (
      this : in out DatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.remove_DateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectedDateChanged
   (
      this : in out DatePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDatePicker.all.add_SelectedDateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectedDateChanged
   (
      this : in out DatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.remove_SelectedDateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickerFlyout

   procedure Initialize (this : in out DatePickerFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickerFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickerFlyout, IDatePickerFlyout_Ptr);
   begin
      if this.m_IDatePickerFlyout /= null then
         if this.m_IDatePickerFlyout.all /= null then
            temp := this.m_IDatePickerFlyout.all.Release;
            Free (this.m_IDatePickerFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DatePickerFlyout

   function Constructor return DatePickerFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IDatePickerFlyout");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyout;
   begin
      return RetVal : DatePickerFlyout do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDatePickerFlyout := new WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyout;
            Retval.m_IDatePickerFlyout.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DatePickerFlyout

   function get_CalendarIdentifierProperty_DatePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DateProperty_DatePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayVisibleProperty_DatePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthVisibleProperty_DatePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_YearVisibleProperty_DatePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_YearVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinYearProperty_DatePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinYearProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxYearProperty_DatePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxYearProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayFormatProperty_DatePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthFormatProperty_DatePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_YearFormatProperty_DatePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_YearFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickerFlyout

   function get_CalendarIdentifier
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_CalendarIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CalendarIdentifier
   (
      this : in out DatePickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePickerFlyout.all.put_CalendarIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Date
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_Date (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Date
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_Date (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayVisible
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_DayVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayVisible
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_DayVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthVisible
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_MonthVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthVisible
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_MonthVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_YearVisible
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_YearVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_YearVisible
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_YearVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinYear
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_MinYear (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinYear
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_MinYear (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxYear
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_MaxYear (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxYear
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_MaxYear (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayFormat
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_DayFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DayFormat
   (
      this : in out DatePickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePickerFlyout.all.put_DayFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_MonthFormat
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_MonthFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_MonthFormat
   (
      this : in out DatePickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePickerFlyout.all.put_MonthFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_YearFormat
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_YearFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_YearFormat
   (
      this : in out DatePickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePickerFlyout.all.put_YearFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function add_DatePicked
   (
      this : in out DatePickerFlyout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDatePickerFlyout.all.add_DatePicked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DatePicked
   (
      this : in out DatePickerFlyout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.remove_DatePicked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAtAsync
   (
      this : in out DatePickerFlyout;
      target : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.GenericObject;
      m_IID            : aliased WinUI3.IID := (539341647, 16916, 22187, (171, 254, 47, 190, 101, 149, 218, 157 )); -- GenericObject;
      m_HandlerIID     : aliased WinUI3.IID := (3290586462, 7036, 22302, (155, 136, 42, 178, 238, 250, 140, 143 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IDatePickerFlyout.all.ShowAtAsync (target.m_IFrameworkElement.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickerFlyoutItem

   procedure Initialize (this : in out DatePickerFlyoutItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickerFlyoutItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickerFlyoutItem, IDatePickerFlyoutItem_Ptr);
   begin
      if this.m_IDatePickerFlyoutItem /= null then
         if this.m_IDatePickerFlyoutItem.all /= null then
            temp := this.m_IDatePickerFlyoutItem.all.Release;
            Free (this.m_IDatePickerFlyoutItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DatePickerFlyoutItem

   function get_PrimaryTextProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryTextProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickerFlyoutItem

   function get_PrimaryText
   (
      this : in out DatePickerFlyoutItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePickerFlyoutItem.all.get_PrimaryText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PrimaryText
   (
      this : in out DatePickerFlyoutItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePickerFlyoutItem.all.put_PrimaryText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SecondaryText
   (
      this : in out DatePickerFlyoutItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePickerFlyoutItem.all.get_SecondaryText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SecondaryText
   (
      this : in out DatePickerFlyoutItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePickerFlyoutItem.all.put_SecondaryText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function GetCustomProperty
   (
      this : in out DatePickerFlyoutItem;
      name : WinUI3.WString
   )
   return WinUI3.Microsoft.UI.Xaml.Data.ICustomProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.ICustomPropertyProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Data.ICustomProperty;
      HStr_name : constant WinUI3.HString := To_HString (name);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutItem_Interface, WinUI3.Microsoft.UI.Xaml.Data.ICustomPropertyProvider, WinUI3.Microsoft.UI.Xaml.Data.IID_ICustomPropertyProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyoutItem.all);
      Hr := m_Interface.GetCustomProperty (HStr_name, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_name);
      return m_ComRetVal;
   end;

   function GetIndexedProperty
   (
      this : in out DatePickerFlyoutItem;
      name : WinUI3.WString;
      type_x : WinUI3.Windows.UI.Xaml.Interop.TypeName
   )
   return WinUI3.Microsoft.UI.Xaml.Data.ICustomProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.ICustomPropertyProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Data.ICustomProperty;
      HStr_name : constant WinUI3.HString := To_HString (name);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutItem_Interface, WinUI3.Microsoft.UI.Xaml.Data.ICustomPropertyProvider, WinUI3.Microsoft.UI.Xaml.Data.IID_ICustomPropertyProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyoutItem.all);
      Hr := m_Interface.GetIndexedProperty (HStr_name, type_x, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_name);
      return m_ComRetVal;
   end;

   function GetStringRepresentation
   (
      this : in out DatePickerFlyoutItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.ICustomPropertyProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutItem_Interface, WinUI3.Microsoft.UI.Xaml.Data.ICustomPropertyProvider, WinUI3.Microsoft.UI.Xaml.Data.IID_ICustomPropertyProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyoutItem.all);
      Hr := m_Interface.GetStringRepresentation (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Type
   (
      this : in out DatePickerFlyoutItem
   )
   return WinUI3.Windows.UI.Xaml.Interop.TypeName is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.ICustomPropertyProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Interop.TypeName;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutItem_Interface, WinUI3.Microsoft.UI.Xaml.Data.ICustomPropertyProvider, WinUI3.Microsoft.UI.Xaml.Data.IID_ICustomPropertyProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyoutItem.all);
      Hr := m_Interface.get_Type (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickerFlyoutPresenter

   procedure Initialize (this : in out DatePickerFlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickerFlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickerFlyoutPresenter, IDatePickerFlyoutPresenter_Ptr);
   begin
      if this.m_IDatePickerFlyoutPresenter /= null then
         if this.m_IDatePickerFlyoutPresenter.all /= null then
            temp := this.m_IDatePickerFlyoutPresenter.all.Release;
            Free (this.m_IDatePickerFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DatePickerFlyoutPresenter

   function get_IsDefaultShadowEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.DatePickerFlyoutPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IDatePickerFlyoutPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDefaultShadowEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickerFlyoutPresenter

   function get_IsDefaultShadowEnabled
   (
      this : in out DatePickerFlyoutPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePickerFlyoutPresenter.all.get_IsDefaultShadowEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDefaultShadowEnabled
   (
      this : in out DatePickerFlyoutPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyoutPresenter.all.put_IsDefaultShadowEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickerSelectedValueChangedEventArgs

   procedure Initialize (this : in out DatePickerSelectedValueChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickerSelectedValueChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickerSelectedValueChangedEventArgs, IDatePickerSelectedValueChangedEventArgs_Ptr);
   begin
      if this.m_IDatePickerSelectedValueChangedEventArgs /= null then
         if this.m_IDatePickerSelectedValueChangedEventArgs.all /= null then
            temp := this.m_IDatePickerSelectedValueChangedEventArgs.all.Release;
            Free (this.m_IDatePickerSelectedValueChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickerSelectedValueChangedEventArgs

   function get_OldDate
   (
      this : in out DatePickerSelectedValueChangedEventArgs
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
   begin
      Hr := this.m_IDatePickerSelectedValueChangedEventArgs.all.get_OldDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_NewDate
   (
      this : in out DatePickerSelectedValueChangedEventArgs
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
   begin
      Hr := this.m_IDatePickerSelectedValueChangedEventArgs.all.get_NewDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickerValueChangedEventArgs

   procedure Initialize (this : in out DatePickerValueChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickerValueChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickerValueChangedEventArgs, IDatePickerValueChangedEventArgs_Ptr);
   begin
      if this.m_IDatePickerValueChangedEventArgs /= null then
         if this.m_IDatePickerValueChangedEventArgs.all /= null then
            temp := this.m_IDatePickerValueChangedEventArgs.all.Release;
            Free (this.m_IDatePickerValueChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickerValueChangedEventArgs

   function get_OldDate
   (
      this : in out DatePickerValueChangedEventArgs
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickerValueChangedEventArgs.all.get_OldDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewDate
   (
      this : in out DatePickerValueChangedEventArgs
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickerValueChangedEventArgs.all.get_NewDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragItemsCompletedEventArgs

   procedure Initialize (this : in out DragItemsCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragItemsCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragItemsCompletedEventArgs, IDragItemsCompletedEventArgs_Ptr);
   begin
      if this.m_IDragItemsCompletedEventArgs /= null then
         if this.m_IDragItemsCompletedEventArgs.all /= null then
            temp := this.m_IDragItemsCompletedEventArgs.all.Release;
            Free (this.m_IDragItemsCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragItemsCompletedEventArgs

   function get_Items
   (
      this : in out DragItemsCompletedEventArgs
   )
   return IVectorView_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IInspectable.Kind;
   begin
      Hr := this.m_IDragItemsCompletedEventArgs.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_DropResult
   (
      this : in out DragItemsCompletedEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation;
   begin
      Hr := this.m_IDragItemsCompletedEventArgs.all.get_DropResult (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragItemsStartingEventArgs

   procedure Initialize (this : in out DragItemsStartingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragItemsStartingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragItemsStartingEventArgs, IDragItemsStartingEventArgs_Ptr);
   begin
      if this.m_IDragItemsStartingEventArgs /= null then
         if this.m_IDragItemsStartingEventArgs.all /= null then
            temp := this.m_IDragItemsStartingEventArgs.all.Release;
            Free (this.m_IDragItemsStartingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DragItemsStartingEventArgs

   function Constructor return DragItemsStartingEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IDragItemsStartingEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDragItemsStartingEventArgs;
   begin
      return RetVal : DragItemsStartingEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDragItemsStartingEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IDragItemsStartingEventArgs;
            Retval.m_IDragItemsStartingEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragItemsStartingEventArgs

   function get_Cancel
   (
      this : in out DragItemsStartingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDragItemsStartingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out DragItemsStartingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragItemsStartingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Items
   (
      this : in out DragItemsStartingEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IDragItemsStartingEventArgs.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Data
   (
      this : in out DragItemsStartingEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage do
         Hr := this.m_IDragItemsStartingEventArgs.all.get_Data (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataPackage := new WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
         Retval.m_IDataPackage.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Delegate DragItemsStartingEventHandler

   function Invoke
   (
      this : access DragItemsStartingEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.IDragItemsStartingEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DropDownButton

   procedure Initialize (this : in out DropDownButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out DropDownButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDropDownButton, IDropDownButton_Ptr);
   begin
      if this.m_IDropDownButton /= null then
         if this.m_IDropDownButton.all /= null then
            temp := this.m_IDropDownButton.all.Release;
            Free (this.m_IDropDownButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DropDownButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DropDownButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IDropDownButton");
      m_Factory    : access IDropDownButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDropDownButton;
   begin
      return RetVal : DropDownButton do
         Hr := RoGetActivationFactory (m_hString, IID_IDropDownButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDropDownButton := new WinUI3.Microsoft.UI.Xaml.Controls.IDropDownButton;
            Retval.m_IDropDownButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DropDownButton

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DynamicOverflowItemsChangingEventArgs

   procedure Initialize (this : in out DynamicOverflowItemsChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DynamicOverflowItemsChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDynamicOverflowItemsChangingEventArgs, IDynamicOverflowItemsChangingEventArgs_Ptr);
   begin
      if this.m_IDynamicOverflowItemsChangingEventArgs /= null then
         if this.m_IDynamicOverflowItemsChangingEventArgs.all /= null then
            temp := this.m_IDynamicOverflowItemsChangingEventArgs.all.Release;
            Free (this.m_IDynamicOverflowItemsChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DynamicOverflowItemsChangingEventArgs

   function Constructor return DynamicOverflowItemsChangingEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IDynamicOverflowItemsChangingEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDynamicOverflowItemsChangingEventArgs;
   begin
      return RetVal : DynamicOverflowItemsChangingEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDynamicOverflowItemsChangingEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IDynamicOverflowItemsChangingEventArgs;
            Retval.m_IDynamicOverflowItemsChangingEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DynamicOverflowItemsChangingEventArgs

   function get_Action
   (
      this : in out DynamicOverflowItemsChangingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CommandBarDynamicOverflowAction is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CommandBarDynamicOverflowAction;
   begin
      Hr := this.m_IDynamicOverflowItemsChangingEventArgs.all.get_Action (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Expander

   procedure Initialize (this : in out Expander) is
   begin
      null;
   end;

   procedure Finalize (this : in out Expander) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IExpander, IExpander_Ptr);
   begin
      if this.m_IExpander /= null then
         if this.m_IExpander.all /= null then
            temp := this.m_IExpander.all.Release;
            Free (this.m_IExpander);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Expander

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Expander is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IExpander");
      m_Factory    : access IExpanderFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IExpander;
   begin
      return RetVal : Expander do
         Hr := RoGetActivationFactory (m_hString, IID_IExpanderFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IExpander := new WinUI3.Microsoft.UI.Xaml.Controls.IExpander;
            Retval.m_IExpander.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Expander

   function get_HeaderProperty_Expander
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Expander");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IExpanderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IExpanderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_Expander
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Expander");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IExpanderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IExpanderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateSelectorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Expander");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IExpanderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IExpanderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsExpandedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Expander");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IExpanderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IExpanderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsExpandedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExpandDirectionProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Expander");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IExpanderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IExpanderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExpandDirectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Expander

   function get_Header
   (
      this : in out Expander
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IExpander.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out Expander;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IExpander.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out Expander
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IExpander.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out Expander;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IExpander.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplateSelector
   (
      this : in out Expander
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_IExpander.all.get_HeaderTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplateSelector
   (
      this : in out Expander;
      value : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IExpander.all.put_HeaderTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsExpanded
   (
      this : in out Expander
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IExpander.all.get_IsExpanded (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsExpanded
   (
      this : in out Expander;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IExpander.all.put_IsExpanded (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExpandDirection
   (
      this : in out Expander
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ExpandDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ExpandDirection;
   begin
      Hr := this.m_IExpander.all.get_ExpandDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ExpandDirection
   (
      this : in out Expander;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ExpandDirection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IExpander.all.put_ExpandDirection (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Expanding
   (
      this : in out Expander;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IExpander.all.add_Expanding (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Expanding
   (
      this : in out Expander;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IExpander.all.remove_Expanding (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Collapsed
   (
      this : in out Expander;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IExpander.all.add_Collapsed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Collapsed
   (
      this : in out Expander;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IExpander.all.remove_Collapsed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out Expander
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ExpanderTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IExpanderTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ExpanderTemplateSettings do
         Hr := this.m_IExpander.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IExpanderTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.IExpanderTemplateSettings;
         Retval.m_IExpanderTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ExpanderCollapsedEventArgs

   procedure Initialize (this : in out ExpanderCollapsedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ExpanderCollapsedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IExpanderCollapsedEventArgs, IExpanderCollapsedEventArgs_Ptr);
   begin
      if this.m_IExpanderCollapsedEventArgs /= null then
         if this.m_IExpanderCollapsedEventArgs.all /= null then
            temp := this.m_IExpanderCollapsedEventArgs.all.Release;
            Free (this.m_IExpanderCollapsedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ExpanderCollapsedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ExpanderExpandingEventArgs

   procedure Initialize (this : in out ExpanderExpandingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ExpanderExpandingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IExpanderExpandingEventArgs, IExpanderExpandingEventArgs_Ptr);
   begin
      if this.m_IExpanderExpandingEventArgs /= null then
         if this.m_IExpanderExpandingEventArgs.all /= null then
            temp := this.m_IExpanderExpandingEventArgs.all.Release;
            Free (this.m_IExpanderExpandingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ExpanderExpandingEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ExpanderTemplateSettings

   procedure Initialize (this : in out ExpanderTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out ExpanderTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IExpanderTemplateSettings, IExpanderTemplateSettings_Ptr);
   begin
      if this.m_IExpanderTemplateSettings /= null then
         if this.m_IExpanderTemplateSettings.all /= null then
            temp := this.m_IExpanderTemplateSettings.all.Release;
            Free (this.m_IExpanderTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ExpanderTemplateSettings

   function get_ContentHeight
   (
      this : in out ExpanderTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IExpanderTemplateSettings.all.get_ContentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NegativeContentHeight
   (
      this : in out ExpanderTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IExpanderTemplateSettings.all.get_NegativeContentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FlipView

   procedure Initialize (this : in out FlipView) is
   begin
      null;
   end;

   procedure Finalize (this : in out FlipView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlipView, IFlipView_Ptr);
   begin
      if this.m_IFlipView /= null then
         if this.m_IFlipView.all /= null then
            temp := this.m_IFlipView.all.Release;
            Free (this.m_IFlipView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FlipView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FlipView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IFlipView");
      m_Factory    : access IFlipViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IFlipView;
   begin
      return RetVal : FlipView do
         Hr := RoGetActivationFactory (m_hString, IID_IFlipViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFlipView := new WinUI3.Microsoft.UI.Xaml.Controls.IFlipView;
            Retval.m_IFlipView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FlipView

   function get_UseTouchAnimationsForAllNavigationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FlipView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFlipViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlipViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UseTouchAnimationsForAllNavigationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FlipView

   function get_UseTouchAnimationsForAllNavigation
   (
      this : in out FlipView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFlipView.all.get_UseTouchAnimationsForAllNavigation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_UseTouchAnimationsForAllNavigation
   (
      this : in out FlipView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlipView.all.put_UseTouchAnimationsForAllNavigation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FlipViewItem

   procedure Initialize (this : in out FlipViewItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out FlipViewItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlipViewItem, IFlipViewItem_Ptr);
   begin
      if this.m_IFlipViewItem /= null then
         if this.m_IFlipViewItem.all /= null then
            temp := this.m_IFlipViewItem.all.Release;
            Free (this.m_IFlipViewItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FlipViewItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FlipViewItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IFlipViewItem");
      m_Factory    : access IFlipViewItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IFlipViewItem;
   begin
      return RetVal : FlipViewItem do
         Hr := RoGetActivationFactory (m_hString, IID_IFlipViewItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFlipViewItem := new WinUI3.Microsoft.UI.Xaml.Controls.IFlipViewItem;
            Retval.m_IFlipViewItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FlipViewItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Flyout

   procedure Initialize (this : in out Flyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out Flyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlyout, IFlyout_Ptr);
   begin
      if this.m_IFlyout /= null then
         if this.m_IFlyout.all /= null then
            temp := this.m_IFlyout.all.Release;
            Free (this.m_IFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Flyout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Flyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IFlyout");
      m_Factory    : access IFlyoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IFlyout;
   begin
      return RetVal : Flyout do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFlyout := new WinUI3.Microsoft.UI.Xaml.Controls.IFlyout;
            Retval.m_IFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Flyout

   function get_ContentProperty_Flyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Flyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FlyoutPresenterStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Flyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FlyoutPresenterStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Flyout

   function get_Content
   (
      this : in out Flyout
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IFlyout.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out Flyout;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyout.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FlyoutPresenterStyle
   (
      this : in out Flyout
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IFlyout.all.get_FlyoutPresenterStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_FlyoutPresenterStyle
   (
      this : in out Flyout;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyout.all.put_FlyoutPresenterStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FlyoutPresenter

   procedure Initialize (this : in out FlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out FlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlyoutPresenter, IFlyoutPresenter_Ptr);
   begin
      if this.m_IFlyoutPresenter /= null then
         if this.m_IFlyoutPresenter.all /= null then
            temp := this.m_IFlyoutPresenter.all.Release;
            Free (this.m_IFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FlyoutPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FlyoutPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IFlyoutPresenter");
      m_Factory    : access IFlyoutPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IFlyoutPresenter;
   begin
      return RetVal : FlyoutPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFlyoutPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.IFlyoutPresenter;
            Retval.m_IFlyoutPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FlyoutPresenter

   function get_IsDefaultShadowEnabledProperty_FlyoutPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FlyoutPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFlyoutPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDefaultShadowEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FlyoutPresenter

   function get_IsDefaultShadowEnabled
   (
      this : in out FlyoutPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFlyoutPresenter.all.get_IsDefaultShadowEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDefaultShadowEnabled
   (
      this : in out FlyoutPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutPresenter.all.put_IsDefaultShadowEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FocusDisengagedEventArgs

   procedure Initialize (this : in out FocusDisengagedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out FocusDisengagedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFocusDisengagedEventArgs, IFocusDisengagedEventArgs_Ptr);
   begin
      if this.m_IFocusDisengagedEventArgs /= null then
         if this.m_IFocusDisengagedEventArgs.all /= null then
            temp := this.m_IFocusDisengagedEventArgs.all.Release;
            Free (this.m_IFocusDisengagedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FocusDisengagedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FocusEngagedEventArgs

   procedure Initialize (this : in out FocusEngagedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out FocusEngagedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFocusEngagedEventArgs, IFocusEngagedEventArgs_Ptr);
   begin
      if this.m_IFocusEngagedEventArgs /= null then
         if this.m_IFocusEngagedEventArgs.all /= null then
            temp := this.m_IFocusEngagedEventArgs.all.Release;
            Free (this.m_IFocusEngagedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FocusEngagedEventArgs

   function get_Handled
   (
      this : in out FocusEngagedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFocusEngagedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out FocusEngagedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFocusEngagedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FontIcon

   procedure Initialize (this : in out FontIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out FontIcon) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFontIcon, IFontIcon_Ptr);
   begin
      if this.m_IFontIcon /= null then
         if this.m_IFontIcon.all /= null then
            temp := this.m_IFontIcon.all.Release;
            Free (this.m_IFontIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FontIcon

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FontIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IFontIcon");
      m_Factory    : access IFontIconFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IFontIcon;
   begin
      return RetVal : FontIcon do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFontIcon := new WinUI3.Microsoft.UI.Xaml.Controls.IFontIcon;
            Retval.m_IFontIcon.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FontIcon

   function get_GlyphProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontSizeProperty_FontIcon
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty_FontIcon
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty_FontIcon
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty_FontIcon
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextScaleFactorEnabledProperty_FontIcon
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MirroredWhenRightToLeftProperty_FontIcon
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MirroredWhenRightToLeftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FontIcon

   function get_Glyph
   (
      this : in out FontIcon
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFontIcon.all.get_Glyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Glyph
   (
      this : in out FontIcon;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IFontIcon.all.put_Glyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_FontSize
   (
      this : in out FontIcon
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFontIcon.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out FontIcon;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIcon.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out FontIcon
   )
   return WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.FontFamily do
         Hr := this.m_IFontIcon.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out FontIcon;
      value : WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIcon.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out FontIcon
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_IFontIcon.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out FontIcon;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIcon.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out FontIcon
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_IFontIcon.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out FontIcon;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIcon.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out FontIcon
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFontIcon.all.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out FontIcon;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIcon.all.put_IsTextScaleFactorEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MirroredWhenRightToLeft
   (
      this : in out FontIcon
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFontIcon.all.get_MirroredWhenRightToLeft (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MirroredWhenRightToLeft
   (
      this : in out FontIcon;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIcon.all.put_MirroredWhenRightToLeft (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FontIconSource

   procedure Initialize (this : in out FontIconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out FontIconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFontIconSource, IFontIconSource_Ptr);
   begin
      if this.m_IFontIconSource /= null then
         if this.m_IFontIconSource.all /= null then
            temp := this.m_IFontIconSource.all.Release;
            Free (this.m_IFontIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FontIconSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FontIconSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IFontIconSource");
      m_Factory    : access IFontIconSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IFontIconSource;
   begin
      return RetVal : FontIconSource do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFontIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IFontIconSource;
            Retval.m_IFontIconSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FontIconSource

   function get_GlyphProperty_FontIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontSizeProperty_FontIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty_FontIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty_FontIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty_FontIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextScaleFactorEnabledProperty_FontIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MirroredWhenRightToLeftProperty_FontIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MirroredWhenRightToLeftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FontIconSource

   function get_Glyph
   (
      this : in out FontIconSource
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFontIconSource.all.get_Glyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Glyph
   (
      this : in out FontIconSource;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IFontIconSource.all.put_Glyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_FontSize
   (
      this : in out FontIconSource
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFontIconSource.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out FontIconSource;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out FontIconSource
   )
   return WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.FontFamily do
         Hr := this.m_IFontIconSource.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out FontIconSource;
      value : WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out FontIconSource
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_IFontIconSource.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out FontIconSource;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out FontIconSource
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_IFontIconSource.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out FontIconSource;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out FontIconSource
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFontIconSource.all.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out FontIconSource;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_IsTextScaleFactorEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MirroredWhenRightToLeft
   (
      this : in out FontIconSource
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFontIconSource.all.get_MirroredWhenRightToLeft (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MirroredWhenRightToLeft
   (
      this : in out FontIconSource;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_MirroredWhenRightToLeft (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Frame

   procedure Initialize (this : in out Frame) is
   begin
      null;
   end;

   procedure Finalize (this : in out Frame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFrame, IFrame_Ptr);
   begin
      if this.m_IFrame /= null then
         if this.m_IFrame.all /= null then
            temp := this.m_IFrame.all.Release;
            Free (this.m_IFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Frame

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Frame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IFrame");
      m_Factory    : access IFrameFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IFrame;
   begin
      return RetVal : Frame do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFrame := new WinUI3.Microsoft.UI.Xaml.Controls.IFrame;
            Retval.m_IFrame.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Frame

   function get_CacheSizeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CacheSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanGoBackProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanGoBackProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanGoForwardProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanGoForwardProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CurrentSourcePageTypeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CurrentSourcePageTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SourcePageTypeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourcePageTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackStackDepthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackStackDepthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackStackProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackStackProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForwardStackProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForwardStackProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsNavigationStackEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsNavigationStackEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Frame

   function get_CacheSize
   (
      this : in out Frame
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IFrame.all.get_CacheSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CacheSize
   (
      this : in out Frame;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.put_CacheSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanGoBack
   (
      this : in out Frame
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFrame.all.get_CanGoBack (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanGoForward
   (
      this : in out Frame
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFrame.all.get_CanGoForward (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CurrentSourcePageType
   (
      this : in out Frame
   )
   return WinUI3.Windows.UI.Xaml.Interop.TypeName is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Interop.TypeName;
   begin
      Hr := this.m_IFrame.all.get_CurrentSourcePageType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SourcePageType
   (
      this : in out Frame
   )
   return WinUI3.Windows.UI.Xaml.Interop.TypeName is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Interop.TypeName;
   begin
      Hr := this.m_IFrame.all.get_SourcePageType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SourcePageType
   (
      this : in out Frame;
      value : WinUI3.Windows.UI.Xaml.Interop.TypeName
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.put_SourcePageType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackStackDepth
   (
      this : in out Frame
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IFrame.all.get_BackStackDepth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_BackStack
   (
      this : in out Frame
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IFrame.all.get_BackStack (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ForwardStack
   (
      this : in out Frame
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IFrame.all.get_ForwardStack (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsNavigationStackEnabled
   (
      this : in out Frame
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFrame.all.get_IsNavigationStackEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsNavigationStackEnabled
   (
      this : in out Frame;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.put_IsNavigationStackEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Navigated
   (
      this : in out Frame;
      handler : WinUI3.Microsoft.UI.Xaml.Navigation.NavigatedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrame.all.add_Navigated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Navigated
   (
      this : in out Frame;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.remove_Navigated (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Navigating
   (
      this : in out Frame;
      handler : WinUI3.Microsoft.UI.Xaml.Navigation.NavigatingCancelEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrame.all.add_Navigating (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Navigating
   (
      this : in out Frame;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.remove_Navigating (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_NavigationFailed
   (
      this : in out Frame;
      handler : WinUI3.Microsoft.UI.Xaml.Navigation.NavigationFailedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrame.all.add_NavigationFailed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NavigationFailed
   (
      this : in out Frame;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.remove_NavigationFailed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_NavigationStopped
   (
      this : in out Frame;
      handler : WinUI3.Microsoft.UI.Xaml.Navigation.NavigationStoppedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrame.all.add_NavigationStopped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NavigationStopped
   (
      this : in out Frame;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.remove_NavigationStopped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GoBack
   (
      this : in out Frame
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.GoBack;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GoBack
   (
      this : in out Frame;
      transitionInfoOverride : WinUI3.Microsoft.UI.Xaml.Media.Animation.NavigationTransitionInfo'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.GoBack (transitionInfoOverride.m_INavigationTransitionInfo.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GoForward
   (
      this : in out Frame
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.GoForward;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function Navigate
   (
      this : in out Frame;
      sourcePageType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFrame.all.Navigate (sourcePageType, parameter, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Navigate
   (
      this : in out Frame;
      sourcePageType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      infoOverride : WinUI3.Microsoft.UI.Xaml.Media.Animation.NavigationTransitionInfo'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFrame.all.Navigate (sourcePageType, parameter, infoOverride.m_INavigationTransitionInfo.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function NavigateToType
   (
      this : in out Frame;
      sourcePageType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      navigationOptions : WinUI3.Microsoft.UI.Xaml.Navigation.FrameNavigationOptions'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFrame.all.NavigateToType (sourcePageType, parameter, navigationOptions.m_IFrameNavigationOptions.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetNavigationState
   (
      this : in out Frame
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFrame.all.GetNavigationState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure SetNavigationState
   (
      this : in out Frame;
      navigationState : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_navigationState : constant WinUI3.HString := To_HString (navigationState);
   begin
      Hr := this.m_IFrame.all.SetNavigationState (HStr_navigationState);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_navigationState);
   end;

   procedure SetNavigationState
   (
      this : in out Frame;
      navigationState : WinUI3.WString;
      suppressNavigate : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_navigationState : constant WinUI3.HString := To_HString (navigationState);
   begin
      Hr := this.m_IFrame.all.SetNavigationState (HStr_navigationState, suppressNavigate);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_navigationState);
   end;

   function Navigate
   (
      this : in out Frame;
      sourcePageType : WinUI3.Windows.UI.Xaml.Interop.TypeName
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigate := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IFrame_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigate, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigate'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrame.all);
      Hr := m_Interface.Navigate (sourcePageType, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Grid

   procedure Initialize (this : in out Grid) is
   begin
      null;
   end;

   procedure Finalize (this : in out Grid) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGrid, IGrid_Ptr);
   begin
      if this.m_IGrid /= null then
         if this.m_IGrid.all /= null then
            temp := this.m_IGrid.all.Release;
            Free (this.m_IGrid);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Grid

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Grid is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IGrid");
      m_Factory    : access IGridFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IGrid;
   begin
      return RetVal : Grid do
         Hr := RoGetActivationFactory (m_hString, IID_IGridFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGrid := new WinUI3.Microsoft.UI.Xaml.Controls.IGrid;
            Retval.m_IGrid.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Grid

   function get_BackgroundSizingProperty_Grid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderBrushProperty_Grid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty_Grid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty_Grid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_Grid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RowSpacingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RowSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ColumnSpacingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColumnSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RowProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetRow
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetRow (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetRow
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetRow (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ColumnProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColumnProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetColumn
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetColumn (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetColumn
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetColumn (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_RowSpanProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RowSpanProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetRowSpan
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetRowSpan (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetRowSpan
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetRowSpan (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ColumnSpanProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColumnSpanProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetColumnSpan
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetColumnSpan (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetColumnSpan
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetColumnSpan (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Grid

   function get_RowDefinitions
   (
      this : in out Grid
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RowDefinitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.RowDefinitionCollection do
         Hr := this.m_IGrid.all.get_RowDefinitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_ColumnDefinitions
   (
      this : in out Grid
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ColumnDefinitionCollection do
         Hr := this.m_IGrid.all.get_ColumnDefinitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_BackgroundSizing
   (
      this : in out Grid
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing;
   begin
      Hr := this.m_IGrid.all.get_BackgroundSizing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out Grid;
      value : WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGrid.all.put_BackgroundSizing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderBrush
   (
      this : in out Grid
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGrid.all.get_BorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out Grid;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGrid.all.put_BorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out Grid
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IGrid.all.get_BorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out Grid;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGrid.all.put_BorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out Grid
   )
   return WinUI3.Microsoft.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_IGrid.all.get_CornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out Grid;
      value : WinUI3.Microsoft.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGrid.all.put_CornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out Grid
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IGrid.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out Grid;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGrid.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RowSpacing
   (
      this : in out Grid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IGrid.all.get_RowSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RowSpacing
   (
      this : in out Grid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGrid.all.put_RowSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ColumnSpacing
   (
      this : in out Grid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IGrid.all.get_ColumnSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ColumnSpacing
   (
      this : in out Grid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGrid.all.put_ColumnSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewBase

   procedure Initialize (this : in out ListViewBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewBase, IListViewBase_Ptr);
   begin
      if this.m_IListViewBase /= null then
         if this.m_IListViewBase.all /= null then
            temp := this.m_IListViewBase.all.Release;
            Free (this.m_IListViewBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListViewBase

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListViewBase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IListViewBase");
      m_Factory    : access IListViewBaseFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase;
   begin
      return RetVal : ListViewBase do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListViewBase := new WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase;
            Retval.m_IListViewBase.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ListViewBase

   function get_SelectionModeProperty_ListViewBase
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSwipeEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSwipeEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanDragItemsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanDragItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanReorderItemsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanReorderItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsItemClickEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsItemClickEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DataFetchSizeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DataFetchSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IncrementalLoadingThresholdProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IncrementalLoadingThresholdProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IncrementalLoadingTriggerProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IncrementalLoadingTriggerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShowsScrollingPlaceholdersProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowsScrollingPlaceholdersProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ReorderModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ReorderModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsMultiSelectCheckBoxEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsMultiSelectCheckBoxEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SingleSelectionFollowsFocusProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SingleSelectionFollowsFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SemanticZoomOwnerProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SemanticZoomOwnerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsActiveViewProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsActiveViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsZoomedInViewProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomedInViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_ListViewBase
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_ListViewBase
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTransitionsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterTransitionsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewBase

   function get_SelectedItems
   (
      this : in out ListViewBase
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IListViewBase.all.get_SelectedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SelectionMode
   (
      this : in out ListViewBase
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ListViewSelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ListViewSelectionMode;
   begin
      Hr := this.m_IListViewBase.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionMode
   (
      this : in out ListViewBase;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ListViewSelectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_SelectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSwipeEnabled
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.get_IsSwipeEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSwipeEnabled
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_IsSwipeEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanDragItems
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.get_CanDragItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanDragItems
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_CanDragItems (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanReorderItems
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.get_CanReorderItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanReorderItems
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_CanReorderItems (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsItemClickEnabled
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.get_IsItemClickEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsItemClickEnabled
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_IsItemClickEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DataFetchSize
   (
      this : in out ListViewBase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IListViewBase.all.get_DataFetchSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DataFetchSize
   (
      this : in out ListViewBase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_DataFetchSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IncrementalLoadingThreshold
   (
      this : in out ListViewBase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IListViewBase.all.get_IncrementalLoadingThreshold (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IncrementalLoadingThreshold
   (
      this : in out ListViewBase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_IncrementalLoadingThreshold (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IncrementalLoadingTrigger
   (
      this : in out ListViewBase
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IncrementalLoadingTrigger is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IncrementalLoadingTrigger;
   begin
      Hr := this.m_IListViewBase.all.get_IncrementalLoadingTrigger (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IncrementalLoadingTrigger
   (
      this : in out ListViewBase;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IncrementalLoadingTrigger
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_IncrementalLoadingTrigger (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowsScrollingPlaceholders
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.get_ShowsScrollingPlaceholders (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowsScrollingPlaceholders
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_ShowsScrollingPlaceholders (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ReorderMode
   (
      this : in out ListViewBase
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ListViewReorderMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ListViewReorderMode;
   begin
      Hr := this.m_IListViewBase.all.get_ReorderMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ReorderMode
   (
      this : in out ListViewBase;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ListViewReorderMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_ReorderMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedRanges
   (
      this : in out ListViewBase
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IListViewBase.all.get_SelectedRanges (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsMultiSelectCheckBoxEnabled
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.get_IsMultiSelectCheckBoxEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsMultiSelectCheckBoxEnabled
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_IsMultiSelectCheckBoxEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SingleSelectionFollowsFocus
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.get_SingleSelectionFollowsFocus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SingleSelectionFollowsFocus
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_SingleSelectionFollowsFocus (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ItemClick
   (
      this : in out ListViewBase;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.ItemClickEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IListViewBase.all.add_ItemClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemClick
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.remove_ItemClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragItemsStarting
   (
      this : in out ListViewBase;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.DragItemsStartingEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IListViewBase.all.add_DragItemsStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragItemsStarting
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.remove_DragItemsStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragItemsCompleted
   (
      this : in out ListViewBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IListViewBase.all.add_DragItemsCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragItemsCompleted
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.remove_DragItemsCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContainerContentChanging
   (
      this : in out ListViewBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IListViewBase.all.add_ContainerContentChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContainerContentChanging
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.remove_ContainerContentChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ChoosingItemContainer
   (
      this : in out ListViewBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IListViewBase.all.add_ChoosingItemContainer (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ChoosingItemContainer
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.remove_ChoosingItemContainer (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ChoosingGroupHeaderContainer
   (
      this : in out ListViewBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IListViewBase.all.add_ChoosingGroupHeaderContainer (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ChoosingGroupHeaderContainer
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.remove_ChoosingGroupHeaderContainer (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollIntoView
   (
      this : in out ListViewBase;
      item : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.ScrollIntoView (item);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out ListViewBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function LoadMoreItemsAsync
   (
      this : in out ListViewBase
   )
   return WinUI3.Microsoft.UI.Xaml.Data.LoadMoreItemsResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_LoadMoreItemsResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_LoadMoreItemsResult.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Microsoft.UI.Xaml.Data.LoadMoreItemsResult;
      m_IID            : aliased WinUI3.IID := (2277953703, 38728, 24476, (179, 89, 30, 18, 117, 156, 243, 206 )); -- Microsoft.UI.Xaml.Data.LoadMoreItemsResult;
      m_HandlerIID     : aliased WinUI3.IID := (2282136791, 33238, 20726, (145, 40, 82, 169, 83, 79, 235, 225 ));
      m_Handler        : AsyncOperationCompletedHandler_LoadMoreItemsResult.Kind := new AsyncOperationCompletedHandler_LoadMoreItemsResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_LoadMoreItemsResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_LoadMoreItemsResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_LoadMoreItemsResult.Kind_Delegate, AsyncOperationCompletedHandler_LoadMoreItemsResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IListViewBase.all.LoadMoreItemsAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   procedure ScrollIntoView
   (
      this : in out ListViewBase;
      item : WinUI3.IInspectable;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.ScrollIntoViewAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.ScrollIntoView (item, alignment);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetDesiredContainerUpdateDuration
   (
      this : in out ListViewBase;
      duration : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.SetDesiredContainerUpdateDuration (duration);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectRange
   (
      this : in out ListViewBase;
      itemIndexRange : WinUI3.Microsoft.UI.Xaml.Data.ItemIndexRange'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.SelectRange (itemIndexRange.m_IItemIndexRange.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure DeselectRange
   (
      this : in out ListViewBase;
      itemIndexRange : WinUI3.Microsoft.UI.Xaml.Data.ItemIndexRange'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.DeselectRange (itemIndexRange.m_IItemIndexRange.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function IsDragSource
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.IsDragSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryStartConnectedAnimationAsync
   (
      this : in out ListViewBase;
      animation : WinUI3.Microsoft.UI.Xaml.Media.Animation.ConnectedAnimation'Class;
      item : WinUI3.IInspectable;
      elementName : WinUI3.WString
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_elementName : constant WinUI3.HString := To_HString (elementName);
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Boolean;
      m_IID            : aliased WinUI3.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinUI3.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IListViewBase.all.TryStartConnectedAnimationAsync (animation.m_IConnectedAnimation.all, item, HStr_elementName, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      tmp := WindowsDeleteString (HStr_elementName);
      return m_RetVal;
   end;

   function PrepareConnectedAnimation
   (
      this : in out ListViewBase;
      key : WinUI3.WString;
      item : WinUI3.IInspectable;
      elementName : WinUI3.WString
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.ConnectedAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.Animation.IConnectedAnimation;
      HStr_key : constant WinUI3.HString := To_HString (key);
      HStr_elementName : constant WinUI3.HString := To_HString (elementName);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.ConnectedAnimation do
         Hr := this.m_IListViewBase.all.PrepareConnectedAnimation (HStr_key, item, HStr_elementName, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IConnectedAnimation := new WinUI3.Microsoft.UI.Xaml.Media.Animation.IConnectedAnimation;
         Retval.m_IConnectedAnimation.all := m_ComRetVal;
         tmp := WindowsDeleteString (HStr_key);
         tmp := WindowsDeleteString (HStr_elementName);
      end return;
   end;

   function get_Header
   (
      this : in out ListViewBase
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IListViewBase.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out ListViewBase;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out ListViewBase
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IListViewBase.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out ListViewBase;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTransitions
   (
      this : in out ListViewBase
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IListViewBase.all.get_HeaderTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTransitions
   (
      this : in out ListViewBase;
      value : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_HeaderTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Footer
   (
      this : in out ListViewBase
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IListViewBase.all.get_Footer (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Footer
   (
      this : in out ListViewBase;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_Footer (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FooterTemplate
   (
      this : in out ListViewBase
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IListViewBase.all.get_FooterTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_FooterTemplate
   (
      this : in out ListViewBase;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_FooterTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FooterTransitions
   (
      this : in out ListViewBase
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IListViewBase.all.get_FooterTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_FooterTransitions
   (
      this : in out ListViewBase;
      value : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_FooterTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SemanticZoomOwner
   (
      this : in out ListViewBase
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoom'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoom;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoom do
         m_Interface := QInterface (this.m_IListViewBase.all);
         Hr := m_Interface.get_SemanticZoomOwner (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISemanticZoom := new WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoom;
         Retval.m_ISemanticZoom.all := m_ComRetVal;
      end return;
   end;

   procedure put_SemanticZoomOwner
   (
      this : in out ListViewBase;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoom'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_SemanticZoomOwner (value.m_ISemanticZoom.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsActiveView
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.get_IsActiveView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsActiveView
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_IsActiveView (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomedInView
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.get_IsZoomedInView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomedInView
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_IsZoomedInView (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InitializeViewChange
   (
      this : in out ListViewBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.InitializeViewChange;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChange
   (
      this : in out ListViewBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.CompleteViewChange;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MakeVisible
   (
      this : in out ListViewBase;
      item : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.MakeVisible (item.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartViewChangeFrom
   (
      this : in out ListViewBase;
      source : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.StartViewChangeFrom (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartViewChangeTo
   (
      this : in out ListViewBase;
      source : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.StartViewChangeTo (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChangeFrom
   (
      this : in out ListViewBase;
      source : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.CompleteViewChangeFrom (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChangeTo
   (
      this : in out ListViewBase;
      source : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.CompleteViewChangeTo (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GridView

   procedure Initialize (this : in out GridView) is
   begin
      null;
   end;

   procedure Finalize (this : in out GridView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGridView, IGridView_Ptr);
   begin
      if this.m_IGridView /= null then
         if this.m_IGridView.all /= null then
            temp := this.m_IGridView.all.Release;
            Free (this.m_IGridView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GridView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GridView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IGridView");
      m_Factory    : access IGridViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IGridView;
   begin
      return RetVal : GridView do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGridView := new WinUI3.Microsoft.UI.Xaml.Controls.IGridView;
            Retval.m_IGridView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GridView

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewBaseHeaderItem

   procedure Initialize (this : in out ListViewBaseHeaderItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewBaseHeaderItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewBaseHeaderItem, IListViewBaseHeaderItem_Ptr);
   begin
      if this.m_IListViewBaseHeaderItem /= null then
         if this.m_IListViewBaseHeaderItem.all /= null then
            temp := this.m_IListViewBaseHeaderItem.all.Release;
            Free (this.m_IListViewBaseHeaderItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListViewBaseHeaderItem

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewBaseHeaderItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GridViewHeaderItem

   procedure Initialize (this : in out GridViewHeaderItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out GridViewHeaderItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGridViewHeaderItem, IGridViewHeaderItem_Ptr);
   begin
      if this.m_IGridViewHeaderItem /= null then
         if this.m_IGridViewHeaderItem.all /= null then
            temp := this.m_IGridViewHeaderItem.all.Release;
            Free (this.m_IGridViewHeaderItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GridViewHeaderItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GridViewHeaderItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IGridViewHeaderItem");
      m_Factory    : access IGridViewHeaderItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IGridViewHeaderItem;
   begin
      return RetVal : GridViewHeaderItem do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewHeaderItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGridViewHeaderItem := new WinUI3.Microsoft.UI.Xaml.Controls.IGridViewHeaderItem;
            Retval.m_IGridViewHeaderItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GridViewHeaderItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GridViewItem

   procedure Initialize (this : in out GridViewItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out GridViewItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGridViewItem, IGridViewItem_Ptr);
   begin
      if this.m_IGridViewItem /= null then
         if this.m_IGridViewItem.all /= null then
            temp := this.m_IGridViewItem.all.Release;
            Free (this.m_IGridViewItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GridViewItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GridViewItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IGridViewItem");
      m_Factory    : access IGridViewItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IGridViewItem;
   begin
      return RetVal : GridViewItem do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGridViewItem := new WinUI3.Microsoft.UI.Xaml.Controls.IGridViewItem;
            Retval.m_IGridViewItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GridViewItem

   function get_TemplateSettings
   (
      this : in out GridViewItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GridViewItemTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GridViewItemTemplateSettings do
         Hr := this.m_IGridViewItem.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGridViewItemTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemTemplateSettings;
         Retval.m_IGridViewItemTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GroupItem

   procedure Initialize (this : in out GroupItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out GroupItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGroupItem, IGroupItem_Ptr);
   begin
      if this.m_IGroupItem /= null then
         if this.m_IGroupItem.all /= null then
            temp := this.m_IGroupItem.all.Release;
            Free (this.m_IGroupItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GroupItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GroupItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IGroupItem");
      m_Factory    : access IGroupItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IGroupItem;
   begin
      return RetVal : GroupItem do
         Hr := RoGetActivationFactory (m_hString, IID_IGroupItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGroupItem := new WinUI3.Microsoft.UI.Xaml.Controls.IGroupItem;
            Retval.m_IGroupItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GroupItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GroupStyle

   procedure Initialize (this : in out GroupStyle) is
   begin
      null;
   end;

   procedure Finalize (this : in out GroupStyle) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGroupStyle, IGroupStyle_Ptr);
   begin
      if this.m_IGroupStyle /= null then
         if this.m_IGroupStyle.all /= null then
            temp := this.m_IGroupStyle.all.Release;
            Free (this.m_IGroupStyle);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GroupStyle

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GroupStyle is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IGroupStyle");
      m_Factory    : access IGroupStyleFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyle;
   begin
      return RetVal : GroupStyle do
         Hr := RoGetActivationFactory (m_hString, IID_IGroupStyleFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGroupStyle := new WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyle;
            Retval.m_IGroupStyle.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GroupStyle

   function get_Panel
   (
      this : in out GroupStyle
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemsPanelTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsPanelTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemsPanelTemplate do
         Hr := this.m_IGroupStyle.all.get_Panel (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemsPanelTemplate := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsPanelTemplate;
         Retval.m_IItemsPanelTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_Panel
   (
      this : in out GroupStyle;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ItemsPanelTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_Panel (value.m_IItemsPanelTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContainerStyle
   (
      this : in out GroupStyle
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IGroupStyle.all.get_ContainerStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContainerStyle
   (
      this : in out GroupStyle;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_ContainerStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderContainerStyle
   (
      this : in out GroupStyle
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IGroupStyle.all.get_HeaderContainerStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderContainerStyle
   (
      this : in out GroupStyle;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_HeaderContainerStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContainerStyleSelector
   (
      this : in out GroupStyle
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelector;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector do
         Hr := this.m_IGroupStyle.all.get_ContainerStyleSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyleSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelector;
         Retval.m_IStyleSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContainerStyleSelector
   (
      this : in out GroupStyle;
      value : WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_ContainerStyleSelector (value.m_IStyleSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out GroupStyle
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IGroupStyle.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out GroupStyle;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplateSelector
   (
      this : in out GroupStyle
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_IGroupStyle.all.get_HeaderTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplateSelector
   (
      this : in out GroupStyle;
      value : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_HeaderTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HidesIfEmpty
   (
      this : in out GroupStyle
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGroupStyle.all.get_HidesIfEmpty (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HidesIfEmpty
   (
      this : in out GroupStyle;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_HidesIfEmpty (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PropertyChanged
   (
      this : in out GroupStyle;
      handler : WinUI3.Microsoft.UI.Xaml.Data.PropertyChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.INotifyPropertyChanged := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyle_Interface, WinUI3.Microsoft.UI.Xaml.Data.INotifyPropertyChanged, WinUI3.Microsoft.UI.Xaml.Data.IID_INotifyPropertyChanged'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGroupStyle.all);
      Hr := m_Interface.add_PropertyChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PropertyChanged
   (
      this : in out GroupStyle;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.INotifyPropertyChanged := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyle_Interface, WinUI3.Microsoft.UI.Xaml.Data.INotifyPropertyChanged, WinUI3.Microsoft.UI.Xaml.Data.IID_INotifyPropertyChanged'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGroupStyle.all);
      Hr := m_Interface.remove_PropertyChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GroupStyleSelector

   procedure Initialize (this : in out GroupStyleSelector) is
   begin
      null;
   end;

   procedure Finalize (this : in out GroupStyleSelector) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGroupStyleSelector, IGroupStyleSelector_Ptr);
   begin
      if this.m_IGroupStyleSelector /= null then
         if this.m_IGroupStyleSelector.all /= null then
            temp := this.m_IGroupStyleSelector.all.Release;
            Free (this.m_IGroupStyleSelector);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GroupStyleSelector

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GroupStyleSelector is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IGroupStyleSelector");
      m_Factory    : access IGroupStyleSelectorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyleSelector;
   begin
      return RetVal : GroupStyleSelector do
         Hr := RoGetActivationFactory (m_hString, IID_IGroupStyleSelectorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGroupStyleSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyleSelector;
            Retval.m_IGroupStyleSelector.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GroupStyleSelector

   function SelectGroupStyle
   (
      this : in out GroupStyleSelector;
      group : WinUI3.IInspectable;
      level : WinUI3.UInt32
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.GroupStyle'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.GroupStyle do
         Hr := this.m_IGroupStyleSelector.all.SelectGroupStyle (group, level, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGroupStyle := new WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyle;
         Retval.m_IGroupStyle.all := m_ComRetVal;
      end return;
   end;

   function SelectGroupStyleCore
   (
      this : in out GroupStyleSelector;
      group : WinUI3.IInspectable;
      level : WinUI3.UInt32
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.GroupStyle'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyleSelectorOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyleSelector_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyleSelectorOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IGroupStyleSelectorOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.GroupStyle do
         m_Interface := QInterface (this.m_IGroupStyleSelector.all);
         Hr := m_Interface.SelectGroupStyleCore (group, level, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGroupStyle := new WinUI3.Microsoft.UI.Xaml.Controls.IGroupStyle;
         Retval.m_IGroupStyle.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HasValidationErrorsChangedEventArgs

   procedure Initialize (this : in out HasValidationErrorsChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out HasValidationErrorsChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHasValidationErrorsChangedEventArgs, IHasValidationErrorsChangedEventArgs_Ptr);
   begin
      if this.m_IHasValidationErrorsChangedEventArgs /= null then
         if this.m_IHasValidationErrorsChangedEventArgs.all /= null then
            temp := this.m_IHasValidationErrorsChangedEventArgs.all.Release;
            Free (this.m_IHasValidationErrorsChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HasValidationErrorsChangedEventArgs

   function get_NewValue
   (
      this : in out HasValidationErrorsChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IHasValidationErrorsChangedEventArgs.all.get_NewValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Hub

   procedure Initialize (this : in out Hub) is
   begin
      null;
   end;

   procedure Finalize (this : in out Hub) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHub, IHub_Ptr);
   begin
      if this.m_IHub /= null then
         if this.m_IHub.all /= null then
            temp := this.m_IHub.all.Release;
            Free (this.m_IHub);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Hub

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Hub is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IHub");
      m_Factory    : access IHubFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IHub;
   begin
      return RetVal : Hub do
         Hr := RoGetActivationFactory (m_hString, IID_IHubFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IHub := new WinUI3.Microsoft.UI.Xaml.Controls.IHub;
            Retval.m_IHub.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Hub

   function get_HeaderProperty_Hub
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_Hub
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_Hub
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultSectionIndexProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultSectionIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SemanticZoomOwnerProperty_Hub
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SemanticZoomOwnerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsActiveViewProperty_Hub
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsActiveViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsZoomedInViewProperty_Hub
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomedInViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Hub

   function get_Header
   (
      this : in out Hub
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IHub.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out Hub;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out Hub
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IHub.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out Hub;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out Hub
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IHub.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out Hub;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DefaultSectionIndex
   (
      this : in out Hub
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IHub.all.get_DefaultSectionIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultSectionIndex
   (
      this : in out Hub;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.put_DefaultSectionIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Sections
   (
      this : in out Hub
   )
   return IVector_IHubSection.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IHubSection.Kind;
   begin
      Hr := this.m_IHub.all.get_Sections (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IHubSection (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SectionsInView
   (
      this : in out Hub
   )
   return IVector_IHubSection.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IHubSection.Kind;
   begin
      Hr := this.m_IHub.all.get_SectionsInView (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IHubSection (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SectionHeaders
   (
      this : in out Hub
   )
   return IObservableVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_IInspectable.Kind;
   begin
      Hr := this.m_IHub.all.get_SectionHeaders (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function add_SectionHeaderClick
   (
      this : in out Hub;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.HubSectionHeaderClickEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IHub.all.add_SectionHeaderClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SectionHeaderClick
   (
      this : in out Hub;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.remove_SectionHeaderClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SectionsInViewChanged
   (
      this : in out Hub;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.SectionsInViewChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IHub.all.add_SectionsInViewChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SectionsInViewChanged
   (
      this : in out Hub;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.remove_SectionsInViewChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollToSection
   (
      this : in out Hub;
      section : WinUI3.Microsoft.UI.Xaml.Controls.HubSection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.ScrollToSection (section.m_IHubSection.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SemanticZoomOwner
   (
      this : in out Hub
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoom'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoom;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoom do
         m_Interface := QInterface (this.m_IHub.all);
         Hr := m_Interface.get_SemanticZoomOwner (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISemanticZoom := new WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoom;
         Retval.m_ISemanticZoom.all := m_ComRetVal;
      end return;
   end;

   procedure put_SemanticZoomOwner
   (
      this : in out Hub;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoom'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.put_SemanticZoomOwner (value.m_ISemanticZoom.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsActiveView
   (
      this : in out Hub
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.get_IsActiveView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsActiveView
   (
      this : in out Hub;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.put_IsActiveView (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomedInView
   (
      this : in out Hub
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.get_IsZoomedInView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomedInView
   (
      this : in out Hub;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.put_IsZoomedInView (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InitializeViewChange
   (
      this : in out Hub
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.InitializeViewChange;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChange
   (
      this : in out Hub
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.CompleteViewChange;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MakeVisible
   (
      this : in out Hub;
      item : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.MakeVisible (item.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartViewChangeFrom
   (
      this : in out Hub;
      source : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.StartViewChangeFrom (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartViewChangeTo
   (
      this : in out Hub;
      source : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.StartViewChangeTo (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChangeFrom
   (
      this : in out Hub;
      source : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.CompleteViewChangeFrom (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChangeTo
   (
      this : in out Hub;
      source : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IHub_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Microsoft.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.CompleteViewChangeTo (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HubSection

   procedure Initialize (this : in out HubSection) is
   begin
      null;
   end;

   procedure Finalize (this : in out HubSection) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHubSection, IHubSection_Ptr);
   begin
      if this.m_IHubSection /= null then
         if this.m_IHubSection.all /= null then
            temp := this.m_IHubSection.all.Release;
            Free (this.m_IHubSection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for HubSection

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return HubSection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IHubSection");
      m_Factory    : access IHubSectionFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IHubSection;
   begin
      return RetVal : HubSection do
         Hr := RoGetActivationFactory (m_hString, IID_IHubSectionFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IHubSection := new WinUI3.Microsoft.UI.Xaml.Controls.IHubSection;
            Retval.m_IHubSection.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for HubSection

   function get_HeaderProperty_HubSection
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.HubSection");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHubSectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubSectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_HubSection
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.HubSection");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHubSectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubSectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTemplateProperty_HubSection
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.HubSection");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHubSectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubSectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHeaderInteractiveProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.HubSection");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHubSectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubSectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHeaderInteractiveProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HubSection

   function get_Header
   (
      this : in out HubSection
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IHubSection.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out HubSection;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHubSection.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out HubSection
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IHubSection.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out HubSection;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHubSection.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplate
   (
      this : in out HubSection
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IHubSection.all.get_ContentTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTemplate
   (
      this : in out HubSection;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHubSection.all.put_ContentTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHeaderInteractive
   (
      this : in out HubSection
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IHubSection.all.get_IsHeaderInteractive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHeaderInteractive
   (
      this : in out HubSection;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHubSection.all.put_IsHeaderInteractive (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HubSectionCollection

   procedure Initialize (this : in out HubSectionCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out HubSectionCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HubSectionCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Controls.HubSection>
   function GetAt
   (
      this : in out HubSectionCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.HubSection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IHubSection;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.HubSection do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHubSection := new WinUI3.Microsoft.UI.Xaml.Controls.IHubSection;
         Retval.m_IHubSection.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out HubSectionCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out HubSectionCollection
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.HubSection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IHubSection;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.HubSection do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHubSection := new WinUI3.Microsoft.UI.Xaml.Controls.IHubSection;
         Retval.m_IHubSection.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out HubSectionCollection;
      value : WinUI3.Microsoft.UI.Xaml.Controls.HubSection'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IHubSection.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out HubSectionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Microsoft.UI.Xaml.Controls.HubSection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IHubSection.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out HubSectionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Microsoft.UI.Xaml.Controls.HubSection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IHubSection.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out HubSectionCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out HubSectionCollection;
      value : WinUI3.Microsoft.UI.Xaml.Controls.HubSection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IHubSection.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out HubSectionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out HubSectionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out HubSectionCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Microsoft.UI.Xaml.Controls.IHubSection_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out HubSectionCollection;
      items : WinUI3.Microsoft.UI.Xaml.Controls.IHubSection_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2777303007, 5312, 22744, (174, 12, 237, 45, 178, 10, 160, 95 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.HubSection>
   function First
   (
      this : in out HubSectionCollection
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.HubSection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IHubSection;
      m_GenericIID     : aliased WinUI3.IID := (186600010, 55800, 23623, (134, 215, 38, 134, 34, 43, 215, 15 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.HubSection do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHubSection := new WinUI3.Microsoft.UI.Xaml.Controls.IHubSection;
         Retval.m_IHubSection.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HubSectionHeaderClickEventArgs

   procedure Initialize (this : in out HubSectionHeaderClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out HubSectionHeaderClickEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHubSectionHeaderClickEventArgs, IHubSectionHeaderClickEventArgs_Ptr);
   begin
      if this.m_IHubSectionHeaderClickEventArgs /= null then
         if this.m_IHubSectionHeaderClickEventArgs.all /= null then
            temp := this.m_IHubSectionHeaderClickEventArgs.all.Release;
            Free (this.m_IHubSectionHeaderClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for HubSectionHeaderClickEventArgs

   function Constructor return HubSectionHeaderClickEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IHubSectionHeaderClickEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IHubSectionHeaderClickEventArgs;
   begin
      return RetVal : HubSectionHeaderClickEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IHubSectionHeaderClickEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IHubSectionHeaderClickEventArgs;
            Retval.m_IHubSectionHeaderClickEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HubSectionHeaderClickEventArgs

   function get_Section
   (
      this : in out HubSectionHeaderClickEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.HubSection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IHubSection;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.HubSection do
         Hr := this.m_IHubSectionHeaderClickEventArgs.all.get_Section (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHubSection := new WinUI3.Microsoft.UI.Xaml.Controls.IHubSection;
         Retval.m_IHubSection.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Delegate HubSectionHeaderClickEventHandler

   function Invoke
   (
      this : access HubSectionHeaderClickEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.IHubSectionHeaderClickEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HyperlinkButton

   procedure Initialize (this : in out HyperlinkButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out HyperlinkButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHyperlinkButton, IHyperlinkButton_Ptr);
   begin
      if this.m_IHyperlinkButton /= null then
         if this.m_IHyperlinkButton.all /= null then
            temp := this.m_IHyperlinkButton.all.Release;
            Free (this.m_IHyperlinkButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for HyperlinkButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return HyperlinkButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IHyperlinkButton");
      m_Factory    : access IHyperlinkButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IHyperlinkButton;
   begin
      return RetVal : HyperlinkButton do
         Hr := RoGetActivationFactory (m_hString, IID_IHyperlinkButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IHyperlinkButton := new WinUI3.Microsoft.UI.Xaml.Controls.IHyperlinkButton;
            Retval.m_IHyperlinkButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for HyperlinkButton

   function get_NavigateUriProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.HyperlinkButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IHyperlinkButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHyperlinkButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NavigateUriProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HyperlinkButton

   function get_NavigateUri
   (
      this : in out HyperlinkButton
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IHyperlinkButton.all.get_NavigateUri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_NavigateUri
   (
      this : in out HyperlinkButton;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHyperlinkButton.all.put_NavigateUri (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for IconSourceElement

   procedure Initialize (this : in out IconSourceElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out IconSourceElement) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IIconSourceElement, IIconSourceElement_Ptr);
   begin
      if this.m_IIconSourceElement /= null then
         if this.m_IIconSourceElement.all /= null then
            temp := this.m_IIconSourceElement.all.Release;
            Free (this.m_IIconSourceElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for IconSourceElement

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return IconSourceElement is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IIconSourceElement");
      m_Factory    : access IIconSourceElementFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconSourceElement;
   begin
      return RetVal : IconSourceElement do
         Hr := RoGetActivationFactory (m_hString, IID_IIconSourceElementFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IIconSourceElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconSourceElement;
            Retval.m_IIconSourceElement.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for IconSourceElement

   function get_IconSourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IconSourceElement");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IIconSourceElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IIconSourceElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for IconSourceElement

   function get_IconSource
   (
      this : in out IconSourceElement
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconSource do
         Hr := this.m_IIconSourceElement.all.get_IconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconSource
   (
      this : in out IconSourceElement;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IIconSourceElement.all.put_IconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Image

   procedure Initialize (this : in out Image) is
   begin
      null;
   end;

   procedure Finalize (this : in out Image) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IImage, IImage_Ptr);
   begin
      if this.m_IImage /= null then
         if this.m_IImage.all /= null then
            temp := this.m_IImage.all.Release;
            Free (this.m_IImage);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Image

   function Constructor return Image is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IImage");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IImage;
   begin
      return RetVal : Image do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IImage := new WinUI3.Microsoft.UI.Xaml.Controls.IImage;
            Retval.m_IImage.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Image

   function get_SourceProperty_Image
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Image");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchProperty_Image
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Image");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NineGridProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Image");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NineGridProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Image

   function get_Source
   (
      this : in out Image
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IImage.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out Image;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImage.all.put_Source (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out Image
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.Stretch;
   begin
      Hr := this.m_IImage.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out Image;
      value : WinUI3.Microsoft.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImage.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NineGrid
   (
      this : in out Image
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IImage.all.get_NineGrid (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NineGrid
   (
      this : in out Image;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImage.all.put_NineGrid (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ImageFailed
   (
      this : in out Image;
      handler : WinUI3.Microsoft.UI.Xaml.ExceptionRoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IImage.all.add_ImageFailed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ImageFailed
   (
      this : in out Image;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImage.all.remove_ImageFailed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ImageOpened
   (
      this : in out Image;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IImage.all.add_ImageOpened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ImageOpened
   (
      this : in out Image;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImage.all.remove_ImageOpened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetAsCastingSource
   (
      this : in out Image
   )
   return WinUI3.Windows.Media.Casting.CastingSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Casting.ICastingSource;
   begin
      return RetVal : WinUI3.Windows.Media.Casting.CastingSource do
         Hr := this.m_IImage.all.GetAsCastingSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICastingSource := new WinUI3.Windows.Media.Casting.ICastingSource;
         Retval.m_ICastingSource.all := m_ComRetVal;
      end return;
   end;

   function GetAlphaMask
   (
      this : in out Image
   )
   return WinUI3.Microsoft.UI.Composition.CompositionBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.ICompositionBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.CompositionBrush do
         Hr := this.m_IImage.all.GetAlphaMask (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinUI3.Microsoft.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ImageIcon

   procedure Initialize (this : in out ImageIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out ImageIcon) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IImageIcon, IImageIcon_Ptr);
   begin
      if this.m_IImageIcon /= null then
         if this.m_IImageIcon.all /= null then
            temp := this.m_IImageIcon.all.Release;
            Free (this.m_IImageIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ImageIcon

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ImageIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IImageIcon");
      m_Factory    : access IImageIconFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IImageIcon;
   begin
      return RetVal : ImageIcon do
         Hr := RoGetActivationFactory (m_hString, IID_IImageIconFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IImageIcon := new WinUI3.Microsoft.UI.Xaml.Controls.IImageIcon;
            Retval.m_IImageIcon.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ImageIcon

   function get_SourceProperty_ImageIcon
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ImageIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IImageIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IImageIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ImageIcon

   function get_Source
   (
      this : in out ImageIcon
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IImageIcon.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out ImageIcon;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImageIcon.all.put_Source (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ImageIconSource

   procedure Initialize (this : in out ImageIconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out ImageIconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IImageIconSource, IImageIconSource_Ptr);
   begin
      if this.m_IImageIconSource /= null then
         if this.m_IImageIconSource.all /= null then
            temp := this.m_IImageIconSource.all.Release;
            Free (this.m_IImageIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ImageIconSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ImageIconSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IImageIconSource");
      m_Factory    : access IImageIconSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IImageIconSource;
   begin
      return RetVal : ImageIconSource do
         Hr := RoGetActivationFactory (m_hString, IID_IImageIconSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IImageIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IImageIconSource;
            Retval.m_IImageIconSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ImageIconSource

   function get_ImageSourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ImageIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IImageIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IImageIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ImageSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ImageIconSource

   function get_ImageSource
   (
      this : in out ImageIconSource
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IImageIconSource.all.get_ImageSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_ImageSource
   (
      this : in out ImageIconSource;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImageIconSource.all.put_ImageSource (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InfoBadge

   procedure Initialize (this : in out InfoBadge) is
   begin
      null;
   end;

   procedure Finalize (this : in out InfoBadge) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInfoBadge, IInfoBadge_Ptr);
   begin
      if this.m_IInfoBadge /= null then
         if this.m_IInfoBadge.all /= null then
            temp := this.m_IInfoBadge.all.Release;
            Free (this.m_IInfoBadge);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InfoBadge

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InfoBadge is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IInfoBadge");
      m_Factory    : access IInfoBadgeFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadge;
   begin
      return RetVal : InfoBadge do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBadgeFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInfoBadge := new WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadge;
            Retval.m_IInfoBadge.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InfoBadge

   function get_ValueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBadge");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadgeStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBadgeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconSourceProperty_InfoBadge
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBadge");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadgeStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBadgeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateSettingsProperty_InfoBadge
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBadge");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadgeStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBadgeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InfoBadge

   function get_Value
   (
      this : in out InfoBadge
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInfoBadge.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out InfoBadge;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBadge.all.put_Value (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IconSource
   (
      this : in out InfoBadge
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconSource do
         Hr := this.m_IInfoBadge.all.get_IconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconSource
   (
      this : in out InfoBadge;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBadge.all.put_IconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out InfoBadge
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.InfoBadgeTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadgeTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.InfoBadgeTemplateSettings do
         Hr := this.m_IInfoBadge.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInfoBadgeTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadgeTemplateSettings;
         Retval.m_IInfoBadgeTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InfoBadgeTemplateSettings

   procedure Initialize (this : in out InfoBadgeTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out InfoBadgeTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInfoBadgeTemplateSettings, IInfoBadgeTemplateSettings_Ptr);
   begin
      if this.m_IInfoBadgeTemplateSettings /= null then
         if this.m_IInfoBadgeTemplateSettings.all /= null then
            temp := this.m_IInfoBadgeTemplateSettings.all.Release;
            Free (this.m_IInfoBadgeTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InfoBadgeTemplateSettings

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InfoBadgeTemplateSettings is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IInfoBadgeTemplateSettings");
      m_Factory    : access IInfoBadgeTemplateSettingsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadgeTemplateSettings;
   begin
      return RetVal : InfoBadgeTemplateSettings do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBadgeTemplateSettingsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInfoBadgeTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadgeTemplateSettings;
            Retval.m_IInfoBadgeTemplateSettings.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InfoBadgeTemplateSettings

   function get_InfoBadgeCornerRadiusProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBadgeTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadgeTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBadgeTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InfoBadgeCornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconElementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBadgeTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadgeTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBadgeTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InfoBadgeTemplateSettings

   function get_InfoBadgeCornerRadius
   (
      this : in out InfoBadgeTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_IInfoBadgeTemplateSettings.all.get_InfoBadgeCornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InfoBadgeCornerRadius
   (
      this : in out InfoBadgeTemplateSettings;
      value : WinUI3.Microsoft.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBadgeTemplateSettings.all.put_InfoBadgeCornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IconElement
   (
      this : in out InfoBadgeTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_IInfoBadgeTemplateSettings.all.get_IconElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconElement
   (
      this : in out InfoBadgeTemplateSettings;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBadgeTemplateSettings.all.put_IconElement (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InfoBar

   procedure Initialize (this : in out InfoBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out InfoBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInfoBar, IInfoBar_Ptr);
   begin
      if this.m_IInfoBar /= null then
         if this.m_IInfoBar.all /= null then
            temp := this.m_IInfoBar.all.Release;
            Free (this.m_IInfoBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InfoBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InfoBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IInfoBar");
      m_Factory    : access IInfoBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IInfoBar;
   begin
      return RetVal : InfoBar do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInfoBar := new WinUI3.Microsoft.UI.Xaml.Controls.IInfoBar;
            Retval.m_IInfoBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InfoBar

   function get_IsOpenProperty_InfoBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TitleProperty_InfoBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MessageProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MessageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SeverityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SeverityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconSourceProperty_InfoBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsIconVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsIconVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsClosableProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsClosableProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonStyleProperty_InfoBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonCommandProperty_InfoBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonCommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonCommandParameterProperty_InfoBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonCommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActionButtonProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActionButtonProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentProperty_InfoBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTemplateProperty_InfoBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateSettingsProperty_InfoBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InfoBar

   function get_IsOpen
   (
      this : in out InfoBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInfoBar.all.get_IsOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOpen
   (
      this : in out InfoBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.put_IsOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Title
   (
      this : in out InfoBar
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IInfoBar.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out InfoBar;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IInfoBar.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Message
   (
      this : in out InfoBar
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IInfoBar.all.get_Message (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Message
   (
      this : in out InfoBar;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IInfoBar.all.put_Message (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Severity
   (
      this : in out InfoBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.InfoBarSeverity is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.InfoBarSeverity;
   begin
      Hr := this.m_IInfoBar.all.get_Severity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Severity
   (
      this : in out InfoBar;
      value : WinUI3.Microsoft.UI.Xaml.Controls.InfoBarSeverity
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.put_Severity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IconSource
   (
      this : in out InfoBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconSource do
         Hr := this.m_IInfoBar.all.get_IconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconSource
   (
      this : in out InfoBar;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.put_IconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsIconVisible
   (
      this : in out InfoBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInfoBar.all.get_IsIconVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsIconVisible
   (
      this : in out InfoBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.put_IsIconVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsClosable
   (
      this : in out InfoBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInfoBar.all.get_IsClosable (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsClosable
   (
      this : in out InfoBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.put_IsClosable (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonStyle
   (
      this : in out InfoBar
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IInfoBar.all.get_CloseButtonStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_CloseButtonStyle
   (
      this : in out InfoBar;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.put_CloseButtonStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonCommand
   (
      this : in out InfoBar
   )
   return WinUI3.Microsoft.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_IInfoBar.all.get_CloseButtonCommand (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CloseButtonCommand
   (
      this : in out InfoBar;
      value : WinUI3.Microsoft.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.put_CloseButtonCommand (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonCommandParameter
   (
      this : in out InfoBar
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IInfoBar.all.get_CloseButtonCommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CloseButtonCommandParameter
   (
      this : in out InfoBar;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.put_CloseButtonCommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActionButton
   (
      this : in out InfoBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ButtonBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IButtonBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ButtonBase do
         Hr := this.m_IInfoBar.all.get_ActionButton (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IButtonBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IButtonBase;
         Retval.m_IButtonBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_ActionButton
   (
      this : in out InfoBar;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ButtonBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.put_ActionButton (value.m_IButtonBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Content
   (
      this : in out InfoBar
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IInfoBar.all.get_Content (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Content
   (
      this : in out InfoBar;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.put_Content (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplate
   (
      this : in out InfoBar
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IInfoBar.all.get_ContentTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTemplate
   (
      this : in out InfoBar;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.put_ContentTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out InfoBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.InfoBarTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.InfoBarTemplateSettings do
         Hr := this.m_IInfoBar.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInfoBarTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarTemplateSettings;
         Retval.m_IInfoBarTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_CloseButtonClick
   (
      this : in out InfoBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInfoBar.all.add_CloseButtonClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CloseButtonClick
   (
      this : in out InfoBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.remove_CloseButtonClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closing
   (
      this : in out InfoBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInfoBar.all.add_Closing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closing
   (
      this : in out InfoBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.remove_Closing (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out InfoBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInfoBar.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out InfoBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBar.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InfoBarClosedEventArgs

   procedure Initialize (this : in out InfoBarClosedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InfoBarClosedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInfoBarClosedEventArgs, IInfoBarClosedEventArgs_Ptr);
   begin
      if this.m_IInfoBarClosedEventArgs /= null then
         if this.m_IInfoBarClosedEventArgs.all /= null then
            temp := this.m_IInfoBarClosedEventArgs.all.Release;
            Free (this.m_IInfoBarClosedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InfoBarClosedEventArgs

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InfoBarClosedEventArgs

   function get_Reason
   (
      this : in out InfoBarClosedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.InfoBarCloseReason is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.InfoBarCloseReason;
   begin
      Hr := this.m_IInfoBarClosedEventArgs.all.get_Reason (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InfoBarClosingEventArgs

   procedure Initialize (this : in out InfoBarClosingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InfoBarClosingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInfoBarClosingEventArgs, IInfoBarClosingEventArgs_Ptr);
   begin
      if this.m_IInfoBarClosingEventArgs /= null then
         if this.m_IInfoBarClosingEventArgs.all /= null then
            temp := this.m_IInfoBarClosingEventArgs.all.Release;
            Free (this.m_IInfoBarClosingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InfoBarClosingEventArgs

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InfoBarClosingEventArgs

   function get_Reason
   (
      this : in out InfoBarClosingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.InfoBarCloseReason is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.InfoBarCloseReason;
   begin
      Hr := this.m_IInfoBarClosingEventArgs.all.get_Reason (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out InfoBarClosingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInfoBarClosingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out InfoBarClosingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBarClosingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InfoBarTemplateSettings

   procedure Initialize (this : in out InfoBarTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out InfoBarTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInfoBarTemplateSettings, IInfoBarTemplateSettings_Ptr);
   begin
      if this.m_IInfoBarTemplateSettings /= null then
         if this.m_IInfoBarTemplateSettings.all /= null then
            temp := this.m_IInfoBarTemplateSettings.all.Release;
            Free (this.m_IInfoBarTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InfoBarTemplateSettings

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InfoBarTemplateSettings is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IInfoBarTemplateSettings");
      m_Factory    : access IInfoBarTemplateSettingsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarTemplateSettings;
   begin
      return RetVal : InfoBarTemplateSettings do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarTemplateSettingsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInfoBarTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarTemplateSettings;
            Retval.m_IInfoBarTemplateSettings.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InfoBarTemplateSettings

   function get_IconElementProperty_InfoBarTemplateSettings
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.InfoBarTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IInfoBarTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InfoBarTemplateSettings

   function get_IconElement
   (
      this : in out InfoBarTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_IInfoBarTemplateSettings.all.get_IconElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconElement
   (
      this : in out InfoBarTemplateSettings;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBarTemplateSettings.all.put_IconElement (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for IsTextTrimmedChangedEventArgs

   procedure Initialize (this : in out IsTextTrimmedChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out IsTextTrimmedChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IIsTextTrimmedChangedEventArgs, IIsTextTrimmedChangedEventArgs_Ptr);
   begin
      if this.m_IIsTextTrimmedChangedEventArgs /= null then
         if this.m_IIsTextTrimmedChangedEventArgs.all /= null then
            temp := this.m_IIsTextTrimmedChangedEventArgs.all.Release;
            Free (this.m_IIsTextTrimmedChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for IsTextTrimmedChangedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemClickEventArgs

   procedure Initialize (this : in out ItemClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemClickEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemClickEventArgs, IItemClickEventArgs_Ptr);
   begin
      if this.m_IItemClickEventArgs /= null then
         if this.m_IItemClickEventArgs.all /= null then
            temp := this.m_IItemClickEventArgs.all.Release;
            Free (this.m_IItemClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemClickEventArgs

   function Constructor return ItemClickEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemClickEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemClickEventArgs;
   begin
      return RetVal : ItemClickEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemClickEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IItemClickEventArgs;
            Retval.m_IItemClickEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemClickEventArgs

   function get_ClickedItem
   (
      this : in out ItemClickEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemClickEventArgs.all.get_ClickedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ItemClickEventHandler

   function Invoke
   (
      this : access ItemClickEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.IItemClickEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemCollection

   procedure Initialize (this : in out ItemCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemCollection

   -- Generic Interface Windows.Foundation.Collections.IObservableVector`1<System.Object>
   function add_VectorChanged
   (
      this : in out ItemCollection;
      vhnd : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IObservableVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      m_GenericIID     : aliased WinUI3.IID := (2072102250, 2437, 20877, (186, 169, 13, 169, 174, 0, 159, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IObservableVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.add_VectorChanged (vhnd, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VectorChanged
   (
      this : in out ItemCollection;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IObservableVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2072102250, 2437, 20877, (186, 169, 13, 169, 174, 0, 159, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IObservableVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.remove_VectorChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IVector`1<System.Object>
   function GetAt
   (
      this : in out ItemCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out ItemCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out ItemCollection
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IndexOf
   (
      this : in out ItemCollection;
      value : WinUI3.IInspectable;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out ItemCollection;
      index : WinUI3.UInt32;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out ItemCollection;
      index : WinUI3.UInt32;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out ItemCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out ItemCollection;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out ItemCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out ItemCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out ItemCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.IInspectable_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out ItemCollection;
      items : WinUI3.IInspectable_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<System.Object>
   function First
   (
      this : in out ItemCollection
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      m_GenericIID     : aliased WinUI3.IID := (153846939, 24753, 21182, (164, 74, 111, 232, 233, 51, 203, 228 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.First (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemCollectionTransition

   procedure Initialize (this : in out ItemCollectionTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemCollectionTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemCollectionTransition, IItemCollectionTransition_Ptr);
   begin
      if this.m_IItemCollectionTransition /= null then
         if this.m_IItemCollectionTransition.all /= null then
            temp := this.m_IItemCollectionTransition.all.Release;
            Free (this.m_IItemCollectionTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemCollectionTransition

   function get_Operation
   (
      this : in out ItemCollectionTransition
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionOperation;
   begin
      Hr := this.m_IItemCollectionTransition.all.get_Operation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Triggers
   (
      this : in out ItemCollectionTransition
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionTriggers is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionTriggers;
   begin
      Hr := this.m_IItemCollectionTransition.all.get_Triggers (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OldBounds
   (
      this : in out ItemCollectionTransition
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IItemCollectionTransition.all.get_OldBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewBounds
   (
      this : in out ItemCollectionTransition
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IItemCollectionTransition.all.get_NewBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HasStarted
   (
      this : in out ItemCollectionTransition
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IItemCollectionTransition.all.get_HasStarted (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Start
   (
      this : in out ItemCollectionTransition
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionProgress'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProgress;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionProgress do
         Hr := this.m_IItemCollectionTransition.all.Start (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemCollectionTransitionProgress := new WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProgress;
         Retval.m_IItemCollectionTransitionProgress.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemCollectionTransitionCompletedEventArgs

   procedure Initialize (this : in out ItemCollectionTransitionCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemCollectionTransitionCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemCollectionTransitionCompletedEventArgs, IItemCollectionTransitionCompletedEventArgs_Ptr);
   begin
      if this.m_IItemCollectionTransitionCompletedEventArgs /= null then
         if this.m_IItemCollectionTransitionCompletedEventArgs.all /= null then
            temp := this.m_IItemCollectionTransitionCompletedEventArgs.all.Release;
            Free (this.m_IItemCollectionTransitionCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemCollectionTransitionCompletedEventArgs

   function get_Transition
   (
      this : in out ItemCollectionTransitionCompletedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransition;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransition do
         Hr := this.m_IItemCollectionTransitionCompletedEventArgs.all.get_Transition (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemCollectionTransition := new WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransition;
         Retval.m_IItemCollectionTransition.all := m_ComRetVal;
      end return;
   end;

   function get_Element
   (
      this : in out ItemCollectionTransitionCompletedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IItemCollectionTransitionCompletedEventArgs.all.get_Element (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemCollectionTransitionProgress

   procedure Initialize (this : in out ItemCollectionTransitionProgress) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemCollectionTransitionProgress) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemCollectionTransitionProgress, IItemCollectionTransitionProgress_Ptr);
   begin
      if this.m_IItemCollectionTransitionProgress /= null then
         if this.m_IItemCollectionTransitionProgress.all /= null then
            temp := this.m_IItemCollectionTransitionProgress.all.Release;
            Free (this.m_IItemCollectionTransitionProgress);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemCollectionTransitionProgress

   function get_Transition
   (
      this : in out ItemCollectionTransitionProgress
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransition;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransition do
         Hr := this.m_IItemCollectionTransitionProgress.all.get_Transition (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemCollectionTransition := new WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransition;
         Retval.m_IItemCollectionTransition.all := m_ComRetVal;
      end return;
   end;

   function get_Element
   (
      this : in out ItemCollectionTransitionProgress
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IItemCollectionTransitionProgress.all.get_Element (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure Complete
   (
      this : in out ItemCollectionTransitionProgress
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemCollectionTransitionProgress.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemCollectionTransitionProvider

   procedure Initialize (this : in out ItemCollectionTransitionProvider) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemCollectionTransitionProvider) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemCollectionTransitionProvider, IItemCollectionTransitionProvider_Ptr);
   begin
      if this.m_IItemCollectionTransitionProvider /= null then
         if this.m_IItemCollectionTransitionProvider.all /= null then
            temp := this.m_IItemCollectionTransitionProvider.all.Release;
            Free (this.m_IItemCollectionTransitionProvider);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemCollectionTransitionProvider

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ItemCollectionTransitionProvider is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProvider");
      m_Factory    : access IItemCollectionTransitionProviderFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProvider;
   begin
      return RetVal : ItemCollectionTransitionProvider do
         Hr := RoGetActivationFactory (m_hString, IID_IItemCollectionTransitionProviderFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IItemCollectionTransitionProvider := new WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProvider;
            Retval.m_IItemCollectionTransitionProvider.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemCollectionTransitionProvider

   function ShouldAnimate
   (
      this : in out ItemCollectionTransitionProvider;
      transition : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransition'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IItemCollectionTransitionProvider.all.ShouldAnimate (transition.m_IItemCollectionTransition.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure QueueTransition
   (
      this : in out ItemCollectionTransitionProvider;
      transition : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemCollectionTransitionProvider.all.QueueTransition (transition.m_IItemCollectionTransition.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TransitionCompleted
   (
      this : in out ItemCollectionTransitionProvider;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IItemCollectionTransitionProvider.all.add_TransitionCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TransitionCompleted
   (
      this : in out ItemCollectionTransitionProvider;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemCollectionTransitionProvider.all.remove_TransitionCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShouldAnimateCore
   (
      this : in out ItemCollectionTransitionProvider;
      transition : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransition'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProviderOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProvider_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProviderOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemCollectionTransitionProviderOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemCollectionTransitionProvider.all);
      Hr := m_Interface.ShouldAnimateCore (transition.m_IItemCollectionTransition.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure StartTransitions
   (
      this : in out ItemCollectionTransitionProvider;
      transitions : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProviderOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProvider_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProviderOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemCollectionTransitionProviderOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemCollectionTransitionProvider.all);
      Hr := m_Interface.StartTransitions (transitions);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemContainer

   procedure Initialize (this : in out ItemContainer) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemContainer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemContainer, IItemContainer_Ptr);
   begin
      if this.m_IItemContainer /= null then
         if this.m_IItemContainer.all /= null then
            temp := this.m_IItemContainer.all.Release;
            Free (this.m_IItemContainer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemContainer

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ItemContainer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemContainer");
      m_Factory    : access IItemContainerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemContainer;
   begin
      return RetVal : ItemContainer do
         Hr := RoGetActivationFactory (m_hString, IID_IItemContainerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IItemContainer := new WinUI3.Microsoft.UI.Xaml.Controls.IItemContainer;
            Retval.m_IItemContainer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ItemContainer

   function get_ChildProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemContainer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSelectedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemContainer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSelectedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemContainer

   function get_Child
   (
      this : in out ItemContainer
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IItemContainer.all.get_Child (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Child
   (
      this : in out ItemContainer;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainer.all.put_Child (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSelected
   (
      this : in out ItemContainer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IItemContainer.all.get_IsSelected (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSelected
   (
      this : in out ItemContainer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainer.all.put_IsSelected (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemContainerGenerator

   procedure Initialize (this : in out ItemContainerGenerator) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemContainerGenerator) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemContainerGenerator, IItemContainerGenerator_Ptr);
   begin
      if this.m_IItemContainerGenerator /= null then
         if this.m_IItemContainerGenerator.all /= null then
            temp := this.m_IItemContainerGenerator.all.Release;
            Free (this.m_IItemContainerGenerator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemContainerGenerator

   function add_ItemsChanged
   (
      this : in out ItemContainerGenerator;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IItemContainerGenerator.all.add_ItemsChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemsChanged
   (
      this : in out ItemContainerGenerator;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.remove_ItemsChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ItemFromContainer
   (
      this : in out ItemContainerGenerator;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemContainerGenerator.all.ItemFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromItem
   (
      this : in out ItemContainerGenerator;
      item : WinUI3.IInspectable
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         Hr := this.m_IItemContainerGenerator.all.ContainerFromItem (item, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function IndexFromContainer
   (
      this : in out ItemContainerGenerator;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemContainerGenerator.all.IndexFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromIndex
   (
      this : in out ItemContainerGenerator;
      index : WinUI3.Int32
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         Hr := this.m_IItemContainerGenerator.all.ContainerFromIndex (index, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function GetItemContainerGeneratorForPanel
   (
      this : in out ItemContainerGenerator;
      panel_p : WinUI3.Microsoft.UI.Xaml.Controls.Panel'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemContainerGenerator'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerGenerator;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemContainerGenerator do
         Hr := this.m_IItemContainerGenerator.all.GetItemContainerGeneratorForPanel (panel_p.m_IPanel.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemContainerGenerator := new WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerGenerator;
         Retval.m_IItemContainerGenerator.all := m_ComRetVal;
      end return;
   end;

   procedure StartAt
   (
      this : in out ItemContainerGenerator;
      position : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition;
      direction : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorDirection;
      allowStartAtRealizedItem : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.StartAt (position, direction, allowStartAtRealizedItem);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out ItemContainerGenerator
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GenerateNext
   (
      this : in out ItemContainerGenerator;
      isNewlyRealized : WinUI3.Boolean_Ptr
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         Hr := this.m_IItemContainerGenerator.all.GenerateNext (isNewlyRealized, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure PrepareItemContainer
   (
      this : in out ItemContainerGenerator;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.PrepareItemContainer (container.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAll
   (
      this : in out ItemContainerGenerator
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.RemoveAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Remove
   (
      this : in out ItemContainerGenerator;
      position : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition;
      count : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.Remove (position, count);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GeneratorPositionFromIndex
   (
      this : in out ItemContainerGenerator;
      itemIndex : WinUI3.Int32
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition;
   begin
      Hr := this.m_IItemContainerGenerator.all.GeneratorPositionFromIndex (itemIndex, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IndexFromGeneratorPosition
   (
      this : in out ItemContainerGenerator;
      position : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemContainerGenerator.all.IndexFromGeneratorPosition (position, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Recycle
   (
      this : in out ItemContainerGenerator;
      position : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition;
      count : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.Recycle (position, count);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsPanelTemplate

   procedure Initialize (this : in out ItemsPanelTemplate) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsPanelTemplate) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsPanelTemplate, IItemsPanelTemplate_Ptr);
   begin
      if this.m_IItemsPanelTemplate /= null then
         if this.m_IItemsPanelTemplate.all /= null then
            temp := this.m_IItemsPanelTemplate.all.Release;
            Free (this.m_IItemsPanelTemplate);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsPanelTemplate

   function Constructor return ItemsPanelTemplate is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemsPanelTemplate");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsPanelTemplate;
   begin
      return RetVal : ItemsPanelTemplate do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemsPanelTemplate := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsPanelTemplate;
            Retval.m_IItemsPanelTemplate.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsPanelTemplate

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsPickedEventArgs

   procedure Initialize (this : in out ItemsPickedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsPickedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsPickedEventArgs, IItemsPickedEventArgs_Ptr);
   begin
      if this.m_IItemsPickedEventArgs /= null then
         if this.m_IItemsPickedEventArgs.all /= null then
            temp := this.m_IItemsPickedEventArgs.all.Release;
            Free (this.m_IItemsPickedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsPickedEventArgs

   function Constructor return ItemsPickedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemsPickedEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsPickedEventArgs;
   begin
      return RetVal : ItemsPickedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemsPickedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsPickedEventArgs;
            Retval.m_IItemsPickedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsPickedEventArgs

   function get_AddedItems
   (
      this : in out ItemsPickedEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IItemsPickedEventArgs.all.get_AddedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_RemovedItems
   (
      this : in out ItemsPickedEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IItemsPickedEventArgs.all.get_RemovedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsPresenter

   procedure Initialize (this : in out ItemsPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsPresenter, IItemsPresenter_Ptr);
   begin
      if this.m_IItemsPresenter /= null then
         if this.m_IItemsPresenter.all /= null then
            temp := this.m_IItemsPresenter.all.Release;
            Free (this.m_IItemsPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsPresenter

   function Constructor return ItemsPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemsPresenter");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenter;
   begin
      return RetVal : ItemsPresenter do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemsPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenter;
            Retval.m_IItemsPresenter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ItemsPresenter

   function get_HeaderProperty_ItemsPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_ItemsPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTransitionsProperty_ItemsPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterProperty_ItemsPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterTemplateProperty_ItemsPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterTransitionsProperty_ItemsPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_ItemsPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsPresenter

   function get_Header
   (
      this : in out ItemsPresenter
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemsPresenter.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out ItemsPresenter;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsPresenter.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IItemsPresenter.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out ItemsPresenter;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsPresenter.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTransitions
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IItemsPresenter.all.get_HeaderTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTransitions
   (
      this : in out ItemsPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsPresenter.all.put_HeaderTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Footer
   (
      this : in out ItemsPresenter
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemsPresenter.all.get_Footer (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Footer
   (
      this : in out ItemsPresenter;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsPresenter.all.put_Footer (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FooterTemplate
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IItemsPresenter.all.get_FooterTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_FooterTemplate
   (
      this : in out ItemsPresenter;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsPresenter.all.put_FooterTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FooterTransitions
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IItemsPresenter.all.get_FooterTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_FooterTransitions
   (
      this : in out ItemsPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsPresenter.all.put_FooterTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IItemsPresenter.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out ItemsPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsPresenter.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AreHorizontalSnapPointsRegular
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.get_AreHorizontalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreVerticalSnapPointsRegular
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.get_AreVerticalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HorizontalSnapPointsChanged
   (
      this : in out ItemsPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.add_HorizontalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HorizontalSnapPointsChanged
   (
      this : in out ItemsPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.remove_HorizontalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_VerticalSnapPointsChanged
   (
      this : in out ItemsPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.add_VerticalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VerticalSnapPointsChanged
   (
      this : in out ItemsPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.remove_VerticalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetIrregularSnapPoints
   (
      this : in out ItemsPresenter;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   )
   return IVectorView_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_Single.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.GetIrregularSnapPoints (orientation, alignment, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetRegularSnapPoints
   (
      this : in out ItemsPresenter;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
      offset : WinUI3.Single_Ptr
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.GetRegularSnapPoints (orientation, alignment, offset, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsRepeater

   procedure Initialize (this : in out ItemsRepeater) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsRepeater) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsRepeater, IItemsRepeater_Ptr);
   begin
      if this.m_IItemsRepeater /= null then
         if this.m_IItemsRepeater.all /= null then
            temp := this.m_IItemsRepeater.all.Release;
            Free (this.m_IItemsRepeater);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsRepeater

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ItemsRepeater is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemsRepeater");
      m_Factory    : access IItemsRepeaterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeater;
   begin
      return RetVal : ItemsRepeater do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsRepeaterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IItemsRepeater := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeater;
            Retval.m_IItemsRepeater.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ItemsRepeater

   function get_ItemTransitionProviderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsRepeater");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeaterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsRepeaterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTransitionProviderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsSourceProperty_ItemsRepeater
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsRepeater");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeaterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsRepeaterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty_ItemsRepeater
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsRepeater");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeaterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsRepeaterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LayoutProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsRepeater");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeaterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsRepeaterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LayoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalCacheLengthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsRepeater");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeaterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsRepeaterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalCacheLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalCacheLengthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsRepeater");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeaterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsRepeaterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalCacheLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundProperty_ItemsRepeater
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsRepeater");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeaterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsRepeaterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsRepeater

   function get_ItemsSource
   (
      this : in out ItemsRepeater
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemsRepeater.all.get_ItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out ItemsRepeater;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeater.all.put_ItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsSourceView
   (
      this : in out ItemsRepeater
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemsSourceView'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsSourceView;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemsSourceView do
         Hr := this.m_IItemsRepeater.all.get_ItemsSourceView (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemsSourceView := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsSourceView;
         Retval.m_IItemsSourceView.all := m_ComRetVal;
      end return;
   end;

   function get_ItemTemplate
   (
      this : in out ItemsRepeater
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemsRepeater.all.get_ItemTemplate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemTemplate
   (
      this : in out ItemsRepeater;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeater.all.put_ItemTemplate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Layout
   (
      this : in out ItemsRepeater
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Layout'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ILayout;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Layout do
         Hr := this.m_IItemsRepeater.all.get_Layout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ILayout := new WinUI3.Microsoft.UI.Xaml.Controls.ILayout;
         Retval.m_ILayout.all := m_ComRetVal;
      end return;
   end;

   procedure put_Layout
   (
      this : in out ItemsRepeater;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Layout'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeater.all.put_Layout (value.m_ILayout.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalCacheLength
   (
      this : in out ItemsRepeater
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsRepeater.all.get_HorizontalCacheLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalCacheLength
   (
      this : in out ItemsRepeater;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeater.all.put_HorizontalCacheLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalCacheLength
   (
      this : in out ItemsRepeater
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsRepeater.all.get_VerticalCacheLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalCacheLength
   (
      this : in out ItemsRepeater;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeater.all.put_VerticalCacheLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Background
   (
      this : in out ItemsRepeater
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IItemsRepeater.all.get_Background (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out ItemsRepeater;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeater.all.put_Background (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetElementIndex
   (
      this : in out ItemsRepeater;
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsRepeater.all.GetElementIndex (element.m_IUIElement.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryGetElement
   (
      this : in out ItemsRepeater;
      index : WinUI3.Int32
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IItemsRepeater.all.TryGetElement (index, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function GetOrCreateElement
   (
      this : in out ItemsRepeater;
      index : WinUI3.Int32
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IItemsRepeater.all.GetOrCreateElement (index, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function add_ElementPrepared
   (
      this : in out ItemsRepeater;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IItemsRepeater.all.add_ElementPrepared (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ElementPrepared
   (
      this : in out ItemsRepeater;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeater.all.remove_ElementPrepared (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ElementClearing
   (
      this : in out ItemsRepeater;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IItemsRepeater.all.add_ElementClearing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ElementClearing
   (
      this : in out ItemsRepeater;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeater.all.remove_ElementClearing (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ElementIndexChanged
   (
      this : in out ItemsRepeater;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IItemsRepeater.all.add_ElementIndexChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ElementIndexChanged
   (
      this : in out ItemsRepeater;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeater.all.remove_ElementIndexChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTransitionProvider
   (
      this : in out ItemsRepeater
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionProvider'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeater2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProvider;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeater_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeater2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsRepeater2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionProvider do
         m_Interface := QInterface (this.m_IItemsRepeater.all);
         Hr := m_Interface.get_ItemTransitionProvider (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemCollectionTransitionProvider := new WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProvider;
         Retval.m_IItemCollectionTransitionProvider.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTransitionProvider
   (
      this : in out ItemsRepeater;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionProvider'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeater2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeater_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeater2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IItemsRepeater2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsRepeater.all);
      Hr := m_Interface.put_ItemTransitionProvider (value.m_IItemCollectionTransitionProvider.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsRepeaterElementClearingEventArgs

   procedure Initialize (this : in out ItemsRepeaterElementClearingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsRepeaterElementClearingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsRepeaterElementClearingEventArgs, IItemsRepeaterElementClearingEventArgs_Ptr);
   begin
      if this.m_IItemsRepeaterElementClearingEventArgs /= null then
         if this.m_IItemsRepeaterElementClearingEventArgs.all /= null then
            temp := this.m_IItemsRepeaterElementClearingEventArgs.all.Release;
            Free (this.m_IItemsRepeaterElementClearingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsRepeaterElementClearingEventArgs

   function get_Element
   (
      this : in out ItemsRepeaterElementClearingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IItemsRepeaterElementClearingEventArgs.all.get_Element (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsRepeaterElementIndexChangedEventArgs

   procedure Initialize (this : in out ItemsRepeaterElementIndexChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsRepeaterElementIndexChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsRepeaterElementIndexChangedEventArgs, IItemsRepeaterElementIndexChangedEventArgs_Ptr);
   begin
      if this.m_IItemsRepeaterElementIndexChangedEventArgs /= null then
         if this.m_IItemsRepeaterElementIndexChangedEventArgs.all /= null then
            temp := this.m_IItemsRepeaterElementIndexChangedEventArgs.all.Release;
            Free (this.m_IItemsRepeaterElementIndexChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsRepeaterElementIndexChangedEventArgs

   function get_Element
   (
      this : in out ItemsRepeaterElementIndexChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IItemsRepeaterElementIndexChangedEventArgs.all.get_Element (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_OldIndex
   (
      this : in out ItemsRepeaterElementIndexChangedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsRepeaterElementIndexChangedEventArgs.all.get_OldIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewIndex
   (
      this : in out ItemsRepeaterElementIndexChangedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsRepeaterElementIndexChangedEventArgs.all.get_NewIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsRepeaterElementPreparedEventArgs

   procedure Initialize (this : in out ItemsRepeaterElementPreparedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsRepeaterElementPreparedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsRepeaterElementPreparedEventArgs, IItemsRepeaterElementPreparedEventArgs_Ptr);
   begin
      if this.m_IItemsRepeaterElementPreparedEventArgs /= null then
         if this.m_IItemsRepeaterElementPreparedEventArgs.all /= null then
            temp := this.m_IItemsRepeaterElementPreparedEventArgs.all.Release;
            Free (this.m_IItemsRepeaterElementPreparedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsRepeaterElementPreparedEventArgs

   function get_Element
   (
      this : in out ItemsRepeaterElementPreparedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IItemsRepeaterElementPreparedEventArgs.all.get_Element (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_Index
   (
      this : in out ItemsRepeaterElementPreparedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsRepeaterElementPreparedEventArgs.all.get_Index (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsRepeaterScrollHost

   procedure Initialize (this : in out ItemsRepeaterScrollHost) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsRepeaterScrollHost) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsRepeaterScrollHost, IItemsRepeaterScrollHost_Ptr);
   begin
      if this.m_IItemsRepeaterScrollHost /= null then
         if this.m_IItemsRepeaterScrollHost.all /= null then
            temp := this.m_IItemsRepeaterScrollHost.all.Release;
            Free (this.m_IItemsRepeaterScrollHost);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsRepeaterScrollHost

   function Constructor return ItemsRepeaterScrollHost is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemsRepeaterScrollHost");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeaterScrollHost;
   begin
      return RetVal : ItemsRepeaterScrollHost do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemsRepeaterScrollHost := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsRepeaterScrollHost;
            Retval.m_IItemsRepeaterScrollHost.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsRepeaterScrollHost

   function get_ScrollViewer
   (
      this : in out ItemsRepeaterScrollHost
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollViewer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ScrollViewer do
         Hr := this.m_IItemsRepeaterScrollHost.all.get_ScrollViewer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScrollViewer := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewer;
         Retval.m_IScrollViewer.all := m_ComRetVal;
      end return;
   end;

   procedure put_ScrollViewer
   (
      this : in out ItemsRepeaterScrollHost;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollViewer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeaterScrollHost.all.put_ScrollViewer (value.m_IScrollViewer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CurrentAnchor
   (
      this : in out ItemsRepeaterScrollHost
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IItemsRepeaterScrollHost.all.get_CurrentAnchor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_HorizontalAnchorRatio
   (
      this : in out ItemsRepeaterScrollHost
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsRepeaterScrollHost.all.get_HorizontalAnchorRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalAnchorRatio
   (
      this : in out ItemsRepeaterScrollHost;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeaterScrollHost.all.put_HorizontalAnchorRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalAnchorRatio
   (
      this : in out ItemsRepeaterScrollHost
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsRepeaterScrollHost.all.get_VerticalAnchorRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalAnchorRatio
   (
      this : in out ItemsRepeaterScrollHost;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsRepeaterScrollHost.all.put_VerticalAnchorRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsSourceView

   procedure Initialize (this : in out ItemsSourceView) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsSourceView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsSourceView, IItemsSourceView_Ptr);
   begin
      if this.m_IItemsSourceView /= null then
         if this.m_IItemsSourceView.all /= null then
            temp := this.m_IItemsSourceView.all.Release;
            Free (this.m_IItemsSourceView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsSourceView

   function Constructor
   (
      source : WinUI3.IInspectable;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ItemsSourceView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemsSourceView");
      m_Factory    : access IItemsSourceViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsSourceView;
   begin
      return RetVal : ItemsSourceView do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsSourceViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (source, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IItemsSourceView := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsSourceView;
            Retval.m_IItemsSourceView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsSourceView

   function get_Count
   (
      this : in out ItemsSourceView
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsSourceView.all.get_Count (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetAt
   (
      this : in out ItemsSourceView;
      index : WinUI3.Int32
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemsSourceView.all.GetAt (index, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HasKeyIndexMapping
   (
      this : in out ItemsSourceView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IItemsSourceView.all.get_HasKeyIndexMapping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function KeyFromIndex
   (
      this : in out ItemsSourceView;
      index : WinUI3.Int32
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IItemsSourceView.all.KeyFromIndex (index, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function IndexFromKey
   (
      this : in out ItemsSourceView;
      key : WinUI3.WString
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      HStr_key : constant WinUI3.HString := To_HString (key);
   begin
      Hr := this.m_IItemsSourceView.all.IndexFromKey (HStr_key, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
      return m_ComRetVal;
   end;

   function IndexOf
   (
      this : in out ItemsSourceView;
      item : WinUI3.IInspectable
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsSourceView.all.IndexOf (item, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_CollectionChanged
   (
      this : in out ItemsSourceView;
      handler : WinUI3.Microsoft.UI.Xaml.Interop.NotifyCollectionChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Interop.INotifyCollectionChanged := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsSourceView_Interface, WinUI3.Microsoft.UI.Xaml.Interop.INotifyCollectionChanged, WinUI3.Microsoft.UI.Xaml.Interop.IID_INotifyCollectionChanged'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsSourceView.all);
      Hr := m_Interface.add_CollectionChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CollectionChanged
   (
      this : in out ItemsSourceView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Interop.INotifyCollectionChanged := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IItemsSourceView_Interface, WinUI3.Microsoft.UI.Xaml.Interop.INotifyCollectionChanged, WinUI3.Microsoft.UI.Xaml.Interop.IID_INotifyCollectionChanged'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsSourceView.all);
      Hr := m_Interface.remove_CollectionChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsStackPanel

   procedure Initialize (this : in out ItemsStackPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsStackPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsStackPanel, IItemsStackPanel_Ptr);
   begin
      if this.m_IItemsStackPanel /= null then
         if this.m_IItemsStackPanel.all /= null then
            temp := this.m_IItemsStackPanel.all.Release;
            Free (this.m_IItemsStackPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsStackPanel

   function Constructor return ItemsStackPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemsStackPanel");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsStackPanel;
   begin
      return RetVal : ItemsStackPanel do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemsStackPanel := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsStackPanel;
            Retval.m_IItemsStackPanel.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ItemsStackPanel

   function get_GroupPaddingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupPaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_ItemsStackPanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GroupHeaderPlacementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupHeaderPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CacheLengthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CacheLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AreStickyGroupHeadersEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreStickyGroupHeadersEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsStackPanel

   function get_GroupPadding
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IItemsStackPanel.all.get_GroupPadding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GroupPadding
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsStackPanel.all.put_GroupPadding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IItemsStackPanel.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsStackPanel.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstCacheIndex
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsStackPanel.all.get_FirstCacheIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_FirstVisibleIndex
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsStackPanel.all.get_FirstVisibleIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LastVisibleIndex
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsStackPanel.all.get_LastVisibleIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LastCacheIndex
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsStackPanel.all.get_LastCacheIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollingDirection
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PanelScrollingDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.PanelScrollingDirection;
   begin
      Hr := this.m_IItemsStackPanel.all.get_ScrollingDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_GroupHeaderPlacement
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GroupHeaderPlacement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GroupHeaderPlacement;
   begin
      Hr := this.m_IItemsStackPanel.all.get_GroupHeaderPlacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GroupHeaderPlacement
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GroupHeaderPlacement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsStackPanel.all.put_GroupHeaderPlacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsUpdatingScrollMode
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemsUpdatingScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ItemsUpdatingScrollMode;
   begin
      Hr := this.m_IItemsStackPanel.all.get_ItemsUpdatingScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsUpdatingScrollMode
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ItemsUpdatingScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsStackPanel.all.put_ItemsUpdatingScrollMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CacheLength
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsStackPanel.all.get_CacheLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CacheLength
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsStackPanel.all.put_CacheLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AreStickyGroupHeadersEnabled
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IItemsStackPanel.all.get_AreStickyGroupHeadersEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreStickyGroupHeadersEnabled
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsStackPanel.all.put_AreStickyGroupHeadersEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsView

   procedure Initialize (this : in out ItemsView) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsView, IItemsView_Ptr);
   begin
      if this.m_IItemsView /= null then
         if this.m_IItemsView.all /= null then
            temp := this.m_IItemsView.all.Release;
            Free (this.m_IItemsView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ItemsView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemsView");
      m_Factory    : access IItemsViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsView;
   begin
      return RetVal : ItemsView do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IItemsView := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsView;
            Retval.m_IItemsView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ItemsView

   function get_IsItemInvokedEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsItemInvokedEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsSourceProperty_ItemsView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty_ItemsView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LayoutProperty_ItemsView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LayoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionModeProperty_ItemsView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTransitionProviderProperty_ItemsView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTransitionProviderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CurrentItemIndexProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CurrentItemIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScrollViewProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScrollViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalScrollControllerProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollControllerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsView

   function get_ItemsSource
   (
      this : in out ItemsView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemsView.all.get_ItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out ItemsView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.put_ItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScrollView
   (
      this : in out ItemsView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollView'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollView;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ScrollView do
         Hr := this.m_IItemsView.all.get_ScrollView (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScrollView := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollView;
         Retval.m_IScrollView.all := m_ComRetVal;
      end return;
   end;

   function get_VerticalScrollController
   (
      this : in out ItemsView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollController is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollController;
   begin
      Hr := this.m_IItemsView.all.get_VerticalScrollController (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollController
   (
      this : in out ItemsView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollController
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.put_VerticalScrollController (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTemplate
   (
      this : in out ItemsView
   )
   return WinUI3.Microsoft.UI.Xaml.IElementFactory is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IElementFactory;
   begin
      Hr := this.m_IItemsView.all.get_ItemTemplate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemTemplate
   (
      this : in out ItemsView;
      value : WinUI3.Microsoft.UI.Xaml.IElementFactory
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.put_ItemTemplate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Layout
   (
      this : in out ItemsView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Layout'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ILayout;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Layout do
         Hr := this.m_IItemsView.all.get_Layout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ILayout := new WinUI3.Microsoft.UI.Xaml.Controls.ILayout;
         Retval.m_ILayout.all := m_ComRetVal;
      end return;
   end;

   procedure put_Layout
   (
      this : in out ItemsView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Layout'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.put_Layout (value.m_ILayout.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsItemInvokedEnabled
   (
      this : in out ItemsView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IItemsView.all.get_IsItemInvokedEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsItemInvokedEnabled
   (
      this : in out ItemsView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.put_IsItemInvokedEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionMode
   (
      this : in out ItemsView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemsViewSelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ItemsViewSelectionMode;
   begin
      Hr := this.m_IItemsView.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionMode
   (
      this : in out ItemsView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ItemsViewSelectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.put_SelectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTransitionProvider
   (
      this : in out ItemsView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionProvider'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProvider;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionProvider do
         Hr := this.m_IItemsView.all.get_ItemTransitionProvider (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemCollectionTransitionProvider := new WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProvider;
         Retval.m_IItemCollectionTransitionProvider.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTransitionProvider
   (
      this : in out ItemsView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionProvider'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.put_ItemTransitionProvider (value.m_IItemCollectionTransitionProvider.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CurrentItemIndex
   (
      this : in out ItemsView
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsView.all.get_CurrentItemIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectedItem
   (
      this : in out ItemsView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemsView.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectedItems
   (
      this : in out ItemsView
   )
   return IVectorView_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IInspectable.Kind;
   begin
      Hr := this.m_IItemsView.all.get_SelectedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function TryGetItemIndex
   (
      this : in out ItemsView;
      horizontalViewportRatio : WinUI3.Double;
      verticalViewportRatio : WinUI3.Double;
      index : WinUI3.Int32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IItemsView.all.TryGetItemIndex (horizontalViewportRatio, verticalViewportRatio, index, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure StartBringItemIntoView
   (
      this : in out ItemsView;
      index : WinUI3.Int32;
      options : WinUI3.Microsoft.UI.Xaml.BringIntoViewOptions'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.StartBringItemIntoView (index, options.m_IBringIntoViewOptions.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Select_x
   (
      this : in out ItemsView;
      itemIndex : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.Select_x (itemIndex);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Deselect
   (
      this : in out ItemsView;
      itemIndex : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.Deselect (itemIndex);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function IsSelected
   (
      this : in out ItemsView;
      itemIndex : WinUI3.Int32
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IItemsView.all.IsSelected (itemIndex, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SelectAll
   (
      this : in out ItemsView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure DeselectAll
   (
      this : in out ItemsView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.DeselectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InvertSelection
   (
      this : in out ItemsView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.InvertSelection;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ItemInvoked
   (
      this : in out ItemsView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IItemsView.all.add_ItemInvoked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemInvoked
   (
      this : in out ItemsView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.remove_ItemInvoked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out ItemsView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IItemsView.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out ItemsView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsView.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsViewItemInvokedEventArgs

   procedure Initialize (this : in out ItemsViewItemInvokedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsViewItemInvokedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsViewItemInvokedEventArgs, IItemsViewItemInvokedEventArgs_Ptr);
   begin
      if this.m_IItemsViewItemInvokedEventArgs /= null then
         if this.m_IItemsViewItemInvokedEventArgs.all /= null then
            temp := this.m_IItemsViewItemInvokedEventArgs.all.Release;
            Free (this.m_IItemsViewItemInvokedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsViewItemInvokedEventArgs

   function get_InvokedItem
   (
      this : in out ItemsViewItemInvokedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemsViewItemInvokedEventArgs.all.get_InvokedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsViewSelectionChangedEventArgs

   procedure Initialize (this : in out ItemsViewSelectionChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsViewSelectionChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsViewSelectionChangedEventArgs, IItemsViewSelectionChangedEventArgs_Ptr);
   begin
      if this.m_IItemsViewSelectionChangedEventArgs /= null then
         if this.m_IItemsViewSelectionChangedEventArgs.all /= null then
            temp := this.m_IItemsViewSelectionChangedEventArgs.all.Release;
            Free (this.m_IItemsViewSelectionChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsViewSelectionChangedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsWrapGrid

   procedure Initialize (this : in out ItemsWrapGrid) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsWrapGrid) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsWrapGrid, IItemsWrapGrid_Ptr);
   begin
      if this.m_IItemsWrapGrid /= null then
         if this.m_IItemsWrapGrid.all /= null then
            temp := this.m_IItemsWrapGrid.all.Release;
            Free (this.m_IItemsWrapGrid);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsWrapGrid

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ItemsWrapGrid is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IItemsWrapGrid");
      m_Factory    : access IItemsWrapGridFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemsWrapGrid;
   begin
      return RetVal : ItemsWrapGrid do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IItemsWrapGrid := new WinUI3.Microsoft.UI.Xaml.Controls.IItemsWrapGrid;
            Retval.m_IItemsWrapGrid.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ItemsWrapGrid

   function get_GroupPaddingProperty_ItemsWrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupPaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_ItemsWrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaximumRowsOrColumnsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaximumRowsOrColumnsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GroupHeaderPlacementProperty_ItemsWrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupHeaderPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CacheLengthProperty_ItemsWrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CacheLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AreStickyGroupHeadersEnabledProperty_ItemsWrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreStickyGroupHeadersEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsWrapGrid

   function get_GroupPadding
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_GroupPadding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GroupPadding
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_GroupPadding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaximumRowsOrColumns
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_MaximumRowsOrColumns (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaximumRowsOrColumns
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_MaximumRowsOrColumns (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemWidth
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_ItemWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemWidth
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_ItemWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemHeight
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_ItemHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemHeight
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_ItemHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstCacheIndex
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_FirstCacheIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_FirstVisibleIndex
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_FirstVisibleIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LastVisibleIndex
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_LastVisibleIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LastCacheIndex
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_LastCacheIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollingDirection
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PanelScrollingDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.PanelScrollingDirection;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_ScrollingDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_GroupHeaderPlacement
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GroupHeaderPlacement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GroupHeaderPlacement;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_GroupHeaderPlacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GroupHeaderPlacement
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GroupHeaderPlacement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_GroupHeaderPlacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CacheLength
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_CacheLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CacheLength
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_CacheLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AreStickyGroupHeadersEnabled
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_AreStickyGroupHeadersEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreStickyGroupHeadersEnabled
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_AreStickyGroupHeadersEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Layout

   procedure Initialize (this : in out Layout) is
   begin
      null;
   end;

   procedure Finalize (this : in out Layout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILayout, ILayout_Ptr);
   begin
      if this.m_ILayout /= null then
         if this.m_ILayout.all /= null then
            temp := this.m_ILayout.all.Release;
            Free (this.m_ILayout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Layout

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Layout

   procedure InitializeForContext
   (
      this : in out Layout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.LayoutContext'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILayout.all.InitializeForContext (context.m_ILayoutContext.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure UninitializeForContext
   (
      this : in out Layout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.LayoutContext'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILayout.all.UninitializeForContext (context.m_ILayoutContext.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function Measure
   (
      this : in out Layout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.LayoutContext'Class;
      availableSize : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := this.m_ILayout.all.Measure (context.m_ILayoutContext.all, availableSize, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Arrange
   (
      this : in out Layout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.LayoutContext'Class;
      finalSize : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := this.m_ILayout.all.Arrange (context.m_ILayoutContext.all, finalSize, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_MeasureInvalidated
   (
      this : in out Layout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ILayout.all.add_MeasureInvalidated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MeasureInvalidated
   (
      this : in out Layout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILayout.all.remove_MeasureInvalidated (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ArrangeInvalidated
   (
      this : in out Layout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ILayout.all.add_ArrangeInvalidated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ArrangeInvalidated
   (
      this : in out Layout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILayout.all.remove_ArrangeInvalidated (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IndexBasedLayoutOrientation
   (
      this : in out Layout
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IndexBasedLayoutOrientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ILayout2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IndexBasedLayoutOrientation;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ILayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ILayout2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ILayout2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILayout.all);
      Hr := m_Interface.get_IndexBasedLayoutOrientation (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure InvalidateMeasure
   (
      this : in out Layout
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ILayoutProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ILayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ILayoutProtected, WinUI3.Microsoft.UI.Xaml.Controls.IID_ILayoutProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILayout.all);
      Hr := m_Interface.InvalidateMeasure;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InvalidateArrange
   (
      this : in out Layout
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ILayoutProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ILayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ILayoutProtected, WinUI3.Microsoft.UI.Xaml.Controls.IID_ILayoutProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILayout.all);
      Hr := m_Interface.InvalidateArrange;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetIndexBasedLayoutOrientation
   (
      this : in out Layout;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.IndexBasedLayoutOrientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ILayoutProtected2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ILayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ILayoutProtected2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ILayoutProtected2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILayout.all);
      Hr := m_Interface.SetIndexBasedLayoutOrientation (orientation);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CreateDefaultItemTransitionProvider
   (
      this : in out Layout
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionProvider'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ILayoutOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProvider;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ILayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ILayoutOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_ILayoutOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemCollectionTransitionProvider do
         m_Interface := QInterface (this.m_ILayout.all);
         Hr := m_Interface.CreateDefaultItemTransitionProvider (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemCollectionTransitionProvider := new WinUI3.Microsoft.UI.Xaml.Controls.IItemCollectionTransitionProvider;
         Retval.m_IItemCollectionTransitionProvider.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LayoutContext

   procedure Initialize (this : in out LayoutContext) is
   begin
      null;
   end;

   procedure Finalize (this : in out LayoutContext) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILayoutContext, ILayoutContext_Ptr);
   begin
      if this.m_ILayoutContext /= null then
         if this.m_ILayoutContext.all /= null then
            temp := this.m_ILayoutContext.all.Release;
            Free (this.m_ILayoutContext);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LayoutContext

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LayoutContext

   function get_LayoutState
   (
      this : in out LayoutContext
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ILayoutContext.all.get_LayoutState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LayoutState
   (
      this : in out LayoutContext;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILayoutContext.all.put_LayoutState (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LayoutStateCore
   (
      this : in out LayoutContext
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ILayoutContextOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ILayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ILayoutContextOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_ILayoutContextOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILayoutContext.all);
      Hr := m_Interface.get_LayoutStateCore (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LayoutStateCore
   (
      this : in out LayoutContext;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ILayoutContextOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ILayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ILayoutContextOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_ILayoutContextOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILayoutContext.all);
      Hr := m_Interface.put_LayoutStateCore (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VirtualizingLayout

   procedure Initialize (this : in out VirtualizingLayout) is
   begin
      null;
   end;

   procedure Finalize (this : in out VirtualizingLayout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVirtualizingLayout, IVirtualizingLayout_Ptr);
   begin
      if this.m_IVirtualizingLayout /= null then
         if this.m_IVirtualizingLayout.all /= null then
            temp := this.m_IVirtualizingLayout.all.Release;
            Free (this.m_IVirtualizingLayout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VirtualizingLayout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return VirtualizingLayout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IVirtualizingLayout");
      m_Factory    : access IVirtualizingLayoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayout;
   begin
      return RetVal : VirtualizingLayout do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingLayoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IVirtualizingLayout := new WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayout;
            Retval.m_IVirtualizingLayout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VirtualizingLayout

   procedure InitializeForContextCore
   (
      this : in out VirtualizingLayout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayout.all);
      Hr := m_Interface.InitializeForContextCore (context.m_IVirtualizingLayoutContext.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure UninitializeForContextCore
   (
      this : in out VirtualizingLayout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayout.all);
      Hr := m_Interface.UninitializeForContextCore (context.m_IVirtualizingLayoutContext.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function MeasureOverride
   (
      this : in out VirtualizingLayout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext'Class;
      availableSize : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayout.all);
      Hr := m_Interface.MeasureOverride (context.m_IVirtualizingLayoutContext.all, availableSize, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ArrangeOverride
   (
      this : in out VirtualizingLayout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext'Class;
      finalSize : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayout.all);
      Hr := m_Interface.ArrangeOverride (context.m_IVirtualizingLayoutContext.all, finalSize, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure OnItemsChangedCore
   (
      this : in out VirtualizingLayout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.VirtualizingLayoutContext'Class;
      source : WinUI3.IInspectable;
      args : WinUI3.Microsoft.UI.Xaml.Interop.NotifyCollectionChangedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayout.all);
      Hr := m_Interface.OnItemsChangedCore (context.m_IVirtualizingLayoutContext.all, source, args.m_INotifyCollectionChangedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LinedFlowLayout

   procedure Initialize (this : in out LinedFlowLayout) is
   begin
      null;
   end;

   procedure Finalize (this : in out LinedFlowLayout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILinedFlowLayout, ILinedFlowLayout_Ptr);
   begin
      if this.m_ILinedFlowLayout /= null then
         if this.m_ILinedFlowLayout.all /= null then
            temp := this.m_ILinedFlowLayout.all.Release;
            Free (this.m_ILinedFlowLayout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LinedFlowLayout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return LinedFlowLayout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ILinedFlowLayout");
      m_Factory    : access ILinedFlowLayoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ILinedFlowLayout;
   begin
      return RetVal : LinedFlowLayout do
         Hr := RoGetActivationFactory (m_hString, IID_ILinedFlowLayoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ILinedFlowLayout := new WinUI3.Microsoft.UI.Xaml.Controls.ILinedFlowLayout;
            Retval.m_ILinedFlowLayout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for LinedFlowLayout

   function get_ItemsJustificationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.LinedFlowLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ILinedFlowLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILinedFlowLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsJustificationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsStretchProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.LinedFlowLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ILinedFlowLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILinedFlowLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsStretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinItemSpacingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.LinedFlowLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ILinedFlowLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILinedFlowLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinItemSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineSpacingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.LinedFlowLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ILinedFlowLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILinedFlowLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineHeightProperty_LinedFlowLayout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.LinedFlowLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ILinedFlowLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILinedFlowLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActualLineHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.LinedFlowLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ILinedFlowLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILinedFlowLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActualLineHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LinedFlowLayout

   function add_ItemsInfoRequested
   (
      this : in out LinedFlowLayout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ILinedFlowLayout.all.add_ItemsInfoRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemsInfoRequested
   (
      this : in out LinedFlowLayout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinedFlowLayout.all.remove_ItemsInfoRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ItemsUnlocked
   (
      this : in out LinedFlowLayout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ILinedFlowLayout.all.add_ItemsUnlocked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemsUnlocked
   (
      this : in out LinedFlowLayout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinedFlowLayout.all.remove_ItemsUnlocked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsJustification
   (
      this : in out LinedFlowLayout
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.LinedFlowLayoutItemsJustification is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.LinedFlowLayoutItemsJustification;
   begin
      Hr := this.m_ILinedFlowLayout.all.get_ItemsJustification (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsJustification
   (
      this : in out LinedFlowLayout;
      value : WinUI3.Microsoft.UI.Xaml.Controls.LinedFlowLayoutItemsJustification
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinedFlowLayout.all.put_ItemsJustification (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsStretch
   (
      this : in out LinedFlowLayout
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.LinedFlowLayoutItemsStretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.LinedFlowLayoutItemsStretch;
   begin
      Hr := this.m_ILinedFlowLayout.all.get_ItemsStretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsStretch
   (
      this : in out LinedFlowLayout;
      value : WinUI3.Microsoft.UI.Xaml.Controls.LinedFlowLayoutItemsStretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinedFlowLayout.all.put_ItemsStretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinItemSpacing
   (
      this : in out LinedFlowLayout
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ILinedFlowLayout.all.get_MinItemSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinItemSpacing
   (
      this : in out LinedFlowLayout;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinedFlowLayout.all.put_MinItemSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineSpacing
   (
      this : in out LinedFlowLayout
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ILinedFlowLayout.all.get_LineSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineSpacing
   (
      this : in out LinedFlowLayout;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinedFlowLayout.all.put_LineSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineHeight
   (
      this : in out LinedFlowLayout
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ILinedFlowLayout.all.get_LineHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineHeight
   (
      this : in out LinedFlowLayout;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinedFlowLayout.all.put_LineHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActualLineHeight
   (
      this : in out LinedFlowLayout
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ILinedFlowLayout.all.get_ActualLineHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_RequestedRangeStartIndex
   (
      this : in out LinedFlowLayout
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ILinedFlowLayout.all.get_RequestedRangeStartIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_RequestedRangeLength
   (
      this : in out LinedFlowLayout
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ILinedFlowLayout.all.get_RequestedRangeLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure InvalidateItemsInfo
   (
      this : in out LinedFlowLayout
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinedFlowLayout.all.InvalidateItemsInfo;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function LockItemToLine
   (
      this : in out LinedFlowLayout;
      itemIndex : WinUI3.Int32
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ILinedFlowLayout.all.LockItemToLine (itemIndex, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LinedFlowLayoutItemCollectionTransitionProvider

   procedure Initialize (this : in out LinedFlowLayoutItemCollectionTransitionProvider) is
   begin
      null;
   end;

   procedure Finalize (this : in out LinedFlowLayoutItemCollectionTransitionProvider) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILinedFlowLayoutItemCollectionTransitionProvider, ILinedFlowLayoutItemCollectionTransitionProvider_Ptr);
   begin
      if this.m_ILinedFlowLayoutItemCollectionTransitionProvider /= null then
         if this.m_ILinedFlowLayoutItemCollectionTransitionProvider.all /= null then
            temp := this.m_ILinedFlowLayoutItemCollectionTransitionProvider.all.Release;
            Free (this.m_ILinedFlowLayoutItemCollectionTransitionProvider);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LinedFlowLayoutItemCollectionTransitionProvider

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return LinedFlowLayoutItemCollectionTransitionProvider is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ILinedFlowLayoutItemCollectionTransitionProvider");
      m_Factory    : access ILinedFlowLayoutItemCollectionTransitionProviderFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ILinedFlowLayoutItemCollectionTransitionProvider;
   begin
      return RetVal : LinedFlowLayoutItemCollectionTransitionProvider do
         Hr := RoGetActivationFactory (m_hString, IID_ILinedFlowLayoutItemCollectionTransitionProviderFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ILinedFlowLayoutItemCollectionTransitionProvider := new WinUI3.Microsoft.UI.Xaml.Controls.ILinedFlowLayoutItemCollectionTransitionProvider;
            Retval.m_ILinedFlowLayoutItemCollectionTransitionProvider.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LinedFlowLayoutItemCollectionTransitionProvider

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LinedFlowLayoutItemsInfoRequestedEventArgs

   procedure Initialize (this : in out LinedFlowLayoutItemsInfoRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out LinedFlowLayoutItemsInfoRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILinedFlowLayoutItemsInfoRequestedEventArgs, ILinedFlowLayoutItemsInfoRequestedEventArgs_Ptr);
   begin
      if this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs /= null then
         if this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all /= null then
            temp := this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all.Release;
            Free (this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LinedFlowLayoutItemsInfoRequestedEventArgs

   function get_ItemsRangeStartIndex
   (
      this : in out LinedFlowLayoutItemsInfoRequestedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all.get_ItemsRangeStartIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsRangeStartIndex
   (
      this : in out LinedFlowLayoutItemsInfoRequestedEventArgs;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all.put_ItemsRangeStartIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsRangeRequestedLength
   (
      this : in out LinedFlowLayoutItemsInfoRequestedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all.get_ItemsRangeRequestedLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MinWidth
   (
      this : in out LinedFlowLayoutItemsInfoRequestedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all.get_MinWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinWidth
   (
      this : in out LinedFlowLayoutItemsInfoRequestedEventArgs;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all.put_MinWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxWidth
   (
      this : in out LinedFlowLayoutItemsInfoRequestedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all.get_MaxWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxWidth
   (
      this : in out LinedFlowLayoutItemsInfoRequestedEventArgs;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all.put_MaxWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetDesiredAspectRatios
   (
      this : in out LinedFlowLayoutItemsInfoRequestedEventArgs;
      values : WinUI3.Double_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      function Convert_values is new Ada.Unchecked_Conversion (Address, WinUI3.Double_Ptr);
   begin
      Hr := this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all.SetDesiredAspectRatios (WinUI3.UInt32(values'Length), Convert_values (values (values'First)'Address));
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetMinWidths
   (
      this : in out LinedFlowLayoutItemsInfoRequestedEventArgs;
      values : WinUI3.Double_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      function Convert_values is new Ada.Unchecked_Conversion (Address, WinUI3.Double_Ptr);
   begin
      Hr := this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all.SetMinWidths (WinUI3.UInt32(values'Length), Convert_values (values (values'First)'Address));
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetMaxWidths
   (
      this : in out LinedFlowLayoutItemsInfoRequestedEventArgs;
      values : WinUI3.Double_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      function Convert_values is new Ada.Unchecked_Conversion (Address, WinUI3.Double_Ptr);
   begin
      Hr := this.m_ILinedFlowLayoutItemsInfoRequestedEventArgs.all.SetMaxWidths (WinUI3.UInt32(values'Length), Convert_values (values (values'First)'Address));
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListBox

   procedure Initialize (this : in out ListBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListBox, IListBox_Ptr);
   begin
      if this.m_IListBox /= null then
         if this.m_IListBox.all /= null then
            temp := this.m_IListBox.all.Release;
            Free (this.m_IListBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IListBox");
      m_Factory    : access IListBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IListBox;
   begin
      return RetVal : ListBox do
         Hr := RoGetActivationFactory (m_hString, IID_IListBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListBox := new WinUI3.Microsoft.UI.Xaml.Controls.IListBox;
            Retval.m_IListBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ListBox

   function get_SelectionModeProperty_ListBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SingleSelectionFollowsFocusProperty_ListBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SingleSelectionFollowsFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListBox

   function get_SelectedItems
   (
      this : in out ListBox
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IListBox.all.get_SelectedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SelectionMode
   (
      this : in out ListBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.SelectionMode;
   begin
      Hr := this.m_IListBox.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionMode
   (
      this : in out ListBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SelectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListBox.all.put_SelectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SingleSelectionFollowsFocus
   (
      this : in out ListBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListBox.all.get_SingleSelectionFollowsFocus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SingleSelectionFollowsFocus
   (
      this : in out ListBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListBox.all.put_SingleSelectionFollowsFocus (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollIntoView
   (
      this : in out ListBox;
      item : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListBox.all.ScrollIntoView (item);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out ListBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListBox.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListBoxItem

   procedure Initialize (this : in out ListBoxItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListBoxItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListBoxItem, IListBoxItem_Ptr);
   begin
      if this.m_IListBoxItem /= null then
         if this.m_IListBoxItem.all /= null then
            temp := this.m_IListBoxItem.all.Release;
            Free (this.m_IListBoxItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListBoxItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListBoxItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IListBoxItem");
      m_Factory    : access IListBoxItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IListBoxItem;
   begin
      return RetVal : ListBoxItem do
         Hr := RoGetActivationFactory (m_hString, IID_IListBoxItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListBoxItem := new WinUI3.Microsoft.UI.Xaml.Controls.IListBoxItem;
            Retval.m_IListBoxItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListBoxItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListPickerFlyout

   procedure Initialize (this : in out ListPickerFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListPickerFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListPickerFlyout, IListPickerFlyout_Ptr);
   begin
      if this.m_IListPickerFlyout /= null then
         if this.m_IListPickerFlyout.all /= null then
            temp := this.m_IListPickerFlyout.all.Release;
            Free (this.m_IListPickerFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListPickerFlyout

   function Constructor return ListPickerFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IListPickerFlyout");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IListPickerFlyout;
   begin
      return RetVal : ListPickerFlyout do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IListPickerFlyout := new WinUI3.Microsoft.UI.Xaml.Controls.IListPickerFlyout;
            Retval.m_IListPickerFlyout.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ListPickerFlyout

   function get_ItemsSourceProperty_ListPickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty_ListPickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayMemberPathProperty_ListPickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayMemberPathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionModeProperty_ListPickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedIndexProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty_ListPickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedValueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedValuePathProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedValuePathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListPickerFlyout

   function get_ItemsSource
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IListPickerFlyout.all.get_ItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out ListPickerFlyout;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_ItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTemplate
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IListPickerFlyout.all.get_ItemTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplate
   (
      this : in out ListPickerFlyout;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_ItemTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMemberPath
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IListPickerFlyout.all.get_DisplayMemberPath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DisplayMemberPath
   (
      this : in out ListPickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IListPickerFlyout.all.put_DisplayMemberPath (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectionMode
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ListPickerFlyoutSelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ListPickerFlyoutSelectionMode;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionMode
   (
      this : in out ListPickerFlyout;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ListPickerFlyoutSelectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_SelectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedIndex
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectedIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedIndex
   (
      this : in out ListPickerFlyout;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_SelectedIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItem
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedItem
   (
      this : in out ListPickerFlyout;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_SelectedItem (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedValue
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectedValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedValue
   (
      this : in out ListPickerFlyout;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_SelectedValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedValuePath
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectedValuePath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SelectedValuePath
   (
      this : in out ListPickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IListPickerFlyout.all.put_SelectedValuePath (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectedItems
   (
      this : in out ListPickerFlyout
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function add_ItemsPicked
   (
      this : in out ListPickerFlyout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IListPickerFlyout.all.add_ItemsPicked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemsPicked
   (
      this : in out ListPickerFlyout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.remove_ItemsPicked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAtAsync
   (
      this : in out ListPickerFlyout;
      target : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.GenericObject;
      m_IID            : aliased WinUI3.IID := (3597783858, 8874, 21911, (141, 204, 36, 89, 234, 180, 148, 24 )); -- GenericObject;
      m_HandlerIID     : aliased WinUI3.IID := (639278465, 62863, 21123, (148, 97, 202, 62, 49, 193, 18, 60 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IListPickerFlyout.all.ShowAtAsync (target.m_IFrameworkElement.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListPickerFlyoutPresenter

   procedure Initialize (this : in out ListPickerFlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListPickerFlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListPickerFlyoutPresenter, IListPickerFlyoutPresenter_Ptr);
   begin
      if this.m_IListPickerFlyoutPresenter /= null then
         if this.m_IListPickerFlyoutPresenter.all /= null then
            temp := this.m_IListPickerFlyoutPresenter.all.Release;
            Free (this.m_IListPickerFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListPickerFlyoutPresenter

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListView

   procedure Initialize (this : in out ListView) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListView, IListView_Ptr);
   begin
      if this.m_IListView /= null then
         if this.m_IListView.all /= null then
            temp := this.m_IListView.all.Release;
            Free (this.m_IListView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IListView");
      m_Factory    : access IListViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IListView;
   begin
      return RetVal : ListView do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListView := new WinUI3.Microsoft.UI.Xaml.Controls.IListView;
            Retval.m_IListView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListView

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewHeaderItem

   procedure Initialize (this : in out ListViewHeaderItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewHeaderItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewHeaderItem, IListViewHeaderItem_Ptr);
   begin
      if this.m_IListViewHeaderItem /= null then
         if this.m_IListViewHeaderItem.all /= null then
            temp := this.m_IListViewHeaderItem.all.Release;
            Free (this.m_IListViewHeaderItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListViewHeaderItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListViewHeaderItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IListViewHeaderItem");
      m_Factory    : access IListViewHeaderItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IListViewHeaderItem;
   begin
      return RetVal : ListViewHeaderItem do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewHeaderItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListViewHeaderItem := new WinUI3.Microsoft.UI.Xaml.Controls.IListViewHeaderItem;
            Retval.m_IListViewHeaderItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewHeaderItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewItem

   procedure Initialize (this : in out ListViewItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewItem, IListViewItem_Ptr);
   begin
      if this.m_IListViewItem /= null then
         if this.m_IListViewItem.all /= null then
            temp := this.m_IListViewItem.all.Release;
            Free (this.m_IListViewItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListViewItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListViewItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IListViewItem");
      m_Factory    : access IListViewItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IListViewItem;
   begin
      return RetVal : ListViewItem do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListViewItem := new WinUI3.Microsoft.UI.Xaml.Controls.IListViewItem;
            Retval.m_IListViewItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewItem

   function get_TemplateSettings
   (
      this : in out ListViewItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ListViewItemTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ListViewItemTemplateSettings do
         Hr := this.m_IListViewItem.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IListViewItemTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemTemplateSettings;
         Retval.m_IListViewItemTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ListViewItemToKeyHandler

   function Invoke
   (
      this : access ListViewItemToKeyHandler_Delegate;
      item : WinUI3.IInspectable
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (item);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ListViewKeyToItemHandler

   function Invoke
   (
      this : access ListViewKeyToItemHandler_Delegate;
      key : WinUI3.HString
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (key);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewPersistenceHelper

   procedure Initialize (this : in out ListViewPersistenceHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewPersistenceHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewPersistenceHelper, IListViewPersistenceHelper_Ptr);
   begin
      if this.m_IListViewPersistenceHelper /= null then
         if this.m_IListViewPersistenceHelper.all /= null then
            temp := this.m_IListViewPersistenceHelper.all.Release;
            Free (this.m_IListViewPersistenceHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ListViewPersistenceHelper

   function GetRelativeScrollPosition
   (
      listViewBase_p : WinUI3.Microsoft.UI.Xaml.Controls.ListViewBase'Class;
      itemToKeyHandler : WinUI3.Microsoft.UI.Xaml.Controls.ListViewItemToKeyHandler
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewPersistenceHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewPersistenceHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IListViewPersistenceHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetRelativeScrollPosition (listViewBase_p.m_IListViewBase.all, itemToKeyHandler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure SetRelativeScrollPositionAsync
   (
      listViewBase_p : WinUI3.Microsoft.UI.Xaml.Controls.ListViewBase'Class;
      relativeScrollPosition : WinUI3.WString;
      keyToItemHandler : WinUI3.Microsoft.UI.Xaml.Controls.ListViewKeyToItemHandler
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ListViewPersistenceHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IListViewPersistenceHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_relativeScrollPosition : constant WinUI3.HString := To_HString (relativeScrollPosition);
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := RoGetActivationFactory (m_hString, IID_IListViewPersistenceHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetRelativeScrollPositionAsync (listViewBase_p.m_IListViewBase.all, HStr_relativeScrollPosition, keyToItemHandler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr = S_OK then
            m_Captured := m_Completed;
            Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            temp := m_ComRetVal.Release;
            temp := m_CompletedHandler.Release;
            if temp = 0 then
               Free (m_CompletedHandler);
            end if;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_relativeScrollPosition);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewPersistenceHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControl

   procedure Initialize (this : in out MapControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControl, IMapControl_Ptr);
   begin
      if this.m_IMapControl /= null then
         if this.m_IMapControl.all /= null then
            temp := this.m_IMapControl.all.Release;
            Free (this.m_IMapControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MapControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMapControl");
      m_Factory    : access IMapControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMapControl;
   begin
      return RetVal : MapControl do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapControl := new WinUI3.Microsoft.UI.Xaml.Controls.IMapControl;
            Retval.m_IMapControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapControl

   function get_LayersProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MapControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMapControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LayersProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MapServiceTokenProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MapControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMapControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MapServiceTokenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CenterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MapControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMapControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomLevelProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MapControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMapControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomLevelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InteractiveControlsVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MapControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMapControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InteractiveControlsVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControl

   function get_MapServiceToken
   (
      this : in out MapControl
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapControl.all.get_MapServiceToken (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_MapServiceToken
   (
      this : in out MapControl;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IMapControl.all.put_MapServiceToken (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Center
   (
      this : in out MapControl
   )
   return WinUI3.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinUI3.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapControl.all.get_Center (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new WinUI3.Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   procedure put_Center
   (
      this : in out MapControl;
      value : WinUI3.Windows.Devices.Geolocation.Geopoint'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_Center (value.m_IGeopoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Layers
   (
      this : in out MapControl
   )
   return IVector_IMapLayer.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IMapLayer.Kind;
   begin
      Hr := this.m_IMapControl.all.get_Layers (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMapLayer (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_Layers
   (
      this : in out MapControl;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_Layers (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomLevel
   (
      this : in out MapControl
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IMapControl.all.get_ZoomLevel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomLevel
   (
      this : in out MapControl;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_ZoomLevel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InteractiveControlsVisible
   (
      this : in out MapControl
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMapControl.all.get_InteractiveControlsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InteractiveControlsVisible
   (
      this : in out MapControl;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_InteractiveControlsVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapElementClick
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControl.all.add_MapElementClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapElementClick
   (
      this : in out MapControl;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.remove_MapElementClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapServiceErrorOccurred
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControl.all.add_MapServiceErrorOccurred (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapServiceErrorOccurred
   (
      this : in out MapControl;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.remove_MapServiceErrorOccurred (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControlMapServiceErrorOccurredEventArgs

   procedure Initialize (this : in out MapControlMapServiceErrorOccurredEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControlMapServiceErrorOccurredEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControlMapServiceErrorOccurredEventArgs, IMapControlMapServiceErrorOccurredEventArgs_Ptr);
   begin
      if this.m_IMapControlMapServiceErrorOccurredEventArgs /= null then
         if this.m_IMapControlMapServiceErrorOccurredEventArgs.all /= null then
            temp := this.m_IMapControlMapServiceErrorOccurredEventArgs.all.Release;
            Free (this.m_IMapControlMapServiceErrorOccurredEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControlMapServiceErrorOccurredEventArgs

   function get_DiagnosticMessage
   (
      this : in out MapControlMapServiceErrorOccurredEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapControlMapServiceErrorOccurredEventArgs.all.get_DiagnosticMessage (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElement

   procedure Initialize (this : in out MapElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElement) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElement, IMapElement_Ptr);
   begin
      if this.m_IMapElement /= null then
         if this.m_IMapElement.all /= null then
            temp := this.m_IMapElement.all.Release;
            Free (this.m_IMapElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElement

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElement

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElementClickEventArgs

   procedure Initialize (this : in out MapElementClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElementClickEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElementClickEventArgs, IMapElementClickEventArgs_Ptr);
   begin
      if this.m_IMapElementClickEventArgs /= null then
         if this.m_IMapElementClickEventArgs.all /= null then
            temp := this.m_IMapElementClickEventArgs.all.Release;
            Free (this.m_IMapElementClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElementClickEventArgs

   function get_Location
   (
      this : in out MapElementClickEventArgs
   )
   return WinUI3.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinUI3.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapElementClickEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new WinUI3.Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_Element
   (
      this : in out MapElementClickEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.MapElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMapElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.MapElement do
         Hr := this.m_IMapElementClickEventArgs.all.get_Element (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapElement := new WinUI3.Microsoft.UI.Xaml.Controls.IMapElement;
         Retval.m_IMapElement.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapLayer

   procedure Initialize (this : in out MapLayer) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapLayer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapLayer, IMapLayer_Ptr);
   begin
      if this.m_IMapLayer /= null then
         if this.m_IMapLayer.all /= null then
            temp := this.m_IMapLayer.all.Release;
            Free (this.m_IMapLayer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapLayer

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapLayer

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElementsLayer

   procedure Initialize (this : in out MapElementsLayer) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElementsLayer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElementsLayer, IMapElementsLayer_Ptr);
   begin
      if this.m_IMapElementsLayer /= null then
         if this.m_IMapElementsLayer.all /= null then
            temp := this.m_IMapElementsLayer.all.Release;
            Free (this.m_IMapElementsLayer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElementsLayer

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MapElementsLayer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMapElementsLayer");
      m_Factory    : access IMapElementsLayerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMapElementsLayer;
   begin
      return RetVal : MapElementsLayer do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElementsLayerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapElementsLayer := new WinUI3.Microsoft.UI.Xaml.Controls.IMapElementsLayer;
            Retval.m_IMapElementsLayer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapElementsLayer

   function get_MapElementsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MapElementsLayer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMapElementsLayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElementsLayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MapElementsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElementsLayer

   function get_MapElements
   (
      this : in out MapElementsLayer
   )
   return IVector_IMapElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IMapElement.Kind;
   begin
      Hr := this.m_IMapElementsLayer.all.get_MapElements (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMapElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_MapElements
   (
      this : in out MapElementsLayer;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMapElementsLayer.all.put_MapElements (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapElementClick
   (
      this : in out MapElementsLayer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapElementsLayer.all.add_MapElementClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapElementClick
   (
      this : in out MapElementsLayer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMapElementsLayer.all.remove_MapElementClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapIcon

   procedure Initialize (this : in out MapIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapIcon) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapIcon, IMapIcon_Ptr);
   begin
      if this.m_IMapIcon /= null then
         if this.m_IMapIcon.all /= null then
            temp := this.m_IMapIcon.all.Release;
            Free (this.m_IMapIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapIcon

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MapIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMapIcon");
      m_Factory    : access IMapIconFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMapIcon;
   begin
      return RetVal : MapIcon do
         Hr := RoGetActivationFactory (m_hString, IID_IMapIconFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapIcon := new WinUI3.Microsoft.UI.Xaml.Controls.IMapIcon;
            Retval.m_IMapIcon.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapIcon

   function get_LocationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MapIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMapIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LocationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapIcon

   function get_Location
   (
      this : in out MapIcon
   )
   return WinUI3.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinUI3.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapIcon.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new WinUI3.Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   procedure put_Location
   (
      this : in out MapIcon;
      value : WinUI3.Windows.Devices.Geolocation.Geopoint'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMapIcon.all.put_Location (value.m_IGeopoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MediaPlayerElement

   procedure Initialize (this : in out MediaPlayerElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out MediaPlayerElement) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMediaPlayerElement, IMediaPlayerElement_Ptr);
   begin
      if this.m_IMediaPlayerElement /= null then
         if this.m_IMediaPlayerElement.all /= null then
            temp := this.m_IMediaPlayerElement.all.Release;
            Free (this.m_IMediaPlayerElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MediaPlayerElement

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MediaPlayerElement is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMediaPlayerElement");
      m_Factory    : access IMediaPlayerElementFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerElement;
   begin
      return RetVal : MediaPlayerElement do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMediaPlayerElement := new WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerElement;
            Retval.m_IMediaPlayerElement.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MediaPlayerElement

   function get_SourceProperty_MediaPlayerElement
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AreTransportControlsEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreTransportControlsEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PosterSourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PosterSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchProperty_MediaPlayerElement
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AutoPlayProperty_MediaPlayerElement
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoPlayProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFullWindowProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFullWindowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MediaPlayerProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MediaPlayerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MediaPlayerElement

   function get_Source
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Windows.Media.Playback.IMediaPlaybackSource is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Playback.IMediaPlaybackSource;
   begin
      Hr := this.m_IMediaPlayerElement.all.get_Source (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Source
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Windows.Media.Playback.IMediaPlaybackSource
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_Source (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransportControls
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.MediaTransportControls'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControls;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.MediaTransportControls do
         Hr := this.m_IMediaPlayerElement.all.get_TransportControls (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMediaTransportControls := new WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControls;
         Retval.m_IMediaTransportControls.all := m_ComRetVal;
      end return;
   end;

   procedure put_TransportControls
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Microsoft.UI.Xaml.Controls.MediaTransportControls'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_TransportControls (value.m_IMediaTransportControls.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AreTransportControlsEnabled
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaPlayerElement.all.get_AreTransportControlsEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreTransportControlsEnabled
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_AreTransportControlsEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PosterSource
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IMediaPlayerElement.all.get_PosterSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_PosterSource
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_PosterSource (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.Stretch;
   begin
      Hr := this.m_IMediaPlayerElement.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Microsoft.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AutoPlay
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaPlayerElement.all.get_AutoPlay (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutoPlay
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_AutoPlay (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFullWindow
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaPlayerElement.all.get_IsFullWindow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFullWindow
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_IsFullWindow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MediaPlayer
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Windows.Media.Playback.MediaPlayer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Playback.IMediaPlayer;
   begin
      return RetVal : WinUI3.Windows.Media.Playback.MediaPlayer do
         Hr := this.m_IMediaPlayerElement.all.get_MediaPlayer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMediaPlayer := new WinUI3.Windows.Media.Playback.IMediaPlayer;
         Retval.m_IMediaPlayer.all := m_ComRetVal;
      end return;
   end;

   procedure SetMediaPlayer
   (
      this : in out MediaPlayerElement;
      mediaPlayer : WinUI3.Windows.Media.Playback.MediaPlayer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.SetMediaPlayer (mediaPlayer.m_IMediaPlayer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MediaPlayerPresenter

   procedure Initialize (this : in out MediaPlayerPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out MediaPlayerPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMediaPlayerPresenter, IMediaPlayerPresenter_Ptr);
   begin
      if this.m_IMediaPlayerPresenter /= null then
         if this.m_IMediaPlayerPresenter.all /= null then
            temp := this.m_IMediaPlayerPresenter.all.Release;
            Free (this.m_IMediaPlayerPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MediaPlayerPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MediaPlayerPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMediaPlayerPresenter");
      m_Factory    : access IMediaPlayerPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerPresenter;
   begin
      return RetVal : MediaPlayerPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMediaPlayerPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerPresenter;
            Retval.m_IMediaPlayerPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MediaPlayerPresenter

   function get_MediaPlayerProperty_MediaPlayerPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaPlayerPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MediaPlayerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchProperty_MediaPlayerPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaPlayerPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFullWindowProperty_MediaPlayerPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaPlayerPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaPlayerPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFullWindowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MediaPlayerPresenter

   function get_MediaPlayer
   (
      this : in out MediaPlayerPresenter
   )
   return WinUI3.Windows.Media.Playback.MediaPlayer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Playback.IMediaPlayer;
   begin
      return RetVal : WinUI3.Windows.Media.Playback.MediaPlayer do
         Hr := this.m_IMediaPlayerPresenter.all.get_MediaPlayer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMediaPlayer := new WinUI3.Windows.Media.Playback.IMediaPlayer;
         Retval.m_IMediaPlayer.all := m_ComRetVal;
      end return;
   end;

   procedure put_MediaPlayer
   (
      this : in out MediaPlayerPresenter;
      value : WinUI3.Windows.Media.Playback.MediaPlayer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerPresenter.all.put_MediaPlayer (value.m_IMediaPlayer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out MediaPlayerPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.Stretch;
   begin
      Hr := this.m_IMediaPlayerPresenter.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out MediaPlayerPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerPresenter.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFullWindow
   (
      this : in out MediaPlayerPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaPlayerPresenter.all.get_IsFullWindow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFullWindow
   (
      this : in out MediaPlayerPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerPresenter.all.put_IsFullWindow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MediaTransportControls

   procedure Initialize (this : in out MediaTransportControls) is
   begin
      null;
   end;

   procedure Finalize (this : in out MediaTransportControls) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMediaTransportControls, IMediaTransportControls_Ptr);
   begin
      if this.m_IMediaTransportControls /= null then
         if this.m_IMediaTransportControls.all /= null then
            temp := this.m_IMediaTransportControls.all.Release;
            Free (this.m_IMediaTransportControls);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MediaTransportControls

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MediaTransportControls is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMediaTransportControls");
      m_Factory    : access IMediaTransportControlsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControls;
   begin
      return RetVal : MediaTransportControls do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMediaTransportControls := new WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControls;
            Retval.m_IMediaTransportControls.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MediaTransportControls

   function get_IsZoomButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsZoomEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFastForwardButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFastForwardButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFastForwardEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFastForwardEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFastRewindButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFastRewindButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFastRewindEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFastRewindEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsStopButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStopButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsStopEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStopEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsVolumeButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVolumeButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsVolumeEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVolumeEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPlaybackRateButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPlaybackRateButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPlaybackRateEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPlaybackRateEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSeekBarVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSeekBarVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSeekEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSeekEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCompactProperty_MediaTransportControls
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSkipForwardButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSkipForwardButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSkipForwardEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSkipForwardEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSkipBackwardButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSkipBackwardButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSkipBackwardEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSkipBackwardEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsNextTrackButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsNextTrackButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPreviousTrackButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPreviousTrackButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FastPlayFallbackBehaviourProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FastPlayFallbackBehaviourProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShowAndHideAutomaticallyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowAndHideAutomaticallyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsRepeatEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsRepeatEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsRepeatButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsRepeatButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MediaTransportControls

   function get_IsZoomButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsZoomButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsZoomButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsZoomEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsZoomEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFastForwardButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsFastForwardButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFastForwardButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsFastForwardButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFastForwardEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsFastForwardEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFastForwardEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsFastForwardEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFastRewindButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsFastRewindButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFastRewindButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsFastRewindButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFastRewindEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsFastRewindEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFastRewindEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsFastRewindEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsStopButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsStopButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsStopButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsStopButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsStopEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsStopEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsStopEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsStopEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVolumeButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsVolumeButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsVolumeButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsVolumeButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVolumeEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsVolumeEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsVolumeEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsVolumeEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPlaybackRateButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsPlaybackRateButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPlaybackRateButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsPlaybackRateButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPlaybackRateEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsPlaybackRateEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPlaybackRateEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsPlaybackRateEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSeekBarVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsSeekBarVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSeekBarVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsSeekBarVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSeekEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsSeekEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSeekEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsSeekEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsCompact
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsCompact (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompact
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsCompact (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSkipForwardButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsSkipForwardButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSkipForwardButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsSkipForwardButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSkipForwardEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsSkipForwardEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSkipForwardEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsSkipForwardEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSkipBackwardButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsSkipBackwardButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSkipBackwardButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsSkipBackwardButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSkipBackwardEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsSkipBackwardEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSkipBackwardEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsSkipBackwardEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsNextTrackButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsNextTrackButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsNextTrackButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsNextTrackButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPreviousTrackButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsPreviousTrackButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPreviousTrackButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsPreviousTrackButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FastPlayFallbackBehaviour
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Microsoft.UI.Xaml.Media.FastPlayFallbackBehaviour is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.FastPlayFallbackBehaviour;
   begin
      Hr := this.m_IMediaTransportControls.all.get_FastPlayFallbackBehaviour (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FastPlayFallbackBehaviour
   (
      this : in out MediaTransportControls;
      value : WinUI3.Microsoft.UI.Xaml.Media.FastPlayFallbackBehaviour
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_FastPlayFallbackBehaviour (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowAndHideAutomatically
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_ShowAndHideAutomatically (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowAndHideAutomatically
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_ShowAndHideAutomatically (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsRepeatEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsRepeatEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsRepeatEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsRepeatEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsRepeatButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsRepeatButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsRepeatButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsRepeatButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ThumbnailRequested
   (
      this : in out MediaTransportControls;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMediaTransportControls.all.add_ThumbnailRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ThumbnailRequested
   (
      this : in out MediaTransportControls;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.remove_ThumbnailRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Show
   (
      this : in out MediaTransportControls
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.Show;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Hide
   (
      this : in out MediaTransportControls
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.Hide;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MediaTransportControlsHelper

   procedure Initialize (this : in out MediaTransportControlsHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out MediaTransportControlsHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMediaTransportControlsHelper, IMediaTransportControlsHelper_Ptr);
   begin
      if this.m_IMediaTransportControlsHelper /= null then
         if this.m_IMediaTransportControlsHelper.all /= null then
            temp := this.m_IMediaTransportControlsHelper.all.Release;
            Free (this.m_IMediaTransportControlsHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MediaTransportControlsHelper

   function get_DropoutOrderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControlsHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsHelperStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DropoutOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDropoutOrder
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControlsHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDropoutOrder (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetDropoutOrder
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MediaTransportControlsHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMediaTransportControlsHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetDropoutOrder (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MediaTransportControlsHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuBar

   procedure Initialize (this : in out MenuBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuBar, IMenuBar_Ptr);
   begin
      if this.m_IMenuBar /= null then
         if this.m_IMenuBar.all /= null then
            temp := this.m_IMenuBar.all.Release;
            Free (this.m_IMenuBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMenuBar");
      m_Factory    : access IMenuBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMenuBar;
   begin
      return RetVal : MenuBar do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuBar := new WinUI3.Microsoft.UI.Xaml.Controls.IMenuBar;
            Retval.m_IMenuBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuBar

   function get_ItemsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuBar

   function get_Items
   (
      this : in out MenuBar
   )
   return IVector_IMenuBarItem.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IMenuBarItem.Kind;
   begin
      Hr := this.m_IMenuBar.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMenuBarItem (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuBarItem

   procedure Initialize (this : in out MenuBarItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuBarItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuBarItem, IMenuBarItem_Ptr);
   begin
      if this.m_IMenuBarItem /= null then
         if this.m_IMenuBarItem.all /= null then
            temp := this.m_IMenuBarItem.all.Release;
            Free (this.m_IMenuBarItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuBarItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuBarItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMenuBarItem");
      m_Factory    : access IMenuBarItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMenuBarItem;
   begin
      return RetVal : MenuBarItem do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuBarItem := new WinUI3.Microsoft.UI.Xaml.Controls.IMenuBarItem;
            Retval.m_IMenuBarItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuBarItem

   function get_TitleProperty_MenuBarItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuBarItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuBarItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsProperty_MenuBarItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuBarItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuBarItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuBarItem

   function get_Title
   (
      this : in out MenuBarItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMenuBarItem.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out MenuBarItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IMenuBarItem.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Items
   (
      this : in out MenuBarItem
   )
   return IVector_IMenuFlyoutItemBase.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IMenuFlyoutItemBase.Kind;
   begin
      Hr := this.m_IMenuBarItem.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMenuFlyoutItemBase (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyout

   procedure Initialize (this : in out MenuFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyout, IMenuFlyout_Ptr);
   begin
      if this.m_IMenuFlyout /= null then
         if this.m_IMenuFlyout.all /= null then
            temp := this.m_IMenuFlyout.all.Release;
            Free (this.m_IMenuFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMenuFlyout");
      m_Factory    : access IMenuFlyoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyout;
   begin
      return RetVal : MenuFlyout do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuFlyout := new WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyout;
            Retval.m_IMenuFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuFlyout

   function get_MenuFlyoutPresenterStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuFlyoutPresenterStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyout

   function get_Items
   (
      this : in out MenuFlyout
   )
   return IVector_IMenuFlyoutItemBase.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IMenuFlyoutItemBase.Kind;
   begin
      Hr := this.m_IMenuFlyout.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMenuFlyoutItemBase (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_MenuFlyoutPresenterStyle
   (
      this : in out MenuFlyout
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IMenuFlyout.all.get_MenuFlyoutPresenterStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_MenuFlyoutPresenterStyle
   (
      this : in out MenuFlyout;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyout.all.put_MenuFlyoutPresenterStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ShowAt
   (
      this : in out MenuFlyout;
      targetElement : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      point : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyout.all.ShowAt (targetElement.m_IUIElement.all, point);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuBarItemFlyout

   procedure Initialize (this : in out MenuBarItemFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuBarItemFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuBarItemFlyout, IMenuBarItemFlyout_Ptr);
   begin
      if this.m_IMenuBarItemFlyout /= null then
         if this.m_IMenuBarItemFlyout.all /= null then
            temp := this.m_IMenuBarItemFlyout.all.Release;
            Free (this.m_IMenuBarItemFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuBarItemFlyout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuBarItemFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMenuBarItemFlyout");
      m_Factory    : access IMenuBarItemFlyoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMenuBarItemFlyout;
   begin
      return RetVal : MenuBarItemFlyout do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarItemFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuBarItemFlyout := new WinUI3.Microsoft.UI.Xaml.Controls.IMenuBarItemFlyout;
            Retval.m_IMenuBarItemFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuBarItemFlyout

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutItemBase

   procedure Initialize (this : in out MenuFlyoutItemBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutItemBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutItemBase, IMenuFlyoutItemBase_Ptr);
   begin
      if this.m_IMenuFlyoutItemBase /= null then
         if this.m_IMenuFlyoutItemBase.all /= null then
            temp := this.m_IMenuFlyoutItemBase.all.Release;
            Free (this.m_IMenuFlyoutItemBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyoutItemBase

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutItemBase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutItem

   procedure Initialize (this : in out MenuFlyoutItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutItem, IMenuFlyoutItem_Ptr);
   begin
      if this.m_IMenuFlyoutItem /= null then
         if this.m_IMenuFlyoutItem.all /= null then
            temp := this.m_IMenuFlyoutItem.all.Release;
            Free (this.m_IMenuFlyoutItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyoutItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuFlyoutItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMenuFlyoutItem");
      m_Factory    : access IMenuFlyoutItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutItem;
   begin
      return RetVal : MenuFlyoutItem do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuFlyoutItem := new WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutItem;
            Retval.m_IMenuFlyoutItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuFlyoutItem

   function get_TextProperty_MenuFlyoutItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandParameterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty_MenuFlyoutItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyboardAcceleratorTextOverrideProperty_MenuFlyoutItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyboardAcceleratorTextOverrideProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutItem

   function get_Text
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMenuFlyoutItem.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out MenuFlyoutItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IMenuFlyoutItem.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Command
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.Microsoft.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_IMenuFlyoutItem.all.get_Command (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Command
   (
      this : in out MenuFlyoutItem;
      value : WinUI3.Microsoft.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyoutItem.all.put_Command (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CommandParameter
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IMenuFlyoutItem.all.get_CommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CommandParameter
   (
      this : in out MenuFlyoutItem;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyoutItem.all.put_CommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Icon
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_IMenuFlyoutItem.all.get_Icon (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out MenuFlyoutItem;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyoutItem.all.put_Icon (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyboardAcceleratorTextOverride
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMenuFlyoutItem.all.get_KeyboardAcceleratorTextOverride (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_KeyboardAcceleratorTextOverride
   (
      this : in out MenuFlyoutItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IMenuFlyoutItem.all.put_KeyboardAcceleratorTextOverride (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_TemplateSettings
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.MenuFlyoutItemTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IMenuFlyoutItemTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.MenuFlyoutItemTemplateSettings do
         Hr := this.m_IMenuFlyoutItem.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMenuFlyoutItemTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IMenuFlyoutItemTemplateSettings;
         Retval.m_IMenuFlyoutItemTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_Click
   (
      this : in out MenuFlyoutItem;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMenuFlyoutItem.all.add_Click (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Click
   (
      this : in out MenuFlyoutItem;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyoutItem.all.remove_Click (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutPresenter

   procedure Initialize (this : in out MenuFlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutPresenter, IMenuFlyoutPresenter_Ptr);
   begin
      if this.m_IMenuFlyoutPresenter /= null then
         if this.m_IMenuFlyoutPresenter.all /= null then
            temp := this.m_IMenuFlyoutPresenter.all.Release;
            Free (this.m_IMenuFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyoutPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuFlyoutPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMenuFlyoutPresenter");
      m_Factory    : access IMenuFlyoutPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutPresenter;
   begin
      return RetVal : MenuFlyoutPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuFlyoutPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutPresenter;
            Retval.m_IMenuFlyoutPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuFlyoutPresenter

   function get_SystemBackdropProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuFlyoutPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SystemBackdropProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsDefaultShadowEnabledProperty_MenuFlyoutPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuFlyoutPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDefaultShadowEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutPresenter

   function get_TemplateSettings
   (
      this : in out MenuFlyoutPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.MenuFlyoutPresenterTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IMenuFlyoutPresenterTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.MenuFlyoutPresenterTemplateSettings do
         Hr := this.m_IMenuFlyoutPresenter.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMenuFlyoutPresenterTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IMenuFlyoutPresenterTemplateSettings;
         Retval.m_IMenuFlyoutPresenterTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_IsDefaultShadowEnabled
   (
      this : in out MenuFlyoutPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMenuFlyoutPresenter.all.get_IsDefaultShadowEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDefaultShadowEnabled
   (
      this : in out MenuFlyoutPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyoutPresenter.all.put_IsDefaultShadowEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SystemBackdrop
   (
      this : in out MenuFlyoutPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISystemBackdrop;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutPresenter2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IMenuFlyoutPresenter2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop do
         m_Interface := QInterface (this.m_IMenuFlyoutPresenter.all);
         Hr := m_Interface.get_SystemBackdrop (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISystemBackdrop := new WinUI3.Microsoft.UI.Xaml.Media.ISystemBackdrop;
         Retval.m_ISystemBackdrop.all := m_ComRetVal;
      end return;
   end;

   procedure put_SystemBackdrop
   (
      this : in out MenuFlyoutPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutPresenter2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IMenuFlyoutPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMenuFlyoutPresenter.all);
      Hr := m_Interface.put_SystemBackdrop (value.m_ISystemBackdrop.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutSeparator

   procedure Initialize (this : in out MenuFlyoutSeparator) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutSeparator) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutSeparator, IMenuFlyoutSeparator_Ptr);
   begin
      if this.m_IMenuFlyoutSeparator /= null then
         if this.m_IMenuFlyoutSeparator.all /= null then
            temp := this.m_IMenuFlyoutSeparator.all.Release;
            Free (this.m_IMenuFlyoutSeparator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyoutSeparator

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuFlyoutSeparator is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMenuFlyoutSeparator");
      m_Factory    : access IMenuFlyoutSeparatorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutSeparator;
   begin
      return RetVal : MenuFlyoutSeparator do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutSeparatorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuFlyoutSeparator := new WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutSeparator;
            Retval.m_IMenuFlyoutSeparator.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutSeparator

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutSubItem

   procedure Initialize (this : in out MenuFlyoutSubItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutSubItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutSubItem, IMenuFlyoutSubItem_Ptr);
   begin
      if this.m_IMenuFlyoutSubItem /= null then
         if this.m_IMenuFlyoutSubItem.all /= null then
            temp := this.m_IMenuFlyoutSubItem.all.Release;
            Free (this.m_IMenuFlyoutSubItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyoutSubItem

   function Constructor return MenuFlyoutSubItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IMenuFlyoutSubItem");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutSubItem;
   begin
      return RetVal : MenuFlyoutSubItem do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMenuFlyoutSubItem := new WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutSubItem;
            Retval.m_IMenuFlyoutSubItem.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuFlyoutSubItem

   function get_TextProperty_MenuFlyoutSubItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuFlyoutSubItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutSubItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutSubItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty_MenuFlyoutSubItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.MenuFlyoutSubItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IMenuFlyoutSubItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutSubItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutSubItem

   function get_Items
   (
      this : in out MenuFlyoutSubItem
   )
   return IVector_IMenuFlyoutItemBase.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IMenuFlyoutItemBase.Kind;
   begin
      Hr := this.m_IMenuFlyoutSubItem.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMenuFlyoutItemBase (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Text
   (
      this : in out MenuFlyoutSubItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMenuFlyoutSubItem.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out MenuFlyoutSubItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IMenuFlyoutSubItem.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Icon
   (
      this : in out MenuFlyoutSubItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_IMenuFlyoutSubItem.all.get_Icon (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out MenuFlyoutSubItem;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyoutSubItem.all.put_Icon (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationView

   procedure Initialize (this : in out NavigationView) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationView, INavigationView_Ptr);
   begin
      if this.m_INavigationView /= null then
         if this.m_INavigationView.all /= null then
            temp := this.m_INavigationView.all.Release;
            Free (this.m_INavigationView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.INavigationView");
      m_Factory    : access INavigationViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.INavigationView;
   begin
      return RetVal : NavigationView do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationView := new WinUI3.Microsoft.UI.Xaml.Controls.INavigationView;
            Retval.m_INavigationView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for NavigationView

   function get_IsPaneOpenProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPaneOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CompactModeThresholdWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompactModeThresholdWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExpandedModeThresholdWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExpandedModeThresholdWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterMenuItemsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterMenuItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterMenuItemsSourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterMenuItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneFooterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneFooterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_NavigationView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_NavigationView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayModeProperty_NavigationView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSettingsVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSettingsVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPaneToggleButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPaneToggleButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AlwaysShowHeaderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlwaysShowHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CompactPaneLengthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompactPaneLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpenPaneLengthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpenPaneLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneToggleButtonStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneToggleButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemsSourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty_NavigationView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SettingsItemProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SettingsItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AutoSuggestBoxProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoSuggestBoxProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemTemplateSelectorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemContainerStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemContainerStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemContainerStyleSelectorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemContainerStyleSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTitleBarAutoPaddingEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTitleBarAutoPaddingEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsBackButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsBackButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsBackEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsBackEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneTitleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneTitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneDisplayModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneDisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneHeaderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneCustomContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneCustomContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentOverlayProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentOverlayProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPaneVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPaneVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFollowsFocusProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFollowsFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateSettingsProperty_NavigationView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShoulderNavigationEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShoulderNavigationEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OverflowLabelModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OverflowLabelModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationView

   function get_IsPaneOpen
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationView.all.get_IsPaneOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPaneOpen
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_IsPaneOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CompactModeThresholdWidth
   (
      this : in out NavigationView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationView.all.get_CompactModeThresholdWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CompactModeThresholdWidth
   (
      this : in out NavigationView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_CompactModeThresholdWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExpandedModeThresholdWidth
   (
      this : in out NavigationView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationView.all.get_ExpandedModeThresholdWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ExpandedModeThresholdWidth
   (
      this : in out NavigationView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_ExpandedModeThresholdWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FooterMenuItems
   (
      this : in out NavigationView
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_INavigationView.all.get_FooterMenuItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_FooterMenuItemsSource
   (
      this : in out NavigationView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationView.all.get_FooterMenuItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FooterMenuItemsSource
   (
      this : in out NavigationView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_FooterMenuItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneFooter
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_INavigationView.all.get_PaneFooter (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_PaneFooter
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_PaneFooter (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out NavigationView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationView.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out NavigationView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_INavigationView.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMode
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewDisplayMode;
   begin
      Hr := this.m_INavigationView.all.get_DisplayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsSettingsVisible
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationView.all.get_IsSettingsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSettingsVisible
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_IsSettingsVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPaneToggleButtonVisible
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationView.all.get_IsPaneToggleButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPaneToggleButtonVisible
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_IsPaneToggleButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AlwaysShowHeader
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationView.all.get_AlwaysShowHeader (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AlwaysShowHeader
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_AlwaysShowHeader (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CompactPaneLength
   (
      this : in out NavigationView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationView.all.get_CompactPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CompactPaneLength
   (
      this : in out NavigationView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_CompactPaneLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpenPaneLength
   (
      this : in out NavigationView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationView.all.get_OpenPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpenPaneLength
   (
      this : in out NavigationView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_OpenPaneLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneToggleButtonStyle
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_INavigationView.all.get_PaneToggleButtonStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_PaneToggleButtonStyle
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_PaneToggleButtonStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItem
   (
      this : in out NavigationView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationView.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedItem
   (
      this : in out NavigationView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_SelectedItem (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MenuItems
   (
      this : in out NavigationView
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_INavigationView.all.get_MenuItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_MenuItemsSource
   (
      this : in out NavigationView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationView.all.get_MenuItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MenuItemsSource
   (
      this : in out NavigationView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_MenuItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SettingsItem
   (
      this : in out NavigationView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationView.all.get_SettingsItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AutoSuggestBox
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.AutoSuggestBox'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBox;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.AutoSuggestBox do
         Hr := this.m_INavigationView.all.get_AutoSuggestBox (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAutoSuggestBox := new WinUI3.Microsoft.UI.Xaml.Controls.IAutoSuggestBox;
         Retval.m_IAutoSuggestBox.all := m_ComRetVal;
      end return;
   end;

   procedure put_AutoSuggestBox
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.AutoSuggestBox'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_AutoSuggestBox (value.m_IAutoSuggestBox.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MenuItemTemplate
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_INavigationView.all.get_MenuItemTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_MenuItemTemplate
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_MenuItemTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MenuItemTemplateSelector
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_INavigationView.all.get_MenuItemTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_MenuItemTemplateSelector
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_MenuItemTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MenuItemContainerStyle
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_INavigationView.all.get_MenuItemContainerStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_MenuItemContainerStyle
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_MenuItemContainerStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MenuItemContainerStyleSelector
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelector;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector do
         Hr := this.m_INavigationView.all.get_MenuItemContainerStyleSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyleSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelector;
         Retval.m_IStyleSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_MenuItemContainerStyleSelector
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_MenuItemContainerStyleSelector (value.m_IStyleSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function MenuItemFromContainer
   (
      this : in out NavigationView;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationView.all.MenuItemFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromMenuItem
   (
      this : in out NavigationView;
      item : WinUI3.IInspectable
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         Hr := this.m_INavigationView.all.ContainerFromMenuItem (item, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function add_SelectionChanged
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_INavigationView.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ItemInvoked
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_INavigationView.all.add_ItemInvoked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemInvoked
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.remove_ItemInvoked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DisplayModeChanged
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_INavigationView.all.add_DisplayModeChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DisplayModeChanged
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.remove_DisplayModeChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTitleBarAutoPaddingEnabled
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationView.all.get_IsTitleBarAutoPaddingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTitleBarAutoPaddingEnabled
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_IsTitleBarAutoPaddingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsBackButtonVisible
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewBackButtonVisible is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewBackButtonVisible;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_IsBackButtonVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsBackButtonVisible
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewBackButtonVisible
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_IsBackButtonVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsBackEnabled
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_IsBackEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsBackEnabled
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_IsBackEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneTitle
   (
      this : in out NavigationView
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_PaneTitle (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PaneTitle
   (
      this : in out NavigationView;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_PaneTitle (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function add_BackRequested
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_BackRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BackRequested
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_BackRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneClosed
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_PaneClosed (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneClosed
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_PaneClosed (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneClosing
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_PaneClosing (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneClosing
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_PaneClosing (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneOpened
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_PaneOpened (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneOpened
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_PaneOpened (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneOpening
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_PaneOpening (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneOpening
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_PaneOpening (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneDisplayMode
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewPaneDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewPaneDisplayMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_PaneDisplayMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PaneDisplayMode
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewPaneDisplayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_PaneDisplayMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneHeader
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_INavigationView.all);
         Hr := m_Interface.get_PaneHeader (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_PaneHeader
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_PaneHeader (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneCustomContent
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_INavigationView.all);
         Hr := m_Interface.get_PaneCustomContent (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_PaneCustomContent
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_PaneCustomContent (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentOverlay
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_INavigationView.all);
         Hr := m_Interface.get_ContentOverlay (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentOverlay
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_ContentOverlay (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPaneVisible
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_IsPaneVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPaneVisible
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_IsPaneVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionFollowsFocus
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewSelectionFollowsFocus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewSelectionFollowsFocus;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_SelectionFollowsFocus (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionFollowsFocus
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewSelectionFollowsFocus
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_SelectionFollowsFocus (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettings;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings do
         m_Interface := QInterface (this.m_INavigationView.all);
         Hr := m_Interface.get_TemplateSettings (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationViewTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettings;
         Retval.m_INavigationViewTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_ShoulderNavigationEnabled
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewShoulderNavigationEnabled is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewShoulderNavigationEnabled;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_ShoulderNavigationEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShoulderNavigationEnabled
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewShoulderNavigationEnabled
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_ShoulderNavigationEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OverflowLabelMode
   (
      this : in out NavigationView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewOverflowLabelMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewOverflowLabelMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_OverflowLabelMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OverflowLabelMode
   (
      this : in out NavigationView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewOverflowLabelMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_OverflowLabelMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Expanding
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_Expanding (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Expanding
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_Expanding (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Collapsed
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_Collapsed (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Collapsed
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_Collapsed (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Expand
   (
      this : in out NavigationView;
      item : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.Expand (item.m_INavigationViewItem.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Collapse
   (
      this : in out NavigationView;
      item : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.Collapse (item.m_INavigationViewItem.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewBackRequestedEventArgs

   procedure Initialize (this : in out NavigationViewBackRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewBackRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewBackRequestedEventArgs, INavigationViewBackRequestedEventArgs_Ptr);
   begin
      if this.m_INavigationViewBackRequestedEventArgs /= null then
         if this.m_INavigationViewBackRequestedEventArgs.all /= null then
            temp := this.m_INavigationViewBackRequestedEventArgs.all.Release;
            Free (this.m_INavigationViewBackRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewBackRequestedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewDisplayModeChangedEventArgs

   procedure Initialize (this : in out NavigationViewDisplayModeChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewDisplayModeChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewDisplayModeChangedEventArgs, INavigationViewDisplayModeChangedEventArgs_Ptr);
   begin
      if this.m_INavigationViewDisplayModeChangedEventArgs /= null then
         if this.m_INavigationViewDisplayModeChangedEventArgs.all /= null then
            temp := this.m_INavigationViewDisplayModeChangedEventArgs.all.Release;
            Free (this.m_INavigationViewDisplayModeChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewDisplayModeChangedEventArgs

   function get_DisplayMode
   (
      this : in out NavigationViewDisplayModeChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewDisplayMode;
   begin
      Hr := this.m_INavigationViewDisplayModeChangedEventArgs.all.get_DisplayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemBase

   procedure Initialize (this : in out NavigationViewItemBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemBase, INavigationViewItemBase_Ptr);
   begin
      if this.m_INavigationViewItemBase /= null then
         if this.m_INavigationViewItemBase.all /= null then
            temp := this.m_INavigationViewItemBase.all.Release;
            Free (this.m_INavigationViewItemBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItemBase

   -----------------------------------------------------------------------------
   -- Static Interfaces for NavigationViewItemBase

   function get_IsSelectedProperty_NavigationViewItemBase
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewItemBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSelectedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemBase

   function get_IsSelected
   (
      this : in out NavigationViewItemBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItemBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItemBase.all);
      Hr := m_Interface.get_IsSelected (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSelected
   (
      this : in out NavigationViewItemBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItemBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItemBase.all);
      Hr := m_Interface.put_IsSelected (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItem

   procedure Initialize (this : in out NavigationViewItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItem, INavigationViewItem_Ptr);
   begin
      if this.m_INavigationViewItem /= null then
         if this.m_INavigationViewItem.all /= null then
            temp := this.m_INavigationViewItem.all.Release;
            Free (this.m_INavigationViewItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationViewItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.INavigationViewItem");
      m_Factory    : access INavigationViewItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem;
   begin
      return RetVal : NavigationViewItem do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationViewItem := new WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem;
            Retval.m_INavigationViewItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for NavigationViewItem

   function get_InfoBadgeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InfoBadgeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty_NavigationViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CompactPaneLengthProperty_NavigationViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompactPaneLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectsOnInvokedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectsOnInvokedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsExpandedProperty_NavigationViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsExpandedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HasUnrealizedChildrenProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HasUnrealizedChildrenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsChildSelectedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsChildSelectedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemsProperty_NavigationViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemsSourceProperty_NavigationViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItem

   function get_Icon
   (
      this : in out NavigationViewItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_INavigationViewItem.all.get_Icon (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out NavigationViewItem;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationViewItem.all.put_Icon (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CompactPaneLength
   (
      this : in out NavigationViewItem
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationViewItem.all.get_CompactPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectsOnInvoked
   (
      this : in out NavigationViewItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.get_SelectsOnInvoked (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectsOnInvoked
   (
      this : in out NavigationViewItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.put_SelectsOnInvoked (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsExpanded
   (
      this : in out NavigationViewItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.get_IsExpanded (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsExpanded
   (
      this : in out NavigationViewItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.put_IsExpanded (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HasUnrealizedChildren
   (
      this : in out NavigationViewItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.get_HasUnrealizedChildren (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HasUnrealizedChildren
   (
      this : in out NavigationViewItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.put_HasUnrealizedChildren (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsChildSelected
   (
      this : in out NavigationViewItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.get_IsChildSelected (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsChildSelected
   (
      this : in out NavigationViewItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.put_IsChildSelected (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MenuItems
   (
      this : in out NavigationViewItem
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.get_MenuItems (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_MenuItemsSource
   (
      this : in out NavigationViewItem
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.get_MenuItemsSource (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MenuItemsSource
   (
      this : in out NavigationViewItem;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.put_MenuItemsSource (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InfoBadge
   (
      this : in out NavigationViewItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.InfoBadge'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadge;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem3, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.InfoBadge do
         m_Interface := QInterface (this.m_INavigationViewItem.all);
         Hr := m_Interface.get_InfoBadge (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInfoBadge := new WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadge;
         Retval.m_IInfoBadge.all := m_ComRetVal;
      end return;
   end;

   procedure put_InfoBadge
   (
      this : in out NavigationViewItem;
      value : WinUI3.Microsoft.UI.Xaml.Controls.InfoBadge'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItem3, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItem3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.put_InfoBadge (value.m_IInfoBadge.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemCollapsedEventArgs

   procedure Initialize (this : in out NavigationViewItemCollapsedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemCollapsedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemCollapsedEventArgs, INavigationViewItemCollapsedEventArgs_Ptr);
   begin
      if this.m_INavigationViewItemCollapsedEventArgs /= null then
         if this.m_INavigationViewItemCollapsedEventArgs.all /= null then
            temp := this.m_INavigationViewItemCollapsedEventArgs.all.Release;
            Free (this.m_INavigationViewItemCollapsedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemCollapsedEventArgs

   function get_CollapsedItemContainer
   (
      this : in out NavigationViewItemCollapsedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewItemBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewItemBase do
         Hr := this.m_INavigationViewItemCollapsedEventArgs.all.get_CollapsedItemContainer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationViewItemBase := new WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase;
         Retval.m_INavigationViewItemBase.all := m_ComRetVal;
      end return;
   end;

   function get_CollapsedItem
   (
      this : in out NavigationViewItemCollapsedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationViewItemCollapsedEventArgs.all.get_CollapsedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemExpandingEventArgs

   procedure Initialize (this : in out NavigationViewItemExpandingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemExpandingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemExpandingEventArgs, INavigationViewItemExpandingEventArgs_Ptr);
   begin
      if this.m_INavigationViewItemExpandingEventArgs /= null then
         if this.m_INavigationViewItemExpandingEventArgs.all /= null then
            temp := this.m_INavigationViewItemExpandingEventArgs.all.Release;
            Free (this.m_INavigationViewItemExpandingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemExpandingEventArgs

   function get_ExpandingItemContainer
   (
      this : in out NavigationViewItemExpandingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewItemBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewItemBase do
         Hr := this.m_INavigationViewItemExpandingEventArgs.all.get_ExpandingItemContainer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationViewItemBase := new WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase;
         Retval.m_INavigationViewItemBase.all := m_ComRetVal;
      end return;
   end;

   function get_ExpandingItem
   (
      this : in out NavigationViewItemExpandingEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationViewItemExpandingEventArgs.all.get_ExpandingItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemHeader

   procedure Initialize (this : in out NavigationViewItemHeader) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemHeader) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemHeader, INavigationViewItemHeader_Ptr);
   begin
      if this.m_INavigationViewItemHeader /= null then
         if this.m_INavigationViewItemHeader.all /= null then
            temp := this.m_INavigationViewItemHeader.all.Release;
            Free (this.m_INavigationViewItemHeader);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItemHeader

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationViewItemHeader is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.INavigationViewItemHeader");
      m_Factory    : access INavigationViewItemHeaderFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemHeader;
   begin
      return RetVal : NavigationViewItemHeader do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemHeaderFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationViewItemHeader := new WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemHeader;
            Retval.m_INavigationViewItemHeader.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemHeader

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemInvokedEventArgs

   procedure Initialize (this : in out NavigationViewItemInvokedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemInvokedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemInvokedEventArgs, INavigationViewItemInvokedEventArgs_Ptr);
   begin
      if this.m_INavigationViewItemInvokedEventArgs /= null then
         if this.m_INavigationViewItemInvokedEventArgs.all /= null then
            temp := this.m_INavigationViewItemInvokedEventArgs.all.Release;
            Free (this.m_INavigationViewItemInvokedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItemInvokedEventArgs

   function Constructor return NavigationViewItemInvokedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs;
   begin
      return RetVal : NavigationViewItemInvokedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_INavigationViewItemInvokedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs;
            Retval.m_INavigationViewItemInvokedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemInvokedEventArgs

   function get_InvokedItem
   (
      this : in out NavigationViewItemInvokedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationViewItemInvokedEventArgs.all.get_InvokedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsSettingsInvoked
   (
      this : in out NavigationViewItemInvokedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationViewItemInvokedEventArgs.all.get_IsSettingsInvoked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_InvokedItemContainer
   (
      this : in out NavigationViewItemInvokedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewItemBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItemInvokedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewItemBase do
         m_Interface := QInterface (this.m_INavigationViewItemInvokedEventArgs.all);
         Hr := m_Interface.get_InvokedItemContainer (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationViewItemBase := new WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase;
         Retval.m_INavigationViewItemBase.all := m_ComRetVal;
      end return;
   end;

   function get_RecommendedNavigationTransitionInfo
   (
      this : in out NavigationViewItemInvokedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.NavigationTransitionInfo'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.Animation.INavigationTransitionInfo;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewItemInvokedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.NavigationTransitionInfo do
         m_Interface := QInterface (this.m_INavigationViewItemInvokedEventArgs.all);
         Hr := m_Interface.get_RecommendedNavigationTransitionInfo (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationTransitionInfo := new WinUI3.Microsoft.UI.Xaml.Media.Animation.INavigationTransitionInfo;
         Retval.m_INavigationTransitionInfo.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemSeparator

   procedure Initialize (this : in out NavigationViewItemSeparator) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemSeparator) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemSeparator, INavigationViewItemSeparator_Ptr);
   begin
      if this.m_INavigationViewItemSeparator /= null then
         if this.m_INavigationViewItemSeparator.all /= null then
            temp := this.m_INavigationViewItemSeparator.all.Release;
            Free (this.m_INavigationViewItemSeparator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItemSeparator

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationViewItemSeparator is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.INavigationViewItemSeparator");
      m_Factory    : access INavigationViewItemSeparatorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemSeparator;
   begin
      return RetVal : NavigationViewItemSeparator do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemSeparatorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationViewItemSeparator := new WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemSeparator;
            Retval.m_INavigationViewItemSeparator.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemSeparator

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewPaneClosingEventArgs

   procedure Initialize (this : in out NavigationViewPaneClosingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewPaneClosingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewPaneClosingEventArgs, INavigationViewPaneClosingEventArgs_Ptr);
   begin
      if this.m_INavigationViewPaneClosingEventArgs /= null then
         if this.m_INavigationViewPaneClosingEventArgs.all /= null then
            temp := this.m_INavigationViewPaneClosingEventArgs.all.Release;
            Free (this.m_INavigationViewPaneClosingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewPaneClosingEventArgs

   function get_Cancel
   (
      this : in out NavigationViewPaneClosingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationViewPaneClosingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out NavigationViewPaneClosingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationViewPaneClosingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewSelectionChangedEventArgs

   procedure Initialize (this : in out NavigationViewSelectionChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewSelectionChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewSelectionChangedEventArgs, INavigationViewSelectionChangedEventArgs_Ptr);
   begin
      if this.m_INavigationViewSelectionChangedEventArgs /= null then
         if this.m_INavigationViewSelectionChangedEventArgs.all /= null then
            temp := this.m_INavigationViewSelectionChangedEventArgs.all.Release;
            Free (this.m_INavigationViewSelectionChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewSelectionChangedEventArgs

   function get_SelectedItem
   (
      this : in out NavigationViewSelectionChangedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationViewSelectionChangedEventArgs.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsSettingsSelected
   (
      this : in out NavigationViewSelectionChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationViewSelectionChangedEventArgs.all.get_IsSettingsSelected (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectedItemContainer
   (
      this : in out NavigationViewSelectionChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewItemBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewSelectionChangedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.NavigationViewItemBase do
         m_Interface := QInterface (this.m_INavigationViewSelectionChangedEventArgs.all);
         Hr := m_Interface.get_SelectedItemContainer (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationViewItemBase := new WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewItemBase;
         Retval.m_INavigationViewItemBase.all := m_ComRetVal;
      end return;
   end;

   function get_RecommendedNavigationTransitionInfo
   (
      this : in out NavigationViewSelectionChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.NavigationTransitionInfo'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.Animation.INavigationTransitionInfo;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewSelectionChangedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.NavigationTransitionInfo do
         m_Interface := QInterface (this.m_INavigationViewSelectionChangedEventArgs.all);
         Hr := m_Interface.get_RecommendedNavigationTransitionInfo (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationTransitionInfo := new WinUI3.Microsoft.UI.Xaml.Media.Animation.INavigationTransitionInfo;
         Retval.m_INavigationTransitionInfo.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewTemplateSettings

   procedure Initialize (this : in out NavigationViewTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewTemplateSettings, INavigationViewTemplateSettings_Ptr);
   begin
      if this.m_INavigationViewTemplateSettings /= null then
         if this.m_INavigationViewTemplateSettings.all /= null then
            temp := this.m_INavigationViewTemplateSettings.all.Release;
            Free (this.m_INavigationViewTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewTemplateSettings

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationViewTemplateSettings is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettings");
      m_Factory    : access INavigationViewTemplateSettingsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettings;
   begin
      return RetVal : NavigationViewTemplateSettings do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationViewTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettings;
            Retval.m_INavigationViewTemplateSettings.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for NavigationViewTemplateSettings

   function get_OpenPaneLengthProperty_NavigationViewTemplateSettings
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpenPaneLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TopPaddingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopPaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OverflowButtonVisibilityProperty_NavigationViewTemplateSettings
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OverflowButtonVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneToggleButtonVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneToggleButtonVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackButtonVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackButtonVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TopPaneVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopPaneVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LeftPaneVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftPaneVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SingleSelectionFollowsFocusProperty_NavigationViewTemplateSettings
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SingleSelectionFollowsFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneToggleButtonWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneToggleButtonWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SmallerPaneToggleButtonWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SmallerPaneToggleButtonWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewTemplateSettings

   function get_TopPadding
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_TopPadding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowButtonVisibility
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_OverflowButtonVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PaneToggleButtonVisibility
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_PaneToggleButtonVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_BackButtonVisibility
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_BackButtonVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_TopPaneVisibility
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_TopPaneVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LeftPaneVisibility
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_LeftPaneVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SingleSelectionFollowsFocus
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_SingleSelectionFollowsFocus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PaneToggleButtonWidth
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_PaneToggleButtonWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SmallerPaneToggleButtonWidth
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_SmallerPaneToggleButtonWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OpenPaneLength
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettings2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettings_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INavigationViewTemplateSettings2, WinUI3.Microsoft.UI.Xaml.Controls.IID_INavigationViewTemplateSettings2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewTemplateSettings.all);
      Hr := m_Interface.get_OpenPaneLength (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NonVirtualizingLayout

   procedure Initialize (this : in out NonVirtualizingLayout) is
   begin
      null;
   end;

   procedure Finalize (this : in out NonVirtualizingLayout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INonVirtualizingLayout, INonVirtualizingLayout_Ptr);
   begin
      if this.m_INonVirtualizingLayout /= null then
         if this.m_INonVirtualizingLayout.all /= null then
            temp := this.m_INonVirtualizingLayout.all.Release;
            Free (this.m_INonVirtualizingLayout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NonVirtualizingLayout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NonVirtualizingLayout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.INonVirtualizingLayout");
      m_Factory    : access INonVirtualizingLayoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayout;
   begin
      return RetVal : NonVirtualizingLayout do
         Hr := RoGetActivationFactory (m_hString, IID_INonVirtualizingLayoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INonVirtualizingLayout := new WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayout;
            Retval.m_INonVirtualizingLayout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NonVirtualizingLayout

   procedure InitializeForContextCore
   (
      this : in out NonVirtualizingLayout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.NonVirtualizingLayoutContext'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_INonVirtualizingLayoutOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INonVirtualizingLayout.all);
      Hr := m_Interface.InitializeForContextCore (context.m_INonVirtualizingLayoutContext.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure UninitializeForContextCore
   (
      this : in out NonVirtualizingLayout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.NonVirtualizingLayoutContext'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_INonVirtualizingLayoutOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INonVirtualizingLayout.all);
      Hr := m_Interface.UninitializeForContextCore (context.m_INonVirtualizingLayoutContext.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function MeasureOverride
   (
      this : in out NonVirtualizingLayout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.NonVirtualizingLayoutContext'Class;
      availableSize : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_INonVirtualizingLayoutOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INonVirtualizingLayout.all);
      Hr := m_Interface.MeasureOverride (context.m_INonVirtualizingLayoutContext.all, availableSize, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ArrangeOverride
   (
      this : in out NonVirtualizingLayout;
      context : WinUI3.Microsoft.UI.Xaml.Controls.NonVirtualizingLayoutContext'Class;
      finalSize : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayout_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_INonVirtualizingLayoutOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INonVirtualizingLayout.all);
      Hr := m_Interface.ArrangeOverride (context.m_INonVirtualizingLayoutContext.all, finalSize, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NonVirtualizingLayoutContext

   procedure Initialize (this : in out NonVirtualizingLayoutContext) is
   begin
      null;
   end;

   procedure Finalize (this : in out NonVirtualizingLayoutContext) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INonVirtualizingLayoutContext, INonVirtualizingLayoutContext_Ptr);
   begin
      if this.m_INonVirtualizingLayoutContext /= null then
         if this.m_INonVirtualizingLayoutContext.all /= null then
            temp := this.m_INonVirtualizingLayoutContext.all.Release;
            Free (this.m_INonVirtualizingLayoutContext);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NonVirtualizingLayoutContext

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NonVirtualizingLayoutContext is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutContext");
      m_Factory    : access INonVirtualizingLayoutContextFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutContext;
   begin
      return RetVal : NonVirtualizingLayoutContext do
         Hr := RoGetActivationFactory (m_hString, IID_INonVirtualizingLayoutContextFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INonVirtualizingLayoutContext := new WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutContext;
            Retval.m_INonVirtualizingLayoutContext.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NonVirtualizingLayoutContext

   function get_Children
   (
      this : in out NonVirtualizingLayoutContext
   )
   return IVectorView_IUIElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IUIElement.Kind;
   begin
      Hr := this.m_INonVirtualizingLayoutContext.all.get_Children (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IUIElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_ChildrenCore
   (
      this : in out NonVirtualizingLayoutContext
   )
   return IVectorView_IUIElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutContextOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IUIElement.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.INonVirtualizingLayoutContextOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_INonVirtualizingLayoutContextOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INonVirtualizingLayoutContext.all);
      Hr := m_Interface.get_ChildrenCore (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IUIElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NumberBox

   procedure Initialize (this : in out NumberBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out NumberBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INumberBox, INumberBox_Ptr);
   begin
      if this.m_INumberBox /= null then
         if this.m_INumberBox.all /= null then
            temp := this.m_INumberBox.all.Release;
            Free (this.m_INumberBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NumberBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NumberBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.INumberBox");
      m_Factory    : access INumberBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.INumberBox;
   begin
      return RetVal : NumberBox do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INumberBox := new WinUI3.Microsoft.UI.Xaml.Controls.INumberBox;
            Retval.m_INumberBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for NumberBox

   function get_MinimumProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinimumProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaximumProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaximumProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ValueProperty_NumberBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SmallChangeProperty_NumberBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SmallChangeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LargeChangeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LargeChangeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextProperty_NumberBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_NumberBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_NumberBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_NumberBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFlyoutProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextReadingOrderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextReadingOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocusProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreventKeyboardDisplayOnProgrammaticFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty_NumberBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ValidationModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ValidationModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SpinButtonPlacementModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SpinButtonPlacementModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsWrapEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsWrapEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AcceptsExpressionProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AcceptsExpressionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NumberFormatterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.NumberBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.INumberBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INumberBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NumberFormatterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NumberBox

   function get_Minimum
   (
      this : in out NumberBox
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INumberBox.all.get_Minimum (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Minimum
   (
      this : in out NumberBox;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_Minimum (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Maximum
   (
      this : in out NumberBox
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INumberBox.all.get_Maximum (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Maximum
   (
      this : in out NumberBox;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_Maximum (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Value
   (
      this : in out NumberBox
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INumberBox.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out NumberBox;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_Value (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SmallChange
   (
      this : in out NumberBox
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INumberBox.all.get_SmallChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SmallChange
   (
      this : in out NumberBox;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_SmallChange (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LargeChange
   (
      this : in out NumberBox
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INumberBox.all.get_LargeChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LargeChange
   (
      this : in out NumberBox;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_LargeChange (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Text
   (
      this : in out NumberBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_INumberBox.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out NumberBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_INumberBox.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Header
   (
      this : in out NumberBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INumberBox.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out NumberBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out NumberBox
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_INumberBox.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out NumberBox;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderText
   (
      this : in out NumberBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_INumberBox.all.get_PlaceholderText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out NumberBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_INumberBox.all.put_PlaceholderText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectionFlyout
   (
      this : in out NumberBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := this.m_INumberBox.all.get_SelectionFlyout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionFlyout
   (
      this : in out NumberBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_SelectionFlyout (value.m_IFlyoutBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionHighlightColor
   (
      this : in out NumberBox
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush do
         Hr := this.m_INumberBox.all.get_SelectionHighlightColor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColor
   (
      this : in out NumberBox;
      value : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_SelectionHighlightColor (value.m_ISolidColorBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextReadingOrder
   (
      this : in out NumberBox
   )
   return WinUI3.Microsoft.UI.Xaml.TextReadingOrder is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextReadingOrder;
   begin
      Hr := this.m_INumberBox.all.get_TextReadingOrder (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextReadingOrder
   (
      this : in out NumberBox;
      value : WinUI3.Microsoft.UI.Xaml.TextReadingOrder
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_TextReadingOrder (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out NumberBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INumberBox.all.get_PreventKeyboardDisplayOnProgrammaticFocus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out NumberBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_PreventKeyboardDisplayOnProgrammaticFocus (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Description
   (
      this : in out NumberBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INumberBox.all.get_Description (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out NumberBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_Description (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ValidationMode
   (
      this : in out NumberBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NumberBoxValidationMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.NumberBoxValidationMode;
   begin
      Hr := this.m_INumberBox.all.get_ValidationMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ValidationMode
   (
      this : in out NumberBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.NumberBoxValidationMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_ValidationMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SpinButtonPlacementMode
   (
      this : in out NumberBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.NumberBoxSpinButtonPlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.NumberBoxSpinButtonPlacementMode;
   begin
      Hr := this.m_INumberBox.all.get_SpinButtonPlacementMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SpinButtonPlacementMode
   (
      this : in out NumberBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.NumberBoxSpinButtonPlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_SpinButtonPlacementMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsWrapEnabled
   (
      this : in out NumberBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INumberBox.all.get_IsWrapEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsWrapEnabled
   (
      this : in out NumberBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_IsWrapEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AcceptsExpression
   (
      this : in out NumberBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INumberBox.all.get_AcceptsExpression (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AcceptsExpression
   (
      this : in out NumberBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_AcceptsExpression (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NumberFormatter
   (
      this : in out NumberBox
   )
   return WinUI3.Windows.Globalization.NumberFormatting.INumberFormatter2 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Globalization.NumberFormatting.INumberFormatter2;
   begin
      Hr := this.m_INumberBox.all.get_NumberFormatter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NumberFormatter
   (
      this : in out NumberBox;
      value : WinUI3.Windows.Globalization.NumberFormatting.INumberFormatter2
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.put_NumberFormatter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ValueChanged
   (
      this : in out NumberBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_INumberBox.all.add_ValueChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ValueChanged
   (
      this : in out NumberBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INumberBox.all.remove_ValueChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NumberBoxValueChangedEventArgs

   procedure Initialize (this : in out NumberBoxValueChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NumberBoxValueChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INumberBoxValueChangedEventArgs, INumberBoxValueChangedEventArgs_Ptr);
   begin
      if this.m_INumberBoxValueChangedEventArgs /= null then
         if this.m_INumberBoxValueChangedEventArgs.all /= null then
            temp := this.m_INumberBoxValueChangedEventArgs.all.Release;
            Free (this.m_INumberBoxValueChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NumberBoxValueChangedEventArgs

   function get_OldValue
   (
      this : in out NumberBoxValueChangedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INumberBoxValueChangedEventArgs.all.get_OldValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewValue
   (
      this : in out NumberBoxValueChangedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INumberBoxValueChangedEventArgs.all.get_NewValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UserControl

   procedure Initialize (this : in out UserControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out UserControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUserControl, IUserControl_Ptr);
   begin
      if this.m_IUserControl /= null then
         if this.m_IUserControl.all /= null then
            temp := this.m_IUserControl.all.Release;
            Free (this.m_IUserControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for UserControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return UserControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IUserControl");
      m_Factory    : access IUserControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IUserControl;
   begin
      return RetVal : UserControl do
         Hr := RoGetActivationFactory (m_hString, IID_IUserControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IUserControl := new WinUI3.Microsoft.UI.Xaml.Controls.IUserControl;
            Retval.m_IUserControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for UserControl

   function get_ContentProperty_UserControl
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.UserControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IUserControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUserControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UserControl

   function get_Content
   (
      this : in out UserControl
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IUserControl.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out UserControl;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUserControl.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Page

   procedure Initialize (this : in out Page) is
   begin
      null;
   end;

   procedure Finalize (this : in out Page) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPage, IPage_Ptr);
   begin
      if this.m_IPage /= null then
         if this.m_IPage.all /= null then
            temp := this.m_IPage.all.Release;
            Free (this.m_IPage);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Page

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Page is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPage");
      m_Factory    : access IPageFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPage;
   begin
      return RetVal : Page do
         Hr := RoGetActivationFactory (m_hString, IID_IPageFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPage := new WinUI3.Microsoft.UI.Xaml.Controls.IPage;
            Retval.m_IPage.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Page

   function get_FrameProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Page");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FrameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TopAppBarProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Page");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopAppBarProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BottomAppBarProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Page");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BottomAppBarProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Page

   function get_Frame
   (
      this : in out Page
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Frame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IFrame;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Frame do
         Hr := this.m_IPage.all.get_Frame (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFrame := new WinUI3.Microsoft.UI.Xaml.Controls.IFrame;
         Retval.m_IFrame.all := m_ComRetVal;
      end return;
   end;

   function get_NavigationCacheMode
   (
      this : in out Page
   )
   return WinUI3.Microsoft.UI.Xaml.Navigation.NavigationCacheMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Navigation.NavigationCacheMode;
   begin
      Hr := this.m_IPage.all.get_NavigationCacheMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NavigationCacheMode
   (
      this : in out Page;
      value : WinUI3.Microsoft.UI.Xaml.Navigation.NavigationCacheMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPage.all.put_NavigationCacheMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopAppBar
   (
      this : in out Page
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.AppBar'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAppBar;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.AppBar do
         Hr := this.m_IPage.all.get_TopAppBar (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppBar := new WinUI3.Microsoft.UI.Xaml.Controls.IAppBar;
         Retval.m_IAppBar.all := m_ComRetVal;
      end return;
   end;

   procedure put_TopAppBar
   (
      this : in out Page;
      value : WinUI3.Microsoft.UI.Xaml.Controls.AppBar'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPage.all.put_TopAppBar (value.m_IAppBar.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BottomAppBar
   (
      this : in out Page
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.AppBar'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IAppBar;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.AppBar do
         Hr := this.m_IPage.all.get_BottomAppBar (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppBar := new WinUI3.Microsoft.UI.Xaml.Controls.IAppBar;
         Retval.m_IAppBar.all := m_ComRetVal;
      end return;
   end;

   procedure put_BottomAppBar
   (
      this : in out Page;
      value : WinUI3.Microsoft.UI.Xaml.Controls.AppBar'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPage.all.put_BottomAppBar (value.m_IAppBar.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnNavigatedFrom
   (
      this : in out Page;
      e : WinUI3.Microsoft.UI.Xaml.Navigation.NavigationEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IPageOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IPage_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IPageOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IPageOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPage.all);
      Hr := m_Interface.OnNavigatedFrom (e.m_INavigationEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnNavigatedTo
   (
      this : in out Page;
      e : WinUI3.Microsoft.UI.Xaml.Navigation.NavigationEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IPageOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IPage_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IPageOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IPageOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPage.all);
      Hr := m_Interface.OnNavigatedTo (e.m_INavigationEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnNavigatingFrom
   (
      this : in out Page;
      e : WinUI3.Microsoft.UI.Xaml.Navigation.NavigatingCancelEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IPageOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IPage_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IPageOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IPageOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPage.all);
      Hr := m_Interface.OnNavigatingFrom (e.m_INavigatingCancelEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ParallaxView

   procedure Initialize (this : in out ParallaxView) is
   begin
      null;
   end;

   procedure Finalize (this : in out ParallaxView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IParallaxView, IParallaxView_Ptr);
   begin
      if this.m_IParallaxView /= null then
         if this.m_IParallaxView.all /= null then
            temp := this.m_IParallaxView.all.Release;
            Free (this.m_IParallaxView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ParallaxView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ParallaxView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IParallaxView");
      m_Factory    : access IParallaxViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IParallaxView;
   begin
      return RetVal : ParallaxView do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IParallaxView := new WinUI3.Microsoft.UI.Xaml.Controls.IParallaxView;
            Retval.m_IParallaxView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ParallaxView

   function get_ChildProperty_ParallaxView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalSourceEndOffsetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalSourceEndOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalSourceOffsetKindProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalSourceOffsetKindProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalSourceStartOffsetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalSourceStartOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxHorizontalShiftRatioProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxHorizontalShiftRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalShiftProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalShiftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHorizontalShiftClampedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHorizontalShiftClampedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsVerticalShiftClampedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVerticalShiftClampedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SourceProperty_ParallaxView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalSourceEndOffsetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalSourceEndOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalSourceOffsetKindProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalSourceOffsetKindProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalSourceStartOffsetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalSourceStartOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxVerticalShiftRatioProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxVerticalShiftRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalShiftProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalShiftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ParallaxView

   function get_Child
   (
      this : in out ParallaxView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IParallaxView.all.get_Child (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Child
   (
      this : in out ParallaxView;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_Child (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalShift
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_HorizontalShift (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalShift
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_HorizontalShift (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalSourceEndOffset
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_HorizontalSourceEndOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalSourceEndOffset
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_HorizontalSourceEndOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalSourceOffsetKind
   (
      this : in out ParallaxView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ParallaxSourceOffsetKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ParallaxSourceOffsetKind;
   begin
      Hr := this.m_IParallaxView.all.get_HorizontalSourceOffsetKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalSourceOffsetKind
   (
      this : in out ParallaxView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ParallaxSourceOffsetKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_HorizontalSourceOffsetKind (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalSourceStartOffset
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_HorizontalSourceStartOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalSourceStartOffset
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_HorizontalSourceStartOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHorizontalShiftClamped
   (
      this : in out ParallaxView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IParallaxView.all.get_IsHorizontalShiftClamped (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHorizontalShiftClamped
   (
      this : in out ParallaxView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_IsHorizontalShiftClamped (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVerticalShiftClamped
   (
      this : in out ParallaxView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IParallaxView.all.get_IsVerticalShiftClamped (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsVerticalShiftClamped
   (
      this : in out ParallaxView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_IsVerticalShiftClamped (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxHorizontalShiftRatio
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_MaxHorizontalShiftRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxHorizontalShiftRatio
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_MaxHorizontalShiftRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxVerticalShiftRatio
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_MaxVerticalShiftRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxVerticalShiftRatio
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_MaxVerticalShiftRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Source
   (
      this : in out ParallaxView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IParallaxView.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out ParallaxView;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_Source (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalShift
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_VerticalShift (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalShift
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_VerticalShift (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalSourceEndOffset
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_VerticalSourceEndOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalSourceEndOffset
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_VerticalSourceEndOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalSourceOffsetKind
   (
      this : in out ParallaxView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ParallaxSourceOffsetKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ParallaxSourceOffsetKind;
   begin
      Hr := this.m_IParallaxView.all.get_VerticalSourceOffsetKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalSourceOffsetKind
   (
      this : in out ParallaxView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ParallaxSourceOffsetKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_VerticalSourceOffsetKind (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalSourceStartOffset
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_VerticalSourceStartOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalSourceStartOffset
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_VerticalSourceStartOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RefreshAutomaticHorizontalOffsets
   (
      this : in out ParallaxView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.RefreshAutomaticHorizontalOffsets;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RefreshAutomaticVerticalOffsets
   (
      this : in out ParallaxView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.RefreshAutomaticVerticalOffsets;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PasswordBox

   procedure Initialize (this : in out PasswordBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out PasswordBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPasswordBox, IPasswordBox_Ptr);
   begin
      if this.m_IPasswordBox /= null then
         if this.m_IPasswordBox.all /= null then
            temp := this.m_IPasswordBox.all.Release;
            Free (this.m_IPasswordBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PasswordBox

   function Constructor return PasswordBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPasswordBox");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBox;
   begin
      return RetVal : PasswordBox do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPasswordBox := new WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBox;
            Retval.m_IPasswordBox.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PasswordBox

   function get_PasswordProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PasswordProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PasswordCharProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PasswordCharProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPasswordRevealButtonEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPasswordRevealButtonEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLengthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_PasswordBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_PasswordBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_PasswordBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorProperty_PasswordBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocusProperty_PasswordBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreventKeyboardDisplayOnProgrammaticFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PasswordRevealModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PasswordRevealModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextReadingOrderProperty_PasswordBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextReadingOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InputScopeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InputScopeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanPasteClipboardContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanPasteClipboardContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFlyoutProperty_PasswordBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty_PasswordBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PasswordBox

   function get_Password
   (
      this : in out PasswordBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPasswordBox.all.get_Password (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Password
   (
      this : in out PasswordBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPasswordBox.all.put_Password (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PasswordChar
   (
      this : in out PasswordBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPasswordBox.all.get_PasswordChar (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PasswordChar
   (
      this : in out PasswordBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPasswordBox.all.put_PasswordChar (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsPasswordRevealButtonEnabled
   (
      this : in out PasswordBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPasswordBox.all.get_IsPasswordRevealButtonEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPasswordRevealButtonEnabled
   (
      this : in out PasswordBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_IsPasswordRevealButtonEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxLength
   (
      this : in out PasswordBox
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IPasswordBox.all.get_MaxLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLength
   (
      this : in out PasswordBox;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_MaxLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out PasswordBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IPasswordBox.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out PasswordBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out PasswordBox
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IPasswordBox.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out PasswordBox;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderText
   (
      this : in out PasswordBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPasswordBox.all.get_PlaceholderText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out PasswordBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPasswordBox.all.put_PlaceholderText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectionHighlightColor
   (
      this : in out PasswordBox
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush do
         Hr := this.m_IPasswordBox.all.get_SelectionHighlightColor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColor
   (
      this : in out PasswordBox;
      value : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_SelectionHighlightColor (value.m_ISolidColorBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out PasswordBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPasswordBox.all.get_PreventKeyboardDisplayOnProgrammaticFocus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out PasswordBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_PreventKeyboardDisplayOnProgrammaticFocus (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PasswordRevealMode
   (
      this : in out PasswordBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PasswordRevealMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.PasswordRevealMode;
   begin
      Hr := this.m_IPasswordBox.all.get_PasswordRevealMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PasswordRevealMode
   (
      this : in out PasswordBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.PasswordRevealMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_PasswordRevealMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextReadingOrder
   (
      this : in out PasswordBox
   )
   return WinUI3.Microsoft.UI.Xaml.TextReadingOrder is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextReadingOrder;
   begin
      Hr := this.m_IPasswordBox.all.get_TextReadingOrder (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextReadingOrder
   (
      this : in out PasswordBox;
      value : WinUI3.Microsoft.UI.Xaml.TextReadingOrder
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_TextReadingOrder (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InputScope
   (
      this : in out PasswordBox
   )
   return WinUI3.Microsoft.UI.Xaml.Input.InputScope'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.IInputScope;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Input.InputScope do
         Hr := this.m_IPasswordBox.all.get_InputScope (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInputScope := new WinUI3.Microsoft.UI.Xaml.Input.IInputScope;
         Retval.m_IInputScope.all := m_ComRetVal;
      end return;
   end;

   procedure put_InputScope
   (
      this : in out PasswordBox;
      value : WinUI3.Microsoft.UI.Xaml.Input.InputScope'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_InputScope (value.m_IInputScope.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanPasteClipboardContent
   (
      this : in out PasswordBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPasswordBox.all.get_CanPasteClipboardContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionFlyout
   (
      this : in out PasswordBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := this.m_IPasswordBox.all.get_SelectionFlyout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionFlyout
   (
      this : in out PasswordBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_SelectionFlyout (value.m_IFlyoutBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Description
   (
      this : in out PasswordBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IPasswordBox.all.get_Description (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out PasswordBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_Description (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PasswordChanged
   (
      this : in out PasswordBox;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPasswordBox.all.add_PasswordChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PasswordChanged
   (
      this : in out PasswordBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.remove_PasswordChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextMenuOpening
   (
      this : in out PasswordBox;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.ContextMenuOpeningEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPasswordBox.all.add_ContextMenuOpening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextMenuOpening
   (
      this : in out PasswordBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.remove_ContextMenuOpening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Paste
   (
      this : in out PasswordBox;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.TextControlPasteEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPasswordBox.all.add_Paste (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Paste
   (
      this : in out PasswordBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.remove_Paste (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PasswordChanging
   (
      this : in out PasswordBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPasswordBox.all.add_PasswordChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PasswordChanging
   (
      this : in out PasswordBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.remove_PasswordChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out PasswordBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PasteFromClipboard
   (
      this : in out PasswordBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.PasteFromClipboard;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PasswordBoxPasswordChangingEventArgs

   procedure Initialize (this : in out PasswordBoxPasswordChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PasswordBoxPasswordChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPasswordBoxPasswordChangingEventArgs, IPasswordBoxPasswordChangingEventArgs_Ptr);
   begin
      if this.m_IPasswordBoxPasswordChangingEventArgs /= null then
         if this.m_IPasswordBoxPasswordChangingEventArgs.all /= null then
            temp := this.m_IPasswordBoxPasswordChangingEventArgs.all.Release;
            Free (this.m_IPasswordBoxPasswordChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PasswordBoxPasswordChangingEventArgs

   function get_IsContentChanging
   (
      this : in out PasswordBoxPasswordChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPasswordBoxPasswordChangingEventArgs.all.get_IsContentChanging (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PathIcon

   procedure Initialize (this : in out PathIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out PathIcon) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPathIcon, IPathIcon_Ptr);
   begin
      if this.m_IPathIcon /= null then
         if this.m_IPathIcon.all /= null then
            temp := this.m_IPathIcon.all.Release;
            Free (this.m_IPathIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PathIcon

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PathIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPathIcon");
      m_Factory    : access IPathIconFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPathIcon;
   begin
      return RetVal : PathIcon do
         Hr := RoGetActivationFactory (m_hString, IID_IPathIconFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPathIcon := new WinUI3.Microsoft.UI.Xaml.Controls.IPathIcon;
            Retval.m_IPathIcon.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PathIcon

   function get_DataProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PathIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPathIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPathIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DataProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PathIcon

   function get_Data
   (
      this : in out PathIcon
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Geometry'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IGeometry;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Geometry do
         Hr := this.m_IPathIcon.all.get_Data (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeometry := new WinUI3.Microsoft.UI.Xaml.Media.IGeometry;
         Retval.m_IGeometry.all := m_ComRetVal;
      end return;
   end;

   procedure put_Data
   (
      this : in out PathIcon;
      value : WinUI3.Microsoft.UI.Xaml.Media.Geometry'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPathIcon.all.put_Data (value.m_IGeometry.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PathIconSource

   procedure Initialize (this : in out PathIconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out PathIconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPathIconSource, IPathIconSource_Ptr);
   begin
      if this.m_IPathIconSource /= null then
         if this.m_IPathIconSource.all /= null then
            temp := this.m_IPathIconSource.all.Release;
            Free (this.m_IPathIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PathIconSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PathIconSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPathIconSource");
      m_Factory    : access IPathIconSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPathIconSource;
   begin
      return RetVal : PathIconSource do
         Hr := RoGetActivationFactory (m_hString, IID_IPathIconSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPathIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IPathIconSource;
            Retval.m_IPathIconSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PathIconSource

   function get_DataProperty_PathIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PathIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPathIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPathIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DataProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PathIconSource

   function get_Data
   (
      this : in out PathIconSource
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Geometry'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IGeometry;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Geometry do
         Hr := this.m_IPathIconSource.all.get_Data (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeometry := new WinUI3.Microsoft.UI.Xaml.Media.IGeometry;
         Retval.m_IGeometry.all := m_ComRetVal;
      end return;
   end;

   procedure put_Data
   (
      this : in out PathIconSource;
      value : WinUI3.Microsoft.UI.Xaml.Media.Geometry'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPathIconSource.all.put_Data (value.m_IGeometry.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PersonPicture

   procedure Initialize (this : in out PersonPicture) is
   begin
      null;
   end;

   procedure Finalize (this : in out PersonPicture) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPersonPicture, IPersonPicture_Ptr);
   begin
      if this.m_IPersonPicture /= null then
         if this.m_IPersonPicture.all /= null then
            temp := this.m_IPersonPicture.all.Release;
            Free (this.m_IPersonPicture);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PersonPicture

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PersonPicture is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPersonPicture");
      m_Factory    : access IPersonPictureFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPersonPicture;
   begin
      return RetVal : PersonPicture do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPersonPicture := new WinUI3.Microsoft.UI.Xaml.Controls.IPersonPicture;
            Retval.m_IPersonPicture.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PersonPicture

   function get_BadgeNumberProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BadgeNumberProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BadgeGlyphProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BadgeGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BadgeImageSourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BadgeImageSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BadgeTextProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BadgeTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsGroupProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsGroupProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContactProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayNameProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InitialsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InitialsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreferSmallImageProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreferSmallImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ProfilePictureProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ProfilePictureProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PersonPicture

   function get_BadgeNumber
   (
      this : in out PersonPicture
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IPersonPicture.all.get_BadgeNumber (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BadgeNumber
   (
      this : in out PersonPicture;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_BadgeNumber (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BadgeGlyph
   (
      this : in out PersonPicture
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPersonPicture.all.get_BadgeGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_BadgeGlyph
   (
      this : in out PersonPicture;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPersonPicture.all.put_BadgeGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_BadgeImageSource
   (
      this : in out PersonPicture
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IPersonPicture.all.get_BadgeImageSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_BadgeImageSource
   (
      this : in out PersonPicture;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_BadgeImageSource (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BadgeText
   (
      this : in out PersonPicture
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPersonPicture.all.get_BadgeText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_BadgeText
   (
      this : in out PersonPicture;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPersonPicture.all.put_BadgeText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsGroup
   (
      this : in out PersonPicture
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPersonPicture.all.get_IsGroup (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsGroup
   (
      this : in out PersonPicture;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_IsGroup (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Contact
   (
      this : in out PersonPicture
   )
   return WinUI3.Windows.ApplicationModel.Contacts.Contact'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.Contacts.IContact;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.Contacts.Contact do
         Hr := this.m_IPersonPicture.all.get_Contact (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IContact := new WinUI3.Windows.ApplicationModel.Contacts.IContact;
         Retval.m_IContact.all := m_ComRetVal;
      end return;
   end;

   procedure put_Contact
   (
      this : in out PersonPicture;
      value : WinUI3.Windows.ApplicationModel.Contacts.Contact'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_Contact (value.m_IContact.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayName
   (
      this : in out PersonPicture
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPersonPicture.all.get_DisplayName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DisplayName
   (
      this : in out PersonPicture;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPersonPicture.all.put_DisplayName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Initials
   (
      this : in out PersonPicture
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPersonPicture.all.get_Initials (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Initials
   (
      this : in out PersonPicture;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPersonPicture.all.put_Initials (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PreferSmallImage
   (
      this : in out PersonPicture
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPersonPicture.all.get_PreferSmallImage (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreferSmallImage
   (
      this : in out PersonPicture;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_PreferSmallImage (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ProfilePicture
   (
      this : in out PersonPicture
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IPersonPicture.all.get_ProfilePicture (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_ProfilePicture
   (
      this : in out PersonPicture;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_ProfilePicture (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out PersonPicture
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PersonPictureTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.PersonPictureTemplateSettings do
         Hr := this.m_IPersonPicture.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPersonPictureTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.IPersonPictureTemplateSettings;
         Retval.m_IPersonPictureTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PersonPictureTemplateSettings

   procedure Initialize (this : in out PersonPictureTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out PersonPictureTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPersonPictureTemplateSettings, IPersonPictureTemplateSettings_Ptr);
   begin
      if this.m_IPersonPictureTemplateSettings /= null then
         if this.m_IPersonPictureTemplateSettings.all /= null then
            temp := this.m_IPersonPictureTemplateSettings.all.Release;
            Free (this.m_IPersonPictureTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PersonPictureTemplateSettings

   function get_ActualInitials
   (
      this : in out PersonPictureTemplateSettings
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPersonPictureTemplateSettings.all.get_ActualInitials (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ActualImageBrush
   (
      this : in out PersonPictureTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageBrush do
         Hr := this.m_IPersonPictureTemplateSettings.all.get_ActualImageBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageBrush := new WinUI3.Microsoft.UI.Xaml.Media.IImageBrush;
         Retval.m_IImageBrush.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PickerConfirmedEventArgs

   procedure Initialize (this : in out PickerConfirmedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PickerConfirmedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPickerConfirmedEventArgs, IPickerConfirmedEventArgs_Ptr);
   begin
      if this.m_IPickerConfirmedEventArgs /= null then
         if this.m_IPickerConfirmedEventArgs.all /= null then
            temp := this.m_IPickerConfirmedEventArgs.all.Release;
            Free (this.m_IPickerConfirmedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PickerConfirmedEventArgs

   function Constructor return PickerConfirmedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPickerConfirmedEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPickerConfirmedEventArgs;
   begin
      return RetVal : PickerConfirmedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPickerConfirmedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IPickerConfirmedEventArgs;
            Retval.m_IPickerConfirmedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PickerConfirmedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PickerFlyout

   procedure Initialize (this : in out PickerFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out PickerFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPickerFlyout, IPickerFlyout_Ptr);
   begin
      if this.m_IPickerFlyout /= null then
         if this.m_IPickerFlyout.all /= null then
            temp := this.m_IPickerFlyout.all.Release;
            Free (this.m_IPickerFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PickerFlyout

   function Constructor return PickerFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPickerFlyout");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPickerFlyout;
   begin
      return RetVal : PickerFlyout do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPickerFlyout := new WinUI3.Microsoft.UI.Xaml.Controls.IPickerFlyout;
            Retval.m_IPickerFlyout.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PickerFlyout

   function get_ContentProperty_PickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ConfirmationButtonsVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ConfirmationButtonsVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PickerFlyout

   function get_Content
   (
      this : in out PickerFlyout
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IPickerFlyout.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out PickerFlyout;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPickerFlyout.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ConfirmationButtonsVisible
   (
      this : in out PickerFlyout
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPickerFlyout.all.get_ConfirmationButtonsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ConfirmationButtonsVisible
   (
      this : in out PickerFlyout;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPickerFlyout.all.put_ConfirmationButtonsVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Confirmed
   (
      this : in out PickerFlyout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPickerFlyout.all.add_Confirmed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Confirmed
   (
      this : in out PickerFlyout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPickerFlyout.all.remove_Confirmed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAtAsync
   (
      this : in out PickerFlyout;
      target : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Boolean;
      m_IID            : aliased WinUI3.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinUI3.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IPickerFlyout.all.ShowAtAsync (target.m_IFrameworkElement.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PickerFlyoutPresenter

   procedure Initialize (this : in out PickerFlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out PickerFlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPickerFlyoutPresenter, IPickerFlyoutPresenter_Ptr);
   begin
      if this.m_IPickerFlyoutPresenter /= null then
         if this.m_IPickerFlyoutPresenter.all /= null then
            temp := this.m_IPickerFlyoutPresenter.all.Release;
            Free (this.m_IPickerFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PickerFlyoutPresenter

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PipsPager

   procedure Initialize (this : in out PipsPager) is
   begin
      null;
   end;

   procedure Finalize (this : in out PipsPager) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPipsPager, IPipsPager_Ptr);
   begin
      if this.m_IPipsPager /= null then
         if this.m_IPipsPager.all /= null then
            temp := this.m_IPipsPager.all.Release;
            Free (this.m_IPipsPager);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PipsPager

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PipsPager is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPipsPager");
      m_Factory    : access IPipsPagerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPipsPager;
   begin
      return RetVal : PipsPager do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPipsPager := new WinUI3.Microsoft.UI.Xaml.Controls.IPipsPager;
            Retval.m_IPipsPager.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PipsPager

   function get_WrapModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PipsPager");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_WrapModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NumberOfPagesProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PipsPager");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NumberOfPagesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPageIndexProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PipsPager");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPageIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxVisiblePipsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PipsPager");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxVisiblePipsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_PipsPager
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PipsPager");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreviousButtonVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PipsPager");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreviousButtonVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NextButtonVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PipsPager");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NextButtonVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreviousButtonStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PipsPager");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreviousButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NextButtonStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PipsPager");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NextButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPipStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PipsPager");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPipStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NormalPipStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PipsPager");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPipsPagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NormalPipStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PipsPager

   function get_NumberOfPages
   (
      this : in out PipsPager
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IPipsPager.all.get_NumberOfPages (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NumberOfPages
   (
      this : in out PipsPager;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPipsPager.all.put_NumberOfPages (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPageIndex
   (
      this : in out PipsPager
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IPipsPager.all.get_SelectedPageIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedPageIndex
   (
      this : in out PipsPager;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPipsPager.all.put_SelectedPageIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxVisiblePips
   (
      this : in out PipsPager
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IPipsPager.all.get_MaxVisiblePips (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxVisiblePips
   (
      this : in out PipsPager;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPipsPager.all.put_MaxVisiblePips (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out PipsPager
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IPipsPager.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out PipsPager;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPipsPager.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreviousButtonVisibility
   (
      this : in out PipsPager
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PipsPagerButtonVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.PipsPagerButtonVisibility;
   begin
      Hr := this.m_IPipsPager.all.get_PreviousButtonVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreviousButtonVisibility
   (
      this : in out PipsPager;
      value : WinUI3.Microsoft.UI.Xaml.Controls.PipsPagerButtonVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPipsPager.all.put_PreviousButtonVisibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NextButtonVisibility
   (
      this : in out PipsPager
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PipsPagerButtonVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.PipsPagerButtonVisibility;
   begin
      Hr := this.m_IPipsPager.all.get_NextButtonVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NextButtonVisibility
   (
      this : in out PipsPager;
      value : WinUI3.Microsoft.UI.Xaml.Controls.PipsPagerButtonVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPipsPager.all.put_NextButtonVisibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreviousButtonStyle
   (
      this : in out PipsPager
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IPipsPager.all.get_PreviousButtonStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_PreviousButtonStyle
   (
      this : in out PipsPager;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPipsPager.all.put_PreviousButtonStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NextButtonStyle
   (
      this : in out PipsPager
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IPipsPager.all.get_NextButtonStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_NextButtonStyle
   (
      this : in out PipsPager;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPipsPager.all.put_NextButtonStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPipStyle
   (
      this : in out PipsPager
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IPipsPager.all.get_SelectedPipStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedPipStyle
   (
      this : in out PipsPager;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPipsPager.all.put_SelectedPipStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NormalPipStyle
   (
      this : in out PipsPager
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IPipsPager.all.get_NormalPipStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_NormalPipStyle
   (
      this : in out PipsPager;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPipsPager.all.put_NormalPipStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectedIndexChanged
   (
      this : in out PipsPager;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPipsPager.all.add_SelectedIndexChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectedIndexChanged
   (
      this : in out PipsPager;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPipsPager.all.remove_SelectedIndexChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out PipsPager
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PipsPagerTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.PipsPagerTemplateSettings do
         Hr := this.m_IPipsPager.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPipsPagerTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.IPipsPagerTemplateSettings;
         Retval.m_IPipsPagerTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_WrapMode
   (
      this : in out PipsPager
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PipsPagerWrapMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IPipsPager2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.PipsPagerWrapMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IPipsPager_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IPipsPager2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IPipsPager2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPipsPager.all);
      Hr := m_Interface.get_WrapMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_WrapMode
   (
      this : in out PipsPager;
      value : WinUI3.Microsoft.UI.Xaml.Controls.PipsPagerWrapMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IPipsPager2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IPipsPager_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IPipsPager2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IPipsPager2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPipsPager.all);
      Hr := m_Interface.put_WrapMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PipsPagerSelectedIndexChangedEventArgs

   procedure Initialize (this : in out PipsPagerSelectedIndexChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PipsPagerSelectedIndexChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPipsPagerSelectedIndexChangedEventArgs, IPipsPagerSelectedIndexChangedEventArgs_Ptr);
   begin
      if this.m_IPipsPagerSelectedIndexChangedEventArgs /= null then
         if this.m_IPipsPagerSelectedIndexChangedEventArgs.all /= null then
            temp := this.m_IPipsPagerSelectedIndexChangedEventArgs.all.Release;
            Free (this.m_IPipsPagerSelectedIndexChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PipsPagerSelectedIndexChangedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PipsPagerTemplateSettings

   procedure Initialize (this : in out PipsPagerTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out PipsPagerTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPipsPagerTemplateSettings, IPipsPagerTemplateSettings_Ptr);
   begin
      if this.m_IPipsPagerTemplateSettings /= null then
         if this.m_IPipsPagerTemplateSettings.all /= null then
            temp := this.m_IPipsPagerTemplateSettings.all.Release;
            Free (this.m_IPipsPagerTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PipsPagerTemplateSettings

   function get_PipsPagerItems
   (
      this : in out PipsPagerTemplateSettings
   )
   return IVector_Int32.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_Int32.Kind;
   begin
      Hr := this.m_IPipsPagerTemplateSettings.all.get_PipsPagerItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_Int32 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Pivot

   procedure Initialize (this : in out Pivot) is
   begin
      null;
   end;

   procedure Finalize (this : in out Pivot) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPivot, IPivot_Ptr);
   begin
      if this.m_IPivot /= null then
         if this.m_IPivot.all /= null then
            temp := this.m_IPivot.all.Release;
            Free (this.m_IPivot);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Pivot

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Pivot is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPivot");
      m_Factory    : access IPivotFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPivot;
   begin
      return RetVal : Pivot do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPivot := new WinUI3.Microsoft.UI.Xaml.Controls.IPivot;
            Retval.m_IPivot.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Pivot

   function get_TitleProperty_Pivot
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TitleTemplateProperty_Pivot
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LeftHeaderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LeftHeaderTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftHeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RightHeaderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RightHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RightHeaderTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RightHeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_Pivot
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedIndexProperty_Pivot
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty_Pivot
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsLockedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsLockedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderFocusVisualPlacementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderFocusVisualPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHeaderItemsCarouselEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHeaderItemsCarouselEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SlideInAnimationGroupProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SlideInAnimationGroupProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetSlideInAnimationGroup
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PivotSlideInAnimationGroup is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.PivotSlideInAnimationGroup;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetSlideInAnimationGroup (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetSlideInAnimationGroup
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Microsoft.UI.Xaml.Controls.PivotSlideInAnimationGroup
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetSlideInAnimationGroup (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Pivot

   function get_Title
   (
      this : in out Pivot
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IPivot.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Title
   (
      this : in out Pivot;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_Title (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TitleTemplate
   (
      this : in out Pivot
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IPivot.all.get_TitleTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_TitleTemplate
   (
      this : in out Pivot;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_TitleTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LeftHeader
   (
      this : in out Pivot
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IPivot.all.get_LeftHeader (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LeftHeader
   (
      this : in out Pivot;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_LeftHeader (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LeftHeaderTemplate
   (
      this : in out Pivot
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IPivot.all.get_LeftHeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_LeftHeaderTemplate
   (
      this : in out Pivot;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_LeftHeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RightHeader
   (
      this : in out Pivot
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IPivot.all.get_RightHeader (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RightHeader
   (
      this : in out Pivot;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_RightHeader (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RightHeaderTemplate
   (
      this : in out Pivot
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IPivot.all.get_RightHeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_RightHeaderTemplate
   (
      this : in out Pivot;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_RightHeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out Pivot
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IPivot.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out Pivot;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedIndex
   (
      this : in out Pivot
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IPivot.all.get_SelectedIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedIndex
   (
      this : in out Pivot;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_SelectedIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItem
   (
      this : in out Pivot
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IPivot.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedItem
   (
      this : in out Pivot;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_SelectedItem (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsLocked
   (
      this : in out Pivot
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPivot.all.get_IsLocked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsLocked
   (
      this : in out Pivot;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_IsLocked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderFocusVisualPlacement
   (
      this : in out Pivot
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PivotHeaderFocusVisualPlacement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.PivotHeaderFocusVisualPlacement;
   begin
      Hr := this.m_IPivot.all.get_HeaderFocusVisualPlacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HeaderFocusVisualPlacement
   (
      this : in out Pivot;
      value : WinUI3.Microsoft.UI.Xaml.Controls.PivotHeaderFocusVisualPlacement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_HeaderFocusVisualPlacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHeaderItemsCarouselEnabled
   (
      this : in out Pivot
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPivot.all.get_IsHeaderItemsCarouselEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHeaderItemsCarouselEnabled
   (
      this : in out Pivot;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_IsHeaderItemsCarouselEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out Pivot;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.SelectionChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPivot.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out Pivot;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PivotItemLoading
   (
      this : in out Pivot;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPivot.all.add_PivotItemLoading (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PivotItemLoading
   (
      this : in out Pivot;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.remove_PivotItemLoading (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PivotItemLoaded
   (
      this : in out Pivot;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPivot.all.add_PivotItemLoaded (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PivotItemLoaded
   (
      this : in out Pivot;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.remove_PivotItemLoaded (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PivotItemUnloading
   (
      this : in out Pivot;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPivot.all.add_PivotItemUnloading (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PivotItemUnloading
   (
      this : in out Pivot;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.remove_PivotItemUnloading (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PivotItemUnloaded
   (
      this : in out Pivot;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPivot.all.add_PivotItemUnloaded (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PivotItemUnloaded
   (
      this : in out Pivot;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.remove_PivotItemUnloaded (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PivotItem

   procedure Initialize (this : in out PivotItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out PivotItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPivotItem, IPivotItem_Ptr);
   begin
      if this.m_IPivotItem /= null then
         if this.m_IPivotItem.all /= null then
            temp := this.m_IPivotItem.all.Release;
            Free (this.m_IPivotItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PivotItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PivotItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPivotItem");
      m_Factory    : access IPivotItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPivotItem;
   begin
      return RetVal : PivotItem do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPivotItem := new WinUI3.Microsoft.UI.Xaml.Controls.IPivotItem;
            Retval.m_IPivotItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PivotItem

   function get_HeaderProperty_PivotItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.PivotItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IPivotItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PivotItem

   function get_Header
   (
      this : in out PivotItem
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IPivotItem.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out PivotItem;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivotItem.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PivotItemEventArgs

   procedure Initialize (this : in out PivotItemEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PivotItemEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPivotItemEventArgs, IPivotItemEventArgs_Ptr);
   begin
      if this.m_IPivotItemEventArgs /= null then
         if this.m_IPivotItemEventArgs.all /= null then
            temp := this.m_IPivotItemEventArgs.all.Release;
            Free (this.m_IPivotItemEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PivotItemEventArgs

   function Constructor return PivotItemEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IPivotItemEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPivotItemEventArgs;
   begin
      return RetVal : PivotItemEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPivotItemEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IPivotItemEventArgs;
            Retval.m_IPivotItemEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PivotItemEventArgs

   function get_Item
   (
      this : in out PivotItemEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.PivotItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IPivotItem;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.PivotItem do
         Hr := this.m_IPivotItemEventArgs.all.get_Item (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPivotItem := new WinUI3.Microsoft.UI.Xaml.Controls.IPivotItem;
         Retval.m_IPivotItem.all := m_ComRetVal;
      end return;
   end;

   procedure put_Item
   (
      this : in out PivotItemEventArgs;
      value : WinUI3.Microsoft.UI.Xaml.Controls.PivotItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivotItemEventArgs.all.put_Item (value.m_IPivotItem.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VirtualizingPanel

   procedure Initialize (this : in out VirtualizingPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out VirtualizingPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVirtualizingPanel, IVirtualizingPanel_Ptr);
   begin
      if this.m_IVirtualizingPanel /= null then
         if this.m_IVirtualizingPanel.all /= null then
            temp := this.m_IVirtualizingPanel.all.Release;
            Free (this.m_IVirtualizingPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VirtualizingPanel

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VirtualizingPanel

   function get_ItemContainerGenerator
   (
      this : in out VirtualizingPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ItemContainerGenerator'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerGenerator;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ItemContainerGenerator do
         Hr := this.m_IVirtualizingPanel.all.get_ItemContainerGenerator (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemContainerGenerator := new WinUI3.Microsoft.UI.Xaml.Controls.IItemContainerGenerator;
         Retval.m_IItemContainerGenerator.all := m_ComRetVal;
      end return;
   end;

   procedure AddInternalChild
   (
      this : in out VirtualizingPanel;
      child : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelProtected, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingPanelProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.AddInternalChild (child.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertInternalChild
   (
      this : in out VirtualizingPanel;
      index : WinUI3.Int32;
      child : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelProtected, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingPanelProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.InsertInternalChild (index, child.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveInternalChildRange
   (
      this : in out VirtualizingPanel;
      index : WinUI3.Int32;
      range_x : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelProtected, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingPanelProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.RemoveInternalChildRange (index, range_x);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemsChanged
   (
      this : in out VirtualizingPanel;
      sender : WinUI3.IInspectable;
      args : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingPanelOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.OnItemsChanged (sender, args.m_IItemsChangedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnClearChildren
   (
      this : in out VirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingPanelOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.OnClearChildren;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure BringIndexIntoView
   (
      this : in out VirtualizingPanel;
      index : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingPanelOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingPanelOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.BringIndexIntoView (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Slider

   procedure Initialize (this : in out Slider) is
   begin
      null;
   end;

   procedure Finalize (this : in out Slider) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISlider, ISlider_Ptr);
   begin
      if this.m_ISlider /= null then
         if this.m_ISlider.all /= null then
            temp := this.m_ISlider.all.Release;
            Free (this.m_ISlider);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Slider

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Slider is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISlider");
      m_Factory    : access ISliderFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISlider;
   begin
      return RetVal : Slider do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISlider := new WinUI3.Microsoft.UI.Xaml.Controls.ISlider;
            Retval.m_ISlider.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Slider

   function get_IntermediateValueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IntermediateValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StepFrequencyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StepFrequencyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SnapsToProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SnapsToProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TickFrequencyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TickFrequencyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TickPlacementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TickPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_Slider
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsDirectionReversedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDirectionReversedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsThumbToolTipEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsThumbToolTipEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ThumbToolTipValueConverterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ThumbToolTipValueConverterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_Slider
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_Slider
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Slider

   function get_IntermediateValue
   (
      this : in out Slider
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISlider.all.get_IntermediateValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IntermediateValue
   (
      this : in out Slider;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_IntermediateValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StepFrequency
   (
      this : in out Slider
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISlider.all.get_StepFrequency (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StepFrequency
   (
      this : in out Slider;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_StepFrequency (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SnapsTo
   (
      this : in out Slider
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SliderSnapsTo is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SliderSnapsTo;
   begin
      Hr := this.m_ISlider.all.get_SnapsTo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SnapsTo
   (
      this : in out Slider;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SliderSnapsTo
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_SnapsTo (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TickFrequency
   (
      this : in out Slider
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISlider.all.get_TickFrequency (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TickFrequency
   (
      this : in out Slider;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_TickFrequency (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TickPlacement
   (
      this : in out Slider
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.TickPlacement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.TickPlacement;
   begin
      Hr := this.m_ISlider.all.get_TickPlacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TickPlacement
   (
      this : in out Slider;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.TickPlacement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_TickPlacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out Slider
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_ISlider.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out Slider;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsDirectionReversed
   (
      this : in out Slider
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISlider.all.get_IsDirectionReversed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDirectionReversed
   (
      this : in out Slider;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_IsDirectionReversed (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsThumbToolTipEnabled
   (
      this : in out Slider
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISlider.all.get_IsThumbToolTipEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsThumbToolTipEnabled
   (
      this : in out Slider;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_IsThumbToolTipEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ThumbToolTipValueConverter
   (
      this : in out Slider
   )
   return WinUI3.Microsoft.UI.Xaml.Data.IValueConverter is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Data.IValueConverter;
   begin
      Hr := this.m_ISlider.all.get_ThumbToolTipValueConverter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ThumbToolTipValueConverter
   (
      this : in out Slider;
      value : WinUI3.Microsoft.UI.Xaml.Data.IValueConverter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_ThumbToolTipValueConverter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out Slider
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ISlider.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out Slider;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out Slider
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_ISlider.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out Slider;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProgressBar

   procedure Initialize (this : in out ProgressBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProgressBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IProgressBar, IProgressBar_Ptr);
   begin
      if this.m_IProgressBar /= null then
         if this.m_IProgressBar.all /= null then
            temp := this.m_IProgressBar.all.Release;
            Free (this.m_IProgressBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ProgressBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ProgressBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IProgressBar");
      m_Factory    : access IProgressBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IProgressBar;
   begin
      return RetVal : ProgressBar do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IProgressBar := new WinUI3.Microsoft.UI.Xaml.Controls.IProgressBar;
            Retval.m_IProgressBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ProgressBar

   function get_IsIndeterminateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ProgressBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IProgressBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsIndeterminateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShowErrorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ProgressBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IProgressBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowErrorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShowPausedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ProgressBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IProgressBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowPausedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProgressBar

   function get_IsIndeterminate
   (
      this : in out ProgressBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IProgressBar.all.get_IsIndeterminate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsIndeterminate
   (
      this : in out ProgressBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressBar.all.put_IsIndeterminate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowError
   (
      this : in out ProgressBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IProgressBar.all.get_ShowError (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowError
   (
      this : in out ProgressBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressBar.all.put_ShowError (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowPaused
   (
      this : in out ProgressBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IProgressBar.all.get_ShowPaused (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowPaused
   (
      this : in out ProgressBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressBar.all.put_ShowPaused (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out ProgressBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IProgressBarTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ProgressBarTemplateSettings do
         Hr := this.m_IProgressBar.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IProgressBarTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.IProgressBarTemplateSettings;
         Retval.m_IProgressBarTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProgressBarTemplateSettings

   procedure Initialize (this : in out ProgressBarTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProgressBarTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IProgressBarTemplateSettings, IProgressBarTemplateSettings_Ptr);
   begin
      if this.m_IProgressBarTemplateSettings /= null then
         if this.m_IProgressBarTemplateSettings.all /= null then
            temp := this.m_IProgressBarTemplateSettings.all.Release;
            Free (this.m_IProgressBarTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProgressBarTemplateSettings

   function get_ContainerAnimationStartPosition
   (
      this : in out ProgressBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressBarTemplateSettings.all.get_ContainerAnimationStartPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContainerAnimationEndPosition
   (
      this : in out ProgressBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressBarTemplateSettings.all.get_ContainerAnimationEndPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Container2AnimationStartPosition
   (
      this : in out ProgressBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressBarTemplateSettings.all.get_Container2AnimationStartPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Container2AnimationEndPosition
   (
      this : in out ProgressBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressBarTemplateSettings.all.get_Container2AnimationEndPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContainerAnimationMidPosition
   (
      this : in out ProgressBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressBarTemplateSettings.all.get_ContainerAnimationMidPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IndicatorLengthDelta
   (
      this : in out ProgressBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressBarTemplateSettings.all.get_IndicatorLengthDelta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ClipRect
   (
      this : in out ProgressBarTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Media.RectangleGeometry'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IRectangleGeometry;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.RectangleGeometry do
         Hr := this.m_IProgressBarTemplateSettings.all.get_ClipRect (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRectangleGeometry := new WinUI3.Microsoft.UI.Xaml.Media.IRectangleGeometry;
         Retval.m_IRectangleGeometry.all := m_ComRetVal;
      end return;
   end;

   function get_EllipseAnimationEndPosition
   (
      this : in out ProgressBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressBarTemplateSettings.all.get_EllipseAnimationEndPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_EllipseAnimationWellPosition
   (
      this : in out ProgressBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressBarTemplateSettings.all.get_EllipseAnimationWellPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_EllipseDiameter
   (
      this : in out ProgressBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressBarTemplateSettings.all.get_EllipseDiameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_EllipseOffset
   (
      this : in out ProgressBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressBarTemplateSettings.all.get_EllipseOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProgressRing

   procedure Initialize (this : in out ProgressRing) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProgressRing) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IProgressRing, IProgressRing_Ptr);
   begin
      if this.m_IProgressRing /= null then
         if this.m_IProgressRing.all /= null then
            temp := this.m_IProgressRing.all.Release;
            Free (this.m_IProgressRing);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ProgressRing

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ProgressRing is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IProgressRing");
      m_Factory    : access IProgressRingFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IProgressRing;
   begin
      return RetVal : ProgressRing do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressRingFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IProgressRing := new WinUI3.Microsoft.UI.Xaml.Controls.IProgressRing;
            Retval.m_IProgressRing.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ProgressRing

   function get_IsActiveProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ProgressRing");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IProgressRingStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressRingStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsActiveProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsIndeterminateProperty_ProgressRing
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ProgressRing");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IProgressRingStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressRingStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsIndeterminateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ValueProperty_ProgressRing
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ProgressRing");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IProgressRingStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressRingStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinimumProperty_ProgressRing
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ProgressRing");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IProgressRingStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressRingStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinimumProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaximumProperty_ProgressRing
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ProgressRing");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IProgressRingStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressRingStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaximumProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProgressRing

   function get_IsActive
   (
      this : in out ProgressRing
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IProgressRing.all.get_IsActive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsActive
   (
      this : in out ProgressRing;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressRing.all.put_IsActive (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsIndeterminate
   (
      this : in out ProgressRing
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IProgressRing.all.get_IsIndeterminate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsIndeterminate
   (
      this : in out ProgressRing;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressRing.all.put_IsIndeterminate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out ProgressRing
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ProgressRingTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IProgressRingTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ProgressRingTemplateSettings do
         Hr := this.m_IProgressRing.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IProgressRingTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.IProgressRingTemplateSettings;
         Retval.m_IProgressRingTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_Value
   (
      this : in out ProgressRing
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressRing.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out ProgressRing;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressRing.all.put_Value (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Minimum
   (
      this : in out ProgressRing
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressRing.all.get_Minimum (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Minimum
   (
      this : in out ProgressRing;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressRing.all.put_Minimum (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Maximum
   (
      this : in out ProgressRing
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressRing.all.get_Maximum (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Maximum
   (
      this : in out ProgressRing;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressRing.all.put_Maximum (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProgressRingTemplateSettings

   procedure Initialize (this : in out ProgressRingTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProgressRingTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IProgressRingTemplateSettings, IProgressRingTemplateSettings_Ptr);
   begin
      if this.m_IProgressRingTemplateSettings /= null then
         if this.m_IProgressRingTemplateSettings.all /= null then
            temp := this.m_IProgressRingTemplateSettings.all.Release;
            Free (this.m_IProgressRingTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProgressRingTemplateSettings

   function get_EllipseDiameter
   (
      this : in out ProgressRingTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressRingTemplateSettings.all.get_EllipseDiameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_EllipseOffset
   (
      this : in out ProgressRingTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IProgressRingTemplateSettings.all.get_EllipseOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MaxSideLength
   (
      this : in out ProgressRingTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IProgressRingTemplateSettings.all.get_MaxSideLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadioButton

   procedure Initialize (this : in out RadioButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadioButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadioButton, IRadioButton_Ptr);
   begin
      if this.m_IRadioButton /= null then
         if this.m_IRadioButton.all /= null then
            temp := this.m_IRadioButton.all.Release;
            Free (this.m_IRadioButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RadioButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RadioButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRadioButton");
      m_Factory    : access IRadioButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRadioButton;
   begin
      return RetVal : RadioButton do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRadioButton := new WinUI3.Microsoft.UI.Xaml.Controls.IRadioButton;
            Retval.m_IRadioButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RadioButton

   function get_GroupNameProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadioButton

   function get_GroupName
   (
      this : in out RadioButton
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRadioButton.all.get_GroupName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_GroupName
   (
      this : in out RadioButton;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRadioButton.all.put_GroupName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadioButtons

   procedure Initialize (this : in out RadioButtons) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadioButtons) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadioButtons, IRadioButtons_Ptr);
   begin
      if this.m_IRadioButtons /= null then
         if this.m_IRadioButtons.all /= null then
            temp := this.m_IRadioButtons.all.Release;
            Free (this.m_IRadioButtons);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RadioButtons

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RadioButtons is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRadioButtons");
      m_Factory    : access IRadioButtonsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRadioButtons;
   begin
      return RetVal : RadioButtons do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRadioButtons := new WinUI3.Microsoft.UI.Xaml.Controls.IRadioButtons;
            Retval.m_IRadioButtons.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RadioButtons

   function get_ItemsSourceProperty_RadioButtons
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioButtons");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioButtonsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsProperty_RadioButtons
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioButtons");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioButtonsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty_RadioButtons
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioButtons");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioButtonsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedIndexProperty_RadioButtons
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioButtons");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioButtonsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty_RadioButtons
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioButtons");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioButtonsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxColumnsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioButtons");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioButtonsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxColumnsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_RadioButtons
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioButtons");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioButtonsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_RadioButtons
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioButtons");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioButtonsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadioButtons

   function get_ItemsSource
   (
      this : in out RadioButtons
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IRadioButtons.all.get_ItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out RadioButtons;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRadioButtons.all.put_ItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Items
   (
      this : in out RadioButtons
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IRadioButtons.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_ItemTemplate
   (
      this : in out RadioButtons
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IRadioButtons.all.get_ItemTemplate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemTemplate
   (
      this : in out RadioButtons;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRadioButtons.all.put_ItemTemplate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ContainerFromIndex
   (
      this : in out RadioButtons;
      index : WinUI3.Int32
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IRadioButtons.all.ContainerFromIndex (index, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_SelectedIndex
   (
      this : in out RadioButtons
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRadioButtons.all.get_SelectedIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedIndex
   (
      this : in out RadioButtons;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRadioButtons.all.put_SelectedIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItem
   (
      this : in out RadioButtons
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IRadioButtons.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedItem
   (
      this : in out RadioButtons;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRadioButtons.all.put_SelectedItem (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out RadioButtons;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.SelectionChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRadioButtons.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out RadioButtons;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRadioButtons.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxColumns
   (
      this : in out RadioButtons
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRadioButtons.all.get_MaxColumns (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxColumns
   (
      this : in out RadioButtons;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRadioButtons.all.put_MaxColumns (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out RadioButtons
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IRadioButtons.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out RadioButtons;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRadioButtons.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out RadioButtons
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IRadioButtons.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out RadioButtons;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRadioButtons.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadioMenuFlyoutItem

   procedure Initialize (this : in out RadioMenuFlyoutItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadioMenuFlyoutItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadioMenuFlyoutItem, IRadioMenuFlyoutItem_Ptr);
   begin
      if this.m_IRadioMenuFlyoutItem /= null then
         if this.m_IRadioMenuFlyoutItem.all /= null then
            temp := this.m_IRadioMenuFlyoutItem.all.Release;
            Free (this.m_IRadioMenuFlyoutItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RadioMenuFlyoutItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RadioMenuFlyoutItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRadioMenuFlyoutItem");
      m_Factory    : access IRadioMenuFlyoutItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRadioMenuFlyoutItem;
   begin
      return RetVal : RadioMenuFlyoutItem do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioMenuFlyoutItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRadioMenuFlyoutItem := new WinUI3.Microsoft.UI.Xaml.Controls.IRadioMenuFlyoutItem;
            Retval.m_IRadioMenuFlyoutItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RadioMenuFlyoutItem

   function get_IsCheckedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCheckedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GroupNameProperty_RadioMenuFlyoutItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AreCheckStatesEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioMenuFlyoutItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioMenuFlyoutItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreCheckStatesEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetAreCheckStatesEnabled
   (
      object : WinUI3.Microsoft.UI.Xaml.Controls.MenuFlyoutSubItem'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioMenuFlyoutItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRadioMenuFlyoutItemStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAreCheckStatesEnabled (object.m_IMenuFlyoutSubItem.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function GetAreCheckStatesEnabled
   (
      object : WinUI3.Microsoft.UI.Xaml.Controls.MenuFlyoutSubItem'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RadioMenuFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRadioMenuFlyoutItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRadioMenuFlyoutItemStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAreCheckStatesEnabled (object.m_IMenuFlyoutSubItem.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadioMenuFlyoutItem

   function get_IsChecked
   (
      this : in out RadioMenuFlyoutItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRadioMenuFlyoutItem.all.get_IsChecked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsChecked
   (
      this : in out RadioMenuFlyoutItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRadioMenuFlyoutItem.all.put_IsChecked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GroupName
   (
      this : in out RadioMenuFlyoutItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRadioMenuFlyoutItem.all.get_GroupName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_GroupName
   (
      this : in out RadioMenuFlyoutItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRadioMenuFlyoutItem.all.put_GroupName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RatingControl

   procedure Initialize (this : in out RatingControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out RatingControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRatingControl, IRatingControl_Ptr);
   begin
      if this.m_IRatingControl /= null then
         if this.m_IRatingControl.all /= null then
            temp := this.m_IRatingControl.all.Release;
            Free (this.m_IRatingControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RatingControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RatingControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRatingControl");
      m_Factory    : access IRatingControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRatingControl;
   begin
      return RetVal : RatingControl do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRatingControl := new WinUI3.Microsoft.UI.Xaml.Controls.IRatingControl;
            Retval.m_IRatingControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RatingControl

   function get_CaptionProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CaptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InitialSetValueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InitialSetValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsClearEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsClearEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsReadOnlyProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsReadOnlyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxRatingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxRatingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderValueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemInfoProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemInfoProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ValueProperty_RatingControl
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RatingControl

   function get_Caption
   (
      this : in out RatingControl
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingControl.all.get_Caption (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Caption
   (
      this : in out RatingControl;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingControl.all.put_Caption (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_InitialSetValue
   (
      this : in out RatingControl
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRatingControl.all.get_InitialSetValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InitialSetValue
   (
      this : in out RatingControl;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_InitialSetValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsClearEnabled
   (
      this : in out RatingControl
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRatingControl.all.get_IsClearEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsClearEnabled
   (
      this : in out RatingControl;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_IsClearEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsReadOnly
   (
      this : in out RatingControl
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRatingControl.all.get_IsReadOnly (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsReadOnly
   (
      this : in out RatingControl;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_IsReadOnly (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxRating
   (
      this : in out RatingControl
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRatingControl.all.get_MaxRating (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxRating
   (
      this : in out RatingControl;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_MaxRating (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderValue
   (
      this : in out RatingControl
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRatingControl.all.get_PlaceholderValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PlaceholderValue
   (
      this : in out RatingControl;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_PlaceholderValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemInfo
   (
      this : in out RatingControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RatingItemInfo'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemInfo;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.RatingItemInfo do
         Hr := this.m_IRatingControl.all.get_ItemInfo (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRatingItemInfo := new WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemInfo;
         Retval.m_IRatingItemInfo.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemInfo
   (
      this : in out RatingControl;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RatingItemInfo'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_ItemInfo (value.m_IRatingItemInfo.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Value
   (
      this : in out RatingControl
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRatingControl.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out RatingControl;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_Value (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ValueChanged
   (
      this : in out RatingControl;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRatingControl.all.add_ValueChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ValueChanged
   (
      this : in out RatingControl;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.remove_ValueChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RatingItemInfo

   procedure Initialize (this : in out RatingItemInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out RatingItemInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRatingItemInfo, IRatingItemInfo_Ptr);
   begin
      if this.m_IRatingItemInfo /= null then
         if this.m_IRatingItemInfo.all /= null then
            temp := this.m_IRatingItemInfo.all.Release;
            Free (this.m_IRatingItemInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RatingItemInfo

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RatingItemInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRatingItemInfo");
      m_Factory    : access IRatingItemInfoFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemInfo;
   begin
      return RetVal : RatingItemInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemInfoFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRatingItemInfo := new WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemInfo;
            Retval.m_IRatingItemInfo.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RatingItemInfo

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RatingItemFontInfo

   procedure Initialize (this : in out RatingItemFontInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out RatingItemFontInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRatingItemFontInfo, IRatingItemFontInfo_Ptr);
   begin
      if this.m_IRatingItemFontInfo /= null then
         if this.m_IRatingItemFontInfo.all /= null then
            temp := this.m_IRatingItemFontInfo.all.Release;
            Free (this.m_IRatingItemFontInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RatingItemFontInfo

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RatingItemFontInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRatingItemFontInfo");
      m_Factory    : access IRatingItemFontInfoFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemFontInfo;
   begin
      return RetVal : RatingItemFontInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRatingItemFontInfo := new WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemFontInfo;
            Retval.m_IRatingItemFontInfo.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RatingItemFontInfo

   function get_DisabledGlyphProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GlyphProperty_RatingItemFontInfo
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderGlyphProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverGlyphProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverPlaceholderGlyphProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverPlaceholderGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_UnsetGlyphProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UnsetGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RatingItemFontInfo

   function get_DisabledGlyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_DisabledGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DisabledGlyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_DisabledGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Glyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_Glyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Glyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_Glyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PointerOverGlyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_PointerOverGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PointerOverGlyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_PointerOverGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PointerOverPlaceholderGlyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_PointerOverPlaceholderGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PointerOverPlaceholderGlyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_PointerOverPlaceholderGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PlaceholderGlyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_PlaceholderGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderGlyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_PlaceholderGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_UnsetGlyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_UnsetGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_UnsetGlyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_UnsetGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RatingItemImageInfo

   procedure Initialize (this : in out RatingItemImageInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out RatingItemImageInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRatingItemImageInfo, IRatingItemImageInfo_Ptr);
   begin
      if this.m_IRatingItemImageInfo /= null then
         if this.m_IRatingItemImageInfo.all /= null then
            temp := this.m_IRatingItemImageInfo.all.Release;
            Free (this.m_IRatingItemImageInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RatingItemImageInfo

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RatingItemImageInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRatingItemImageInfo");
      m_Factory    : access IRatingItemImageInfoFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemImageInfo;
   begin
      return RetVal : RatingItemImageInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRatingItemImageInfo := new WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemImageInfo;
            Retval.m_IRatingItemImageInfo.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RatingItemImageInfo

   function get_DisabledImageProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ImageProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderImageProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverImageProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverPlaceholderImageProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverPlaceholderImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_UnsetImageProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UnsetImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RatingItemImageInfo

   function get_DisabledImage
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_DisabledImage (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_DisabledImage
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_DisabledImage (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Image
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_Image (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_Image
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_Image (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderImage
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_PlaceholderImage (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlaceholderImage
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_PlaceholderImage (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerOverImage
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_PointerOverImage (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_PointerOverImage
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_PointerOverImage (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerOverPlaceholderImage
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_PointerOverPlaceholderImage (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_PointerOverPlaceholderImage
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_PointerOverPlaceholderImage (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_UnsetImage
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_UnsetImage (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Microsoft.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_UnsetImage
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Microsoft.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_UnsetImage (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RefreshContainer

   procedure Initialize (this : in out RefreshContainer) is
   begin
      null;
   end;

   procedure Finalize (this : in out RefreshContainer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRefreshContainer, IRefreshContainer_Ptr);
   begin
      if this.m_IRefreshContainer /= null then
         if this.m_IRefreshContainer.all /= null then
            temp := this.m_IRefreshContainer.all.Release;
            Free (this.m_IRefreshContainer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RefreshContainer

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RefreshContainer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRefreshContainer");
      m_Factory    : access IRefreshContainerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRefreshContainer;
   begin
      return RetVal : RefreshContainer do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshContainerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRefreshContainer := new WinUI3.Microsoft.UI.Xaml.Controls.IRefreshContainer;
            Retval.m_IRefreshContainer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RefreshContainer

   function get_VisualizerProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RefreshContainer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRefreshContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VisualizerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PullDirectionProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RefreshContainer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRefreshContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PullDirectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RefreshContainer

   function get_Visualizer
   (
      this : in out RefreshContainer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRefreshVisualizer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizer do
         Hr := this.m_IRefreshContainer.all.get_Visualizer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRefreshVisualizer := new WinUI3.Microsoft.UI.Xaml.Controls.IRefreshVisualizer;
         Retval.m_IRefreshVisualizer.all := m_ComRetVal;
      end return;
   end;

   procedure put_Visualizer
   (
      this : in out RefreshContainer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshContainer.all.put_Visualizer (value.m_IRefreshVisualizer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PullDirection
   (
      this : in out RefreshContainer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RefreshPullDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.RefreshPullDirection;
   begin
      Hr := this.m_IRefreshContainer.all.get_PullDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PullDirection
   (
      this : in out RefreshContainer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RefreshPullDirection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshContainer.all.put_PullDirection (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_RefreshRequested
   (
      this : in out RefreshContainer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRefreshContainer.all.add_RefreshRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RefreshRequested
   (
      this : in out RefreshContainer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshContainer.all.remove_RefreshRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RequestRefresh
   (
      this : in out RefreshContainer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshContainer.all.RequestRefresh;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RefreshInteractionRatioChangedEventArgs

   procedure Initialize (this : in out RefreshInteractionRatioChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RefreshInteractionRatioChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRefreshInteractionRatioChangedEventArgs, IRefreshInteractionRatioChangedEventArgs_Ptr);
   begin
      if this.m_IRefreshInteractionRatioChangedEventArgs /= null then
         if this.m_IRefreshInteractionRatioChangedEventArgs.all /= null then
            temp := this.m_IRefreshInteractionRatioChangedEventArgs.all.Release;
            Free (this.m_IRefreshInteractionRatioChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RefreshInteractionRatioChangedEventArgs

   function get_InteractionRatio
   (
      this : in out RefreshInteractionRatioChangedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRefreshInteractionRatioChangedEventArgs.all.get_InteractionRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RefreshRequestedEventArgs

   procedure Initialize (this : in out RefreshRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RefreshRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRefreshRequestedEventArgs, IRefreshRequestedEventArgs_Ptr);
   begin
      if this.m_IRefreshRequestedEventArgs /= null then
         if this.m_IRefreshRequestedEventArgs.all /= null then
            temp := this.m_IRefreshRequestedEventArgs.all.Release;
            Free (this.m_IRefreshRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RefreshRequestedEventArgs

   function GetDeferral
   (
      this : in out RefreshRequestedEventArgs
   )
   return WinUI3.Windows.Foundation.Deferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IDeferral;
   begin
      return RetVal : WinUI3.Windows.Foundation.Deferral do
         Hr := this.m_IRefreshRequestedEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new WinUI3.Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RefreshStateChangedEventArgs

   procedure Initialize (this : in out RefreshStateChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RefreshStateChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRefreshStateChangedEventArgs, IRefreshStateChangedEventArgs_Ptr);
   begin
      if this.m_IRefreshStateChangedEventArgs /= null then
         if this.m_IRefreshStateChangedEventArgs.all /= null then
            temp := this.m_IRefreshStateChangedEventArgs.all.Release;
            Free (this.m_IRefreshStateChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RefreshStateChangedEventArgs

   function get_OldState
   (
      this : in out RefreshStateChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizerState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizerState;
   begin
      Hr := this.m_IRefreshStateChangedEventArgs.all.get_OldState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewState
   (
      this : in out RefreshStateChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizerState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizerState;
   begin
      Hr := this.m_IRefreshStateChangedEventArgs.all.get_NewState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RefreshVisualizer

   procedure Initialize (this : in out RefreshVisualizer) is
   begin
      null;
   end;

   procedure Finalize (this : in out RefreshVisualizer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRefreshVisualizer, IRefreshVisualizer_Ptr);
   begin
      if this.m_IRefreshVisualizer /= null then
         if this.m_IRefreshVisualizer.all /= null then
            temp := this.m_IRefreshVisualizer.all.Release;
            Free (this.m_IRefreshVisualizer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RefreshVisualizer

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RefreshVisualizer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRefreshVisualizer");
      m_Factory    : access IRefreshVisualizerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRefreshVisualizer;
   begin
      return RetVal : RefreshVisualizer do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshVisualizerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRefreshVisualizer := new WinUI3.Microsoft.UI.Xaml.Controls.IRefreshVisualizer;
            Retval.m_IRefreshVisualizer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RefreshVisualizer

   function get_InfoProviderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RefreshVisualizer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRefreshVisualizerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshVisualizerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InfoProviderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_RefreshVisualizer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RefreshVisualizer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRefreshVisualizerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshVisualizerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentProperty_RefreshVisualizer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RefreshVisualizer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRefreshVisualizerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshVisualizerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StateProperty_RefreshVisualizer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RefreshVisualizer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRefreshVisualizerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshVisualizerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RefreshVisualizer

   procedure RequestRefresh
   (
      this : in out RefreshVisualizer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshVisualizer.all.RequestRefresh;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out RefreshVisualizer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizerOrientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizerOrientation;
   begin
      Hr := this.m_IRefreshVisualizer.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out RefreshVisualizer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizerOrientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshVisualizer.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Content
   (
      this : in out RefreshVisualizer
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IRefreshVisualizer.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out RefreshVisualizer;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshVisualizer.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_State
   (
      this : in out RefreshVisualizer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizerState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.RefreshVisualizerState;
   begin
      Hr := this.m_IRefreshVisualizer.all.get_State (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_RefreshRequested
   (
      this : in out RefreshVisualizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRefreshVisualizer.all.add_RefreshRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RefreshRequested
   (
      this : in out RefreshVisualizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshVisualizer.all.remove_RefreshRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_RefreshStateChanged
   (
      this : in out RefreshVisualizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRefreshVisualizer.all.add_RefreshStateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RefreshStateChanged
   (
      this : in out RefreshVisualizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshVisualizer.all.remove_RefreshStateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RelativePanel

   procedure Initialize (this : in out RelativePanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out RelativePanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRelativePanel, IRelativePanel_Ptr);
   begin
      if this.m_IRelativePanel /= null then
         if this.m_IRelativePanel.all /= null then
            temp := this.m_IRelativePanel.all.Release;
            Free (this.m_IRelativePanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RelativePanel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RelativePanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRelativePanel");
      m_Factory    : access IRelativePanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanel;
   begin
      return RetVal : RelativePanel do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRelativePanel := new WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanel;
            Retval.m_IRelativePanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RelativePanel

   function get_BackgroundSizingProperty_RelativePanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LeftOfProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftOfProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetLeftOf
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetLeftOf (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetLeftOf
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetLeftOf (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AboveProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AboveProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAbove
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAbove (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAbove
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAbove (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_RightOfProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RightOfProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetRightOf
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetRightOf (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetRightOf
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetRightOf (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_BelowProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BelowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetBelow
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetBelow (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetBelow
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetBelow (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignHorizontalCenterWithProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignHorizontalCenterWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignHorizontalCenterWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignHorizontalCenterWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignHorizontalCenterWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignHorizontalCenterWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignVerticalCenterWithProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignVerticalCenterWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignVerticalCenterWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignVerticalCenterWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignVerticalCenterWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignVerticalCenterWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignLeftWithProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignLeftWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignLeftWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignLeftWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignLeftWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignLeftWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignTopWithProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignTopWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignTopWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignTopWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignTopWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignTopWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignRightWithProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignRightWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignRightWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignRightWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignRightWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignRightWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignBottomWithProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignBottomWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignBottomWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignBottomWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignBottomWith
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignBottomWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignLeftWithPanelProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignLeftWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignLeftWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignLeftWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignLeftWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignLeftWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignTopWithPanelProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignTopWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignTopWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignTopWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignTopWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignTopWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignRightWithPanelProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignRightWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignRightWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignRightWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignRightWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignRightWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignBottomWithPanelProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignBottomWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignBottomWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignBottomWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignBottomWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignBottomWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignHorizontalCenterWithPanelProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignHorizontalCenterWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignHorizontalCenterWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignHorizontalCenterWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignHorizontalCenterWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignHorizontalCenterWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignVerticalCenterWithPanelProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignVerticalCenterWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignVerticalCenterWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignVerticalCenterWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignVerticalCenterWithPanel
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignVerticalCenterWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_BorderBrushProperty_RelativePanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty_RelativePanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty_RelativePanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_RelativePanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RelativePanel

   function get_BackgroundSizing
   (
      this : in out RelativePanel
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing;
   begin
      Hr := this.m_IRelativePanel.all.get_BackgroundSizing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out RelativePanel;
      value : WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRelativePanel.all.put_BackgroundSizing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderBrush
   (
      this : in out RelativePanel
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IRelativePanel.all.get_BorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out RelativePanel;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRelativePanel.all.put_BorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out RelativePanel
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IRelativePanel.all.get_BorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out RelativePanel;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRelativePanel.all.put_BorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out RelativePanel
   )
   return WinUI3.Microsoft.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_IRelativePanel.all.get_CornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out RelativePanel;
      value : WinUI3.Microsoft.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRelativePanel.all.put_CornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out RelativePanel
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IRelativePanel.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out RelativePanel;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRelativePanel.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RevealListViewItemPresenter

   procedure Initialize (this : in out RevealListViewItemPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out RevealListViewItemPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRevealListViewItemPresenter, IRevealListViewItemPresenter_Ptr);
   begin
      if this.m_IRevealListViewItemPresenter /= null then
         if this.m_IRevealListViewItemPresenter.all /= null then
            temp := this.m_IRevealListViewItemPresenter.all.Release;
            Free (this.m_IRevealListViewItemPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RevealListViewItemPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RevealListViewItemPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRevealListViewItemPresenter");
      m_Factory    : access IRevealListViewItemPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRevealListViewItemPresenter;
   begin
      return RetVal : RevealListViewItemPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IRevealListViewItemPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRevealListViewItemPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.IRevealListViewItemPresenter;
            Retval.m_IRevealListViewItemPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RevealListViewItemPresenter

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichEditBox

   procedure Initialize (this : in out RichEditBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichEditBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRichEditBox, IRichEditBox_Ptr);
   begin
      if this.m_IRichEditBox /= null then
         if this.m_IRichEditBox.all /= null then
            temp := this.m_IRichEditBox.all.Release;
            Free (this.m_IRichEditBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RichEditBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RichEditBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRichEditBox");
      m_Factory    : access IRichEditBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBox;
   begin
      return RetVal : RichEditBox do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRichEditBox := new WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBox;
            Retval.m_IRichEditBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RichEditBox

   function get_IsReadOnlyProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsReadOnlyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AcceptsReturnProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AcceptsReturnProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextWrappingProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextWrappingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSpellCheckEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSpellCheckEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextPredictionEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextPredictionEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InputScopeProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InputScopeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocusProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreventKeyboardDisplayOnProgrammaticFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorFontEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorFontEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorWhenNotFocusedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorWhenNotFocusedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLengthProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalTextAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalTextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterCasingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterCasingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisabledFormattingAcceleratorsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledFormattingAcceleratorsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFlyoutProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ProofingMenuFlyoutProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ProofingMenuFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DesiredCandidateWindowAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DesiredCandidateWindowAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextReadingOrderProperty_RichEditBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextReadingOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClipboardCopyFormatProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClipboardCopyFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichEditBox

   function get_IsReadOnly
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBox.all.get_IsReadOnly (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsReadOnly
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_IsReadOnly (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AcceptsReturn
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBox.all.get_AcceptsReturn (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AcceptsReturn
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_AcceptsReturn (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextAlignment
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_IRichEditBox.all.get_TextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextAlignment
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_TextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextWrapping
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.TextWrapping is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextWrapping;
   begin
      Hr := this.m_IRichEditBox.all.get_TextWrapping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextWrapping
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.TextWrapping
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_TextWrapping (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSpellCheckEnabled
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBox.all.get_IsSpellCheckEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSpellCheckEnabled
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_IsSpellCheckEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextPredictionEnabled
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBox.all.get_IsTextPredictionEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextPredictionEnabled
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_IsTextPredictionEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Document
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Text.RichEditTextDocument'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.ITextDocument;
   begin
      return RetVal : WinUI3.Microsoft.UI.Text.RichEditTextDocument do
         Hr := this.m_IRichEditBox.all.get_Document (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextDocument := new WinUI3.Microsoft.UI.Text.ITextDocument;
         Retval.m_ITextDocument.all := m_ComRetVal;
      end return;
   end;

   function get_InputScope
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.Input.InputScope'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.IInputScope;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Input.InputScope do
         Hr := this.m_IRichEditBox.all.get_InputScope (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInputScope := new WinUI3.Microsoft.UI.Xaml.Input.IInputScope;
         Retval.m_IInputScope.all := m_ComRetVal;
      end return;
   end;

   procedure put_InputScope
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.Input.InputScope'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_InputScope (value.m_IInputScope.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out RichEditBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IRichEditBox.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out RichEditBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IRichEditBox.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderText
   (
      this : in out RichEditBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRichEditBox.all.get_PlaceholderText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out RichEditBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRichEditBox.all.put_PlaceholderText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectionHighlightColor
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush do
         Hr := this.m_IRichEditBox.all.get_SelectionHighlightColor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColor
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_SelectionHighlightColor (value.m_ISolidColorBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBox.all.get_PreventKeyboardDisplayOnProgrammaticFocus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_PreventKeyboardDisplayOnProgrammaticFocus (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorFontEnabled
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBox.all.get_IsColorFontEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorFontEnabled
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_IsColorFontEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionHighlightColorWhenNotFocused
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush do
         Hr := this.m_IRichEditBox.all.get_SelectionHighlightColorWhenNotFocused (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColorWhenNotFocused
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_SelectionHighlightColorWhenNotFocused (value.m_ISolidColorBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxLength
   (
      this : in out RichEditBox
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRichEditBox.all.get_MaxLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLength
   (
      this : in out RichEditBox;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_MaxLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalTextAlignment
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_IRichEditBox.all.get_HorizontalTextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalTextAlignment
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_HorizontalTextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterCasing
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CharacterCasing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CharacterCasing;
   begin
      Hr := this.m_IRichEditBox.all.get_CharacterCasing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterCasing
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.CharacterCasing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_CharacterCasing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisabledFormattingAccelerators
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.DisabledFormattingAccelerators is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.DisabledFormattingAccelerators;
   begin
      Hr := this.m_IRichEditBox.all.get_DisabledFormattingAccelerators (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DisabledFormattingAccelerators
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.DisabledFormattingAccelerators
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_DisabledFormattingAccelerators (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextDocument
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Text.RichEditTextDocument'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.ITextDocument;
   begin
      return RetVal : WinUI3.Microsoft.UI.Text.RichEditTextDocument do
         Hr := this.m_IRichEditBox.all.get_TextDocument (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextDocument := new WinUI3.Microsoft.UI.Text.ITextDocument;
         Retval.m_ITextDocument.all := m_ComRetVal;
      end return;
   end;

   function get_SelectionFlyout
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := this.m_IRichEditBox.all.get_SelectionFlyout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionFlyout
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_SelectionFlyout (value.m_IFlyoutBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ProofingMenuFlyout
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := this.m_IRichEditBox.all.get_ProofingMenuFlyout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   function get_Description
   (
      this : in out RichEditBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IRichEditBox.all.get_Description (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out RichEditBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_Description (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextChanged
   (
      this : in out RichEditBox;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_TextChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextChanged
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_TextChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out RichEditBox;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextMenuOpening
   (
      this : in out RichEditBox;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.ContextMenuOpeningEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_ContextMenuOpening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextMenuOpening
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_ContextMenuOpening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Paste
   (
      this : in out RichEditBox;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.TextControlPasteEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_Paste (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Paste
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_Paste (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionStarted
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_TextCompositionStarted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionStarted
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_TextCompositionStarted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionChanged
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_TextCompositionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionChanged
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_TextCompositionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionEnded
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_TextCompositionEnded (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionEnded
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_TextCompositionEnded (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CopyingToClipboard
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_CopyingToClipboard (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CopyingToClipboard
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_CopyingToClipboard (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CuttingToClipboard
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_CuttingToClipboard (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CuttingToClipboard
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_CuttingToClipboard (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanging
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_SelectionChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanging
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_SelectionChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetLinguisticAlternativesAsync
   (
      this : in out RichEditBox
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.GenericObject;
      m_IID            : aliased WinUI3.IID := (798143785, 4507, 22362, (164, 25, 57, 4, 180, 228, 26, 242 )); -- GenericObject;
      m_HandlerIID     : aliased WinUI3.IID := (2088278462, 24366, 23539, (173, 229, 173, 152, 183, 114, 199, 205 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IRichEditBox.all.GetLinguisticAlternativesAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function get_TextReadingOrder
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.TextReadingOrder is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextReadingOrder;
   begin
      Hr := this.m_IRichEditBox.all.get_TextReadingOrder (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextReadingOrder
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.TextReadingOrder
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_TextReadingOrder (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ClipboardCopyFormat
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RichEditClipboardFormat is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.RichEditClipboardFormat;
   begin
      Hr := this.m_IRichEditBox.all.get_ClipboardCopyFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ClipboardCopyFormat
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RichEditClipboardFormat
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_ClipboardCopyFormat (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DesiredCandidateWindowAlignment
   (
      this : in out RichEditBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CandidateWindowAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CandidateWindowAlignment;
   begin
      Hr := this.m_IRichEditBox.all.get_DesiredCandidateWindowAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredCandidateWindowAlignment
   (
      this : in out RichEditBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.CandidateWindowAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_DesiredCandidateWindowAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CandidateWindowBoundsChanged
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_CandidateWindowBoundsChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CandidateWindowBoundsChanged
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_CandidateWindowBoundsChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextChanging
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_TextChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextChanging
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_TextChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichEditBoxSelectionChangingEventArgs

   procedure Initialize (this : in out RichEditBoxSelectionChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichEditBoxSelectionChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRichEditBoxSelectionChangingEventArgs, IRichEditBoxSelectionChangingEventArgs_Ptr);
   begin
      if this.m_IRichEditBoxSelectionChangingEventArgs /= null then
         if this.m_IRichEditBoxSelectionChangingEventArgs.all /= null then
            temp := this.m_IRichEditBoxSelectionChangingEventArgs.all.Release;
            Free (this.m_IRichEditBoxSelectionChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichEditBoxSelectionChangingEventArgs

   function get_SelectionStart
   (
      this : in out RichEditBoxSelectionChangingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRichEditBoxSelectionChangingEventArgs.all.get_SelectionStart (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionLength
   (
      this : in out RichEditBoxSelectionChangingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRichEditBoxSelectionChangingEventArgs.all.get_SelectionLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out RichEditBoxSelectionChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBoxSelectionChangingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out RichEditBoxSelectionChangingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBoxSelectionChangingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichEditBoxTextChangingEventArgs

   procedure Initialize (this : in out RichEditBoxTextChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichEditBoxTextChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRichEditBoxTextChangingEventArgs, IRichEditBoxTextChangingEventArgs_Ptr);
   begin
      if this.m_IRichEditBoxTextChangingEventArgs /= null then
         if this.m_IRichEditBoxTextChangingEventArgs.all /= null then
            temp := this.m_IRichEditBoxTextChangingEventArgs.all.Release;
            Free (this.m_IRichEditBoxTextChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichEditBoxTextChangingEventArgs

   function get_IsContentChanging
   (
      this : in out RichEditBoxTextChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBoxTextChangingEventArgs.all.get_IsContentChanging (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichTextBlock

   procedure Initialize (this : in out RichTextBlock) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichTextBlock) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRichTextBlock, IRichTextBlock_Ptr);
   begin
      if this.m_IRichTextBlock /= null then
         if this.m_IRichTextBlock.all /= null then
            temp := this.m_IRichTextBlock.all.Release;
            Free (this.m_IRichTextBlock);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RichTextBlock

   function Constructor return RichTextBlock is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRichTextBlock");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlock;
   begin
      return RetVal : RichTextBlock do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRichTextBlock := new WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlock;
            Retval.m_IRichTextBlock.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RichTextBlock

   function get_FontSizeProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStretchProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForegroundProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextWrappingProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextWrappingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextTrimmingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextTrimmingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextAlignmentProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineHeightProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineStackingStrategyProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineStackingStrategyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterSpacingProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OverflowContentTargetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OverflowContentTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextSelectionEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextSelectionEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HasOverflowContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HasOverflowContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedTextProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLinesProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLinesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextLineBoundsProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextLineBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpticalMarginAlignmentProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpticalMarginAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorFontEnabledProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorFontEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextReadingOrderProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextReadingOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextScaleFactorEnabledProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextDecorationsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextDecorationsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextTrimmedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextTrimmedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalTextAlignmentProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalTextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFlyoutProperty_RichTextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextIndentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextIndentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichTextBlock

   function get_FontSize
   (
      this : in out RichTextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRichTextBlock.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out RichTextBlock;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.FontFamily do
         Hr := this.m_IRichTextBlock.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_IRichTextBlock.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_IRichTextBlock.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStretch
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Text.FontStretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStretch;
   begin
      Hr := this.m_IRichTextBlock.all.get_FontStretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStretch
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Text.FontStretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_FontStretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Foreground
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IRichTextBlock.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextWrapping
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextWrapping is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextWrapping;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextWrapping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextWrapping
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextWrapping
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_TextWrapping (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextTrimming
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextTrimming is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextTrimming;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextTrimming (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextTrimming
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextTrimming
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_TextTrimming (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextAlignment
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextAlignment
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_TextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Blocks
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.BlockCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.BlockCollection do
         Hr := this.m_IRichTextBlock.all.get_Blocks (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_Padding
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IRichTextBlock.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineHeight
   (
      this : in out RichTextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRichTextBlock.all.get_LineHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineHeight
   (
      this : in out RichTextBlock;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_LineHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineStackingStrategy
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.LineStackingStrategy is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.LineStackingStrategy;
   begin
      Hr := this.m_IRichTextBlock.all.get_LineStackingStrategy (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineStackingStrategy
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.LineStackingStrategy
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_LineStackingStrategy (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterSpacing
   (
      this : in out RichTextBlock
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRichTextBlock.all.get_CharacterSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterSpacing
   (
      this : in out RichTextBlock;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_CharacterSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OverflowContentTarget
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RichTextBlockOverflow'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockOverflow;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.RichTextBlockOverflow do
         Hr := this.m_IRichTextBlock.all.get_OverflowContentTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRichTextBlockOverflow := new WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockOverflow;
         Retval.m_IRichTextBlockOverflow.all := m_ComRetVal;
      end return;
   end;

   procedure put_OverflowContentTarget
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RichTextBlockOverflow'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_OverflowContentTarget (value.m_IRichTextBlockOverflow.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextSelectionEnabled
   (
      this : in out RichTextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlock.all.get_IsTextSelectionEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextSelectionEnabled
   (
      this : in out RichTextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_IsTextSelectionEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HasOverflowContent
   (
      this : in out RichTextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlock.all.get_HasOverflowContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectedText
   (
      this : in out RichTextBlock
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRichTextBlock.all.get_SelectedText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ContentStart
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlock.all.get_ContentStart (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_ContentEnd
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlock.all.get_ContentEnd (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_SelectionStart
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlock.all.get_SelectionStart (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_SelectionEnd
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlock.all.get_SelectionEnd (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_BaselineOffset
   (
      this : in out RichTextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRichTextBlock.all.get_BaselineOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MaxLines
   (
      this : in out RichTextBlock
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRichTextBlock.all.get_MaxLines (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLines
   (
      this : in out RichTextBlock;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_MaxLines (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextLineBounds
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextLineBounds is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextLineBounds;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextLineBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextLineBounds
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextLineBounds
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_TextLineBounds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionHighlightColor
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush do
         Hr := this.m_IRichTextBlock.all.get_SelectionHighlightColor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColor
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_SelectionHighlightColor (value.m_ISolidColorBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpticalMarginAlignment
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.OpticalMarginAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.OpticalMarginAlignment;
   begin
      Hr := this.m_IRichTextBlock.all.get_OpticalMarginAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpticalMarginAlignment
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.OpticalMarginAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_OpticalMarginAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorFontEnabled
   (
      this : in out RichTextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlock.all.get_IsColorFontEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorFontEnabled
   (
      this : in out RichTextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_IsColorFontEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextReadingOrder
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextReadingOrder is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextReadingOrder;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextReadingOrder (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextReadingOrder
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextReadingOrder
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_TextReadingOrder (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out RichTextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlock.all.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out RichTextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_IsTextScaleFactorEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextDecorations
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Text.TextDecorations is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.TextDecorations;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextDecorations (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextDecorations
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Text.TextDecorations
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_TextDecorations (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextTrimmed
   (
      this : in out RichTextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlock.all.get_IsTextTrimmed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HorizontalTextAlignment
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_IRichTextBlock.all.get_HorizontalTextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalTextAlignment
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_HorizontalTextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextHighlighters
   (
      this : in out RichTextBlock
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextHighlighters (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionFlyout
   (
      this : in out RichTextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := this.m_IRichTextBlock.all.get_SelectionFlyout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionFlyout
   (
      this : in out RichTextBlock;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_SelectionFlyout (value.m_IFlyoutBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out RichTextBlock;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichTextBlock.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out RichTextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextMenuOpening
   (
      this : in out RichTextBlock;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.ContextMenuOpeningEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichTextBlock.all.add_ContextMenuOpening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextMenuOpening
   (
      this : in out RichTextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.remove_ContextMenuOpening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_IsTextTrimmedChanged
   (
      this : in out RichTextBlock;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichTextBlock.all.add_IsTextTrimmedChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsTextTrimmedChanged
   (
      this : in out RichTextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.remove_IsTextTrimmedChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out RichTextBlock
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Select_x
   (
      this : in out RichTextBlock;
      start : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class;
      end_x : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.Select_x (start.m_ITextPointer.all, end_x.m_ITextPointer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetPositionFromPoint
   (
      this : in out RichTextBlock;
      point : WinUI3.Windows.Foundation.Point
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlock.all.GetPositionFromPoint (point, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   procedure CopySelectionToClipboard
   (
      this : in out RichTextBlock
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.CopySelectionToClipboard;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextIndent
   (
      this : in out RichTextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextIndent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextIndent
   (
      this : in out RichTextBlock;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_TextIndent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichTextBlockOverflow

   procedure Initialize (this : in out RichTextBlockOverflow) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichTextBlockOverflow) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRichTextBlockOverflow, IRichTextBlockOverflow_Ptr);
   begin
      if this.m_IRichTextBlockOverflow /= null then
         if this.m_IRichTextBlockOverflow.all /= null then
            temp := this.m_IRichTextBlockOverflow.all.Release;
            Free (this.m_IRichTextBlockOverflow);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RichTextBlockOverflow

   function Constructor return RichTextBlockOverflow is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRichTextBlockOverflow");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockOverflow;
   begin
      return RetVal : RichTextBlockOverflow do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRichTextBlockOverflow := new WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockOverflow;
            Retval.m_IRichTextBlockOverflow.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RichTextBlockOverflow

   function get_OverflowContentTargetProperty_RichTextBlockOverflow
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlockOverflow");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockOverflowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockOverflowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OverflowContentTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_RichTextBlockOverflow
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlockOverflow");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockOverflowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockOverflowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HasOverflowContentProperty_RichTextBlockOverflow
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlockOverflow");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockOverflowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockOverflowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HasOverflowContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLinesProperty_RichTextBlockOverflow
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlockOverflow");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockOverflowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockOverflowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLinesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextTrimmedProperty_RichTextBlockOverflow
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RichTextBlockOverflow");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockOverflowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockOverflowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextTrimmedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichTextBlockOverflow

   function get_OverflowContentTarget
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RichTextBlockOverflow'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockOverflow;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.RichTextBlockOverflow do
         Hr := this.m_IRichTextBlockOverflow.all.get_OverflowContentTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRichTextBlockOverflow := new WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlockOverflow;
         Retval.m_IRichTextBlockOverflow.all := m_ComRetVal;
      end return;
   end;

   procedure put_OverflowContentTarget
   (
      this : in out RichTextBlockOverflow;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RichTextBlockOverflow'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.put_OverflowContentTarget (value.m_IRichTextBlockOverflow.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out RichTextBlockOverflow;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentSource
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RichTextBlock'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlock;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.RichTextBlock do
         Hr := this.m_IRichTextBlockOverflow.all.get_ContentSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRichTextBlock := new WinUI3.Microsoft.UI.Xaml.Controls.IRichTextBlock;
         Retval.m_IRichTextBlock.all := m_ComRetVal;
      end return;
   end;

   function get_HasOverflowContent
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.get_HasOverflowContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContentStart
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlockOverflow.all.get_ContentStart (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_ContentEnd
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlockOverflow.all.get_ContentEnd (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_BaselineOffset
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.get_BaselineOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MaxLines
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.get_MaxLines (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLines
   (
      this : in out RichTextBlockOverflow;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.put_MaxLines (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextTrimmed
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.get_IsTextTrimmed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_IsTextTrimmedChanged
   (
      this : in out RichTextBlockOverflow;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.add_IsTextTrimmedChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsTextTrimmedChanged
   (
      this : in out RichTextBlockOverflow;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.remove_IsTextTrimmedChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetPositionFromPoint
   (
      this : in out RichTextBlockOverflow;
      point : WinUI3.Windows.Foundation.Point
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlockOverflow.all.GetPositionFromPoint (point, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RowDefinition

   procedure Initialize (this : in out RowDefinition) is
   begin
      null;
   end;

   procedure Finalize (this : in out RowDefinition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRowDefinition, IRowDefinition_Ptr);
   begin
      if this.m_IRowDefinition /= null then
         if this.m_IRowDefinition.all /= null then
            temp := this.m_IRowDefinition.all.Release;
            Free (this.m_IRowDefinition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RowDefinition

   function Constructor return RowDefinition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IRowDefinition");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinition;
   begin
      return RetVal : RowDefinition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRowDefinition := new WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinition;
            Retval.m_IRowDefinition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RowDefinition

   function get_HeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RowDefinition");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRowDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RowDefinition");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRowDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.RowDefinition");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRowDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RowDefinition

   function get_Height
   (
      this : in out RowDefinition
   )
   return WinUI3.Microsoft.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.GridLength;
   begin
      Hr := this.m_IRowDefinition.all.get_Height (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Height
   (
      this : in out RowDefinition;
      value : WinUI3.Microsoft.UI.Xaml.GridLength
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRowDefinition.all.put_Height (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxHeight
   (
      this : in out RowDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRowDefinition.all.get_MaxHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxHeight
   (
      this : in out RowDefinition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRowDefinition.all.put_MaxHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinHeight
   (
      this : in out RowDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRowDefinition.all.get_MinHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinHeight
   (
      this : in out RowDefinition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRowDefinition.all.put_MinHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActualHeight
   (
      this : in out RowDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRowDefinition.all.get_ActualHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RowDefinitionCollection

   procedure Initialize (this : in out RowDefinitionCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out RowDefinitionCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RowDefinitionCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Controls.RowDefinition>
   function GetAt
   (
      this : in out RowDefinitionCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RowDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinition;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.RowDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRowDefinition := new WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinition;
         Retval.m_IRowDefinition.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out RowDefinitionCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out RowDefinitionCollection
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RowDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinition;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.RowDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRowDefinition := new WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinition;
         Retval.m_IRowDefinition.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out RowDefinitionCollection;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RowDefinition'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IRowDefinition.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out RowDefinitionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RowDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IRowDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out RowDefinitionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RowDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IRowDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out RowDefinitionCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out RowDefinitionCollection;
      value : WinUI3.Microsoft.UI.Xaml.Controls.RowDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IRowDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out RowDefinitionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out RowDefinitionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out RowDefinitionCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinition_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out RowDefinitionCollection;
      items : WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinition_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1574802807, 16276, 22143, (190, 239, 84, 5, 104, 82, 34, 137 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.RowDefinition>
   function First
   (
      this : in out RowDefinitionCollection
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.RowDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinition;
      m_GenericIID     : aliased WinUI3.IID := (2964523312, 30359, 22046, (189, 110, 251, 187, 26, 209, 124, 80 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.RowDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRowDefinition := new WinUI3.Microsoft.UI.Xaml.Controls.IRowDefinition;
         Retval.m_IRowDefinition.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollContentPresenter

   procedure Initialize (this : in out ScrollContentPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollContentPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollContentPresenter, IScrollContentPresenter_Ptr);
   begin
      if this.m_IScrollContentPresenter /= null then
         if this.m_IScrollContentPresenter.all /= null then
            temp := this.m_IScrollContentPresenter.all.Release;
            Free (this.m_IScrollContentPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollContentPresenter

   function Constructor return ScrollContentPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IScrollContentPresenter");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollContentPresenter;
   begin
      return RetVal : ScrollContentPresenter do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IScrollContentPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollContentPresenter;
            Retval.m_IScrollContentPresenter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ScrollContentPresenter

   function get_CanContentRenderOutsideBoundsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanContentRenderOutsideBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SizesContentToTemplatedParentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollContentPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SizesContentToTemplatedParentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollContentPresenter

   function get_CanVerticallyScroll
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_CanVerticallyScroll (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanVerticallyScroll
   (
      this : in out ScrollContentPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.put_CanVerticallyScroll (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanHorizontallyScroll
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_CanHorizontallyScroll (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanHorizontallyScroll
   (
      this : in out ScrollContentPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.put_CanHorizontallyScroll (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExtentWidth
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_ExtentWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentHeight
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_ExtentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportWidth
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_ViewportWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportHeight
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_ViewportHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HorizontalOffset
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalOffset
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollOwner
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_ScrollOwner (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ScrollOwner
   (
      this : in out ScrollContentPresenter;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.put_ScrollOwner (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanContentRenderOutsideBounds
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_CanContentRenderOutsideBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanContentRenderOutsideBounds
   (
      this : in out ScrollContentPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.put_CanContentRenderOutsideBounds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SizesContentToTemplatedParent
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_SizesContentToTemplatedParent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SizesContentToTemplatedParent
   (
      this : in out ScrollContentPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.put_SizesContentToTemplatedParent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineUp
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.LineUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineDown
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.LineDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineLeft
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.LineLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineRight
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.LineRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageUp
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.PageUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageDown
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.PageDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageLeft
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.PageLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageRight
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.PageRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelUp
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.MouseWheelUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelDown
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.MouseWheelDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelLeft
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.MouseWheelLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelRight
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.MouseWheelRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetHorizontalOffset
   (
      this : in out ScrollContentPresenter;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.SetHorizontalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetVerticalOffset
   (
      this : in out ScrollContentPresenter;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.SetVerticalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function MakeVisible
   (
      this : in out ScrollContentPresenter;
      visual : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      rectangle : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IScrollContentPresenter.all.MakeVisible (visual.m_IUIElement.all, rectangle, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollView

   procedure Initialize (this : in out ScrollView) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollView, IScrollView_Ptr);
   begin
      if this.m_IScrollView /= null then
         if this.m_IScrollView.all /= null then
            temp := this.m_IScrollView.all.Release;
            Free (this.m_IScrollView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ScrollView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IScrollView");
      m_Factory    : access IScrollViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollView;
   begin
      return RetVal : ScrollView do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IScrollView := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollView;
            Retval.m_IScrollView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ScrollView

   function get_ContentProperty_ScrollView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScrollPresenterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScrollPresenterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalScrollBarVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalScrollBarVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentOrientationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentOrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalScrollChainModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalScrollChainModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalScrollChainModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollChainModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalScrollRailModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalScrollRailModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalScrollRailModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollRailModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalScrollModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalScrollModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ComputedHorizontalScrollBarVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ComputedHorizontalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ComputedVerticalScrollBarVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ComputedVerticalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ComputedHorizontalScrollModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ComputedHorizontalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ComputedVerticalScrollModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ComputedVerticalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomChainModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomChainModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IgnoredInputKindsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IgnoredInputKindsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinZoomFactorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinZoomFactorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxZoomFactorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxZoomFactorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalAnchorRatioProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalAnchorRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalAnchorRatioProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalAnchorRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollView

   function get_Content
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IScrollView.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CurrentAnchor
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IScrollView.all.get_CurrentAnchor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_ScrollPresenter
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenter;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter do
         Hr := this.m_IScrollView.all.get_ScrollPresenter (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScrollPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenter;
         Retval.m_IScrollPresenter.all := m_ComRetVal;
      end return;
   end;

   function get_ExpressionAnimationSources
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Composition.CompositionPropertySet'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.ICompositionPropertySet;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.CompositionPropertySet do
         Hr := this.m_IScrollView.all.get_ExpressionAnimationSources (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionPropertySet := new WinUI3.Microsoft.UI.Composition.ICompositionPropertySet;
         Retval.m_ICompositionPropertySet.all := m_ComRetVal;
      end return;
   end;

   function get_HorizontalOffset
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalOffset
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZoomFactor
   (
      this : in out ScrollView
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollView.all.get_ZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentWidth
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_ExtentWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentHeight
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_ExtentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportWidth
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_ViewportWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportHeight
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_ViewportHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollableWidth
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_ScrollableWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollableHeight
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_ScrollableHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_State
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingInteractionState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingInteractionState;
   begin
      Hr := this.m_IScrollView.all.get_State (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HorizontalScrollBarVisibility
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollBarVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollBarVisibility;
   begin
      Hr := this.m_IScrollView.all.get_HorizontalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollBarVisibility
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollBarVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_HorizontalScrollBarVisibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollBarVisibility
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollBarVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollBarVisibility;
   begin
      Hr := this.m_IScrollView.all.get_VerticalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollBarVisibility
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollBarVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_VerticalScrollBarVisibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentOrientation
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingContentOrientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingContentOrientation;
   begin
      Hr := this.m_IScrollView.all.get_ContentOrientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ContentOrientation
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingContentOrientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_ContentOrientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalScrollChainMode
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode;
   begin
      Hr := this.m_IScrollView.all.get_HorizontalScrollChainMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollChainMode
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_HorizontalScrollChainMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollChainMode
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode;
   begin
      Hr := this.m_IScrollView.all.get_VerticalScrollChainMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollChainMode
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_VerticalScrollChainMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalScrollRailMode
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode;
   begin
      Hr := this.m_IScrollView.all.get_HorizontalScrollRailMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollRailMode
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_HorizontalScrollRailMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollRailMode
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode;
   begin
      Hr := this.m_IScrollView.all.get_VerticalScrollRailMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollRailMode
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_VerticalScrollRailMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalScrollMode
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode;
   begin
      Hr := this.m_IScrollView.all.get_HorizontalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollMode
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_HorizontalScrollMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollMode
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode;
   begin
      Hr := this.m_IScrollView.all.get_VerticalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollMode
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_VerticalScrollMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ComputedHorizontalScrollBarVisibility
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_IScrollView.all.get_ComputedHorizontalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ComputedVerticalScrollBarVisibility
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_IScrollView.all.get_ComputedVerticalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ComputedHorizontalScrollMode
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode;
   begin
      Hr := this.m_IScrollView.all.get_ComputedHorizontalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ComputedVerticalScrollMode
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode;
   begin
      Hr := this.m_IScrollView.all.get_ComputedVerticalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZoomChainMode
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode;
   begin
      Hr := this.m_IScrollView.all.get_ZoomChainMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomChainMode
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_ZoomChainMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomMode
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingZoomMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingZoomMode;
   begin
      Hr := this.m_IScrollView.all.get_ZoomMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomMode
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingZoomMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_ZoomMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IgnoredInputKinds
   (
      this : in out ScrollView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingInputKinds is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingInputKinds;
   begin
      Hr := this.m_IScrollView.all.get_IgnoredInputKinds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IgnoredInputKinds
   (
      this : in out ScrollView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingInputKinds
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_IgnoredInputKinds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinZoomFactor
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_MinZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinZoomFactor
   (
      this : in out ScrollView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_MinZoomFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxZoomFactor
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_MaxZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxZoomFactor
   (
      this : in out ScrollView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_MaxZoomFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalAnchorRatio
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_HorizontalAnchorRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalAnchorRatio
   (
      this : in out ScrollView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_HorizontalAnchorRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalAnchorRatio
   (
      this : in out ScrollView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollView.all.get_VerticalAnchorRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalAnchorRatio
   (
      this : in out ScrollView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.put_VerticalAnchorRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RegisterAnchorCandidate
   (
      this : in out ScrollView;
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.RegisterAnchorCandidate (element.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure UnregisterAnchorCandidate
   (
      this : in out ScrollView;
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.UnregisterAnchorCandidate (element.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ScrollTo
   (
      this : in out ScrollView;
      horizontalOffset : WinUI3.Double;
      verticalOffset : WinUI3.Double
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollView.all.ScrollTo (horizontalOffset, verticalOffset, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ScrollTo
   (
      this : in out ScrollView;
      horizontalOffset : WinUI3.Double;
      verticalOffset : WinUI3.Double;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollOptions'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollView.all.ScrollTo (horizontalOffset, verticalOffset, options.m_IScrollingScrollOptions.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ScrollBy
   (
      this : in out ScrollView;
      horizontalOffsetDelta : WinUI3.Double;
      verticalOffsetDelta : WinUI3.Double
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollView.all.ScrollBy (horizontalOffsetDelta, verticalOffsetDelta, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ScrollBy
   (
      this : in out ScrollView;
      horizontalOffsetDelta : WinUI3.Double;
      verticalOffsetDelta : WinUI3.Double;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollOptions'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollView.all.ScrollBy (horizontalOffsetDelta, verticalOffsetDelta, options.m_IScrollingScrollOptions.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function AddScrollVelocity
   (
      this : in out ScrollView;
      offsetsVelocity : WinUI3.Windows.Foundation.Numerics.Vector2;
      inertiaDecayRate : GenericObject
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollView.all.AddScrollVelocity (offsetsVelocity, inertiaDecayRate, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ZoomTo
   (
      this : in out ScrollView;
      zoomFactor : WinUI3.Single;
      centerPoint : GenericObject
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollView.all.ZoomTo (zoomFactor, centerPoint, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ZoomTo
   (
      this : in out ScrollView;
      zoomFactor : WinUI3.Single;
      centerPoint : GenericObject;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingZoomOptions'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollView.all.ZoomTo (zoomFactor, centerPoint, options.m_IScrollingZoomOptions.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ZoomBy
   (
      this : in out ScrollView;
      zoomFactorDelta : WinUI3.Single;
      centerPoint : GenericObject
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollView.all.ZoomBy (zoomFactorDelta, centerPoint, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ZoomBy
   (
      this : in out ScrollView;
      zoomFactorDelta : WinUI3.Single;
      centerPoint : GenericObject;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingZoomOptions'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollView.all.ZoomBy (zoomFactorDelta, centerPoint, options.m_IScrollingZoomOptions.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function AddZoomVelocity
   (
      this : in out ScrollView;
      zoomFactorVelocity : WinUI3.Single;
      centerPoint : GenericObject;
      inertiaDecayRate : GenericObject
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollView.all.AddZoomVelocity (zoomFactorVelocity, centerPoint, inertiaDecayRate, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_ExtentChanged
   (
      this : in out ScrollView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollView.all.add_ExtentChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ExtentChanged
   (
      this : in out ScrollView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.remove_ExtentChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_StateChanged
   (
      this : in out ScrollView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollView.all.add_StateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_StateChanged
   (
      this : in out ScrollView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.remove_StateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ViewChanged
   (
      this : in out ScrollView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollView.all.add_ViewChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ViewChanged
   (
      this : in out ScrollView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.remove_ViewChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ScrollAnimationStarting
   (
      this : in out ScrollView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollView.all.add_ScrollAnimationStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ScrollAnimationStarting
   (
      this : in out ScrollView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.remove_ScrollAnimationStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ZoomAnimationStarting
   (
      this : in out ScrollView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollView.all.add_ZoomAnimationStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ZoomAnimationStarting
   (
      this : in out ScrollView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.remove_ZoomAnimationStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ScrollCompleted
   (
      this : in out ScrollView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollView.all.add_ScrollCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ScrollCompleted
   (
      this : in out ScrollView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.remove_ScrollCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ZoomCompleted
   (
      this : in out ScrollView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollView.all.add_ZoomCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ZoomCompleted
   (
      this : in out ScrollView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.remove_ZoomCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_BringingIntoView
   (
      this : in out ScrollView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollView.all.add_BringingIntoView (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BringingIntoView
   (
      this : in out ScrollView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.remove_BringingIntoView (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_AnchorRequested
   (
      this : in out ScrollView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollView.all.add_AnchorRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_AnchorRequested
   (
      this : in out ScrollView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollView.all.remove_AnchorRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollViewer

   procedure Initialize (this : in out ScrollViewer) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollViewer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollViewer, IScrollViewer_Ptr);
   begin
      if this.m_IScrollViewer /= null then
         if this.m_IScrollViewer.all /= null then
            temp := this.m_IScrollViewer.all.Release;
            Free (this.m_IScrollViewer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollViewer

   function Constructor return ScrollViewer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IScrollViewer");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewer;
   begin
      return RetVal : ScrollViewer do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IScrollViewer := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewer;
            Retval.m_IScrollViewer.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ScrollViewer

   function get_HorizontalSnapPointsAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalSnapPointsAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalSnapPointsAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalSnapPointsAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalSnapPointsTypeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalSnapPointsTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalSnapPointsTypeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalSnapPointsTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomSnapPointsTypeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomSnapPointsTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalOffsetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ViewportWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ViewportWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScrollableWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScrollableWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ComputedHorizontalScrollBarVisibilityProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ComputedHorizontalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExtentWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExtentWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalOffsetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ViewportHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ViewportHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScrollableHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScrollableHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ComputedVerticalScrollBarVisibilityProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ComputedVerticalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExtentHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExtentHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinZoomFactorProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinZoomFactorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxZoomFactorProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxZoomFactorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomFactorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomFactorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomSnapPointsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomSnapPointsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TopLeftHeaderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopLeftHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LeftHeaderProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TopHeaderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ReduceViewportForCoreInputViewOcclusionsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ReduceViewportForCoreInputViewOcclusionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalAnchorRatioProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalAnchorRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalAnchorRatioProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalAnchorRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalScrollBarVisibilityProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetHorizontalScrollBarVisibility
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetHorizontalScrollBarVisibility (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetHorizontalScrollBarVisibility
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      horizontalScrollBarVisibility : WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetHorizontalScrollBarVisibility (element.m_IDependencyObject.all, horizontalScrollBarVisibility);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_VerticalScrollBarVisibilityProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetVerticalScrollBarVisibility
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetVerticalScrollBarVisibility (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetVerticalScrollBarVisibility
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      verticalScrollBarVisibility : WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetVerticalScrollBarVisibility (element.m_IDependencyObject.all, verticalScrollBarVisibility);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsHorizontalRailEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHorizontalRailEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsHorizontalRailEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsHorizontalRailEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsHorizontalRailEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      isHorizontalRailEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsHorizontalRailEnabled (element.m_IDependencyObject.all, isHorizontalRailEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsVerticalRailEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVerticalRailEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsVerticalRailEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsVerticalRailEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsVerticalRailEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      isVerticalRailEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsVerticalRailEnabled (element.m_IDependencyObject.all, isVerticalRailEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsHorizontalScrollChainingEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHorizontalScrollChainingEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsHorizontalScrollChainingEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsHorizontalScrollChainingEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsHorizontalScrollChainingEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      isHorizontalScrollChainingEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsHorizontalScrollChainingEnabled (element.m_IDependencyObject.all, isHorizontalScrollChainingEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsVerticalScrollChainingEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVerticalScrollChainingEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsVerticalScrollChainingEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsVerticalScrollChainingEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsVerticalScrollChainingEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      isVerticalScrollChainingEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsVerticalScrollChainingEnabled (element.m_IDependencyObject.all, isVerticalScrollChainingEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsZoomChainingEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomChainingEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsZoomChainingEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsZoomChainingEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsZoomChainingEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      isZoomChainingEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsZoomChainingEnabled (element.m_IDependencyObject.all, isZoomChainingEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsScrollInertiaEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsScrollInertiaEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsScrollInertiaEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsScrollInertiaEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsScrollInertiaEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      isScrollInertiaEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsScrollInertiaEnabled (element.m_IDependencyObject.all, isScrollInertiaEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsZoomInertiaEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomInertiaEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsZoomInertiaEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsZoomInertiaEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsZoomInertiaEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      isZoomInertiaEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsZoomInertiaEnabled (element.m_IDependencyObject.all, isZoomInertiaEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_HorizontalScrollModeProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetHorizontalScrollMode
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetHorizontalScrollMode (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetHorizontalScrollMode
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      horizontalScrollMode : WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetHorizontalScrollMode (element.m_IDependencyObject.all, horizontalScrollMode);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_VerticalScrollModeProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetVerticalScrollMode
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetVerticalScrollMode (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetVerticalScrollMode
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      verticalScrollMode : WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetVerticalScrollMode (element.m_IDependencyObject.all, verticalScrollMode);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ZoomModeProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetZoomMode
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ZoomMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ZoomMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetZoomMode (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetZoomMode
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      zoomMode : WinUI3.Microsoft.UI.Xaml.Controls.ZoomMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetZoomMode (element.m_IDependencyObject.all, zoomMode);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_CanContentRenderOutsideBoundsProperty_ScrollViewer
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanContentRenderOutsideBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetCanContentRenderOutsideBounds
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetCanContentRenderOutsideBounds (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetCanContentRenderOutsideBounds
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      canContentRenderOutsideBounds : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetCanContentRenderOutsideBounds (element.m_IDependencyObject.all, canContentRenderOutsideBounds);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsDeferredScrollingEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDeferredScrollingEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsDeferredScrollingEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsDeferredScrollingEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsDeferredScrollingEnabled
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      isDeferredScrollingEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsDeferredScrollingEnabled (element.m_IDependencyObject.all, isDeferredScrollingEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_BringIntoViewOnFocusChangeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BringIntoViewOnFocusChangeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetBringIntoViewOnFocusChange
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetBringIntoViewOnFocusChange (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetBringIntoViewOnFocusChange
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      bringIntoViewOnFocusChange : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetBringIntoViewOnFocusChange (element.m_IDependencyObject.all, bringIntoViewOnFocusChange);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollViewer

   function get_HorizontalScrollBarVisibility
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility;
   begin
      Hr := this.m_IScrollViewer.all.get_HorizontalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollBarVisibility
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_HorizontalScrollBarVisibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollBarVisibility
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility;
   begin
      Hr := this.m_IScrollViewer.all.get_VerticalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollBarVisibility
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollBarVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_VerticalScrollBarVisibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHorizontalRailEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsHorizontalRailEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHorizontalRailEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsHorizontalRailEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVerticalRailEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsVerticalRailEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsVerticalRailEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsVerticalRailEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHorizontalScrollChainingEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsHorizontalScrollChainingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHorizontalScrollChainingEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsHorizontalScrollChainingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVerticalScrollChainingEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsVerticalScrollChainingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsVerticalScrollChainingEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsVerticalScrollChainingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomChainingEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsZoomChainingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomChainingEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsZoomChainingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsScrollInertiaEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsScrollInertiaEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsScrollInertiaEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsScrollInertiaEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomInertiaEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsZoomInertiaEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomInertiaEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsZoomInertiaEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalScrollMode
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode;
   begin
      Hr := this.m_IScrollViewer.all.get_HorizontalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollMode
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_HorizontalScrollMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollMode
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode;
   begin
      Hr := this.m_IScrollViewer.all.get_VerticalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollMode
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_VerticalScrollMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomMode
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ZoomMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ZoomMode;
   begin
      Hr := this.m_IScrollViewer.all.get_ZoomMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomMode
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ZoomMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_ZoomMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalSnapPointsAlignment
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
   begin
      Hr := this.m_IScrollViewer.all.get_HorizontalSnapPointsAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalSnapPointsAlignment
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_HorizontalSnapPointsAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalSnapPointsAlignment
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
   begin
      Hr := this.m_IScrollViewer.all.get_VerticalSnapPointsAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalSnapPointsAlignment
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_VerticalSnapPointsAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalSnapPointsType
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SnapPointsType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.SnapPointsType;
   begin
      Hr := this.m_IScrollViewer.all.get_HorizontalSnapPointsType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalSnapPointsType
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SnapPointsType
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_HorizontalSnapPointsType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalSnapPointsType
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SnapPointsType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.SnapPointsType;
   begin
      Hr := this.m_IScrollViewer.all.get_VerticalSnapPointsType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalSnapPointsType
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SnapPointsType
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_VerticalSnapPointsType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomSnapPointsType
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SnapPointsType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.SnapPointsType;
   begin
      Hr := this.m_IScrollViewer.all.get_ZoomSnapPointsType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomSnapPointsType
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SnapPointsType
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_ZoomSnapPointsType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalOffset
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportWidth
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ViewportWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollableWidth
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ScrollableWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ComputedHorizontalScrollBarVisibility
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_IScrollViewer.all.get_ComputedHorizontalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentWidth
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ExtentWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalOffset
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportHeight
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ViewportHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollableHeight
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ScrollableHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ComputedVerticalScrollBarVisibility
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_IScrollViewer.all.get_ComputedVerticalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentHeight
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ExtentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MinZoomFactor
   (
      this : in out ScrollViewer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollViewer.all.get_MinZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinZoomFactor
   (
      this : in out ScrollViewer;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_MinZoomFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxZoomFactor
   (
      this : in out ScrollViewer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollViewer.all.get_MaxZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxZoomFactor
   (
      this : in out ScrollViewer;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_MaxZoomFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomFactor
   (
      this : in out ScrollViewer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollViewer.all.get_ZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZoomSnapPoints
   (
      this : in out ScrollViewer
   )
   return IVector_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_Single.Kind;
   begin
      Hr := this.m_IScrollViewer.all.get_ZoomSnapPoints (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_TopLeftHeader
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IScrollViewer.all.get_TopLeftHeader (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_TopLeftHeader
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_TopLeftHeader (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LeftHeader
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IScrollViewer.all.get_LeftHeader (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_LeftHeader
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_LeftHeader (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopHeader
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IScrollViewer.all.get_TopHeader (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_TopHeader
   (
      this : in out ScrollViewer;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_TopHeader (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ReduceViewportForCoreInputViewOcclusions
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_ReduceViewportForCoreInputViewOcclusions (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ReduceViewportForCoreInputViewOcclusions
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_ReduceViewportForCoreInputViewOcclusions (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalAnchorRatio
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_HorizontalAnchorRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalAnchorRatio
   (
      this : in out ScrollViewer;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_HorizontalAnchorRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalAnchorRatio
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_VerticalAnchorRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalAnchorRatio
   (
      this : in out ScrollViewer;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_VerticalAnchorRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanContentRenderOutsideBounds
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_CanContentRenderOutsideBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanContentRenderOutsideBounds
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_CanContentRenderOutsideBounds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_AnchorRequested
   (
      this : in out ScrollViewer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollViewer.all.add_AnchorRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_AnchorRequested
   (
      this : in out ScrollViewer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.remove_AnchorRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ViewChanging
   (
      this : in out ScrollViewer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollViewer.all.add_ViewChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ViewChanging
   (
      this : in out ScrollViewer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.remove_ViewChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ViewChanged
   (
      this : in out ScrollViewer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollViewer.all.add_ViewChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ViewChanged
   (
      this : in out ScrollViewer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.remove_ViewChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DirectManipulationStarted
   (
      this : in out ScrollViewer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollViewer.all.add_DirectManipulationStarted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DirectManipulationStarted
   (
      this : in out ScrollViewer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.remove_DirectManipulationStarted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DirectManipulationCompleted
   (
      this : in out ScrollViewer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollViewer.all.add_DirectManipulationCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DirectManipulationCompleted
   (
      this : in out ScrollViewer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.remove_DirectManipulationCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollToHorizontalOffset
   (
      this : in out ScrollViewer;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.ScrollToHorizontalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollToVerticalOffset
   (
      this : in out ScrollViewer;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.ScrollToVerticalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ZoomToFactor
   (
      this : in out ScrollViewer;
      factor : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.ZoomToFactor (factor);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ChangeView
   (
      this : in out ScrollViewer;
      horizontalOffset : GenericObject;
      verticalOffset : GenericObject;
      zoomFactor : GenericObject
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.ChangeView (horizontalOffset, verticalOffset, zoomFactor, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ChangeView
   (
      this : in out ScrollViewer;
      horizontalOffset : GenericObject;
      verticalOffset : GenericObject;
      zoomFactor : GenericObject;
      disableAnimation : WinUI3.Boolean
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.ChangeView (horizontalOffset, verticalOffset, zoomFactor, disableAnimation, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure InvalidateScrollInfo
   (
      this : in out ScrollViewer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.InvalidateScrollInfo;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsDeferredScrollingEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsDeferredScrollingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDeferredScrollingEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsDeferredScrollingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BringIntoViewOnFocusChange
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_BringIntoViewOnFocusChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BringIntoViewOnFocusChange
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_BringIntoViewOnFocusChange (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CurrentAnchor
   (
      this : in out ScrollViewer
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider, WinUI3.Microsoft.UI.Xaml.Controls.IID_IScrollAnchorProvider'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IScrollViewer.all);
         Hr := m_Interface.get_CurrentAnchor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure RegisterAnchorCandidate
   (
      this : in out ScrollViewer;
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider, WinUI3.Microsoft.UI.Xaml.Controls.IID_IScrollAnchorProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.RegisterAnchorCandidate (element.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure UnregisterAnchorCandidate
   (
      this : in out ScrollViewer;
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider, WinUI3.Microsoft.UI.Xaml.Controls.IID_IScrollAnchorProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.UnregisterAnchorCandidate (element.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollViewerView

   procedure Initialize (this : in out ScrollViewerView) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollViewerView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollViewerView, IScrollViewerView_Ptr);
   begin
      if this.m_IScrollViewerView /= null then
         if this.m_IScrollViewerView.all /= null then
            temp := this.m_IScrollViewerView.all.Release;
            Free (this.m_IScrollViewerView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollViewerView

   function get_HorizontalOffset
   (
      this : in out ScrollViewerView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewerView.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalOffset
   (
      this : in out ScrollViewerView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewerView.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZoomFactor
   (
      this : in out ScrollViewerView
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollViewerView.all.get_ZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollViewerViewChangedEventArgs

   procedure Initialize (this : in out ScrollViewerViewChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollViewerViewChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollViewerViewChangedEventArgs, IScrollViewerViewChangedEventArgs_Ptr);
   begin
      if this.m_IScrollViewerViewChangedEventArgs /= null then
         if this.m_IScrollViewerViewChangedEventArgs.all /= null then
            temp := this.m_IScrollViewerViewChangedEventArgs.all.Release;
            Free (this.m_IScrollViewerViewChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollViewerViewChangedEventArgs

   function Constructor return ScrollViewerViewChangedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IScrollViewerViewChangedEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerViewChangedEventArgs;
   begin
      return RetVal : ScrollViewerViewChangedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IScrollViewerViewChangedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerViewChangedEventArgs;
            Retval.m_IScrollViewerViewChangedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollViewerViewChangedEventArgs

   function get_IsIntermediate
   (
      this : in out ScrollViewerViewChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewerViewChangedEventArgs.all.get_IsIntermediate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollViewerViewChangingEventArgs

   procedure Initialize (this : in out ScrollViewerViewChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollViewerViewChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollViewerViewChangingEventArgs, IScrollViewerViewChangingEventArgs_Ptr);
   begin
      if this.m_IScrollViewerViewChangingEventArgs /= null then
         if this.m_IScrollViewerViewChangingEventArgs.all /= null then
            temp := this.m_IScrollViewerViewChangingEventArgs.all.Release;
            Free (this.m_IScrollViewerViewChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollViewerViewChangingEventArgs

   function get_NextView
   (
      this : in out ScrollViewerViewChangingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollViewerView'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerView;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ScrollViewerView do
         Hr := this.m_IScrollViewerViewChangingEventArgs.all.get_NextView (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScrollViewerView := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerView;
         Retval.m_IScrollViewerView.all := m_ComRetVal;
      end return;
   end;

   function get_FinalView
   (
      this : in out ScrollViewerViewChangingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollViewerView'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerView;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ScrollViewerView do
         Hr := this.m_IScrollViewerViewChangingEventArgs.all.get_FinalView (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScrollViewerView := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollViewerView;
         Retval.m_IScrollViewerView.all := m_ComRetVal;
      end return;
   end;

   function get_IsInertial
   (
      this : in out ScrollViewerViewChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewerViewChangingEventArgs.all.get_IsInertial (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollingAnchorRequestedEventArgs

   procedure Initialize (this : in out ScrollingAnchorRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollingAnchorRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollingAnchorRequestedEventArgs, IScrollingAnchorRequestedEventArgs_Ptr);
   begin
      if this.m_IScrollingAnchorRequestedEventArgs /= null then
         if this.m_IScrollingAnchorRequestedEventArgs.all /= null then
            temp := this.m_IScrollingAnchorRequestedEventArgs.all.Release;
            Free (this.m_IScrollingAnchorRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollingAnchorRequestedEventArgs

   function get_AnchorCandidates
   (
      this : in out ScrollingAnchorRequestedEventArgs
   )
   return IVector_IUIElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IUIElement.Kind;
   begin
      Hr := this.m_IScrollingAnchorRequestedEventArgs.all.get_AnchorCandidates (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IUIElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_AnchorElement
   (
      this : in out ScrollingAnchorRequestedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IScrollingAnchorRequestedEventArgs.all.get_AnchorElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_AnchorElement
   (
      this : in out ScrollingAnchorRequestedEventArgs;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollingAnchorRequestedEventArgs.all.put_AnchorElement (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollingBringingIntoViewEventArgs

   procedure Initialize (this : in out ScrollingBringingIntoViewEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollingBringingIntoViewEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollingBringingIntoViewEventArgs, IScrollingBringingIntoViewEventArgs_Ptr);
   begin
      if this.m_IScrollingBringingIntoViewEventArgs /= null then
         if this.m_IScrollingBringingIntoViewEventArgs.all /= null then
            temp := this.m_IScrollingBringingIntoViewEventArgs.all.Release;
            Free (this.m_IScrollingBringingIntoViewEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollingBringingIntoViewEventArgs

   function get_SnapPointsMode
   (
      this : in out ScrollingBringingIntoViewEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingSnapPointsMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingSnapPointsMode;
   begin
      Hr := this.m_IScrollingBringingIntoViewEventArgs.all.get_SnapPointsMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SnapPointsMode
   (
      this : in out ScrollingBringingIntoViewEventArgs;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingSnapPointsMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollingBringingIntoViewEventArgs.all.put_SnapPointsMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RequestEventArgs
   (
      this : in out ScrollingBringingIntoViewEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.BringIntoViewRequestedEventArgs'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IBringIntoViewRequestedEventArgs;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.BringIntoViewRequestedEventArgs do
         Hr := this.m_IScrollingBringingIntoViewEventArgs.all.get_RequestEventArgs (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBringIntoViewRequestedEventArgs := new WinUI3.Microsoft.UI.Xaml.IBringIntoViewRequestedEventArgs;
         Retval.m_IBringIntoViewRequestedEventArgs.all := m_ComRetVal;
      end return;
   end;

   function get_TargetHorizontalOffset
   (
      this : in out ScrollingBringingIntoViewEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollingBringingIntoViewEventArgs.all.get_TargetHorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_TargetVerticalOffset
   (
      this : in out ScrollingBringingIntoViewEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollingBringingIntoViewEventArgs.all.get_TargetVerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CorrelationId
   (
      this : in out ScrollingBringingIntoViewEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollingBringingIntoViewEventArgs.all.get_CorrelationId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out ScrollingBringingIntoViewEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollingBringingIntoViewEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out ScrollingBringingIntoViewEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollingBringingIntoViewEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollingScrollAnimationStartingEventArgs

   procedure Initialize (this : in out ScrollingScrollAnimationStartingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollingScrollAnimationStartingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollingScrollAnimationStartingEventArgs, IScrollingScrollAnimationStartingEventArgs_Ptr);
   begin
      if this.m_IScrollingScrollAnimationStartingEventArgs /= null then
         if this.m_IScrollingScrollAnimationStartingEventArgs.all /= null then
            temp := this.m_IScrollingScrollAnimationStartingEventArgs.all.Release;
            Free (this.m_IScrollingScrollAnimationStartingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollingScrollAnimationStartingEventArgs

   function get_Animation
   (
      this : in out ScrollingScrollAnimationStartingEventArgs
   )
   return WinUI3.Microsoft.UI.Composition.CompositionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.ICompositionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.CompositionAnimation do
         Hr := this.m_IScrollingScrollAnimationStartingEventArgs.all.get_Animation (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionAnimation := new WinUI3.Microsoft.UI.Composition.ICompositionAnimation;
         Retval.m_ICompositionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_Animation
   (
      this : in out ScrollingScrollAnimationStartingEventArgs;
      value : WinUI3.Microsoft.UI.Composition.CompositionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollingScrollAnimationStartingEventArgs.all.put_Animation (value.m_ICompositionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StartPosition
   (
      this : in out ScrollingScrollAnimationStartingEventArgs
   )
   return WinUI3.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_IScrollingScrollAnimationStartingEventArgs.all.get_StartPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_EndPosition
   (
      this : in out ScrollingScrollAnimationStartingEventArgs
   )
   return WinUI3.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_IScrollingScrollAnimationStartingEventArgs.all.get_EndPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CorrelationId
   (
      this : in out ScrollingScrollAnimationStartingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollingScrollAnimationStartingEventArgs.all.get_CorrelationId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollingScrollCompletedEventArgs

   procedure Initialize (this : in out ScrollingScrollCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollingScrollCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollingScrollCompletedEventArgs, IScrollingScrollCompletedEventArgs_Ptr);
   begin
      if this.m_IScrollingScrollCompletedEventArgs /= null then
         if this.m_IScrollingScrollCompletedEventArgs.all /= null then
            temp := this.m_IScrollingScrollCompletedEventArgs.all.Release;
            Free (this.m_IScrollingScrollCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollingScrollCompletedEventArgs

   function get_CorrelationId
   (
      this : in out ScrollingScrollCompletedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollingScrollCompletedEventArgs.all.get_CorrelationId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollingScrollOptions

   procedure Initialize (this : in out ScrollingScrollOptions) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollingScrollOptions) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollingScrollOptions, IScrollingScrollOptions_Ptr);
   begin
      if this.m_IScrollingScrollOptions /= null then
         if this.m_IScrollingScrollOptions.all /= null then
            temp := this.m_IScrollingScrollOptions.all.Release;
            Free (this.m_IScrollingScrollOptions);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollingScrollOptions

   function Constructor
   (
      animationMode : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingAnimationMode;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ScrollingScrollOptions is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IScrollingScrollOptions");
      m_Factory    : access IScrollingScrollOptionsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollingScrollOptions;
   begin
      return RetVal : ScrollingScrollOptions do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollingScrollOptionsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (animationMode, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IScrollingScrollOptions := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollingScrollOptions;
            Retval.m_IScrollingScrollOptions.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      animationMode : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingAnimationMode;
      snapPointsMode : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingSnapPointsMode;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ScrollingScrollOptions is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IScrollingScrollOptions");
      m_Factory    : access IScrollingScrollOptionsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollingScrollOptions;
   begin
      return RetVal : ScrollingScrollOptions do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollingScrollOptionsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance2 (animationMode, snapPointsMode, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IScrollingScrollOptions := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollingScrollOptions;
            Retval.m_IScrollingScrollOptions.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollingScrollOptions

   function get_AnimationMode
   (
      this : in out ScrollingScrollOptions
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingAnimationMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingAnimationMode;
   begin
      Hr := this.m_IScrollingScrollOptions.all.get_AnimationMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AnimationMode
   (
      this : in out ScrollingScrollOptions;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingAnimationMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollingScrollOptions.all.put_AnimationMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SnapPointsMode
   (
      this : in out ScrollingScrollOptions
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingSnapPointsMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingSnapPointsMode;
   begin
      Hr := this.m_IScrollingScrollOptions.all.get_SnapPointsMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SnapPointsMode
   (
      this : in out ScrollingScrollOptions;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingSnapPointsMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollingScrollOptions.all.put_SnapPointsMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollingZoomAnimationStartingEventArgs

   procedure Initialize (this : in out ScrollingZoomAnimationStartingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollingZoomAnimationStartingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollingZoomAnimationStartingEventArgs, IScrollingZoomAnimationStartingEventArgs_Ptr);
   begin
      if this.m_IScrollingZoomAnimationStartingEventArgs /= null then
         if this.m_IScrollingZoomAnimationStartingEventArgs.all /= null then
            temp := this.m_IScrollingZoomAnimationStartingEventArgs.all.Release;
            Free (this.m_IScrollingZoomAnimationStartingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollingZoomAnimationStartingEventArgs

   function get_CenterPoint
   (
      this : in out ScrollingZoomAnimationStartingEventArgs
   )
   return WinUI3.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_IScrollingZoomAnimationStartingEventArgs.all.get_CenterPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_StartZoomFactor
   (
      this : in out ScrollingZoomAnimationStartingEventArgs
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollingZoomAnimationStartingEventArgs.all.get_StartZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_EndZoomFactor
   (
      this : in out ScrollingZoomAnimationStartingEventArgs
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollingZoomAnimationStartingEventArgs.all.get_EndZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Animation
   (
      this : in out ScrollingZoomAnimationStartingEventArgs
   )
   return WinUI3.Microsoft.UI.Composition.CompositionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.ICompositionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.CompositionAnimation do
         Hr := this.m_IScrollingZoomAnimationStartingEventArgs.all.get_Animation (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionAnimation := new WinUI3.Microsoft.UI.Composition.ICompositionAnimation;
         Retval.m_ICompositionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_Animation
   (
      this : in out ScrollingZoomAnimationStartingEventArgs;
      value : WinUI3.Microsoft.UI.Composition.CompositionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollingZoomAnimationStartingEventArgs.all.put_Animation (value.m_ICompositionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CorrelationId
   (
      this : in out ScrollingZoomAnimationStartingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollingZoomAnimationStartingEventArgs.all.get_CorrelationId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollingZoomCompletedEventArgs

   procedure Initialize (this : in out ScrollingZoomCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollingZoomCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollingZoomCompletedEventArgs, IScrollingZoomCompletedEventArgs_Ptr);
   begin
      if this.m_IScrollingZoomCompletedEventArgs /= null then
         if this.m_IScrollingZoomCompletedEventArgs.all /= null then
            temp := this.m_IScrollingZoomCompletedEventArgs.all.Release;
            Free (this.m_IScrollingZoomCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollingZoomCompletedEventArgs

   function get_CorrelationId
   (
      this : in out ScrollingZoomCompletedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollingZoomCompletedEventArgs.all.get_CorrelationId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollingZoomOptions

   procedure Initialize (this : in out ScrollingZoomOptions) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollingZoomOptions) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollingZoomOptions, IScrollingZoomOptions_Ptr);
   begin
      if this.m_IScrollingZoomOptions /= null then
         if this.m_IScrollingZoomOptions.all /= null then
            temp := this.m_IScrollingZoomOptions.all.Release;
            Free (this.m_IScrollingZoomOptions);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollingZoomOptions

   function Constructor
   (
      animationMode : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingAnimationMode;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ScrollingZoomOptions is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IScrollingZoomOptions");
      m_Factory    : access IScrollingZoomOptionsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollingZoomOptions;
   begin
      return RetVal : ScrollingZoomOptions do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollingZoomOptionsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (animationMode, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IScrollingZoomOptions := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollingZoomOptions;
            Retval.m_IScrollingZoomOptions.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      animationMode : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingAnimationMode;
      snapPointsMode : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingSnapPointsMode;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ScrollingZoomOptions is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IScrollingZoomOptions");
      m_Factory    : access IScrollingZoomOptionsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollingZoomOptions;
   begin
      return RetVal : ScrollingZoomOptions do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollingZoomOptionsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance2 (animationMode, snapPointsMode, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IScrollingZoomOptions := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollingZoomOptions;
            Retval.m_IScrollingZoomOptions.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollingZoomOptions

   function get_AnimationMode
   (
      this : in out ScrollingZoomOptions
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingAnimationMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingAnimationMode;
   begin
      Hr := this.m_IScrollingZoomOptions.all.get_AnimationMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AnimationMode
   (
      this : in out ScrollingZoomOptions;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingAnimationMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollingZoomOptions.all.put_AnimationMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SnapPointsMode
   (
      this : in out ScrollingZoomOptions
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingSnapPointsMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingSnapPointsMode;
   begin
      Hr := this.m_IScrollingZoomOptions.all.get_SnapPointsMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SnapPointsMode
   (
      this : in out ScrollingZoomOptions;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingSnapPointsMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollingZoomOptions.all.put_SnapPointsMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SectionsInViewChangedEventArgs

   procedure Initialize (this : in out SectionsInViewChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SectionsInViewChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISectionsInViewChangedEventArgs, ISectionsInViewChangedEventArgs_Ptr);
   begin
      if this.m_ISectionsInViewChangedEventArgs /= null then
         if this.m_ISectionsInViewChangedEventArgs.all /= null then
            temp := this.m_ISectionsInViewChangedEventArgs.all.Release;
            Free (this.m_ISectionsInViewChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SectionsInViewChangedEventArgs

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SectionsInViewChangedEventArgs

   function get_AddedSections
   (
      this : in out SectionsInViewChangedEventArgs
   )
   return IVector_IHubSection.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IHubSection.Kind;
   begin
      Hr := this.m_ISectionsInViewChangedEventArgs.all.get_AddedSections (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IHubSection (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_RemovedSections
   (
      this : in out SectionsInViewChangedEventArgs
   )
   return IVector_IHubSection.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IHubSection.Kind;
   begin
      Hr := this.m_ISectionsInViewChangedEventArgs.all.get_RemovedSections (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IHubSection (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate SectionsInViewChangedEventHandler

   function Invoke
   (
      this : access SectionsInViewChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.ISectionsInViewChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SelectionChangedEventArgs

   procedure Initialize (this : in out SelectionChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SelectionChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISelectionChangedEventArgs, ISelectionChangedEventArgs_Ptr);
   begin
      if this.m_ISelectionChangedEventArgs /= null then
         if this.m_ISelectionChangedEventArgs.all /= null then
            temp := this.m_ISelectionChangedEventArgs.all.Release;
            Free (this.m_ISelectionChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SelectionChangedEventArgs

   function Constructor
   (
      removedItems : GenericObject;
      addedItems : GenericObject;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SelectionChangedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISelectionChangedEventArgs");
      m_Factory    : access ISelectionChangedEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISelectionChangedEventArgs;
   begin
      return RetVal : SelectionChangedEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectionChangedEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithRemovedItemsAndAddedItems (removedItems, addedItems, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISelectionChangedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.ISelectionChangedEventArgs;
            Retval.m_ISelectionChangedEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SelectionChangedEventArgs

   function get_AddedItems
   (
      this : in out SelectionChangedEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_ISelectionChangedEventArgs.all.get_AddedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_RemovedItems
   (
      this : in out SelectionChangedEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_ISelectionChangedEventArgs.all.get_RemovedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate SelectionChangedEventHandler

   function Invoke
   (
      this : access SelectionChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.ISelectionChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SelectorBar

   procedure Initialize (this : in out SelectorBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out SelectorBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISelectorBar, ISelectorBar_Ptr);
   begin
      if this.m_ISelectorBar /= null then
         if this.m_ISelectorBar.all /= null then
            temp := this.m_ISelectorBar.all.Release;
            Free (this.m_ISelectorBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SelectorBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SelectorBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISelectorBar");
      m_Factory    : access ISelectorBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISelectorBar;
   begin
      return RetVal : SelectorBar do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISelectorBar := new WinUI3.Microsoft.UI.Xaml.Controls.ISelectorBar;
            Retval.m_ISelectorBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SelectorBar

   function get_ItemsProperty_SelectorBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SelectorBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISelectorBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty_SelectorBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SelectorBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISelectorBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SelectorBar

   function get_Items
   (
      this : in out SelectorBar
   )
   return IVector_ISelectorBarItem.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_ISelectorBarItem.Kind;
   begin
      Hr := this.m_ISelectorBar.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_ISelectorBarItem (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SelectedItem
   (
      this : in out SelectorBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SelectorBarItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISelectorBarItem;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SelectorBarItem do
         Hr := this.m_ISelectorBar.all.get_SelectedItem (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISelectorBarItem := new WinUI3.Microsoft.UI.Xaml.Controls.ISelectorBarItem;
         Retval.m_ISelectorBarItem.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedItem
   (
      this : in out SelectorBar;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SelectorBarItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISelectorBar.all.put_SelectedItem (value.m_ISelectorBarItem.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out SelectorBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISelectorBar.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out SelectorBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISelectorBar.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SelectorBarItem

   procedure Initialize (this : in out SelectorBarItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out SelectorBarItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISelectorBarItem, ISelectorBarItem_Ptr);
   begin
      if this.m_ISelectorBarItem /= null then
         if this.m_ISelectorBarItem.all /= null then
            temp := this.m_ISelectorBarItem.all.Release;
            Free (this.m_ISelectorBarItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SelectorBarItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SelectorBarItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISelectorBarItem");
      m_Factory    : access ISelectorBarItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISelectorBarItem;
   begin
      return RetVal : SelectorBarItem do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorBarItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISelectorBarItem := new WinUI3.Microsoft.UI.Xaml.Controls.ISelectorBarItem;
            Retval.m_ISelectorBarItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SelectorBarItem

   function get_TextProperty_SelectorBarItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SelectorBarItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISelectorBarItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorBarItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty_SelectorBarItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SelectorBarItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISelectorBarItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorBarItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SelectorBarItem

   function get_Text
   (
      this : in out SelectorBarItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISelectorBarItem.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out SelectorBarItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISelectorBarItem.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Icon
   (
      this : in out SelectorBarItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_ISelectorBarItem.all.get_Icon (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out SelectorBarItem;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISelectorBarItem.all.put_Icon (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SelectorBarSelectionChangedEventArgs

   procedure Initialize (this : in out SelectorBarSelectionChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SelectorBarSelectionChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISelectorBarSelectionChangedEventArgs, ISelectorBarSelectionChangedEventArgs_Ptr);
   begin
      if this.m_ISelectorBarSelectionChangedEventArgs /= null then
         if this.m_ISelectorBarSelectionChangedEventArgs.all /= null then
            temp := this.m_ISelectorBarSelectionChangedEventArgs.all.Release;
            Free (this.m_ISelectorBarSelectionChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SelectorBarSelectionChangedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SemanticZoom

   procedure Initialize (this : in out SemanticZoom) is
   begin
      null;
   end;

   procedure Finalize (this : in out SemanticZoom) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISemanticZoom, ISemanticZoom_Ptr);
   begin
      if this.m_ISemanticZoom /= null then
         if this.m_ISemanticZoom.all /= null then
            temp := this.m_ISemanticZoom.all.Release;
            Free (this.m_ISemanticZoom);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SemanticZoom

   function Constructor return SemanticZoom is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISemanticZoom");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoom;
   begin
      return RetVal : SemanticZoom do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISemanticZoom := new WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoom;
            Retval.m_ISemanticZoom.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SemanticZoom

   function get_ZoomedInViewProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SemanticZoom");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticZoomStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomedInViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomedOutViewProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SemanticZoom");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticZoomStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomedOutViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsZoomedInViewActiveProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SemanticZoom");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticZoomStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomedInViewActiveProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanChangeViewsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SemanticZoom");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticZoomStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanChangeViewsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsZoomOutButtonEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SemanticZoom");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticZoomStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomOutButtonEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SemanticZoom

   function get_ZoomedInView
   (
      this : in out SemanticZoom
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation;
   begin
      Hr := this.m_ISemanticZoom.all.get_ZoomedInView (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomedInView
   (
      this : in out SemanticZoom;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.put_ZoomedInView (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomedOutView
   (
      this : in out SemanticZoom
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation;
   begin
      Hr := this.m_ISemanticZoom.all.get_ZoomedOutView (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomedOutView
   (
      this : in out SemanticZoom;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomInformation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.put_ZoomedOutView (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomedInViewActive
   (
      this : in out SemanticZoom
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISemanticZoom.all.get_IsZoomedInViewActive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomedInViewActive
   (
      this : in out SemanticZoom;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.put_IsZoomedInViewActive (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanChangeViews
   (
      this : in out SemanticZoom
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISemanticZoom.all.get_CanChangeViews (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanChangeViews
   (
      this : in out SemanticZoom;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.put_CanChangeViews (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ViewChangeStarted
   (
      this : in out SemanticZoom;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISemanticZoom.all.add_ViewChangeStarted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ViewChangeStarted
   (
      this : in out SemanticZoom;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.remove_ViewChangeStarted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ViewChangeCompleted
   (
      this : in out SemanticZoom;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISemanticZoom.all.add_ViewChangeCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ViewChangeCompleted
   (
      this : in out SemanticZoom;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.remove_ViewChangeCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ToggleActiveView
   (
      this : in out SemanticZoom
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.ToggleActiveView;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomOutButtonEnabled
   (
      this : in out SemanticZoom
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISemanticZoom.all.get_IsZoomOutButtonEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomOutButtonEnabled
   (
      this : in out SemanticZoom;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.put_IsZoomOutButtonEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SemanticZoomLocation

   procedure Initialize (this : in out SemanticZoomLocation) is
   begin
      null;
   end;

   procedure Finalize (this : in out SemanticZoomLocation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISemanticZoomLocation, ISemanticZoomLocation_Ptr);
   begin
      if this.m_ISemanticZoomLocation /= null then
         if this.m_ISemanticZoomLocation.all /= null then
            temp := this.m_ISemanticZoomLocation.all.Release;
            Free (this.m_ISemanticZoomLocation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SemanticZoomLocation

   function Constructor return SemanticZoomLocation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISemanticZoomLocation");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomLocation;
   begin
      return RetVal : SemanticZoomLocation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISemanticZoomLocation := new WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomLocation;
            Retval.m_ISemanticZoomLocation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SemanticZoomLocation

   function get_Item
   (
      this : in out SemanticZoomLocation
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ISemanticZoomLocation.all.get_Item (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Item
   (
      this : in out SemanticZoomLocation;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoomLocation.all.put_Item (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Bounds
   (
      this : in out SemanticZoomLocation
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_ISemanticZoomLocation.all.get_Bounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Bounds
   (
      this : in out SemanticZoomLocation;
      value : WinUI3.Windows.Foundation.Rect
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoomLocation.all.put_Bounds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SemanticZoomViewChangedEventArgs

   procedure Initialize (this : in out SemanticZoomViewChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SemanticZoomViewChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISemanticZoomViewChangedEventArgs, ISemanticZoomViewChangedEventArgs_Ptr);
   begin
      if this.m_ISemanticZoomViewChangedEventArgs /= null then
         if this.m_ISemanticZoomViewChangedEventArgs.all /= null then
            temp := this.m_ISemanticZoomViewChangedEventArgs.all.Release;
            Free (this.m_ISemanticZoomViewChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SemanticZoomViewChangedEventArgs

   function Constructor return SemanticZoomViewChangedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs;
   begin
      return RetVal : SemanticZoomViewChangedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISemanticZoomViewChangedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs;
            Retval.m_ISemanticZoomViewChangedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SemanticZoomViewChangedEventArgs

   function get_IsSourceZoomedInView
   (
      this : in out SemanticZoomViewChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISemanticZoomViewChangedEventArgs.all.get_IsSourceZoomedInView (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSourceZoomedInView
   (
      this : in out SemanticZoomViewChangedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoomViewChangedEventArgs.all.put_IsSourceZoomedInView (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SourceItem
   (
      this : in out SemanticZoomViewChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomLocation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation do
         Hr := this.m_ISemanticZoomViewChangedEventArgs.all.get_SourceItem (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISemanticZoomLocation := new WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomLocation;
         Retval.m_ISemanticZoomLocation.all := m_ComRetVal;
      end return;
   end;

   procedure put_SourceItem
   (
      this : in out SemanticZoomViewChangedEventArgs;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoomViewChangedEventArgs.all.put_SourceItem (value.m_ISemanticZoomLocation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DestinationItem
   (
      this : in out SemanticZoomViewChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomLocation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation do
         Hr := this.m_ISemanticZoomViewChangedEventArgs.all.get_DestinationItem (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISemanticZoomLocation := new WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomLocation;
         Retval.m_ISemanticZoomLocation.all := m_ComRetVal;
      end return;
   end;

   procedure put_DestinationItem
   (
      this : in out SemanticZoomViewChangedEventArgs;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoomViewChangedEventArgs.all.put_DestinationItem (value.m_ISemanticZoomLocation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate SemanticZoomViewChangedEventHandler

   function Invoke
   (
      this : access SemanticZoomViewChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitButton

   procedure Initialize (this : in out SplitButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitButton, ISplitButton_Ptr);
   begin
      if this.m_ISplitButton /= null then
         if this.m_ISplitButton.all /= null then
            temp := this.m_ISplitButton.all.Release;
            Free (this.m_ISplitButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SplitButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SplitButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISplitButton");
      m_Factory    : access ISplitButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISplitButton;
   begin
      return RetVal : SplitButton do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISplitButton := new WinUI3.Microsoft.UI.Xaml.Controls.ISplitButton;
            Retval.m_ISplitButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SplitButton

   function get_FlyoutProperty_SplitButton
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandProperty_SplitButton
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandParameterProperty_SplitButton
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitButton

   function get_Flyout
   (
      this : in out SplitButton
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := this.m_ISplitButton.all.get_Flyout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_Flyout
   (
      this : in out SplitButton;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitButton.all.put_Flyout (value.m_IFlyoutBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Command
   (
      this : in out SplitButton
   )
   return WinUI3.Microsoft.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_ISplitButton.all.get_Command (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Command
   (
      this : in out SplitButton;
      value : WinUI3.Microsoft.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitButton.all.put_Command (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CommandParameter
   (
      this : in out SplitButton
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ISplitButton.all.get_CommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CommandParameter
   (
      this : in out SplitButton;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitButton.all.put_CommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Click
   (
      this : in out SplitButton;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISplitButton.all.add_Click (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Click
   (
      this : in out SplitButton;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitButton.all.remove_Click (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitButtonClickEventArgs

   procedure Initialize (this : in out SplitButtonClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitButtonClickEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitButtonClickEventArgs, ISplitButtonClickEventArgs_Ptr);
   begin
      if this.m_ISplitButtonClickEventArgs /= null then
         if this.m_ISplitButtonClickEventArgs.all /= null then
            temp := this.m_ISplitButtonClickEventArgs.all.Release;
            Free (this.m_ISplitButtonClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitButtonClickEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitView

   procedure Initialize (this : in out SplitView) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitView, ISplitView_Ptr);
   begin
      if this.m_ISplitView /= null then
         if this.m_ISplitView.all /= null then
            temp := this.m_ISplitView.all.Release;
            Free (this.m_ISplitView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SplitView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SplitView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISplitView");
      m_Factory    : access ISplitViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISplitView;
   begin
      return RetVal : SplitView do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISplitView := new WinUI3.Microsoft.UI.Xaml.Controls.ISplitView;
            Retval.m_ISplitView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SplitView

   function get_ContentProperty_SplitView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPaneOpenProperty_SplitView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPaneOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpenPaneLengthProperty_SplitView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpenPaneLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CompactPaneLengthProperty_SplitView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompactPaneLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PanePlacementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PanePlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayModeProperty_SplitView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateSettingsProperty_SplitView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty_SplitView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitView

   function get_Content
   (
      this : in out SplitView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_ISplitView.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out SplitView;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pane
   (
      this : in out SplitView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_ISplitView.all.get_Pane (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Pane
   (
      this : in out SplitView;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_Pane (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPaneOpen
   (
      this : in out SplitView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISplitView.all.get_IsPaneOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPaneOpen
   (
      this : in out SplitView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_IsPaneOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpenPaneLength
   (
      this : in out SplitView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitView.all.get_OpenPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpenPaneLength
   (
      this : in out SplitView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_OpenPaneLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CompactPaneLength
   (
      this : in out SplitView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitView.all.get_CompactPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CompactPaneLength
   (
      this : in out SplitView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_CompactPaneLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PanePlacement
   (
      this : in out SplitView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SplitViewPanePlacement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.SplitViewPanePlacement;
   begin
      Hr := this.m_ISplitView.all.get_PanePlacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PanePlacement
   (
      this : in out SplitView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SplitViewPanePlacement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_PanePlacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMode
   (
      this : in out SplitView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SplitViewDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.SplitViewDisplayMode;
   begin
      Hr := this.m_ISplitView.all.get_DisplayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DisplayMode
   (
      this : in out SplitView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SplitViewDisplayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_DisplayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out SplitView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISplitViewTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings do
         Hr := this.m_ISplitView.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISplitViewTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISplitViewTemplateSettings;
         Retval.m_ISplitViewTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_PaneBackground
   (
      this : in out SplitView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ISplitView.all.get_PaneBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PaneBackground
   (
      this : in out SplitView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_PaneBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out SplitView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode;
   begin
      Hr := this.m_ISplitView.all.get_LightDismissOverlayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out SplitView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_LightDismissOverlayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneClosing
   (
      this : in out SplitView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISplitView.all.add_PaneClosing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneClosing
   (
      this : in out SplitView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.remove_PaneClosing (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneClosed
   (
      this : in out SplitView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISplitView.all.add_PaneClosed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneClosed
   (
      this : in out SplitView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.remove_PaneClosed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneOpening
   (
      this : in out SplitView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISplitView.all.add_PaneOpening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneOpening
   (
      this : in out SplitView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.remove_PaneOpening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneOpened
   (
      this : in out SplitView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISplitView.all.add_PaneOpened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneOpened
   (
      this : in out SplitView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.remove_PaneOpened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitViewPaneClosingEventArgs

   procedure Initialize (this : in out SplitViewPaneClosingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitViewPaneClosingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitViewPaneClosingEventArgs, ISplitViewPaneClosingEventArgs_Ptr);
   begin
      if this.m_ISplitViewPaneClosingEventArgs /= null then
         if this.m_ISplitViewPaneClosingEventArgs.all /= null then
            temp := this.m_ISplitViewPaneClosingEventArgs.all.Release;
            Free (this.m_ISplitViewPaneClosingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitViewPaneClosingEventArgs

   function get_Cancel
   (
      this : in out SplitViewPaneClosingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISplitViewPaneClosingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out SplitViewPaneClosingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitViewPaneClosingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StackLayout

   procedure Initialize (this : in out StackLayout) is
   begin
      null;
   end;

   procedure Finalize (this : in out StackLayout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStackLayout, IStackLayout_Ptr);
   begin
      if this.m_IStackLayout /= null then
         if this.m_IStackLayout.all /= null then
            temp := this.m_IStackLayout.all.Release;
            Free (this.m_IStackLayout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for StackLayout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return StackLayout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IStackLayout");
      m_Factory    : access IStackLayoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IStackLayout;
   begin
      return RetVal : StackLayout do
         Hr := RoGetActivationFactory (m_hString, IID_IStackLayoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IStackLayout := new WinUI3.Microsoft.UI.Xaml.Controls.IStackLayout;
            Retval.m_IStackLayout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for StackLayout

   function get_OrientationProperty_StackLayout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.StackLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IStackLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SpacingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.StackLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IStackLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StackLayout

   function get_Orientation
   (
      this : in out StackLayout
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IStackLayout.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out StackLayout;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackLayout.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Spacing
   (
      this : in out StackLayout
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IStackLayout.all.get_Spacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Spacing
   (
      this : in out StackLayout;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackLayout.all.put_Spacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StackPanel

   procedure Initialize (this : in out StackPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out StackPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStackPanel, IStackPanel_Ptr);
   begin
      if this.m_IStackPanel /= null then
         if this.m_IStackPanel.all /= null then
            temp := this.m_IStackPanel.all.Release;
            Free (this.m_IStackPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for StackPanel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return StackPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IStackPanel");
      m_Factory    : access IStackPanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IStackPanel;
   begin
      return RetVal : StackPanel do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IStackPanel := new WinUI3.Microsoft.UI.Xaml.Controls.IStackPanel;
            Retval.m_IStackPanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for StackPanel

   function get_AreScrollSnapPointsRegularProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreScrollSnapPointsRegularProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_StackPanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundSizingProperty_StackPanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderBrushProperty_StackPanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty_StackPanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty_StackPanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_StackPanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SpacingProperty_StackPanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StackPanel

   function get_AreScrollSnapPointsRegular
   (
      this : in out StackPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IStackPanel.all.get_AreScrollSnapPointsRegular (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreScrollSnapPointsRegular
   (
      this : in out StackPanel;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackPanel.all.put_AreScrollSnapPointsRegular (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out StackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IStackPanel.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out StackPanel;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackPanel.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundSizing
   (
      this : in out StackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing;
   begin
      Hr := this.m_IStackPanel.all.get_BackgroundSizing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out StackPanel;
      value : WinUI3.Microsoft.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackPanel.all.put_BackgroundSizing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderBrush
   (
      this : in out StackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IStackPanel.all.get_BorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out StackPanel;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackPanel.all.put_BorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out StackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IStackPanel.all.get_BorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out StackPanel;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackPanel.all.put_BorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out StackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_IStackPanel.all.get_CornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out StackPanel;
      value : WinUI3.Microsoft.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackPanel.all.put_CornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out StackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IStackPanel.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out StackPanel;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackPanel.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Spacing
   (
      this : in out StackPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IStackPanel.all.get_Spacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Spacing
   (
      this : in out StackPanel;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackPanel.all.put_Spacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AreHorizontalSnapPointsRegular
   (
      this : in out StackPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.get_AreHorizontalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreVerticalSnapPointsRegular
   (
      this : in out StackPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.get_AreVerticalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HorizontalSnapPointsChanged
   (
      this : in out StackPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.add_HorizontalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HorizontalSnapPointsChanged
   (
      this : in out StackPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.remove_HorizontalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_VerticalSnapPointsChanged
   (
      this : in out StackPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.add_VerticalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VerticalSnapPointsChanged
   (
      this : in out StackPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.remove_VerticalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetIrregularSnapPoints
   (
      this : in out StackPanel;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   )
   return IVectorView_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_Single.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.GetIrregularSnapPoints (orientation, alignment, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetRegularSnapPoints
   (
      this : in out StackPanel;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
      offset : WinUI3.Single_Ptr
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.GetRegularSnapPoints (orientation, alignment, offset, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure GetInsertionIndexes
   (
      this : in out StackPanel;
      position : WinUI3.Windows.Foundation.Point;
      first : WinUI3.Int32_Ptr;
      second : WinUI3.Int32_Ptr
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IInsertionPanel := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IInsertionPanel, WinUI3.Microsoft.UI.Xaml.Controls.IID_IInsertionPanel'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.GetInsertionIndexes (position, first, second);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StyleSelector

   procedure Initialize (this : in out StyleSelector) is
   begin
      null;
   end;

   procedure Finalize (this : in out StyleSelector) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStyleSelector, IStyleSelector_Ptr);
   begin
      if this.m_IStyleSelector /= null then
         if this.m_IStyleSelector.all /= null then
            temp := this.m_IStyleSelector.all.Release;
            Free (this.m_IStyleSelector);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for StyleSelector

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return StyleSelector is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IStyleSelector");
      m_Factory    : access IStyleSelectorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelector;
   begin
      return RetVal : StyleSelector do
         Hr := RoGetActivationFactory (m_hString, IID_IStyleSelectorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IStyleSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelector;
            Retval.m_IStyleSelector.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StyleSelector

   function SelectStyle
   (
      this : in out StyleSelector;
      item : WinUI3.IInspectable;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_IStyleSelector.all.SelectStyle (item, container.m_IDependencyObject.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   function SelectStyleCore
   (
      this : in out StyleSelector;
      item : WinUI3.IInspectable;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelectorOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelector_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelectorOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IStyleSelectorOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         m_Interface := QInterface (this.m_IStyleSelector.all);
         Hr := m_Interface.SelectStyleCore (item, container.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwapChainBackgroundPanel

   procedure Initialize (this : in out SwapChainBackgroundPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwapChainBackgroundPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwapChainBackgroundPanel, ISwapChainBackgroundPanel_Ptr);
   begin
      if this.m_ISwapChainBackgroundPanel /= null then
         if this.m_ISwapChainBackgroundPanel.all /= null then
            temp := this.m_ISwapChainBackgroundPanel.all.Release;
            Free (this.m_ISwapChainBackgroundPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwapChainBackgroundPanel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SwapChainBackgroundPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISwapChainBackgroundPanel");
      m_Factory    : access ISwapChainBackgroundPanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwapChainBackgroundPanel;
   begin
      return RetVal : SwapChainBackgroundPanel do
         Hr := RoGetActivationFactory (m_hString, IID_ISwapChainBackgroundPanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISwapChainBackgroundPanel := new WinUI3.Microsoft.UI.Xaml.Controls.ISwapChainBackgroundPanel;
            Retval.m_ISwapChainBackgroundPanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwapChainBackgroundPanel

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwapChainPanel

   procedure Initialize (this : in out SwapChainPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwapChainPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwapChainPanel, ISwapChainPanel_Ptr);
   begin
      if this.m_ISwapChainPanel /= null then
         if this.m_ISwapChainPanel.all /= null then
            temp := this.m_ISwapChainPanel.all.Release;
            Free (this.m_ISwapChainPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwapChainPanel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SwapChainPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISwapChainPanel");
      m_Factory    : access ISwapChainPanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwapChainPanel;
   begin
      return RetVal : SwapChainPanel do
         Hr := RoGetActivationFactory (m_hString, IID_ISwapChainPanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISwapChainPanel := new WinUI3.Microsoft.UI.Xaml.Controls.ISwapChainPanel;
            Retval.m_ISwapChainPanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SwapChainPanel

   function get_CompositionScaleXProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwapChainPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwapChainPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwapChainPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompositionScaleXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CompositionScaleYProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwapChainPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwapChainPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwapChainPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompositionScaleYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwapChainPanel

   function get_CompositionScaleX
   (
      this : in out SwapChainPanel
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_ISwapChainPanel.all.get_CompositionScaleX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CompositionScaleY
   (
      this : in out SwapChainPanel
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_ISwapChainPanel.all.get_CompositionScaleY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_CompositionScaleChanged
   (
      this : in out SwapChainPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISwapChainPanel.all.add_CompositionScaleChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CompositionScaleChanged
   (
      this : in out SwapChainPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwapChainPanel.all.remove_CompositionScaleChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CreateCoreIndependentInputSource
   (
      this : in out SwapChainPanel;
      deviceKinds : WinUI3.Microsoft.UI.Input.InputPointerSourceDeviceKinds
   )
   return WinUI3.Microsoft.UI.Input.InputPointerSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputPointerSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputPointerSource do
         Hr := this.m_ISwapChainPanel.all.CreateCoreIndependentInputSource (deviceKinds, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInputPointerSource := new WinUI3.Microsoft.UI.Input.IInputPointerSource;
         Retval.m_IInputPointerSource.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwipeControl

   procedure Initialize (this : in out SwipeControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwipeControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwipeControl, ISwipeControl_Ptr);
   begin
      if this.m_ISwipeControl /= null then
         if this.m_ISwipeControl.all /= null then
            temp := this.m_ISwipeControl.all.Release;
            Free (this.m_ISwipeControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwipeControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SwipeControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISwipeControl");
      m_Factory    : access ISwipeControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwipeControl;
   begin
      return RetVal : SwipeControl do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISwipeControl := new WinUI3.Microsoft.UI.Xaml.Controls.ISwipeControl;
            Retval.m_ISwipeControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SwipeControl

   function get_LeftItemsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RightItemsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RightItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TopItemsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BottomItemsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeControl");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BottomItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwipeControl

   function get_LeftItems
   (
      this : in out SwipeControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems do
         Hr := this.m_ISwipeControl.all.get_LeftItems (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItems := new WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems;
         Retval.m_ISwipeItems.all := m_ComRetVal;
      end return;
   end;

   procedure put_LeftItems
   (
      this : in out SwipeControl;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeControl.all.put_LeftItems (value.m_ISwipeItems.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RightItems
   (
      this : in out SwipeControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems do
         Hr := this.m_ISwipeControl.all.get_RightItems (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItems := new WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems;
         Retval.m_ISwipeItems.all := m_ComRetVal;
      end return;
   end;

   procedure put_RightItems
   (
      this : in out SwipeControl;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeControl.all.put_RightItems (value.m_ISwipeItems.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopItems
   (
      this : in out SwipeControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems do
         Hr := this.m_ISwipeControl.all.get_TopItems (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItems := new WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems;
         Retval.m_ISwipeItems.all := m_ComRetVal;
      end return;
   end;

   procedure put_TopItems
   (
      this : in out SwipeControl;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeControl.all.put_TopItems (value.m_ISwipeItems.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BottomItems
   (
      this : in out SwipeControl
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems do
         Hr := this.m_ISwipeControl.all.get_BottomItems (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItems := new WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems;
         Retval.m_ISwipeItems.all := m_ComRetVal;
      end return;
   end;

   procedure put_BottomItems
   (
      this : in out SwipeControl;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItems'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeControl.all.put_BottomItems (value.m_ISwipeItems.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Close
   (
      this : in out SwipeControl
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeControl.all.Close;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwipeItem

   procedure Initialize (this : in out SwipeItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwipeItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwipeItem, ISwipeItem_Ptr);
   begin
      if this.m_ISwipeItem /= null then
         if this.m_ISwipeItem.all /= null then
            temp := this.m_ISwipeItem.all.Release;
            Free (this.m_ISwipeItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwipeItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SwipeItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISwipeItem");
      m_Factory    : access ISwipeItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItem;
   begin
      return RetVal : SwipeItem do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISwipeItem := new WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItem;
            Retval.m_ISwipeItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SwipeItem

   function get_IconSourceProperty_SwipeItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextProperty_SwipeItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundProperty_SwipeItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForegroundProperty_SwipeItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandProperty_SwipeItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandParameterProperty_SwipeItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BehaviorOnInvokedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BehaviorOnInvokedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwipeItem

   function get_Text
   (
      this : in out SwipeItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISwipeItem.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out SwipeItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISwipeItem.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IconSource
   (
      this : in out SwipeItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconSource do
         Hr := this.m_ISwipeItem.all.get_IconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconSource
   (
      this : in out SwipeItem;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_IconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Background
   (
      this : in out SwipeItem
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ISwipeItem.all.get_Background (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out SwipeItem;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_Background (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Foreground
   (
      this : in out SwipeItem
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ISwipeItem.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out SwipeItem;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Command
   (
      this : in out SwipeItem
   )
   return WinUI3.Microsoft.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_ISwipeItem.all.get_Command (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Command
   (
      this : in out SwipeItem;
      value : WinUI3.Microsoft.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_Command (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CommandParameter
   (
      this : in out SwipeItem
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ISwipeItem.all.get_CommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CommandParameter
   (
      this : in out SwipeItem;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_CommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BehaviorOnInvoked
   (
      this : in out SwipeItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SwipeBehaviorOnInvoked is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.SwipeBehaviorOnInvoked;
   begin
      Hr := this.m_ISwipeItem.all.get_BehaviorOnInvoked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BehaviorOnInvoked
   (
      this : in out SwipeItem;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SwipeBehaviorOnInvoked
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_BehaviorOnInvoked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Invoked
   (
      this : in out SwipeItem;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISwipeItem.all.add_Invoked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Invoked
   (
      this : in out SwipeItem;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.remove_Invoked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwipeItemInvokedEventArgs

   procedure Initialize (this : in out SwipeItemInvokedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwipeItemInvokedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwipeItemInvokedEventArgs, ISwipeItemInvokedEventArgs_Ptr);
   begin
      if this.m_ISwipeItemInvokedEventArgs /= null then
         if this.m_ISwipeItemInvokedEventArgs.all /= null then
            temp := this.m_ISwipeItemInvokedEventArgs.all.Release;
            Free (this.m_ISwipeItemInvokedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwipeItemInvokedEventArgs

   function get_SwipeControl
   (
      this : in out SwipeItemInvokedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SwipeControl'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwipeControl;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SwipeControl do
         Hr := this.m_ISwipeItemInvokedEventArgs.all.get_SwipeControl (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeControl := new WinUI3.Microsoft.UI.Xaml.Controls.ISwipeControl;
         Retval.m_ISwipeControl.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwipeItems

   procedure Initialize (this : in out SwipeItems) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwipeItems) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwipeItems, ISwipeItems_Ptr);
   begin
      if this.m_ISwipeItems /= null then
         if this.m_ISwipeItems.all /= null then
            temp := this.m_ISwipeItems.all.Release;
            Free (this.m_ISwipeItems);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwipeItems

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SwipeItems is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISwipeItems");
      m_Factory    : access ISwipeItemsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems;
   begin
      return RetVal : SwipeItems do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISwipeItems := new WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems;
            Retval.m_ISwipeItems.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SwipeItems

   function get_ModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SwipeItems");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItemsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwipeItems

   function get_Mode
   (
      this : in out SwipeItems
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SwipeMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.SwipeMode;
   begin
      Hr := this.m_ISwipeItems.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Mode
   (
      this : in out SwipeItems;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SwipeMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItems.all.put_Mode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Controls.SwipeItem>
   function GetAt
   (
      this : in out SwipeItems;
      index : WinUI3.UInt32
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SwipeItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItem;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItem do
         m_Interface := QInterface (this.m_ISwipeItems.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItem := new WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItem;
         Retval.m_ISwipeItem.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out SwipeItems
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out SwipeItems
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SwipeItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItem;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItem do
         m_Interface := QInterface (this.m_ISwipeItems.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItem := new WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItem;
         Retval.m_ISwipeItem.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out SwipeItems;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItem'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.IndexOf (value.m_ISwipeItem.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out SwipeItems;
      index : WinUI3.UInt32;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.SetAt (index, value.m_ISwipeItem.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out SwipeItems;
      index : WinUI3.UInt32;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.InsertAt (index, value.m_ISwipeItem.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out SwipeItems;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out SwipeItems;
      value : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.Append (value.m_ISwipeItem.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out SwipeItems
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out SwipeItems
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out SwipeItems;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItem_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out SwipeItems;
      items : WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItem_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3337674097, 10765, 21034, (183, 214, 219, 19, 57, 93, 10, 127 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.SwipeItem>
   function First
   (
      this : in out SwipeItems
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.SwipeItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItem;
      m_GenericIID     : aliased WinUI3.IID := (4244195642, 33032, 21834, (147, 159, 20, 11, 158, 254, 154, 52 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItems_Interface, IIterable_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.SwipeItem do
         m_Interface := QInterface (this.m_ISwipeItems.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItem := new WinUI3.Microsoft.UI.Xaml.Controls.ISwipeItem;
         Retval.m_ISwipeItem.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SymbolIcon

   procedure Initialize (this : in out SymbolIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out SymbolIcon) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISymbolIcon, ISymbolIcon_Ptr);
   begin
      if this.m_ISymbolIcon /= null then
         if this.m_ISymbolIcon.all /= null then
            temp := this.m_ISymbolIcon.all.Release;
            Free (this.m_ISymbolIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SymbolIcon

   function Constructor return SymbolIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISymbolIcon");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISymbolIcon;
   begin
      return RetVal : SymbolIcon do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISymbolIcon := new WinUI3.Microsoft.UI.Xaml.Controls.ISymbolIcon;
            Retval.m_ISymbolIcon.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      symbol : WinUI3.Microsoft.UI.Xaml.Controls.Symbol
   )
   return SymbolIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISymbolIcon");
      m_Factory    : access ISymbolIconFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISymbolIcon;
   begin
      return RetVal : SymbolIcon do
         Hr := RoGetActivationFactory (m_hString, IID_ISymbolIconFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithSymbol (symbol, m_ComRetVal'Access);
            Retval.m_ISymbolIcon := new WinUI3.Microsoft.UI.Xaml.Controls.ISymbolIcon;
            Retval.m_ISymbolIcon.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SymbolIcon

   function get_SymbolProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SymbolIcon");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISymbolIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISymbolIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SymbolProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SymbolIcon

   function get_Symbol
   (
      this : in out SymbolIcon
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Symbol is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Symbol;
   begin
      Hr := this.m_ISymbolIcon.all.get_Symbol (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Symbol
   (
      this : in out SymbolIcon;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Symbol
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISymbolIcon.all.put_Symbol (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SymbolIconSource

   procedure Initialize (this : in out SymbolIconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out SymbolIconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISymbolIconSource, ISymbolIconSource_Ptr);
   begin
      if this.m_ISymbolIconSource /= null then
         if this.m_ISymbolIconSource.all /= null then
            temp := this.m_ISymbolIconSource.all.Release;
            Free (this.m_ISymbolIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SymbolIconSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SymbolIconSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ISymbolIconSource");
      m_Factory    : access ISymbolIconSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ISymbolIconSource;
   begin
      return RetVal : SymbolIconSource do
         Hr := RoGetActivationFactory (m_hString, IID_ISymbolIconSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISymbolIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.ISymbolIconSource;
            Retval.m_ISymbolIconSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SymbolIconSource

   function get_SymbolProperty_SymbolIconSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.SymbolIconSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ISymbolIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISymbolIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SymbolProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SymbolIconSource

   function get_Symbol
   (
      this : in out SymbolIconSource
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Symbol is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Symbol;
   begin
      Hr := this.m_ISymbolIconSource.all.get_Symbol (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Symbol
   (
      this : in out SymbolIconSource;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Symbol
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISymbolIconSource.all.put_Symbol (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabView

   procedure Initialize (this : in out TabView) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabView, ITabView_Ptr);
   begin
      if this.m_ITabView /= null then
         if this.m_ITabView.all /= null then
            temp := this.m_ITabView.all.Release;
            Free (this.m_ITabView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TabView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TabView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITabView");
      m_Factory    : access ITabViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITabView;
   begin
      return RetVal : TabView do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITabView := new WinUI3.Microsoft.UI.Xaml.Controls.ITabView;
            Retval.m_ITabView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TabView

   function get_CanTearOutTabsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanTearOutTabsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabWidthModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabWidthModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabStripHeaderProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabStripHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabStripHeaderTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabStripHeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabStripFooterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabStripFooterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabStripFooterTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabStripFooterTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsAddTabButtonVisibleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsAddTabButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AddTabButtonCommandProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AddTabButtonCommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AddTabButtonCommandParameterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AddTabButtonCommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabItemsSourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabItemsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabItemTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabItemTemplateSelectorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabItemTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonOverlayModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanDragTabsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanDragTabsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanReorderTabsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanReorderTabsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AllowDropTabsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AllowDropTabsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedIndexProperty_TabView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty_TabView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabView

   function get_TabWidthMode
   (
      this : in out TabView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TabViewWidthMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TabViewWidthMode;
   begin
      Hr := this.m_ITabView.all.get_TabWidthMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TabWidthMode
   (
      this : in out TabView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TabViewWidthMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_TabWidthMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonOverlayMode
   (
      this : in out TabView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TabViewCloseButtonOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TabViewCloseButtonOverlayMode;
   begin
      Hr := this.m_ITabView.all.get_CloseButtonOverlayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CloseButtonOverlayMode
   (
      this : in out TabView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TabViewCloseButtonOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_CloseButtonOverlayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabStripHeader
   (
      this : in out TabView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITabView.all.get_TabStripHeader (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TabStripHeader
   (
      this : in out TabView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_TabStripHeader (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabStripHeaderTemplate
   (
      this : in out TabView
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_ITabView.all.get_TabStripHeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_TabStripHeaderTemplate
   (
      this : in out TabView;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_TabStripHeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabStripFooter
   (
      this : in out TabView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITabView.all.get_TabStripFooter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TabStripFooter
   (
      this : in out TabView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_TabStripFooter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabStripFooterTemplate
   (
      this : in out TabView
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_ITabView.all.get_TabStripFooterTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_TabStripFooterTemplate
   (
      this : in out TabView;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_TabStripFooterTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsAddTabButtonVisible
   (
      this : in out TabView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITabView.all.get_IsAddTabButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsAddTabButtonVisible
   (
      this : in out TabView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_IsAddTabButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AddTabButtonCommand
   (
      this : in out TabView
   )
   return WinUI3.Microsoft.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_ITabView.all.get_AddTabButtonCommand (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AddTabButtonCommand
   (
      this : in out TabView;
      value : WinUI3.Microsoft.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_AddTabButtonCommand (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AddTabButtonCommandParameter
   (
      this : in out TabView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITabView.all.get_AddTabButtonCommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AddTabButtonCommandParameter
   (
      this : in out TabView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_AddTabButtonCommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TabCloseRequested
   (
      this : in out TabView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITabView.all.add_TabCloseRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TabCloseRequested
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.remove_TabCloseRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TabDroppedOutside
   (
      this : in out TabView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITabView.all.add_TabDroppedOutside (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TabDroppedOutside
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.remove_TabDroppedOutside (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_AddTabButtonClick
   (
      this : in out TabView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITabView.all.add_AddTabButtonClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_AddTabButtonClick
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.remove_AddTabButtonClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TabItemsChanged
   (
      this : in out TabView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITabView.all.add_TabItemsChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TabItemsChanged
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.remove_TabItemsChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabItemsSource
   (
      this : in out TabView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITabView.all.get_TabItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TabItemsSource
   (
      this : in out TabView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_TabItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabItems
   (
      this : in out TabView
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_ITabView.all.get_TabItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_TabItemTemplate
   (
      this : in out TabView
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_ITabView.all.get_TabItemTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_TabItemTemplate
   (
      this : in out TabView;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_TabItemTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabItemTemplateSelector
   (
      this : in out TabView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_ITabView.all.get_TabItemTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_TabItemTemplateSelector
   (
      this : in out TabView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_TabItemTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanDragTabs
   (
      this : in out TabView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITabView.all.get_CanDragTabs (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanDragTabs
   (
      this : in out TabView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_CanDragTabs (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanReorderTabs
   (
      this : in out TabView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITabView.all.get_CanReorderTabs (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanReorderTabs
   (
      this : in out TabView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_CanReorderTabs (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AllowDropTabs
   (
      this : in out TabView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITabView.all.get_AllowDropTabs (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AllowDropTabs
   (
      this : in out TabView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_AllowDropTabs (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedIndex
   (
      this : in out TabView
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITabView.all.get_SelectedIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedIndex
   (
      this : in out TabView;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_SelectedIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItem
   (
      this : in out TabView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITabView.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedItem
   (
      this : in out TabView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.put_SelectedItem (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ContainerFromItem
   (
      this : in out TabView;
      item : WinUI3.IInspectable
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         Hr := this.m_ITabView.all.ContainerFromItem (item, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function ContainerFromIndex
   (
      this : in out TabView;
      index : WinUI3.Int32
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         Hr := this.m_ITabView.all.ContainerFromIndex (index, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function add_SelectionChanged
   (
      this : in out TabView;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.SelectionChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITabView.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TabDragStarting
   (
      this : in out TabView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITabView.all.add_TabDragStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TabDragStarting
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.remove_TabDragStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TabDragCompleted
   (
      this : in out TabView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITabView.all.add_TabDragCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TabDragCompleted
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.remove_TabDragCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TabStripDragOver
   (
      this : in out TabView;
      handler : WinUI3.Microsoft.UI.Xaml.DragEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITabView.all.add_TabStripDragOver (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TabStripDragOver
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.remove_TabStripDragOver (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TabStripDrop
   (
      this : in out TabView;
      handler : WinUI3.Microsoft.UI.Xaml.DragEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITabView.all.add_TabStripDrop (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TabStripDrop
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabView.all.remove_TabStripDrop (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanTearOutTabs
   (
      this : in out TabView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITabView.all);
      Hr := m_Interface.get_CanTearOutTabs (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanTearOutTabs
   (
      this : in out TabView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITabView.all);
      Hr := m_Interface.put_CanTearOutTabs (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TabTearOutWindowRequested
   (
      this : in out TabView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITabView.all);
      Hr := m_Interface.add_TabTearOutWindowRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TabTearOutWindowRequested
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITabView.all);
      Hr := m_Interface.remove_TabTearOutWindowRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TabTearOutRequested
   (
      this : in out TabView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITabView.all);
      Hr := m_Interface.add_TabTearOutRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TabTearOutRequested
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITabView.all);
      Hr := m_Interface.remove_TabTearOutRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ExternalTornOutTabsDropping
   (
      this : in out TabView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITabView.all);
      Hr := m_Interface.add_ExternalTornOutTabsDropping (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ExternalTornOutTabsDropping
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITabView.all);
      Hr := m_Interface.remove_ExternalTornOutTabsDropping (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ExternalTornOutTabsDropped
   (
      this : in out TabView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITabView.all);
      Hr := m_Interface.add_ExternalTornOutTabsDropped (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ExternalTornOutTabsDropped
   (
      this : in out TabView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITabView.all);
      Hr := m_Interface.remove_ExternalTornOutTabsDropped (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabViewExternalTornOutTabsDroppedEventArgs

   procedure Initialize (this : in out TabViewExternalTornOutTabsDroppedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabViewExternalTornOutTabsDroppedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabViewExternalTornOutTabsDroppedEventArgs, ITabViewExternalTornOutTabsDroppedEventArgs_Ptr);
   begin
      if this.m_ITabViewExternalTornOutTabsDroppedEventArgs /= null then
         if this.m_ITabViewExternalTornOutTabsDroppedEventArgs.all /= null then
            temp := this.m_ITabViewExternalTornOutTabsDroppedEventArgs.all.Release;
            Free (this.m_ITabViewExternalTornOutTabsDroppedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabViewExternalTornOutTabsDroppedEventArgs

   function get_Items
   (
      this : in out TabViewExternalTornOutTabsDroppedEventArgs
   )
   return WinUI3.IInspectable_Array is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable_Ptr;
      m_ComRetValSize  : aliased WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewExternalTornOutTabsDroppedEventArgs.all.get_Items (m_ComRetValSize'Access, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      declare
         ArrayRetVal : WinUI3.IInspectable_Array (1..Integer(m_ComRetValSize));
         function To_Ada_IInspectable is new To_Ada_Type (WinUI3.IInspectable, WinUI3.IInspectable_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_IInspectable (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   function get_Tabs
   (
      this : in out TabViewExternalTornOutTabsDroppedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement_Array is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement_Ptr;
      m_ComRetValSize  : aliased WinUI3.UInt32 := 0;

      function GetArraySize return Integer is
      begin
         Hr := this.m_ITabViewExternalTornOutTabsDroppedEventArgs.all.get_Tabs (m_ComRetValSize'Access, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         return Integer(m_ComRetValSize);
      end;

      function To_Ada_IUIElement is new To_Ada_Type (WinUI3.Microsoft.UI.Xaml.IUIElement, WinUI3.Microsoft.UI.Xaml.IUIElement_Ptr); 

   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement_Array (1..GetArraySize) do
         for i in RetVal'Range loop
            Retval (i).m_IUIElement := new Microsoft.UI.Xaml.IUIElement;
            Retval (i).m_IUIElement.all := To_Ada_IUIElement (m_ComRetVal, i);
         end loop;
      end return;
   end;

   function get_DropIndex
   (
      this : in out TabViewExternalTornOutTabsDroppedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITabViewExternalTornOutTabsDroppedEventArgs.all.get_DropIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabViewExternalTornOutTabsDroppingEventArgs

   procedure Initialize (this : in out TabViewExternalTornOutTabsDroppingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabViewExternalTornOutTabsDroppingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabViewExternalTornOutTabsDroppingEventArgs, ITabViewExternalTornOutTabsDroppingEventArgs_Ptr);
   begin
      if this.m_ITabViewExternalTornOutTabsDroppingEventArgs /= null then
         if this.m_ITabViewExternalTornOutTabsDroppingEventArgs.all /= null then
            temp := this.m_ITabViewExternalTornOutTabsDroppingEventArgs.all.Release;
            Free (this.m_ITabViewExternalTornOutTabsDroppingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabViewExternalTornOutTabsDroppingEventArgs

   function get_Items
   (
      this : in out TabViewExternalTornOutTabsDroppingEventArgs
   )
   return WinUI3.IInspectable_Array is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable_Ptr;
      m_ComRetValSize  : aliased WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewExternalTornOutTabsDroppingEventArgs.all.get_Items (m_ComRetValSize'Access, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      declare
         ArrayRetVal : WinUI3.IInspectable_Array (1..Integer(m_ComRetValSize));
         function To_Ada_IInspectable is new To_Ada_Type (WinUI3.IInspectable, WinUI3.IInspectable_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_IInspectable (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   function get_Tabs
   (
      this : in out TabViewExternalTornOutTabsDroppingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement_Array is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement_Ptr;
      m_ComRetValSize  : aliased WinUI3.UInt32 := 0;

      function GetArraySize return Integer is
      begin
         Hr := this.m_ITabViewExternalTornOutTabsDroppingEventArgs.all.get_Tabs (m_ComRetValSize'Access, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         return Integer(m_ComRetValSize);
      end;

      function To_Ada_IUIElement is new To_Ada_Type (WinUI3.Microsoft.UI.Xaml.IUIElement, WinUI3.Microsoft.UI.Xaml.IUIElement_Ptr); 

   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement_Array (1..GetArraySize) do
         for i in RetVal'Range loop
            Retval (i).m_IUIElement := new Microsoft.UI.Xaml.IUIElement;
            Retval (i).m_IUIElement.all := To_Ada_IUIElement (m_ComRetVal, i);
         end loop;
      end return;
   end;

   function get_DropIndex
   (
      this : in out TabViewExternalTornOutTabsDroppingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITabViewExternalTornOutTabsDroppingEventArgs.all.get_DropIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AllowDrop
   (
      this : in out TabViewExternalTornOutTabsDroppingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITabViewExternalTornOutTabsDroppingEventArgs.all.get_AllowDrop (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AllowDrop
   (
      this : in out TabViewExternalTornOutTabsDroppingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewExternalTornOutTabsDroppingEventArgs.all.put_AllowDrop (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabViewItem

   procedure Initialize (this : in out TabViewItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabViewItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabViewItem, ITabViewItem_Ptr);
   begin
      if this.m_ITabViewItem /= null then
         if this.m_ITabViewItem.all /= null then
            temp := this.m_ITabViewItem.all.Release;
            Free (this.m_ITabViewItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TabViewItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TabViewItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITabViewItem");
      m_Factory    : access ITabViewItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItem;
   begin
      return RetVal : TabViewItem do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITabViewItem := new WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItem;
            Retval.m_ITabViewItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TabViewItem

   function get_HeaderProperty_TabViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_TabViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconSourceProperty_TabViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsClosableProperty_TabViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsClosableProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabViewTemplateSettingsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabViewTemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabViewItem

   function get_Header
   (
      this : in out TabViewItem
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITabViewItem.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out TabViewItem;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewItem.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out TabViewItem
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_ITabViewItem.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out TabViewItem;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewItem.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IconSource
   (
      this : in out TabViewItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconSource do
         Hr := this.m_ITabViewItem.all.get_IconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconSource
   (
      this : in out TabViewItem;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewItem.all.put_IconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsClosable
   (
      this : in out TabViewItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITabViewItem.all.get_IsClosable (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsClosable
   (
      this : in out TabViewItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewItem.all.put_IsClosable (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabViewTemplateSettings
   (
      this : in out TabViewItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TabViewItemTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TabViewItemTemplateSettings do
         Hr := this.m_ITabViewItem.all.get_TabViewTemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITabViewItemTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettings;
         Retval.m_ITabViewItemTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_CloseRequested
   (
      this : in out TabViewItem;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITabViewItem.all.add_CloseRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CloseRequested
   (
      this : in out TabViewItem;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewItem.all.remove_CloseRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabViewItemTemplateSettings

   procedure Initialize (this : in out TabViewItemTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabViewItemTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabViewItemTemplateSettings, ITabViewItemTemplateSettings_Ptr);
   begin
      if this.m_ITabViewItemTemplateSettings /= null then
         if this.m_ITabViewItemTemplateSettings.all /= null then
            temp := this.m_ITabViewItemTemplateSettings.all.Release;
            Free (this.m_ITabViewItemTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TabViewItemTemplateSettings

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TabViewItemTemplateSettings is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettings");
      m_Factory    : access ITabViewItemTemplateSettingsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettings;
   begin
      return RetVal : TabViewItemTemplateSettings do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewItemTemplateSettingsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITabViewItemTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettings;
            Retval.m_ITabViewItemTemplateSettings.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TabViewItemTemplateSettings

   function get_TabGeometryProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabViewItemTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettingsStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewItemTemplateSettingsStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabGeometryProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconElementProperty_TabViewItemTemplateSettings
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TabViewItemTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewItemTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabViewItemTemplateSettings

   function get_IconElement
   (
      this : in out TabViewItemTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_ITabViewItemTemplateSettings.all.get_IconElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconElement
   (
      this : in out TabViewItemTemplateSettings;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewItemTemplateSettings.all.put_IconElement (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabGeometry
   (
      this : in out TabViewItemTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Geometry'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettings2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IGeometry;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettings_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettings2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabViewItemTemplateSettings2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Geometry do
         m_Interface := QInterface (this.m_ITabViewItemTemplateSettings.all);
         Hr := m_Interface.get_TabGeometry (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeometry := new WinUI3.Microsoft.UI.Xaml.Media.IGeometry;
         Retval.m_IGeometry.all := m_ComRetVal;
      end return;
   end;

   procedure put_TabGeometry
   (
      this : in out TabViewItemTemplateSettings;
      value : WinUI3.Microsoft.UI.Xaml.Media.Geometry'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettings2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettings_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItemTemplateSettings2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITabViewItemTemplateSettings2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITabViewItemTemplateSettings.all);
      Hr := m_Interface.put_TabGeometry (value.m_IGeometry.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabViewTabCloseRequestedEventArgs

   procedure Initialize (this : in out TabViewTabCloseRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabViewTabCloseRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabViewTabCloseRequestedEventArgs, ITabViewTabCloseRequestedEventArgs_Ptr);
   begin
      if this.m_ITabViewTabCloseRequestedEventArgs /= null then
         if this.m_ITabViewTabCloseRequestedEventArgs.all /= null then
            temp := this.m_ITabViewTabCloseRequestedEventArgs.all.Release;
            Free (this.m_ITabViewTabCloseRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabViewTabCloseRequestedEventArgs

   function get_Item
   (
      this : in out TabViewTabCloseRequestedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITabViewTabCloseRequestedEventArgs.all.get_Item (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Tab
   (
      this : in out TabViewTabCloseRequestedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TabViewItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItem;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TabViewItem do
         Hr := this.m_ITabViewTabCloseRequestedEventArgs.all.get_Tab (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITabViewItem := new WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItem;
         Retval.m_ITabViewItem.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabViewTabDragCompletedEventArgs

   procedure Initialize (this : in out TabViewTabDragCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabViewTabDragCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabViewTabDragCompletedEventArgs, ITabViewTabDragCompletedEventArgs_Ptr);
   begin
      if this.m_ITabViewTabDragCompletedEventArgs /= null then
         if this.m_ITabViewTabDragCompletedEventArgs.all /= null then
            temp := this.m_ITabViewTabDragCompletedEventArgs.all.Release;
            Free (this.m_ITabViewTabDragCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabViewTabDragCompletedEventArgs

   function get_DropResult
   (
      this : in out TabViewTabDragCompletedEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation;
   begin
      Hr := this.m_ITabViewTabDragCompletedEventArgs.all.get_DropResult (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Item
   (
      this : in out TabViewTabDragCompletedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITabViewTabDragCompletedEventArgs.all.get_Item (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Tab
   (
      this : in out TabViewTabDragCompletedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TabViewItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItem;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TabViewItem do
         Hr := this.m_ITabViewTabDragCompletedEventArgs.all.get_Tab (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITabViewItem := new WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItem;
         Retval.m_ITabViewItem.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabViewTabDragStartingEventArgs

   procedure Initialize (this : in out TabViewTabDragStartingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabViewTabDragStartingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabViewTabDragStartingEventArgs, ITabViewTabDragStartingEventArgs_Ptr);
   begin
      if this.m_ITabViewTabDragStartingEventArgs /= null then
         if this.m_ITabViewTabDragStartingEventArgs.all /= null then
            temp := this.m_ITabViewTabDragStartingEventArgs.all.Release;
            Free (this.m_ITabViewTabDragStartingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabViewTabDragStartingEventArgs

   function get_Cancel
   (
      this : in out TabViewTabDragStartingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITabViewTabDragStartingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out TabViewTabDragStartingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewTabDragStartingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Data
   (
      this : in out TabViewTabDragStartingEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage do
         Hr := this.m_ITabViewTabDragStartingEventArgs.all.get_Data (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataPackage := new WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
         Retval.m_IDataPackage.all := m_ComRetVal;
      end return;
   end;

   function get_Item
   (
      this : in out TabViewTabDragStartingEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITabViewTabDragStartingEventArgs.all.get_Item (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Tab
   (
      this : in out TabViewTabDragStartingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TabViewItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItem;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TabViewItem do
         Hr := this.m_ITabViewTabDragStartingEventArgs.all.get_Tab (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITabViewItem := new WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItem;
         Retval.m_ITabViewItem.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabViewTabDroppedOutsideEventArgs

   procedure Initialize (this : in out TabViewTabDroppedOutsideEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabViewTabDroppedOutsideEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabViewTabDroppedOutsideEventArgs, ITabViewTabDroppedOutsideEventArgs_Ptr);
   begin
      if this.m_ITabViewTabDroppedOutsideEventArgs /= null then
         if this.m_ITabViewTabDroppedOutsideEventArgs.all /= null then
            temp := this.m_ITabViewTabDroppedOutsideEventArgs.all.Release;
            Free (this.m_ITabViewTabDroppedOutsideEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabViewTabDroppedOutsideEventArgs

   function get_Item
   (
      this : in out TabViewTabDroppedOutsideEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITabViewTabDroppedOutsideEventArgs.all.get_Item (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Tab
   (
      this : in out TabViewTabDroppedOutsideEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TabViewItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItem;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TabViewItem do
         Hr := this.m_ITabViewTabDroppedOutsideEventArgs.all.get_Tab (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITabViewItem := new WinUI3.Microsoft.UI.Xaml.Controls.ITabViewItem;
         Retval.m_ITabViewItem.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabViewTabTearOutRequestedEventArgs

   procedure Initialize (this : in out TabViewTabTearOutRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabViewTabTearOutRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabViewTabTearOutRequestedEventArgs, ITabViewTabTearOutRequestedEventArgs_Ptr);
   begin
      if this.m_ITabViewTabTearOutRequestedEventArgs /= null then
         if this.m_ITabViewTabTearOutRequestedEventArgs.all /= null then
            temp := this.m_ITabViewTabTearOutRequestedEventArgs.all.Release;
            Free (this.m_ITabViewTabTearOutRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabViewTabTearOutRequestedEventArgs

   function get_Items
   (
      this : in out TabViewTabTearOutRequestedEventArgs
   )
   return WinUI3.IInspectable_Array is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable_Ptr;
      m_ComRetValSize  : aliased WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewTabTearOutRequestedEventArgs.all.get_Items (m_ComRetValSize'Access, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      declare
         ArrayRetVal : WinUI3.IInspectable_Array (1..Integer(m_ComRetValSize));
         function To_Ada_IInspectable is new To_Ada_Type (WinUI3.IInspectable, WinUI3.IInspectable_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_IInspectable (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   function get_Tabs
   (
      this : in out TabViewTabTearOutRequestedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement_Array is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement_Ptr;
      m_ComRetValSize  : aliased WinUI3.UInt32 := 0;

      function GetArraySize return Integer is
      begin
         Hr := this.m_ITabViewTabTearOutRequestedEventArgs.all.get_Tabs (m_ComRetValSize'Access, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         return Integer(m_ComRetValSize);
      end;

      function To_Ada_IUIElement is new To_Ada_Type (WinUI3.Microsoft.UI.Xaml.IUIElement, WinUI3.Microsoft.UI.Xaml.IUIElement_Ptr); 

   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement_Array (1..GetArraySize) do
         for i in RetVal'Range loop
            Retval (i).m_IUIElement := new Microsoft.UI.Xaml.IUIElement;
            Retval (i).m_IUIElement.all := To_Ada_IUIElement (m_ComRetVal, i);
         end loop;
      end return;
   end;

   function get_NewWindowId
   (
      this : in out TabViewTabTearOutRequestedEventArgs
   )
   return WinUI3.Microsoft.UI.WindowId is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.WindowId;
   begin
      Hr := this.m_ITabViewTabTearOutRequestedEventArgs.all.get_NewWindowId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabViewTabTearOutWindowRequestedEventArgs

   procedure Initialize (this : in out TabViewTabTearOutWindowRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabViewTabTearOutWindowRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabViewTabTearOutWindowRequestedEventArgs, ITabViewTabTearOutWindowRequestedEventArgs_Ptr);
   begin
      if this.m_ITabViewTabTearOutWindowRequestedEventArgs /= null then
         if this.m_ITabViewTabTearOutWindowRequestedEventArgs.all /= null then
            temp := this.m_ITabViewTabTearOutWindowRequestedEventArgs.all.Release;
            Free (this.m_ITabViewTabTearOutWindowRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabViewTabTearOutWindowRequestedEventArgs

   function get_Items
   (
      this : in out TabViewTabTearOutWindowRequestedEventArgs
   )
   return WinUI3.IInspectable_Array is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable_Ptr;
      m_ComRetValSize  : aliased WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewTabTearOutWindowRequestedEventArgs.all.get_Items (m_ComRetValSize'Access, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      declare
         ArrayRetVal : WinUI3.IInspectable_Array (1..Integer(m_ComRetValSize));
         function To_Ada_IInspectable is new To_Ada_Type (WinUI3.IInspectable, WinUI3.IInspectable_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_IInspectable (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   function get_Tabs
   (
      this : in out TabViewTabTearOutWindowRequestedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement_Array is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement_Ptr;
      m_ComRetValSize  : aliased WinUI3.UInt32 := 0;

      function GetArraySize return Integer is
      begin
         Hr := this.m_ITabViewTabTearOutWindowRequestedEventArgs.all.get_Tabs (m_ComRetValSize'Access, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         return Integer(m_ComRetValSize);
      end;

      function To_Ada_IUIElement is new To_Ada_Type (WinUI3.Microsoft.UI.Xaml.IUIElement, WinUI3.Microsoft.UI.Xaml.IUIElement_Ptr); 

   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement_Array (1..GetArraySize) do
         for i in RetVal'Range loop
            Retval (i).m_IUIElement := new Microsoft.UI.Xaml.IUIElement;
            Retval (i).m_IUIElement.all := To_Ada_IUIElement (m_ComRetVal, i);
         end loop;
      end return;
   end;

   function get_NewWindowId
   (
      this : in out TabViewTabTearOutWindowRequestedEventArgs
   )
   return WinUI3.Microsoft.UI.WindowId is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.WindowId;
   begin
      Hr := this.m_ITabViewTabTearOutWindowRequestedEventArgs.all.get_NewWindowId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NewWindowId
   (
      this : in out TabViewTabTearOutWindowRequestedEventArgs;
      value : WinUI3.Microsoft.UI.WindowId
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITabViewTabTearOutWindowRequestedEventArgs.all.put_NewWindowId (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TeachingTip

   procedure Initialize (this : in out TeachingTip) is
   begin
      null;
   end;

   procedure Finalize (this : in out TeachingTip) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITeachingTip, ITeachingTip_Ptr);
   begin
      if this.m_ITeachingTip /= null then
         if this.m_ITeachingTip.all /= null then
            temp := this.m_ITeachingTip.all.Release;
            Free (this.m_ITeachingTip);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TeachingTip

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TeachingTip is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITeachingTip");
      m_Factory    : access ITeachingTipFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTip;
   begin
      return RetVal : TeachingTip do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITeachingTip := new WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTip;
            Retval.m_ITeachingTip.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TeachingTip

   function get_IsOpenProperty_TeachingTip
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TargetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TailVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TailVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TitleProperty_TeachingTip
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SubtitleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SubtitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActionButtonContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActionButtonContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActionButtonStyleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActionButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActionButtonCommandProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActionButtonCommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActionButtonCommandParameterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActionButtonCommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonStyleProperty_TeachingTip
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonCommandProperty_TeachingTip
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonCommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonCommandParameterProperty_TeachingTip
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonCommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlacementMarginProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShouldConstrainToRootBoundsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShouldConstrainToRootBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsLightDismissEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsLightDismissEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreferredPlacementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreferredPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeroContentPlacementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeroContentPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeroContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeroContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconSourceProperty_TeachingTip
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateSettingsProperty_TeachingTip
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TeachingTip

   function get_Title
   (
      this : in out TeachingTip
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITeachingTip.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out TeachingTip;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITeachingTip.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Subtitle
   (
      this : in out TeachingTip
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITeachingTip.all.get_Subtitle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Subtitle
   (
      this : in out TeachingTip;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITeachingTip.all.put_Subtitle (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsOpen
   (
      this : in out TeachingTip
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITeachingTip.all.get_IsOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOpen
   (
      this : in out TeachingTip;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_IsOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Target
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IFrameworkElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.FrameworkElement do
         Hr := this.m_ITeachingTip.all.get_Target (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFrameworkElement := new WinUI3.Microsoft.UI.Xaml.IFrameworkElement;
         Retval.m_IFrameworkElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Target
   (
      this : in out TeachingTip;
      value : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_Target (value.m_IFrameworkElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TailVisibility
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipTailVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipTailVisibility;
   begin
      Hr := this.m_ITeachingTip.all.get_TailVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TailVisibility
   (
      this : in out TeachingTip;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipTailVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_TailVisibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActionButtonContent
   (
      this : in out TeachingTip
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITeachingTip.all.get_ActionButtonContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ActionButtonContent
   (
      this : in out TeachingTip;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_ActionButtonContent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActionButtonStyle
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_ITeachingTip.all.get_ActionButtonStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_ActionButtonStyle
   (
      this : in out TeachingTip;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_ActionButtonStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActionButtonCommand
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_ITeachingTip.all.get_ActionButtonCommand (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ActionButtonCommand
   (
      this : in out TeachingTip;
      value : WinUI3.Microsoft.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_ActionButtonCommand (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActionButtonCommandParameter
   (
      this : in out TeachingTip
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITeachingTip.all.get_ActionButtonCommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ActionButtonCommandParameter
   (
      this : in out TeachingTip;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_ActionButtonCommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonContent
   (
      this : in out TeachingTip
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITeachingTip.all.get_CloseButtonContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CloseButtonContent
   (
      this : in out TeachingTip;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_CloseButtonContent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonStyle
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         Hr := this.m_ITeachingTip.all.get_CloseButtonStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_CloseButtonStyle
   (
      this : in out TeachingTip;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_CloseButtonStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonCommand
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_ITeachingTip.all.get_CloseButtonCommand (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CloseButtonCommand
   (
      this : in out TeachingTip;
      value : WinUI3.Microsoft.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_CloseButtonCommand (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonCommandParameter
   (
      this : in out TeachingTip
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITeachingTip.all.get_CloseButtonCommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CloseButtonCommandParameter
   (
      this : in out TeachingTip;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_CloseButtonCommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlacementMargin
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_ITeachingTip.all.get_PlacementMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PlacementMargin
   (
      this : in out TeachingTip;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_PlacementMargin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShouldConstrainToRootBounds
   (
      this : in out TeachingTip
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITeachingTip.all.get_ShouldConstrainToRootBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShouldConstrainToRootBounds
   (
      this : in out TeachingTip;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_ShouldConstrainToRootBounds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsLightDismissEnabled
   (
      this : in out TeachingTip
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITeachingTip.all.get_IsLightDismissEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsLightDismissEnabled
   (
      this : in out TeachingTip;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_IsLightDismissEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreferredPlacement
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipPlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipPlacementMode;
   begin
      Hr := this.m_ITeachingTip.all.get_PreferredPlacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreferredPlacement
   (
      this : in out TeachingTip;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipPlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_PreferredPlacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeroContentPlacement
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipHeroContentPlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipHeroContentPlacementMode;
   begin
      Hr := this.m_ITeachingTip.all.get_HeroContentPlacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HeroContentPlacement
   (
      this : in out TeachingTip;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipHeroContentPlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_HeroContentPlacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeroContent
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_ITeachingTip.all.get_HeroContent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeroContent
   (
      this : in out TeachingTip;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_HeroContent (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IconSource
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconSource do
         Hr := this.m_ITeachingTip.all.get_IconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconSource
   (
      this : in out TeachingTip;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.put_IconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out TeachingTip
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings do
         Hr := this.m_ITeachingTip.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITeachingTipTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipTemplateSettings;
         Retval.m_ITeachingTipTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_ActionButtonClick
   (
      this : in out TeachingTip;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITeachingTip.all.add_ActionButtonClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ActionButtonClick
   (
      this : in out TeachingTip;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.remove_ActionButtonClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CloseButtonClick
   (
      this : in out TeachingTip;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITeachingTip.all.add_CloseButtonClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CloseButtonClick
   (
      this : in out TeachingTip;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.remove_CloseButtonClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closing
   (
      this : in out TeachingTip;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITeachingTip.all.add_Closing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closing
   (
      this : in out TeachingTip;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.remove_Closing (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out TeachingTip;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITeachingTip.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out TeachingTip;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTip.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TeachingTipClosedEventArgs

   procedure Initialize (this : in out TeachingTipClosedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TeachingTipClosedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITeachingTipClosedEventArgs, ITeachingTipClosedEventArgs_Ptr);
   begin
      if this.m_ITeachingTipClosedEventArgs /= null then
         if this.m_ITeachingTipClosedEventArgs.all /= null then
            temp := this.m_ITeachingTipClosedEventArgs.all.Release;
            Free (this.m_ITeachingTipClosedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TeachingTipClosedEventArgs

   function get_Reason
   (
      this : in out TeachingTipClosedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipCloseReason is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipCloseReason;
   begin
      Hr := this.m_ITeachingTipClosedEventArgs.all.get_Reason (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TeachingTipClosingEventArgs

   procedure Initialize (this : in out TeachingTipClosingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TeachingTipClosingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITeachingTipClosingEventArgs, ITeachingTipClosingEventArgs_Ptr);
   begin
      if this.m_ITeachingTipClosingEventArgs /= null then
         if this.m_ITeachingTipClosingEventArgs.all /= null then
            temp := this.m_ITeachingTipClosingEventArgs.all.Release;
            Free (this.m_ITeachingTipClosingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TeachingTipClosingEventArgs

   function get_Reason
   (
      this : in out TeachingTipClosingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipCloseReason is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TeachingTipCloseReason;
   begin
      Hr := this.m_ITeachingTipClosingEventArgs.all.get_Reason (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out TeachingTipClosingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITeachingTipClosingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out TeachingTipClosingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTipClosingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out TeachingTipClosingEventArgs
   )
   return WinUI3.Windows.Foundation.Deferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IDeferral;
   begin
      return RetVal : WinUI3.Windows.Foundation.Deferral do
         Hr := this.m_ITeachingTipClosingEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new WinUI3.Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TeachingTipTemplateSettings

   procedure Initialize (this : in out TeachingTipTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out TeachingTipTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITeachingTipTemplateSettings, ITeachingTipTemplateSettings_Ptr);
   begin
      if this.m_ITeachingTipTemplateSettings /= null then
         if this.m_ITeachingTipTemplateSettings.all /= null then
            temp := this.m_ITeachingTipTemplateSettings.all.Release;
            Free (this.m_ITeachingTipTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TeachingTipTemplateSettings

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TeachingTipTemplateSettings is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITeachingTipTemplateSettings");
      m_Factory    : access ITeachingTipTemplateSettingsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipTemplateSettings;
   begin
      return RetVal : TeachingTipTemplateSettings do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipTemplateSettingsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITeachingTipTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipTemplateSettings;
            Retval.m_ITeachingTipTemplateSettings.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TeachingTipTemplateSettings

   function get_TopRightHighlightMarginProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopRightHighlightMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TopLeftHighlightMarginProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopLeftHighlightMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconElementProperty_TeachingTipTemplateSettings
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TeachingTipTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITeachingTipTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITeachingTipTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TeachingTipTemplateSettings

   function get_TopRightHighlightMargin
   (
      this : in out TeachingTipTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_ITeachingTipTemplateSettings.all.get_TopRightHighlightMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TopRightHighlightMargin
   (
      this : in out TeachingTipTemplateSettings;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTipTemplateSettings.all.put_TopRightHighlightMargin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopLeftHighlightMargin
   (
      this : in out TeachingTipTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_ITeachingTipTemplateSettings.all.get_TopLeftHighlightMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TopLeftHighlightMargin
   (
      this : in out TeachingTipTemplateSettings;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTipTemplateSettings.all.put_TopLeftHighlightMargin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IconElement
   (
      this : in out TeachingTipTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_ITeachingTipTemplateSettings.all.get_IconElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconElement
   (
      this : in out TeachingTipTemplateSettings;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITeachingTipTemplateSettings.all.put_IconElement (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextBlock

   procedure Initialize (this : in out TextBlock) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextBlock) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextBlock, ITextBlock_Ptr);
   begin
      if this.m_ITextBlock /= null then
         if this.m_ITextBlock.all /= null then
            temp := this.m_ITextBlock.all.Release;
            Free (this.m_ITextBlock);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TextBlock

   function Constructor return TextBlock is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITextBlock");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITextBlock;
   begin
      return RetVal : TextBlock do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITextBlock := new WinUI3.Microsoft.UI.Xaml.Controls.ITextBlock;
            Retval.m_ITextBlock.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TextBlock

   function get_FontSizeProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStretchProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterSpacingProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForegroundProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextWrappingProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextWrappingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextTrimmingProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextTrimmingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextAlignmentProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineHeightProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineStackingStrategyProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineStackingStrategyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextSelectionEnabledProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextSelectionEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedTextProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLinesProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLinesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextLineBoundsProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextLineBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpticalMarginAlignmentProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpticalMarginAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorFontEnabledProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorFontEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextReadingOrderProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextReadingOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextScaleFactorEnabledProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextDecorationsProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextDecorationsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextTrimmedProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextTrimmedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalTextAlignmentProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalTextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFlyoutProperty_TextBlock
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextBlock

   function get_FontSize
   (
      this : in out TextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITextBlock.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out TextBlock;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.FontFamily do
         Hr := this.m_ITextBlock.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Microsoft.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ITextBlock.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_ITextBlock.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStretch
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Text.FontStretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStretch;
   begin
      Hr := this.m_ITextBlock.all.get_FontStretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStretch
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Text.FontStretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_FontStretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterSpacing
   (
      this : in out TextBlock
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBlock.all.get_CharacterSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterSpacing
   (
      this : in out TextBlock;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_CharacterSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Foreground
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ITextBlock.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextWrapping
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextWrapping is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextWrapping;
   begin
      Hr := this.m_ITextBlock.all.get_TextWrapping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextWrapping
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextWrapping
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_TextWrapping (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextTrimming
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextTrimming is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextTrimming;
   begin
      Hr := this.m_ITextBlock.all.get_TextTrimming (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextTrimming
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextTrimming
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_TextTrimming (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextAlignment
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_ITextBlock.all.get_TextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextAlignment
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_TextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Text
   (
      this : in out TextBlock
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextBlock.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out TextBlock;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextBlock.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Inlines
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.InlineCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.InlineCollection do
         Hr := this.m_ITextBlock.all.get_Inlines (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_Padding
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_ITextBlock.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineHeight
   (
      this : in out TextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITextBlock.all.get_LineHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineHeight
   (
      this : in out TextBlock;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_LineHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineStackingStrategy
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.LineStackingStrategy is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.LineStackingStrategy;
   begin
      Hr := this.m_ITextBlock.all.get_LineStackingStrategy (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineStackingStrategy
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.LineStackingStrategy
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_LineStackingStrategy (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextSelectionEnabled
   (
      this : in out TextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBlock.all.get_IsTextSelectionEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextSelectionEnabled
   (
      this : in out TextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_IsTextSelectionEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedText
   (
      this : in out TextBlock
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextBlock.all.get_SelectedText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ContentStart
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_ITextBlock.all.get_ContentStart (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_ContentEnd
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_ITextBlock.all.get_ContentEnd (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_SelectionStart
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_ITextBlock.all.get_SelectionStart (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_SelectionEnd
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer do
         Hr := this.m_ITextBlock.all.get_SelectionEnd (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Microsoft.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_BaselineOffset
   (
      this : in out TextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITextBlock.all.get_BaselineOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionHighlightColor
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush do
         Hr := this.m_ITextBlock.all.get_SelectionHighlightColor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColor
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_SelectionHighlightColor (value.m_ISolidColorBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxLines
   (
      this : in out TextBlock
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBlock.all.get_MaxLines (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLines
   (
      this : in out TextBlock;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_MaxLines (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextLineBounds
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextLineBounds is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextLineBounds;
   begin
      Hr := this.m_ITextBlock.all.get_TextLineBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextLineBounds
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextLineBounds
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_TextLineBounds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpticalMarginAlignment
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.OpticalMarginAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.OpticalMarginAlignment;
   begin
      Hr := this.m_ITextBlock.all.get_OpticalMarginAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpticalMarginAlignment
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.OpticalMarginAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_OpticalMarginAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorFontEnabled
   (
      this : in out TextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBlock.all.get_IsColorFontEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorFontEnabled
   (
      this : in out TextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_IsColorFontEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextReadingOrder
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextReadingOrder is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextReadingOrder;
   begin
      Hr := this.m_ITextBlock.all.get_TextReadingOrder (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextReadingOrder
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextReadingOrder
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_TextReadingOrder (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out TextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBlock.all.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out TextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_IsTextScaleFactorEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextDecorations
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Text.TextDecorations is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.TextDecorations;
   begin
      Hr := this.m_ITextBlock.all.get_TextDecorations (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextDecorations
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Text.TextDecorations
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_TextDecorations (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextTrimmed
   (
      this : in out TextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBlock.all.get_IsTextTrimmed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HorizontalTextAlignment
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_ITextBlock.all.get_HorizontalTextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalTextAlignment
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_HorizontalTextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextHighlighters
   (
      this : in out TextBlock
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_ITextBlock.all.get_TextHighlighters (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionFlyout
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := this.m_ITextBlock.all.get_SelectionFlyout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionFlyout
   (
      this : in out TextBlock;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_SelectionFlyout (value.m_IFlyoutBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out TextBlock;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBlock.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out TextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextMenuOpening
   (
      this : in out TextBlock;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.ContextMenuOpeningEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBlock.all.add_ContextMenuOpening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextMenuOpening
   (
      this : in out TextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.remove_ContextMenuOpening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_IsTextTrimmedChanged
   (
      this : in out TextBlock;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBlock.all.add_IsTextTrimmedChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsTextTrimmedChanged
   (
      this : in out TextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.remove_IsTextTrimmedChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out TextBlock
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Select_x
   (
      this : in out TextBlock;
      start : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class;
      end_x : WinUI3.Microsoft.UI.Xaml.Documents.TextPointer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.Select_x (start.m_ITextPointer.all, end_x.m_ITextPointer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetAlphaMask
   (
      this : in out TextBlock
   )
   return WinUI3.Microsoft.UI.Composition.CompositionBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.ICompositionBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.CompositionBrush do
         Hr := this.m_ITextBlock.all.GetAlphaMask (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinUI3.Microsoft.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   procedure CopySelectionToClipboard
   (
      this : in out TextBlock
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.CopySelectionToClipboard;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextBox

   procedure Initialize (this : in out TextBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextBox, ITextBox_Ptr);
   begin
      if this.m_ITextBox /= null then
         if this.m_ITextBox.all /= null then
            temp := this.m_ITextBox.all.Release;
            Free (this.m_ITextBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TextBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TextBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITextBox");
      m_Factory    : access ITextBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITextBox;
   begin
      return RetVal : TextBox do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITextBox := new WinUI3.Microsoft.UI.Xaml.Controls.ITextBox;
            Retval.m_ITextBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TextBox

   function get_TextProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLengthProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsReadOnlyProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsReadOnlyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AcceptsReturnProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AcceptsReturnProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextAlignmentProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextWrappingProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextWrappingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSpellCheckEnabledProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSpellCheckEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextPredictionEnabledProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextPredictionEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InputScopeProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InputScopeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocusProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreventKeyboardDisplayOnProgrammaticFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorFontEnabledProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorFontEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorWhenNotFocusedProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorWhenNotFocusedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalTextAlignmentProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalTextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterCasingProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterCasingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderForegroundProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanPasteClipboardContentProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanPasteClipboardContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanUndoProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanUndoProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanRedoProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanRedoProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFlyoutProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ProofingMenuFlyoutProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ProofingMenuFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DesiredCandidateWindowAlignmentProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DesiredCandidateWindowAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextReadingOrderProperty_TextBox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextReadingOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextBox

   function get_Text
   (
      this : in out TextBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextBox.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out TextBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextBox.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectedText
   (
      this : in out TextBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextBox.all.get_SelectedText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SelectedText
   (
      this : in out TextBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextBox.all.put_SelectedText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectionLength
   (
      this : in out TextBox
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBox.all.get_SelectionLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionLength
   (
      this : in out TextBox;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_SelectionLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionStart
   (
      this : in out TextBox
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBox.all.get_SelectionStart (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionStart
   (
      this : in out TextBox;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_SelectionStart (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxLength
   (
      this : in out TextBox
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBox.all.get_MaxLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLength
   (
      this : in out TextBox;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_MaxLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsReadOnly
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_IsReadOnly (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsReadOnly
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_IsReadOnly (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AcceptsReturn
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_AcceptsReturn (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AcceptsReturn
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_AcceptsReturn (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextAlignment
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_ITextBox.all.get_TextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextAlignment
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_TextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextWrapping
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.TextWrapping is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextWrapping;
   begin
      Hr := this.m_ITextBox.all.get_TextWrapping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextWrapping
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.TextWrapping
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_TextWrapping (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSpellCheckEnabled
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_IsSpellCheckEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSpellCheckEnabled
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_IsSpellCheckEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextPredictionEnabled
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_IsTextPredictionEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextPredictionEnabled
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_IsTextPredictionEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InputScope
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.Input.InputScope'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.IInputScope;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Input.InputScope do
         Hr := this.m_ITextBox.all.get_InputScope (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInputScope := new WinUI3.Microsoft.UI.Xaml.Input.IInputScope;
         Retval.m_IInputScope.all := m_ComRetVal;
      end return;
   end;

   procedure put_InputScope
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.Input.InputScope'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_InputScope (value.m_IInputScope.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out TextBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITextBox.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out TextBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_ITextBox.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderText
   (
      this : in out TextBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextBox.all.get_PlaceholderText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out TextBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextBox.all.put_PlaceholderText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectionHighlightColor
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush do
         Hr := this.m_ITextBox.all.get_SelectionHighlightColor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColor
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_SelectionHighlightColor (value.m_ISolidColorBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_PreventKeyboardDisplayOnProgrammaticFocus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_PreventKeyboardDisplayOnProgrammaticFocus (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorFontEnabled
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_IsColorFontEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorFontEnabled
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_IsColorFontEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionHighlightColorWhenNotFocused
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush do
         Hr := this.m_ITextBox.all.get_SelectionHighlightColorWhenNotFocused (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Microsoft.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColorWhenNotFocused
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_SelectionHighlightColorWhenNotFocused (value.m_ISolidColorBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalTextAlignment
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_ITextBox.all.get_HorizontalTextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalTextAlignment
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_HorizontalTextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterCasing
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CharacterCasing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CharacterCasing;
   begin
      Hr := this.m_ITextBox.all.get_CharacterCasing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterCasing
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.CharacterCasing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_CharacterCasing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderForeground
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ITextBox.all.get_PlaceholderForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlaceholderForeground
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_PlaceholderForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanPasteClipboardContent
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_CanPasteClipboardContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanUndo
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_CanUndo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanRedo
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_CanRedo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionFlyout
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := this.m_ITextBox.all.get_SelectionFlyout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionFlyout
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_SelectionFlyout (value.m_IFlyoutBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ProofingMenuFlyout
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := this.m_ITextBox.all.get_ProofingMenuFlyout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   function get_Description
   (
      this : in out TextBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITextBox.all.get_Description (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out TextBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_Description (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextChanged
   (
      this : in out TextBox;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.TextChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_TextChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextChanged
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_TextChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out TextBox;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextMenuOpening
   (
      this : in out TextBox;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.ContextMenuOpeningEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_ContextMenuOpening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextMenuOpening
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_ContextMenuOpening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Paste
   (
      this : in out TextBox;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.TextControlPasteEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_Paste (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Paste
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_Paste (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionStarted
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_TextCompositionStarted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionStarted
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_TextCompositionStarted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionChanged
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_TextCompositionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionChanged
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_TextCompositionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionEnded
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_TextCompositionEnded (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionEnded
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_TextCompositionEnded (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CopyingToClipboard
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_CopyingToClipboard (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CopyingToClipboard
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_CopyingToClipboard (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CuttingToClipboard
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_CuttingToClipboard (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CuttingToClipboard
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_CuttingToClipboard (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_BeforeTextChanging
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_BeforeTextChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BeforeTextChanging
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_BeforeTextChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanging
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_SelectionChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanging
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_SelectionChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Select_x
   (
      this : in out TextBox;
      start : WinUI3.Int32;
      length : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.Select_x (start, length);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetRectFromCharacterIndex
   (
      this : in out TextBox;
      charIndex : WinUI3.Int32;
      trailingEdge : WinUI3.Boolean
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_ITextBox.all.GetRectFromCharacterIndex (charIndex, trailingEdge, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetLinguisticAlternativesAsync
   (
      this : in out TextBox
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.GenericObject;
      m_IID            : aliased WinUI3.IID := (798143785, 4507, 22362, (164, 25, 57, 4, 180, 228, 26, 242 )); -- GenericObject;
      m_HandlerIID     : aliased WinUI3.IID := (2088278462, 24366, 23539, (173, 229, 173, 152, 183, 114, 199, 205 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ITextBox.all.GetLinguisticAlternativesAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   procedure Undo
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.Undo;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Redo
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.Redo;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PasteFromClipboard
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.PasteFromClipboard;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CopySelectionToClipboard
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.CopySelectionToClipboard;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CutSelectionToClipboard
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.CutSelectionToClipboard;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ClearUndoRedoHistory
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.ClearUndoRedoHistory;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextReadingOrder
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.TextReadingOrder is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.TextReadingOrder;
   begin
      Hr := this.m_ITextBox.all.get_TextReadingOrder (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextReadingOrder
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.TextReadingOrder
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_TextReadingOrder (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DesiredCandidateWindowAlignment
   (
      this : in out TextBox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.CandidateWindowAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.CandidateWindowAlignment;
   begin
      Hr := this.m_ITextBox.all.get_DesiredCandidateWindowAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredCandidateWindowAlignment
   (
      this : in out TextBox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.CandidateWindowAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_DesiredCandidateWindowAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CandidateWindowBoundsChanged
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_CandidateWindowBoundsChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CandidateWindowBoundsChanged
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_CandidateWindowBoundsChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextChanging
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_TextChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextChanging
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_TextChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextBoxBeforeTextChangingEventArgs

   procedure Initialize (this : in out TextBoxBeforeTextChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextBoxBeforeTextChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextBoxBeforeTextChangingEventArgs, ITextBoxBeforeTextChangingEventArgs_Ptr);
   begin
      if this.m_ITextBoxBeforeTextChangingEventArgs /= null then
         if this.m_ITextBoxBeforeTextChangingEventArgs.all /= null then
            temp := this.m_ITextBoxBeforeTextChangingEventArgs.all.Release;
            Free (this.m_ITextBoxBeforeTextChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextBoxBeforeTextChangingEventArgs

   function get_NewText
   (
      this : in out TextBoxBeforeTextChangingEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextBoxBeforeTextChangingEventArgs.all.get_NewText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Cancel
   (
      this : in out TextBoxBeforeTextChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBoxBeforeTextChangingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out TextBoxBeforeTextChangingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBoxBeforeTextChangingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextBoxSelectionChangingEventArgs

   procedure Initialize (this : in out TextBoxSelectionChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextBoxSelectionChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextBoxSelectionChangingEventArgs, ITextBoxSelectionChangingEventArgs_Ptr);
   begin
      if this.m_ITextBoxSelectionChangingEventArgs /= null then
         if this.m_ITextBoxSelectionChangingEventArgs.all /= null then
            temp := this.m_ITextBoxSelectionChangingEventArgs.all.Release;
            Free (this.m_ITextBoxSelectionChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextBoxSelectionChangingEventArgs

   function get_SelectionStart
   (
      this : in out TextBoxSelectionChangingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBoxSelectionChangingEventArgs.all.get_SelectionStart (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionLength
   (
      this : in out TextBoxSelectionChangingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBoxSelectionChangingEventArgs.all.get_SelectionLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out TextBoxSelectionChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBoxSelectionChangingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out TextBoxSelectionChangingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBoxSelectionChangingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextBoxTextChangingEventArgs

   procedure Initialize (this : in out TextBoxTextChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextBoxTextChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextBoxTextChangingEventArgs, ITextBoxTextChangingEventArgs_Ptr);
   begin
      if this.m_ITextBoxTextChangingEventArgs /= null then
         if this.m_ITextBoxTextChangingEventArgs.all /= null then
            temp := this.m_ITextBoxTextChangingEventArgs.all.Release;
            Free (this.m_ITextBoxTextChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextBoxTextChangingEventArgs

   function get_IsContentChanging
   (
      this : in out TextBoxTextChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBoxTextChangingEventArgs.all.get_IsContentChanging (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextChangedEventArgs

   procedure Initialize (this : in out TextChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextChangedEventArgs, ITextChangedEventArgs_Ptr);
   begin
      if this.m_ITextChangedEventArgs /= null then
         if this.m_ITextChangedEventArgs.all /= null then
            temp := this.m_ITextChangedEventArgs.all.Release;
            Free (this.m_ITextChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextChangedEventArgs

   -----------------------------------------------------------------------------
   -- Delegate TextChangedEventHandler

   function Invoke
   (
      this : access TextChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.ITextChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextCommandBarFlyout

   procedure Initialize (this : in out TextCommandBarFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextCommandBarFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextCommandBarFlyout, ITextCommandBarFlyout_Ptr);
   begin
      if this.m_ITextCommandBarFlyout /= null then
         if this.m_ITextCommandBarFlyout.all /= null then
            temp := this.m_ITextCommandBarFlyout.all.Release;
            Free (this.m_ITextCommandBarFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TextCommandBarFlyout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TextCommandBarFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITextCommandBarFlyout");
      m_Factory    : access ITextCommandBarFlyoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITextCommandBarFlyout;
   begin
      return RetVal : TextCommandBarFlyout do
         Hr := RoGetActivationFactory (m_hString, IID_ITextCommandBarFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITextCommandBarFlyout := new WinUI3.Microsoft.UI.Xaml.Controls.ITextCommandBarFlyout;
            Retval.m_ITextCommandBarFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextCommandBarFlyout

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextCompositionChangedEventArgs

   procedure Initialize (this : in out TextCompositionChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextCompositionChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextCompositionChangedEventArgs, ITextCompositionChangedEventArgs_Ptr);
   begin
      if this.m_ITextCompositionChangedEventArgs /= null then
         if this.m_ITextCompositionChangedEventArgs.all /= null then
            temp := this.m_ITextCompositionChangedEventArgs.all.Release;
            Free (this.m_ITextCompositionChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextCompositionChangedEventArgs

   function get_StartIndex
   (
      this : in out TextCompositionChangedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionChangedEventArgs.all.get_StartIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Length
   (
      this : in out TextCompositionChangedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionChangedEventArgs.all.get_Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextCompositionEndedEventArgs

   procedure Initialize (this : in out TextCompositionEndedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextCompositionEndedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextCompositionEndedEventArgs, ITextCompositionEndedEventArgs_Ptr);
   begin
      if this.m_ITextCompositionEndedEventArgs /= null then
         if this.m_ITextCompositionEndedEventArgs.all /= null then
            temp := this.m_ITextCompositionEndedEventArgs.all.Release;
            Free (this.m_ITextCompositionEndedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextCompositionEndedEventArgs

   function get_StartIndex
   (
      this : in out TextCompositionEndedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionEndedEventArgs.all.get_StartIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Length
   (
      this : in out TextCompositionEndedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionEndedEventArgs.all.get_Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextCompositionStartedEventArgs

   procedure Initialize (this : in out TextCompositionStartedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextCompositionStartedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextCompositionStartedEventArgs, ITextCompositionStartedEventArgs_Ptr);
   begin
      if this.m_ITextCompositionStartedEventArgs /= null then
         if this.m_ITextCompositionStartedEventArgs.all /= null then
            temp := this.m_ITextCompositionStartedEventArgs.all.Release;
            Free (this.m_ITextCompositionStartedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextCompositionStartedEventArgs

   function get_StartIndex
   (
      this : in out TextCompositionStartedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionStartedEventArgs.all.get_StartIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Length
   (
      this : in out TextCompositionStartedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionStartedEventArgs.all.get_Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextControlCopyingToClipboardEventArgs

   procedure Initialize (this : in out TextControlCopyingToClipboardEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextControlCopyingToClipboardEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextControlCopyingToClipboardEventArgs, ITextControlCopyingToClipboardEventArgs_Ptr);
   begin
      if this.m_ITextControlCopyingToClipboardEventArgs /= null then
         if this.m_ITextControlCopyingToClipboardEventArgs.all /= null then
            temp := this.m_ITextControlCopyingToClipboardEventArgs.all.Release;
            Free (this.m_ITextControlCopyingToClipboardEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextControlCopyingToClipboardEventArgs

   function get_Handled
   (
      this : in out TextControlCopyingToClipboardEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextControlCopyingToClipboardEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out TextControlCopyingToClipboardEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextControlCopyingToClipboardEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextControlCuttingToClipboardEventArgs

   procedure Initialize (this : in out TextControlCuttingToClipboardEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextControlCuttingToClipboardEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextControlCuttingToClipboardEventArgs, ITextControlCuttingToClipboardEventArgs_Ptr);
   begin
      if this.m_ITextControlCuttingToClipboardEventArgs /= null then
         if this.m_ITextControlCuttingToClipboardEventArgs.all /= null then
            temp := this.m_ITextControlCuttingToClipboardEventArgs.all.Release;
            Free (this.m_ITextControlCuttingToClipboardEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextControlCuttingToClipboardEventArgs

   function get_Handled
   (
      this : in out TextControlCuttingToClipboardEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextControlCuttingToClipboardEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out TextControlCuttingToClipboardEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextControlCuttingToClipboardEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextControlPasteEventArgs

   procedure Initialize (this : in out TextControlPasteEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextControlPasteEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextControlPasteEventArgs, ITextControlPasteEventArgs_Ptr);
   begin
      if this.m_ITextControlPasteEventArgs /= null then
         if this.m_ITextControlPasteEventArgs.all /= null then
            temp := this.m_ITextControlPasteEventArgs.all.Release;
            Free (this.m_ITextControlPasteEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextControlPasteEventArgs

   function get_Handled
   (
      this : in out TextControlPasteEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextControlPasteEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out TextControlPasteEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextControlPasteEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate TextControlPasteEventHandler

   function Invoke
   (
      this : access TextControlPasteEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.ITextControlPasteEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePickedEventArgs

   procedure Initialize (this : in out TimePickedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePickedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePickedEventArgs, ITimePickedEventArgs_Ptr);
   begin
      if this.m_ITimePickedEventArgs /= null then
         if this.m_ITimePickedEventArgs.all /= null then
            temp := this.m_ITimePickedEventArgs.all.Release;
            Free (this.m_ITimePickedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TimePickedEventArgs

   function Constructor return TimePickedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITimePickedEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITimePickedEventArgs;
   begin
      return RetVal : TimePickedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITimePickedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.ITimePickedEventArgs;
            Retval.m_ITimePickedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePickedEventArgs

   function get_OldTime
   (
      this : in out TimePickedEventArgs
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePickedEventArgs.all.get_OldTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewTime
   (
      this : in out TimePickedEventArgs
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePickedEventArgs.all.get_NewTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePicker

   procedure Initialize (this : in out TimePicker) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePicker) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePicker, ITimePicker_Ptr);
   begin
      if this.m_ITimePicker /= null then
         if this.m_ITimePicker.all /= null then
            temp := this.m_ITimePicker.all.Release;
            Free (this.m_ITimePicker);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TimePicker

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TimePicker is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITimePicker");
      m_Factory    : access ITimePickerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITimePicker;
   begin
      return RetVal : TimePicker do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITimePicker := new WinUI3.Microsoft.UI.Xaml.Controls.ITimePicker;
            Retval.m_ITimePicker.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TimePicker

   function get_HeaderProperty_TimePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_TimePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClockIdentifierProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClockIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinuteIncrementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinuteIncrementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TimeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty_TimePicker
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedTimeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedTimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePicker

   function get_Header
   (
      this : in out TimePicker
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITimePicker.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out TimePicker;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out TimePicker
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_ITimePicker.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out TimePicker;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ClockIdentifier
   (
      this : in out TimePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITimePicker.all.get_ClockIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ClockIdentifier
   (
      this : in out TimePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITimePicker.all.put_ClockIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_MinuteIncrement
   (
      this : in out TimePicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITimePicker.all.get_MinuteIncrement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinuteIncrement
   (
      this : in out TimePicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.put_MinuteIncrement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Time
   (
      this : in out TimePicker
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePicker.all.get_Time (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Time
   (
      this : in out TimePicker;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.put_Time (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out TimePicker
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode;
   begin
      Hr := this.m_ITimePicker.all.get_LightDismissOverlayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out TimePicker;
      value : WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.put_LightDismissOverlayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedTime
   (
      this : in out TimePicker
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
   begin
      Hr := this.m_ITimePicker.all.get_SelectedTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_SelectedTime
   (
      this : in out TimePicker;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.put_SelectedTime (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TimeChanged
   (
      this : in out TimePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITimePicker.all.add_TimeChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TimeChanged
   (
      this : in out TimePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.remove_TimeChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectedTimeChanged
   (
      this : in out TimePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITimePicker.all.add_SelectedTimeChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectedTimeChanged
   (
      this : in out TimePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.remove_SelectedTimeChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePickerFlyout

   procedure Initialize (this : in out TimePickerFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePickerFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePickerFlyout, ITimePickerFlyout_Ptr);
   begin
      if this.m_ITimePickerFlyout /= null then
         if this.m_ITimePickerFlyout.all /= null then
            temp := this.m_ITimePickerFlyout.all.Release;
            Free (this.m_ITimePickerFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TimePickerFlyout

   function Constructor return TimePickerFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITimePickerFlyout");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerFlyout;
   begin
      return RetVal : TimePickerFlyout do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITimePickerFlyout := new WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerFlyout;
            Retval.m_ITimePickerFlyout.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TimePickerFlyout

   function get_ClockIdentifierProperty_TimePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TimePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClockIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TimeProperty_TimePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TimePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinuteIncrementProperty_TimePickerFlyout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TimePickerFlyout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinuteIncrementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePickerFlyout

   function get_ClockIdentifier
   (
      this : in out TimePickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITimePickerFlyout.all.get_ClockIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ClockIdentifier
   (
      this : in out TimePickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITimePickerFlyout.all.put_ClockIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Time
   (
      this : in out TimePickerFlyout
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePickerFlyout.all.get_Time (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Time
   (
      this : in out TimePickerFlyout;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePickerFlyout.all.put_Time (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinuteIncrement
   (
      this : in out TimePickerFlyout
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITimePickerFlyout.all.get_MinuteIncrement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinuteIncrement
   (
      this : in out TimePickerFlyout;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePickerFlyout.all.put_MinuteIncrement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TimePicked
   (
      this : in out TimePickerFlyout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITimePickerFlyout.all.add_TimePicked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TimePicked
   (
      this : in out TimePickerFlyout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePickerFlyout.all.remove_TimePicked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAtAsync
   (
      this : in out TimePickerFlyout;
      target : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.GenericObject;
      m_IID            : aliased WinUI3.IID := (615055789, 37135, 23567, (178, 60, 103, 0, 117, 119, 165, 88 )); -- GenericObject;
      m_HandlerIID     : aliased WinUI3.IID := (3778524791, 49135, 21680, (178, 0, 149, 197, 194, 144, 42, 37 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ITimePickerFlyout.all.ShowAtAsync (target.m_IFrameworkElement.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePickerFlyoutPresenter

   procedure Initialize (this : in out TimePickerFlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePickerFlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePickerFlyoutPresenter, ITimePickerFlyoutPresenter_Ptr);
   begin
      if this.m_ITimePickerFlyoutPresenter /= null then
         if this.m_ITimePickerFlyoutPresenter.all /= null then
            temp := this.m_ITimePickerFlyoutPresenter.all.Release;
            Free (this.m_ITimePickerFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TimePickerFlyoutPresenter

   function get_IsDefaultShadowEnabledProperty_TimePickerFlyoutPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TimePickerFlyoutPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITimePickerFlyoutPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerFlyoutPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDefaultShadowEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePickerFlyoutPresenter

   function get_IsDefaultShadowEnabled
   (
      this : in out TimePickerFlyoutPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITimePickerFlyoutPresenter.all.get_IsDefaultShadowEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDefaultShadowEnabled
   (
      this : in out TimePickerFlyoutPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePickerFlyoutPresenter.all.put_IsDefaultShadowEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePickerSelectedValueChangedEventArgs

   procedure Initialize (this : in out TimePickerSelectedValueChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePickerSelectedValueChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePickerSelectedValueChangedEventArgs, ITimePickerSelectedValueChangedEventArgs_Ptr);
   begin
      if this.m_ITimePickerSelectedValueChangedEventArgs /= null then
         if this.m_ITimePickerSelectedValueChangedEventArgs.all /= null then
            temp := this.m_ITimePickerSelectedValueChangedEventArgs.all.Release;
            Free (this.m_ITimePickerSelectedValueChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePickerSelectedValueChangedEventArgs

   function get_OldTime
   (
      this : in out TimePickerSelectedValueChangedEventArgs
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
   begin
      Hr := this.m_ITimePickerSelectedValueChangedEventArgs.all.get_OldTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_NewTime
   (
      this : in out TimePickerSelectedValueChangedEventArgs
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
   begin
      Hr := this.m_ITimePickerSelectedValueChangedEventArgs.all.get_NewTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePickerValueChangedEventArgs

   procedure Initialize (this : in out TimePickerValueChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePickerValueChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePickerValueChangedEventArgs, ITimePickerValueChangedEventArgs_Ptr);
   begin
      if this.m_ITimePickerValueChangedEventArgs /= null then
         if this.m_ITimePickerValueChangedEventArgs.all /= null then
            temp := this.m_ITimePickerValueChangedEventArgs.all.Release;
            Free (this.m_ITimePickerValueChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePickerValueChangedEventArgs

   function get_OldTime
   (
      this : in out TimePickerValueChangedEventArgs
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePickerValueChangedEventArgs.all.get_OldTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewTime
   (
      this : in out TimePickerValueChangedEventArgs
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePickerValueChangedEventArgs.all.get_NewTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TitleBar

   procedure Initialize (this : in out TitleBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out TitleBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITitleBar, ITitleBar_Ptr);
   begin
      if this.m_ITitleBar /= null then
         if this.m_ITitleBar.all /= null then
            temp := this.m_ITitleBar.all.Release;
            Free (this.m_ITitleBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TitleBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TitleBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITitleBar");
      m_Factory    : access ITitleBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITitleBar;
   begin
      return RetVal : TitleBar do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITitleBar := new WinUI3.Microsoft.UI.Xaml.Controls.ITitleBar;
            Retval.m_ITitleBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TitleBar

   function get_TitleProperty_TitleBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TitleBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SubtitleProperty_TitleBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TitleBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SubtitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconSourceProperty_TitleBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TitleBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LeftHeaderProperty_TitleBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TitleBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentProperty_TitleBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TitleBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RightHeaderProperty_TitleBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TitleBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RightHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsBackButtonVisibleProperty_TitleBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TitleBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsBackButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsBackButtonEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TitleBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsBackButtonEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPaneToggleButtonVisibleProperty_TitleBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TitleBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPaneToggleButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateSettingsProperty_TitleBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TitleBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TitleBar

   function get_Title
   (
      this : in out TitleBar
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITitleBar.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out TitleBar;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITitleBar.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Subtitle
   (
      this : in out TitleBar
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITitleBar.all.get_Subtitle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Subtitle
   (
      this : in out TitleBar;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITitleBar.all.put_Subtitle (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IconSource
   (
      this : in out TitleBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconSource do
         Hr := this.m_ITitleBar.all.get_IconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinUI3.Microsoft.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconSource
   (
      this : in out TitleBar;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITitleBar.all.put_IconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LeftHeader
   (
      this : in out TitleBar
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_ITitleBar.all.get_LeftHeader (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_LeftHeader
   (
      this : in out TitleBar;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITitleBar.all.put_LeftHeader (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Content
   (
      this : in out TitleBar
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_ITitleBar.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out TitleBar;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITitleBar.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RightHeader
   (
      this : in out TitleBar
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_ITitleBar.all.get_RightHeader (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_RightHeader
   (
      this : in out TitleBar;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITitleBar.all.put_RightHeader (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsBackButtonVisible
   (
      this : in out TitleBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITitleBar.all.get_IsBackButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsBackButtonVisible
   (
      this : in out TitleBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITitleBar.all.put_IsBackButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsBackButtonEnabled
   (
      this : in out TitleBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITitleBar.all.get_IsBackButtonEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsBackButtonEnabled
   (
      this : in out TitleBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITitleBar.all.put_IsBackButtonEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPaneToggleButtonVisible
   (
      this : in out TitleBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITitleBar.all.get_IsPaneToggleButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPaneToggleButtonVisible
   (
      this : in out TitleBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITitleBar.all.put_IsPaneToggleButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out TitleBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TitleBarTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TitleBarTemplateSettings do
         Hr := this.m_ITitleBar.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITitleBarTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarTemplateSettings;
         Retval.m_ITitleBarTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_BackRequested
   (
      this : in out TitleBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITitleBar.all.add_BackRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BackRequested
   (
      this : in out TitleBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITitleBar.all.remove_BackRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneToggleRequested
   (
      this : in out TitleBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITitleBar.all.add_PaneToggleRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneToggleRequested
   (
      this : in out TitleBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITitleBar.all.remove_PaneToggleRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TitleBarAutomationPeer

   procedure Initialize (this : in out TitleBarAutomationPeer) is
   begin
      null;
   end;

   procedure Finalize (this : in out TitleBarAutomationPeer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITitleBarAutomationPeer, ITitleBarAutomationPeer_Ptr);
   begin
      if this.m_ITitleBarAutomationPeer /= null then
         if this.m_ITitleBarAutomationPeer.all /= null then
            temp := this.m_ITitleBarAutomationPeer.all.Release;
            Free (this.m_ITitleBarAutomationPeer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TitleBarAutomationPeer

   function Constructor
   (
      owner : WinUI3.Microsoft.UI.Xaml.Controls.TitleBar'Class;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TitleBarAutomationPeer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITitleBarAutomationPeer");
      m_Factory    : access ITitleBarAutomationPeerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarAutomationPeer;
   begin
      return RetVal : TitleBarAutomationPeer do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarAutomationPeerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (owner.m_ITitleBar.all, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITitleBarAutomationPeer := new WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarAutomationPeer;
            Retval.m_ITitleBarAutomationPeer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TitleBarAutomationPeer

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TitleBarTemplateSettings

   procedure Initialize (this : in out TitleBarTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out TitleBarTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITitleBarTemplateSettings, ITitleBarTemplateSettings_Ptr);
   begin
      if this.m_ITitleBarTemplateSettings /= null then
         if this.m_ITitleBarTemplateSettings.all /= null then
            temp := this.m_ITitleBarTemplateSettings.all.Release;
            Free (this.m_ITitleBarTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TitleBarTemplateSettings

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TitleBarTemplateSettings is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITitleBarTemplateSettings");
      m_Factory    : access ITitleBarTemplateSettingsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarTemplateSettings;
   begin
      return RetVal : TitleBarTemplateSettings do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarTemplateSettingsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITitleBarTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarTemplateSettings;
            Retval.m_ITitleBarTemplateSettings.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TitleBarTemplateSettings

   function get_IconElementProperty_TitleBarTemplateSettings
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TitleBarTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITitleBarTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITitleBarTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TitleBarTemplateSettings

   function get_IconElement
   (
      this : in out TitleBarTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_ITitleBarTemplateSettings.all.get_IconElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconElement
   (
      this : in out TitleBarTemplateSettings;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITitleBarTemplateSettings.all.put_IconElement (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToggleMenuFlyoutItem

   procedure Initialize (this : in out ToggleMenuFlyoutItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToggleMenuFlyoutItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToggleMenuFlyoutItem, IToggleMenuFlyoutItem_Ptr);
   begin
      if this.m_IToggleMenuFlyoutItem /= null then
         if this.m_IToggleMenuFlyoutItem.all /= null then
            temp := this.m_IToggleMenuFlyoutItem.all.Release;
            Free (this.m_IToggleMenuFlyoutItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ToggleMenuFlyoutItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ToggleMenuFlyoutItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IToggleMenuFlyoutItem");
      m_Factory    : access IToggleMenuFlyoutItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IToggleMenuFlyoutItem;
   begin
      return RetVal : ToggleMenuFlyoutItem do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleMenuFlyoutItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IToggleMenuFlyoutItem := new WinUI3.Microsoft.UI.Xaml.Controls.IToggleMenuFlyoutItem;
            Retval.m_IToggleMenuFlyoutItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ToggleMenuFlyoutItem

   function get_IsCheckedProperty_ToggleMenuFlyoutItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToggleMenuFlyoutItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToggleMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCheckedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToggleMenuFlyoutItem

   function get_IsChecked
   (
      this : in out ToggleMenuFlyoutItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IToggleMenuFlyoutItem.all.get_IsChecked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsChecked
   (
      this : in out ToggleMenuFlyoutItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleMenuFlyoutItem.all.put_IsChecked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToggleSplitButton

   procedure Initialize (this : in out ToggleSplitButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToggleSplitButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToggleSplitButton, IToggleSplitButton_Ptr);
   begin
      if this.m_IToggleSplitButton /= null then
         if this.m_IToggleSplitButton.all /= null then
            temp := this.m_IToggleSplitButton.all.Release;
            Free (this.m_IToggleSplitButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ToggleSplitButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ToggleSplitButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IToggleSplitButton");
      m_Factory    : access IToggleSplitButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IToggleSplitButton;
   begin
      return RetVal : ToggleSplitButton do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSplitButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IToggleSplitButton := new WinUI3.Microsoft.UI.Xaml.Controls.IToggleSplitButton;
            Retval.m_IToggleSplitButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ToggleSplitButton

   function get_IsCheckedProperty_ToggleSplitButton
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToggleSplitButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToggleSplitButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSplitButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCheckedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToggleSplitButton

   function get_IsChecked
   (
      this : in out ToggleSplitButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IToggleSplitButton.all.get_IsChecked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsChecked
   (
      this : in out ToggleSplitButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSplitButton.all.put_IsChecked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_IsCheckedChanged
   (
      this : in out ToggleSplitButton;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IToggleSplitButton.all.add_IsCheckedChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsCheckedChanged
   (
      this : in out ToggleSplitButton;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSplitButton.all.remove_IsCheckedChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToggleSplitButtonIsCheckedChangedEventArgs

   procedure Initialize (this : in out ToggleSplitButtonIsCheckedChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToggleSplitButtonIsCheckedChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToggleSplitButtonIsCheckedChangedEventArgs, IToggleSplitButtonIsCheckedChangedEventArgs_Ptr);
   begin
      if this.m_IToggleSplitButtonIsCheckedChangedEventArgs /= null then
         if this.m_IToggleSplitButtonIsCheckedChangedEventArgs.all /= null then
            temp := this.m_IToggleSplitButtonIsCheckedChangedEventArgs.all.Release;
            Free (this.m_IToggleSplitButtonIsCheckedChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToggleSplitButtonIsCheckedChangedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToggleSwitch

   procedure Initialize (this : in out ToggleSwitch) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToggleSwitch) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToggleSwitch, IToggleSwitch_Ptr);
   begin
      if this.m_IToggleSwitch /= null then
         if this.m_IToggleSwitch.all /= null then
            temp := this.m_IToggleSwitch.all.Release;
            Free (this.m_IToggleSwitch);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ToggleSwitch

   function Constructor return ToggleSwitch is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IToggleSwitch");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitch;
   begin
      return RetVal : ToggleSwitch do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IToggleSwitch := new WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitch;
            Retval.m_IToggleSwitch.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ToggleSwitch

   function get_IsOnProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOnProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_ToggleSwitch
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_ToggleSwitch
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OnContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OnContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OnContentTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OnContentTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OffContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OffContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OffContentTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OffContentTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToggleSwitch

   function get_IsOn
   (
      this : in out ToggleSwitch
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IToggleSwitch.all.get_IsOn (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOn
   (
      this : in out ToggleSwitch;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_IsOn (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out ToggleSwitch
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IToggleSwitch.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out ToggleSwitch;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out ToggleSwitch
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IToggleSwitch.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out ToggleSwitch;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OnContent
   (
      this : in out ToggleSwitch
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IToggleSwitch.all.get_OnContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OnContent
   (
      this : in out ToggleSwitch;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_OnContent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OnContentTemplate
   (
      this : in out ToggleSwitch
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IToggleSwitch.all.get_OnContentTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_OnContentTemplate
   (
      this : in out ToggleSwitch;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_OnContentTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OffContent
   (
      this : in out ToggleSwitch
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IToggleSwitch.all.get_OffContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OffContent
   (
      this : in out ToggleSwitch;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_OffContent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OffContentTemplate
   (
      this : in out ToggleSwitch
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_IToggleSwitch.all.get_OffContentTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_OffContentTemplate
   (
      this : in out ToggleSwitch;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_OffContentTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out ToggleSwitch
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IToggleSwitchTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings do
         Hr := this.m_IToggleSwitch.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IToggleSwitchTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IToggleSwitchTemplateSettings;
         Retval.m_IToggleSwitchTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_Toggled
   (
      this : in out ToggleSwitch;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IToggleSwitch.all.add_Toggled (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Toggled
   (
      this : in out ToggleSwitch;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.remove_Toggled (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnToggled
   (
      this : in out ToggleSwitch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitch_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IToggleSwitchOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSwitch.all);
      Hr := m_Interface.OnToggled;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnOnContentChanged
   (
      this : in out ToggleSwitch;
      oldContent : WinUI3.IInspectable;
      newContent : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitch_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IToggleSwitchOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSwitch.all);
      Hr := m_Interface.OnOnContentChanged (oldContent, newContent);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnOffContentChanged
   (
      this : in out ToggleSwitch;
      oldContent : WinUI3.IInspectable;
      newContent : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitch_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IToggleSwitchOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSwitch.all);
      Hr := m_Interface.OnOffContentChanged (oldContent, newContent);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnHeaderChanged
   (
      this : in out ToggleSwitch;
      oldContent : WinUI3.IInspectable;
      newContent : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitch_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IToggleSwitchOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IToggleSwitchOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSwitch.all);
      Hr := m_Interface.OnHeaderChanged (oldContent, newContent);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToolTip

   procedure Initialize (this : in out ToolTip) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToolTip) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToolTip, IToolTip_Ptr);
   begin
      if this.m_IToolTip /= null then
         if this.m_IToolTip.all /= null then
            temp := this.m_IToolTip.all.Release;
            Free (this.m_IToolTip);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ToolTip

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ToolTip is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IToolTip");
      m_Factory    : access IToolTipFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IToolTip;
   begin
      return RetVal : ToolTip do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IToolTip := new WinUI3.Microsoft.UI.Xaml.Controls.IToolTip;
            Retval.m_IToolTip.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ToolTip

   function get_HorizontalOffsetProperty_ToolTip
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsOpenProperty_ToolTip
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlacementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlacementTargetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlacementRectProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementRectProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalOffsetProperty_ToolTip
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToolTip

   function get_HorizontalOffset
   (
      this : in out ToolTip
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToolTip.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalOffset
   (
      this : in out ToolTip;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.put_HorizontalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsOpen
   (
      this : in out ToolTip
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IToolTip.all.get_IsOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOpen
   (
      this : in out ToolTip;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.put_IsOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Placement
   (
      this : in out ToolTip
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.PlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.PlacementMode;
   begin
      Hr := this.m_IToolTip.all.get_Placement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Placement
   (
      this : in out ToolTip;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.PlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.put_Placement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlacementTarget
   (
      this : in out ToolTip
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IToolTip.all.get_PlacementTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlacementTarget
   (
      this : in out ToolTip;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.put_PlacementTarget (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlacementRect
   (
      this : in out ToolTip
   )
   return IReference_Rect.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Rect.Kind;
   begin
      Hr := this.m_IToolTip.all.get_PlacementRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Rect (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_PlacementRect
   (
      this : in out ToolTip;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.put_PlacementRect (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalOffset
   (
      this : in out ToolTip
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToolTip.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalOffset
   (
      this : in out ToolTip;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.put_VerticalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out ToolTip
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IToolTipTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings do
         Hr := this.m_IToolTip.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IToolTipTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IToolTipTemplateSettings;
         Retval.m_IToolTipTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_Closed
   (
      this : in out ToolTip;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IToolTip.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out ToolTip;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opened
   (
      this : in out ToolTip;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IToolTip.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out ToolTip;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToolTipService

   procedure Initialize (this : in out ToolTipService) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToolTipService) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToolTipService, IToolTipService_Ptr);
   begin
      if this.m_IToolTipService /= null then
         if this.m_IToolTipService.all /= null then
            temp := this.m_IToolTipService.all.Release;
            Free (this.m_IToolTipService);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ToolTipService

   function get_PlacementProperty_ToolTipService
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetPlacement
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.PlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.PlacementMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetPlacement (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetPlacement
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.PlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetPlacement (element.m_IDependencyObject.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_PlacementTargetProperty_ToolTipService
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetPlacementTarget
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetPlacementTarget (element.m_IDependencyObject.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
            Retval.m_IUIElement.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetPlacementTarget
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetPlacementTarget (element.m_IDependencyObject.all, value.m_IUIElement.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ToolTipProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ToolTipProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetToolTip
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetToolTip (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetToolTip
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetToolTip (element.m_IDependencyObject.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToolTipService

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeView

   procedure Initialize (this : in out TreeView) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeView, ITreeView_Ptr);
   begin
      if this.m_ITreeView /= null then
         if this.m_ITreeView.all /= null then
            temp := this.m_ITreeView.all.Release;
            Free (this.m_ITreeView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TreeView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TreeView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITreeView");
      m_Factory    : access ITreeViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITreeView;
   begin
      return RetVal : TreeView do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITreeView := new WinUI3.Microsoft.UI.Xaml.Controls.ITreeView;
            Retval.m_ITreeView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TreeView

   function get_SelectedItemProperty_TreeView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionModeProperty_TreeView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanDragItemsProperty_TreeView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanDragItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanReorderItemsProperty_TreeView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanReorderItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty_TreeView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateSelectorProperty_TreeView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerStyleProperty_TreeView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerStyleSelectorProperty_TreeView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerStyleSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerTransitionsProperty_TreeView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsSourceProperty_TreeView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeView

   function get_RootNodes
   (
      this : in out TreeView
   )
   return IVector_ITreeViewNode.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_ITreeViewNode.Kind;
   begin
      Hr := this.m_ITreeView.all.get_RootNodes (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_ITreeViewNode (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SelectionMode
   (
      this : in out TreeView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TreeViewSelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TreeViewSelectionMode;
   begin
      Hr := this.m_ITreeView.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionMode
   (
      this : in out TreeView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TreeViewSelectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.put_SelectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedNodes
   (
      this : in out TreeView
   )
   return IVector_ITreeViewNode.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_ITreeViewNode.Kind;
   begin
      Hr := this.m_ITreeView.all.get_SelectedNodes (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_ITreeViewNode (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure Expand
   (
      this : in out TreeView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.Expand (value.m_ITreeViewNode.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Collapse
   (
      this : in out TreeView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.Collapse (value.m_ITreeViewNode.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out TreeView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ItemInvoked
   (
      this : in out TreeView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITreeView.all.add_ItemInvoked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemInvoked
   (
      this : in out TreeView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.remove_ItemInvoked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Expanding
   (
      this : in out TreeView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITreeView.all.add_Expanding (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Expanding
   (
      this : in out TreeView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.remove_Expanding (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Collapsed
   (
      this : in out TreeView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITreeView.all.add_Collapsed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Collapsed
   (
      this : in out TreeView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.remove_Collapsed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function NodeFromContainer
   (
      this : in out TreeView;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.NodeFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITreeViewNode := new WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
         Retval.m_ITreeViewNode.all := m_ComRetVal;
      end return;
   end;

   function ContainerFromNode
   (
      this : in out TreeView;
      node : WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode'Class
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.ContainerFromNode (node.m_ITreeViewNode.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function ItemFromContainer
   (
      this : in out TreeView;
      container : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.ItemFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromItem
   (
      this : in out TreeView;
      item : WinUI3.IInspectable
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.ContainerFromItem (item, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function get_CanDragItems
   (
      this : in out TreeView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.get_CanDragItems (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanDragItems
   (
      this : in out TreeView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_CanDragItems (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanReorderItems
   (
      this : in out TreeView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.get_CanReorderItems (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanReorderItems
   (
      this : in out TreeView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_CanReorderItems (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTemplate
   (
      this : in out TreeView
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.get_ItemTemplate (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplate
   (
      this : in out TreeView;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemTemplate (value.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTemplateSelector
   (
      this : in out TreeView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.get_ItemTemplateSelector (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplateSelector
   (
      this : in out TreeView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemTemplateSelector (value.m_IDataTemplateSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemContainerStyle
   (
      this : in out TreeView
   )
   return WinUI3.Microsoft.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Style do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.get_ItemContainerStyle (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Microsoft.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerStyle
   (
      this : in out TreeView;
      value : WinUI3.Microsoft.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemContainerStyle (value.m_IStyle.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemContainerStyleSelector
   (
      this : in out TreeView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelector;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.get_ItemContainerStyleSelector (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyleSelector := new WinUI3.Microsoft.UI.Xaml.Controls.IStyleSelector;
         Retval.m_IStyleSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerStyleSelector
   (
      this : in out TreeView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.StyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemContainerStyleSelector (value.m_IStyleSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemContainerTransitions
   (
      this : in out TreeView
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.get_ItemContainerTransitions (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerTransitions
   (
      this : in out TreeView;
      value : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemContainerTransitions (value.m_GenericObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsSource
   (
      this : in out TreeView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.get_ItemsSource (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out TreeView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemsSource (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragItemsStarting
   (
      this : in out TreeView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.add_DragItemsStarting (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragItemsStarting
   (
      this : in out TreeView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.remove_DragItemsStarting (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragItemsCompleted
   (
      this : in out TreeView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.add_DragItemsCompleted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragItemsCompleted
   (
      this : in out TreeView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.remove_DragItemsCompleted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedNode
   (
      this : in out TreeView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.get_SelectedNode (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITreeViewNode := new WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
         Retval.m_ITreeViewNode.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedNode
   (
      this : in out TreeView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_SelectedNode (value.m_ITreeViewNode.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItem
   (
      this : in out TreeView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.get_SelectedItem (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedItem
   (
      this : in out TreeView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_SelectedItem (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItems
   (
      this : in out TreeView
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.get_SelectedItems (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function add_SelectionChanged
   (
      this : in out TreeView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView3, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.add_SelectionChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out TreeView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeView3, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.remove_SelectionChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewCollapsedEventArgs

   procedure Initialize (this : in out TreeViewCollapsedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewCollapsedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewCollapsedEventArgs, ITreeViewCollapsedEventArgs_Ptr);
   begin
      if this.m_ITreeViewCollapsedEventArgs /= null then
         if this.m_ITreeViewCollapsedEventArgs.all /= null then
            temp := this.m_ITreeViewCollapsedEventArgs.all.Release;
            Free (this.m_ITreeViewCollapsedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewCollapsedEventArgs

   function get_Node
   (
      this : in out TreeViewCollapsedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode do
         Hr := this.m_ITreeViewCollapsedEventArgs.all.get_Node (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITreeViewNode := new WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
         Retval.m_ITreeViewNode.all := m_ComRetVal;
      end return;
   end;

   function get_Item
   (
      this : in out TreeViewCollapsedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewCollapsedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewCollapsedEventArgs_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewCollapsedEventArgs2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeViewCollapsedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewCollapsedEventArgs.all);
      Hr := m_Interface.get_Item (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewDragItemsCompletedEventArgs

   procedure Initialize (this : in out TreeViewDragItemsCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewDragItemsCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewDragItemsCompletedEventArgs, ITreeViewDragItemsCompletedEventArgs_Ptr);
   begin
      if this.m_ITreeViewDragItemsCompletedEventArgs /= null then
         if this.m_ITreeViewDragItemsCompletedEventArgs.all /= null then
            temp := this.m_ITreeViewDragItemsCompletedEventArgs.all.Release;
            Free (this.m_ITreeViewDragItemsCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewDragItemsCompletedEventArgs

   function get_DropResult
   (
      this : in out TreeViewDragItemsCompletedEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation;
   begin
      Hr := this.m_ITreeViewDragItemsCompletedEventArgs.all.get_DropResult (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Items
   (
      this : in out TreeViewDragItemsCompletedEventArgs
   )
   return IVectorView_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IInspectable.Kind;
   begin
      Hr := this.m_ITreeViewDragItemsCompletedEventArgs.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_NewParentItem
   (
      this : in out TreeViewDragItemsCompletedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewDragItemsCompletedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewDragItemsCompletedEventArgs_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewDragItemsCompletedEventArgs2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeViewDragItemsCompletedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewDragItemsCompletedEventArgs.all);
      Hr := m_Interface.get_NewParentItem (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewDragItemsStartingEventArgs

   procedure Initialize (this : in out TreeViewDragItemsStartingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewDragItemsStartingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewDragItemsStartingEventArgs, ITreeViewDragItemsStartingEventArgs_Ptr);
   begin
      if this.m_ITreeViewDragItemsStartingEventArgs /= null then
         if this.m_ITreeViewDragItemsStartingEventArgs.all /= null then
            temp := this.m_ITreeViewDragItemsStartingEventArgs.all.Release;
            Free (this.m_ITreeViewDragItemsStartingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewDragItemsStartingEventArgs

   function get_Cancel
   (
      this : in out TreeViewDragItemsStartingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewDragItemsStartingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out TreeViewDragItemsStartingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewDragItemsStartingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Data
   (
      this : in out TreeViewDragItemsStartingEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage do
         Hr := this.m_ITreeViewDragItemsStartingEventArgs.all.get_Data (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataPackage := new WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
         Retval.m_IDataPackage.all := m_ComRetVal;
      end return;
   end;

   function get_Items
   (
      this : in out TreeViewDragItemsStartingEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_ITreeViewDragItemsStartingEventArgs.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewExpandingEventArgs

   procedure Initialize (this : in out TreeViewExpandingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewExpandingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewExpandingEventArgs, ITreeViewExpandingEventArgs_Ptr);
   begin
      if this.m_ITreeViewExpandingEventArgs /= null then
         if this.m_ITreeViewExpandingEventArgs.all /= null then
            temp := this.m_ITreeViewExpandingEventArgs.all.Release;
            Free (this.m_ITreeViewExpandingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewExpandingEventArgs

   function get_Node
   (
      this : in out TreeViewExpandingEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode do
         Hr := this.m_ITreeViewExpandingEventArgs.all.get_Node (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITreeViewNode := new WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
         Retval.m_ITreeViewNode.all := m_ComRetVal;
      end return;
   end;

   function get_Item
   (
      this : in out TreeViewExpandingEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewExpandingEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewExpandingEventArgs_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewExpandingEventArgs2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeViewExpandingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewExpandingEventArgs.all);
      Hr := m_Interface.get_Item (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewItem

   procedure Initialize (this : in out TreeViewItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewItem, ITreeViewItem_Ptr);
   begin
      if this.m_ITreeViewItem /= null then
         if this.m_ITreeViewItem.all /= null then
            temp := this.m_ITreeViewItem.all.Release;
            Free (this.m_ITreeViewItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TreeViewItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TreeViewItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITreeViewItem");
      m_Factory    : access ITreeViewItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem;
   begin
      return RetVal : TreeViewItem do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITreeViewItem := new WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem;
            Retval.m_ITreeViewItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TreeViewItem

   function get_GlyphOpacityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphOpacityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GlyphBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExpandedGlyphProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExpandedGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CollapsedGlyphProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CollapsedGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GlyphSizeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsExpandedProperty_TreeViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsExpandedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TreeViewItemTemplateSettingsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TreeViewItemTemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HasUnrealizedChildrenProperty_TreeViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HasUnrealizedChildrenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsSourceProperty_TreeViewItem
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewItem

   function get_GlyphOpacity
   (
      this : in out TreeViewItem
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITreeViewItem.all.get_GlyphOpacity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GlyphOpacity
   (
      this : in out TreeViewItem;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewItem.all.put_GlyphOpacity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GlyphBrush
   (
      this : in out TreeViewItem
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ITreeViewItem.all.get_GlyphBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_GlyphBrush
   (
      this : in out TreeViewItem;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewItem.all.put_GlyphBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExpandedGlyph
   (
      this : in out TreeViewItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITreeViewItem.all.get_ExpandedGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ExpandedGlyph
   (
      this : in out TreeViewItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITreeViewItem.all.put_ExpandedGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_CollapsedGlyph
   (
      this : in out TreeViewItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITreeViewItem.all.get_CollapsedGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CollapsedGlyph
   (
      this : in out TreeViewItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITreeViewItem.all.put_CollapsedGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_GlyphSize
   (
      this : in out TreeViewItem
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITreeViewItem.all.get_GlyphSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GlyphSize
   (
      this : in out TreeViewItem;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewItem.all.put_GlyphSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsExpanded
   (
      this : in out TreeViewItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewItem.all.get_IsExpanded (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsExpanded
   (
      this : in out TreeViewItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewItem.all.put_IsExpanded (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TreeViewItemTemplateSettings
   (
      this : in out TreeViewItem
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings do
         Hr := this.m_ITreeViewItem.all.get_TreeViewItemTemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITreeViewItemTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemTemplateSettings;
         Retval.m_ITreeViewItemTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_HasUnrealizedChildren
   (
      this : in out TreeViewItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewItem.all);
      Hr := m_Interface.get_HasUnrealizedChildren (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HasUnrealizedChildren
   (
      this : in out TreeViewItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewItem.all);
      Hr := m_Interface.put_HasUnrealizedChildren (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsSource
   (
      this : in out TreeViewItem
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewItem.all);
      Hr := m_Interface.get_ItemsSource (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out TreeViewItem;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem_Interface, WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItem2, WinUI3.Microsoft.UI.Xaml.Controls.IID_ITreeViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewItem.all);
      Hr := m_Interface.put_ItemsSource (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewItemInvokedEventArgs

   procedure Initialize (this : in out TreeViewItemInvokedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewItemInvokedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewItemInvokedEventArgs, ITreeViewItemInvokedEventArgs_Ptr);
   begin
      if this.m_ITreeViewItemInvokedEventArgs /= null then
         if this.m_ITreeViewItemInvokedEventArgs.all /= null then
            temp := this.m_ITreeViewItemInvokedEventArgs.all.Release;
            Free (this.m_ITreeViewItemInvokedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewItemInvokedEventArgs

   function get_InvokedItem
   (
      this : in out TreeViewItemInvokedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITreeViewItemInvokedEventArgs.all.get_InvokedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out TreeViewItemInvokedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewItemInvokedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Handled
   (
      this : in out TreeViewItemInvokedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewItemInvokedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewItemTemplateSettings

   procedure Initialize (this : in out TreeViewItemTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewItemTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewItemTemplateSettings, ITreeViewItemTemplateSettings_Ptr);
   begin
      if this.m_ITreeViewItemTemplateSettings /= null then
         if this.m_ITreeViewItemTemplateSettings.all /= null then
            temp := this.m_ITreeViewItemTemplateSettings.all.Release;
            Free (this.m_ITreeViewItemTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TreeViewItemTemplateSettings

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TreeViewItemTemplateSettings is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITreeViewItemTemplateSettings");
      m_Factory    : access ITreeViewItemTemplateSettingsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemTemplateSettings;
   begin
      return RetVal : TreeViewItemTemplateSettings do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemTemplateSettingsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITreeViewItemTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemTemplateSettings;
            Retval.m_ITreeViewItemTemplateSettings.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TreeViewItemTemplateSettings

   function get_ExpandedGlyphVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExpandedGlyphVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CollapsedGlyphVisibilityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CollapsedGlyphVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IndentationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IndentationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DragItemsCountProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewItemTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DragItemsCountProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewItemTemplateSettings

   function get_ExpandedGlyphVisibility
   (
      this : in out TreeViewItemTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_ITreeViewItemTemplateSettings.all.get_ExpandedGlyphVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CollapsedGlyphVisibility
   (
      this : in out TreeViewItemTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_ITreeViewItemTemplateSettings.all.get_CollapsedGlyphVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Indentation
   (
      this : in out TreeViewItemTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_ITreeViewItemTemplateSettings.all.get_Indentation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DragItemsCount
   (
      this : in out TreeViewItemTemplateSettings
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITreeViewItemTemplateSettings.all.get_DragItemsCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewList

   procedure Initialize (this : in out TreeViewList) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewList) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewList, ITreeViewList_Ptr);
   begin
      if this.m_ITreeViewList /= null then
         if this.m_ITreeViewList.all /= null then
            temp := this.m_ITreeViewList.all.Release;
            Free (this.m_ITreeViewList);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TreeViewList

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TreeViewList is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITreeViewList");
      m_Factory    : access ITreeViewListFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewList;
   begin
      return RetVal : TreeViewList do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewListFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITreeViewList := new WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewList;
            Retval.m_ITreeViewList.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewList

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewNode

   procedure Initialize (this : in out TreeViewNode) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewNode) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewNode, ITreeViewNode_Ptr);
   begin
      if this.m_ITreeViewNode /= null then
         if this.m_ITreeViewNode.all /= null then
            temp := this.m_ITreeViewNode.all.Release;
            Free (this.m_ITreeViewNode);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TreeViewNode

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TreeViewNode is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITreeViewNode");
      m_Factory    : access ITreeViewNodeFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
   begin
      return RetVal : TreeViewNode do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewNodeFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITreeViewNode := new WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
            Retval.m_ITreeViewNode.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TreeViewNode

   function get_ContentProperty_TreeViewNode
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewNode");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNodeStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewNodeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DepthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewNode");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNodeStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewNodeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DepthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsExpandedProperty_TreeViewNode
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewNode");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNodeStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewNodeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsExpandedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HasChildrenProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TreeViewNode");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNodeStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewNodeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HasChildrenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewNode

   function get_Content
   (
      this : in out TreeViewNode
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITreeViewNode.all.get_Content (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Content
   (
      this : in out TreeViewNode;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewNode.all.put_Content (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Parent
   (
      this : in out TreeViewNode
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.TreeViewNode do
         Hr := this.m_ITreeViewNode.all.get_Parent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITreeViewNode := new WinUI3.Microsoft.UI.Xaml.Controls.ITreeViewNode;
         Retval.m_ITreeViewNode.all := m_ComRetVal;
      end return;
   end;

   function get_IsExpanded
   (
      this : in out TreeViewNode
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewNode.all.get_IsExpanded (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsExpanded
   (
      this : in out TreeViewNode;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewNode.all.put_IsExpanded (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HasChildren
   (
      this : in out TreeViewNode
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewNode.all.get_HasChildren (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Depth
   (
      this : in out TreeViewNode
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITreeViewNode.all.get_Depth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HasUnrealizedChildren
   (
      this : in out TreeViewNode
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewNode.all.get_HasUnrealizedChildren (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HasUnrealizedChildren
   (
      this : in out TreeViewNode;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewNode.all.put_HasUnrealizedChildren (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Children
   (
      this : in out TreeViewNode
   )
   return IVector_ITreeViewNode.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_ITreeViewNode.Kind;
   begin
      Hr := this.m_ITreeViewNode.all.get_Children (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_ITreeViewNode (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewSelectionChangedEventArgs

   procedure Initialize (this : in out TreeViewSelectionChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewSelectionChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewSelectionChangedEventArgs, ITreeViewSelectionChangedEventArgs_Ptr);
   begin
      if this.m_ITreeViewSelectionChangedEventArgs /= null then
         if this.m_ITreeViewSelectionChangedEventArgs.all /= null then
            temp := this.m_ITreeViewSelectionChangedEventArgs.all.Release;
            Free (this.m_ITreeViewSelectionChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewSelectionChangedEventArgs

   function get_AddedItems
   (
      this : in out TreeViewSelectionChangedEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_ITreeViewSelectionChangedEventArgs.all.get_AddedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_RemovedItems
   (
      this : in out TreeViewSelectionChangedEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_ITreeViewSelectionChangedEventArgs.all.get_RemovedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TwoPaneView

   procedure Initialize (this : in out TwoPaneView) is
   begin
      null;
   end;

   procedure Finalize (this : in out TwoPaneView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITwoPaneView, ITwoPaneView_Ptr);
   begin
      if this.m_ITwoPaneView /= null then
         if this.m_ITwoPaneView.all /= null then
            temp := this.m_ITwoPaneView.all.Release;
            Free (this.m_ITwoPaneView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TwoPaneView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TwoPaneView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.ITwoPaneView");
      m_Factory    : access ITwoPaneViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneView;
   begin
      return RetVal : TwoPaneView do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITwoPaneView := new WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneView;
            Retval.m_ITwoPaneView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TwoPaneView

   function get_Pane1Property
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pane1Property (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Pane2Property
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pane2Property (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Pane1LengthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pane1LengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Pane2LengthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pane2LengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PanePriorityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PanePriorityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ModeProperty_TwoPaneView
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_WideModeConfigurationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_WideModeConfigurationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TallModeConfigurationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TallModeConfigurationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinWideModeWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinWideModeWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinTallModeHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinTallModeHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TwoPaneView

   function get_Pane1
   (
      this : in out TwoPaneView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_ITwoPaneView.all.get_Pane1 (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Pane1
   (
      this : in out TwoPaneView;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_Pane1 (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pane2
   (
      this : in out TwoPaneView
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_ITwoPaneView.all.get_Pane2 (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Pane2
   (
      this : in out TwoPaneView;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_Pane2 (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pane1Length
   (
      this : in out TwoPaneView
   )
   return WinUI3.Microsoft.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.GridLength;
   begin
      Hr := this.m_ITwoPaneView.all.get_Pane1Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Pane1Length
   (
      this : in out TwoPaneView;
      value : WinUI3.Microsoft.UI.Xaml.GridLength
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_Pane1Length (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pane2Length
   (
      this : in out TwoPaneView
   )
   return WinUI3.Microsoft.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.GridLength;
   begin
      Hr := this.m_ITwoPaneView.all.get_Pane2Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Pane2Length
   (
      this : in out TwoPaneView;
      value : WinUI3.Microsoft.UI.Xaml.GridLength
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_Pane2Length (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PanePriority
   (
      this : in out TwoPaneView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TwoPaneViewPriority is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TwoPaneViewPriority;
   begin
      Hr := this.m_ITwoPaneView.all.get_PanePriority (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PanePriority
   (
      this : in out TwoPaneView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TwoPaneViewPriority
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_PanePriority (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Mode
   (
      this : in out TwoPaneView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TwoPaneViewMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TwoPaneViewMode;
   begin
      Hr := this.m_ITwoPaneView.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WideModeConfiguration
   (
      this : in out TwoPaneView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TwoPaneViewWideModeConfiguration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TwoPaneViewWideModeConfiguration;
   begin
      Hr := this.m_ITwoPaneView.all.get_WideModeConfiguration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_WideModeConfiguration
   (
      this : in out TwoPaneView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TwoPaneViewWideModeConfiguration
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_WideModeConfiguration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TallModeConfiguration
   (
      this : in out TwoPaneView
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.TwoPaneViewTallModeConfiguration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.TwoPaneViewTallModeConfiguration;
   begin
      Hr := this.m_ITwoPaneView.all.get_TallModeConfiguration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TallModeConfiguration
   (
      this : in out TwoPaneView;
      value : WinUI3.Microsoft.UI.Xaml.Controls.TwoPaneViewTallModeConfiguration
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_TallModeConfiguration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinWideModeWidth
   (
      this : in out TwoPaneView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITwoPaneView.all.get_MinWideModeWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinWideModeWidth
   (
      this : in out TwoPaneView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_MinWideModeWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinTallModeHeight
   (
      this : in out TwoPaneView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITwoPaneView.all.get_MinTallModeHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinTallModeHeight
   (
      this : in out TwoPaneView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_MinTallModeHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ModeChanged
   (
      this : in out TwoPaneView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITwoPaneView.all.add_ModeChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ModeChanged
   (
      this : in out TwoPaneView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.remove_ModeChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UIElementCollection

   procedure Initialize (this : in out UIElementCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out UIElementCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UIElementCollection

   procedure Move
   (
      this : in out UIElementCollection;
      oldIndex : WinUI3.UInt32;
      newIndex : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IUIElementCollection := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IUIElementCollection, WinUI3.Microsoft.UI.Xaml.Controls.IID_IUIElementCollection'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Move (oldIndex, newIndex);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.UIElement>
   function GetAt
   (
      this : in out UIElementCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out UIElementCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out UIElementCollection
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out UIElementCollection;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IUIElement.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out UIElementCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out UIElementCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out UIElementCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out UIElementCollection;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out UIElementCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out UIElementCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out UIElementCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Microsoft.UI.Xaml.IUIElement_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out UIElementCollection;
      items : WinUI3.Microsoft.UI.Xaml.IUIElement_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3930725104, 17030, 24337, (129, 66, 107, 1, 105, 244, 233, 222 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.UIElement>
   function First
   (
      this : in out UIElementCollection
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
      m_GenericIID     : aliased WinUI3.IID := (1167833428, 17059, 23668, (143, 135, 66, 69, 143, 25, 174, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UniformGridLayout

   procedure Initialize (this : in out UniformGridLayout) is
   begin
      null;
   end;

   procedure Finalize (this : in out UniformGridLayout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUniformGridLayout, IUniformGridLayout_Ptr);
   begin
      if this.m_IUniformGridLayout /= null then
         if this.m_IUniformGridLayout.all /= null then
            temp := this.m_IUniformGridLayout.all.Release;
            Free (this.m_IUniformGridLayout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for UniformGridLayout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return UniformGridLayout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IUniformGridLayout");
      m_Factory    : access IUniformGridLayoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IUniformGridLayout;
   begin
      return RetVal : UniformGridLayout do
         Hr := RoGetActivationFactory (m_hString, IID_IUniformGridLayoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IUniformGridLayout := new WinUI3.Microsoft.UI.Xaml.Controls.IUniformGridLayout;
            Retval.m_IUniformGridLayout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for UniformGridLayout

   function get_OrientationProperty_UniformGridLayout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.UniformGridLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IUniformGridLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUniformGridLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinItemWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.UniformGridLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IUniformGridLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUniformGridLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinItemWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinItemHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.UniformGridLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IUniformGridLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUniformGridLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinItemHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinRowSpacingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.UniformGridLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IUniformGridLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUniformGridLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinRowSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinColumnSpacingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.UniformGridLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IUniformGridLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUniformGridLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinColumnSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsJustificationProperty_UniformGridLayout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.UniformGridLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IUniformGridLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUniformGridLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsJustificationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsStretchProperty_UniformGridLayout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.UniformGridLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IUniformGridLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUniformGridLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsStretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaximumRowsOrColumnsProperty_UniformGridLayout
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.UniformGridLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IUniformGridLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUniformGridLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaximumRowsOrColumnsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UniformGridLayout

   function get_Orientation
   (
      this : in out UniformGridLayout
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IUniformGridLayout.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out UniformGridLayout;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUniformGridLayout.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinItemWidth
   (
      this : in out UniformGridLayout
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IUniformGridLayout.all.get_MinItemWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinItemWidth
   (
      this : in out UniformGridLayout;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUniformGridLayout.all.put_MinItemWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinItemHeight
   (
      this : in out UniformGridLayout
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IUniformGridLayout.all.get_MinItemHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinItemHeight
   (
      this : in out UniformGridLayout;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUniformGridLayout.all.put_MinItemHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinRowSpacing
   (
      this : in out UniformGridLayout
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IUniformGridLayout.all.get_MinRowSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinRowSpacing
   (
      this : in out UniformGridLayout;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUniformGridLayout.all.put_MinRowSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinColumnSpacing
   (
      this : in out UniformGridLayout
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IUniformGridLayout.all.get_MinColumnSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinColumnSpacing
   (
      this : in out UniformGridLayout;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUniformGridLayout.all.put_MinColumnSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsJustification
   (
      this : in out UniformGridLayout
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.UniformGridLayoutItemsJustification is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.UniformGridLayoutItemsJustification;
   begin
      Hr := this.m_IUniformGridLayout.all.get_ItemsJustification (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsJustification
   (
      this : in out UniformGridLayout;
      value : WinUI3.Microsoft.UI.Xaml.Controls.UniformGridLayoutItemsJustification
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUniformGridLayout.all.put_ItemsJustification (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsStretch
   (
      this : in out UniformGridLayout
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.UniformGridLayoutItemsStretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.UniformGridLayoutItemsStretch;
   begin
      Hr := this.m_IUniformGridLayout.all.get_ItemsStretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsStretch
   (
      this : in out UniformGridLayout;
      value : WinUI3.Microsoft.UI.Xaml.Controls.UniformGridLayoutItemsStretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUniformGridLayout.all.put_ItemsStretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaximumRowsOrColumns
   (
      this : in out UniformGridLayout
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IUniformGridLayout.all.get_MaximumRowsOrColumns (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaximumRowsOrColumns
   (
      this : in out UniformGridLayout;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUniformGridLayout.all.put_MaximumRowsOrColumns (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VariableSizedWrapGrid

   procedure Initialize (this : in out VariableSizedWrapGrid) is
   begin
      null;
   end;

   procedure Finalize (this : in out VariableSizedWrapGrid) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVariableSizedWrapGrid, IVariableSizedWrapGrid_Ptr);
   begin
      if this.m_IVariableSizedWrapGrid /= null then
         if this.m_IVariableSizedWrapGrid.all /= null then
            temp := this.m_IVariableSizedWrapGrid.all.Release;
            Free (this.m_IVariableSizedWrapGrid);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VariableSizedWrapGrid

   function Constructor return VariableSizedWrapGrid is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IVariableSizedWrapGrid");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGrid;
   begin
      return RetVal : VariableSizedWrapGrid do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IVariableSizedWrapGrid := new WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGrid;
            Retval.m_IVariableSizedWrapGrid.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for VariableSizedWrapGrid

   function get_ItemHeightProperty_VariableSizedWrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemWidthProperty_VariableSizedWrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_VariableSizedWrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalChildrenAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalChildrenAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalChildrenAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalChildrenAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaximumRowsOrColumnsProperty_VariableSizedWrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaximumRowsOrColumnsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RowSpanProperty_VariableSizedWrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RowSpanProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetRowSpan
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetRowSpan (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetRowSpan
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetRowSpan (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ColumnSpanProperty_VariableSizedWrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColumnSpanProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetColumnSpan
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetColumnSpan (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetColumnSpan
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetColumnSpan (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VariableSizedWrapGrid

   function get_ItemHeight
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_ItemHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemHeight
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_ItemHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemWidth
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_ItemWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemWidth
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_ItemWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalChildrenAlignment
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Microsoft.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_HorizontalChildrenAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalChildrenAlignment
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Microsoft.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_HorizontalChildrenAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalChildrenAlignment
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Microsoft.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_VerticalChildrenAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalChildrenAlignment
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Microsoft.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_VerticalChildrenAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaximumRowsOrColumns
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_MaximumRowsOrColumns (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaximumRowsOrColumns
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_MaximumRowsOrColumns (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Viewbox

   procedure Initialize (this : in out Viewbox) is
   begin
      null;
   end;

   procedure Finalize (this : in out Viewbox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IViewbox, IViewbox_Ptr);
   begin
      if this.m_IViewbox /= null then
         if this.m_IViewbox.all /= null then
            temp := this.m_IViewbox.all.Release;
            Free (this.m_IViewbox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Viewbox

   function Constructor return Viewbox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IViewbox");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IViewbox;
   begin
      return RetVal : Viewbox do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IViewbox := new WinUI3.Microsoft.UI.Xaml.Controls.IViewbox;
            Retval.m_IViewbox.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Viewbox

   function get_StretchProperty_Viewbox
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Viewbox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IViewboxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IViewboxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchDirectionProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Viewbox");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IViewboxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IViewboxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchDirectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Viewbox

   function get_Child
   (
      this : in out Viewbox
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IViewbox.all.get_Child (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Child
   (
      this : in out Viewbox;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IViewbox.all.put_Child (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out Viewbox
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.Stretch;
   begin
      Hr := this.m_IViewbox.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out Viewbox;
      value : WinUI3.Microsoft.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IViewbox.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StretchDirection
   (
      this : in out Viewbox
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.StretchDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.StretchDirection;
   begin
      Hr := this.m_IViewbox.all.get_StretchDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StretchDirection
   (
      this : in out Viewbox;
      value : WinUI3.Microsoft.UI.Xaml.Controls.StretchDirection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IViewbox.all.put_StretchDirection (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VirtualizingLayoutContext

   procedure Initialize (this : in out VirtualizingLayoutContext) is
   begin
      null;
   end;

   procedure Finalize (this : in out VirtualizingLayoutContext) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVirtualizingLayoutContext, IVirtualizingLayoutContext_Ptr);
   begin
      if this.m_IVirtualizingLayoutContext /= null then
         if this.m_IVirtualizingLayoutContext.all /= null then
            temp := this.m_IVirtualizingLayoutContext.all.Release;
            Free (this.m_IVirtualizingLayoutContext);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VirtualizingLayoutContext

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return VirtualizingLayoutContext is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext");
      m_Factory    : access IVirtualizingLayoutContextFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext;
   begin
      return RetVal : VirtualizingLayoutContext do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingLayoutContextFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IVirtualizingLayoutContext := new WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext;
            Retval.m_IVirtualizingLayoutContext.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VirtualizingLayoutContext

   function get_ItemCount
   (
      this : in out VirtualizingLayoutContext
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IVirtualizingLayoutContext.all.get_ItemCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetItemAt
   (
      this : in out VirtualizingLayoutContext;
      index : WinUI3.Int32
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IVirtualizingLayoutContext.all.GetItemAt (index, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_RealizationRect
   (
      this : in out VirtualizingLayoutContext
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IVirtualizingLayoutContext.all.get_RealizationRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetOrCreateElementAt
   (
      this : in out VirtualizingLayoutContext;
      index : WinUI3.Int32
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IVirtualizingLayoutContext.all.GetOrCreateElementAt (index, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function GetOrCreateElementAt
   (
      this : in out VirtualizingLayoutContext;
      index : WinUI3.Int32;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ElementRealizationOptions
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IVirtualizingLayoutContext.all.GetOrCreateElementAt (index, options, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure RecycleElement
   (
      this : in out VirtualizingLayoutContext;
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVirtualizingLayoutContext.all.RecycleElement (element.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RecommendedAnchorIndex
   (
      this : in out VirtualizingLayoutContext
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IVirtualizingLayoutContext.all.get_RecommendedAnchorIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LayoutOrigin
   (
      this : in out VirtualizingLayoutContext
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IVirtualizingLayoutContext.all.get_LayoutOrigin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LayoutOrigin
   (
      this : in out VirtualizingLayoutContext;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVirtualizingLayoutContext.all.put_LayoutOrigin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VisibleRect
   (
      this : in out VirtualizingLayoutContext
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutContext2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayoutContext.all);
      Hr := m_Interface.get_VisibleRect (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ItemCountCore
   (
      this : in out VirtualizingLayoutContext
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutContextOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayoutContext.all);
      Hr := m_Interface.ItemCountCore (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetItemAtCore
   (
      this : in out VirtualizingLayoutContext;
      index : WinUI3.Int32
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutContextOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayoutContext.all);
      Hr := m_Interface.GetItemAtCore (index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function RealizationRectCore
   (
      this : in out VirtualizingLayoutContext
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutContextOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayoutContext.all);
      Hr := m_Interface.RealizationRectCore (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetOrCreateElementAtCore
   (
      this : in out VirtualizingLayoutContext;
      index : WinUI3.Int32;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ElementRealizationOptions
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutContextOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IVirtualizingLayoutContext.all);
         Hr := m_Interface.GetOrCreateElementAtCore (index, options, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure RecycleElementCore
   (
      this : in out VirtualizingLayoutContext;
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutContextOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayoutContext.all);
      Hr := m_Interface.RecycleElementCore (element.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RecommendedAnchorIndexCore
   (
      this : in out VirtualizingLayoutContext
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutContextOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayoutContext.all);
      Hr := m_Interface.get_RecommendedAnchorIndexCore (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LayoutOriginCore
   (
      this : in out VirtualizingLayoutContext
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutContextOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayoutContext.all);
      Hr := m_Interface.get_LayoutOriginCore (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LayoutOriginCore
   (
      this : in out VirtualizingLayoutContext;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutContextOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayoutContext.all);
      Hr := m_Interface.put_LayoutOriginCore (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function VisibleRectCore
   (
      this : in out VirtualizingLayoutContext
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContext_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingLayoutContextOverrides2, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingLayoutContextOverrides2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingLayoutContext.all);
      Hr := m_Interface.VisibleRectCore (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VirtualizingStackPanel

   procedure Initialize (this : in out VirtualizingStackPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out VirtualizingStackPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVirtualizingStackPanel, IVirtualizingStackPanel_Ptr);
   begin
      if this.m_IVirtualizingStackPanel /= null then
         if this.m_IVirtualizingStackPanel.all /= null then
            temp := this.m_IVirtualizingStackPanel.all.Release;
            Free (this.m_IVirtualizingStackPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VirtualizingStackPanel

   function Constructor return VirtualizingStackPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IVirtualizingStackPanel");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanel;
   begin
      return RetVal : VirtualizingStackPanel do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IVirtualizingStackPanel := new WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanel;
            Retval.m_IVirtualizingStackPanel.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for VirtualizingStackPanel

   function get_AreScrollSnapPointsRegularProperty_VirtualizingStackPanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreScrollSnapPointsRegularProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_VirtualizingStackPanel
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VirtualizationModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VirtualizationModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetVirtualizationMode
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.VirtualizationMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.VirtualizationMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetVirtualizationMode (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetVirtualizationMode
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      value : WinUI3.Microsoft.UI.Xaml.Controls.VirtualizationMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetVirtualizationMode (element.m_IDependencyObject.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsVirtualizingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVirtualizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsVirtualizing
   (
      o : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsVirtualizing (o.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VirtualizingStackPanel

   function get_AreScrollSnapPointsRegular
   (
      this : in out VirtualizingStackPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.get_AreScrollSnapPointsRegular (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreScrollSnapPointsRegular
   (
      this : in out VirtualizingStackPanel;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.put_AreScrollSnapPointsRegular (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out VirtualizingStackPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out VirtualizingStackPanel;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CleanUpVirtualizedItemEvent
   (
      this : in out VirtualizingStackPanel;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.CleanUpVirtualizedItemEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.add_CleanUpVirtualizedItemEvent (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CleanUpVirtualizedItemEvent
   (
      this : in out VirtualizingStackPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.remove_CleanUpVirtualizedItemEvent (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnCleanUpVirtualizedItem
   (
      this : in out VirtualizingStackPanel;
      e : WinUI3.Microsoft.UI.Xaml.Controls.CleanUpVirtualizedItemEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanelOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IVirtualizingStackPanelOverrides, WinUI3.Microsoft.UI.Xaml.Controls.IID_IVirtualizingStackPanelOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingStackPanel.all);
      Hr := m_Interface.OnCleanUpVirtualizedItem (e.m_ICleanUpVirtualizedItemEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebView2

   procedure Initialize (this : in out WebView2) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebView2) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebView2, IWebView2_Ptr);
   begin
      if this.m_IWebView2 /= null then
         if this.m_IWebView2.all /= null then
            temp := this.m_IWebView2.all.Release;
            Free (this.m_IWebView2);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for WebView2

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return WebView2 is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IWebView2");
      m_Factory    : access IWebView2Factory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IWebView2;
   begin
      return RetVal : WebView2 do
         Hr := RoGetActivationFactory (m_hString, IID_IWebView2Factory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IWebView2 := new WinUI3.Microsoft.UI.Xaml.Controls.IWebView2;
            Retval.m_IWebView2.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for WebView2

   function get_SourceProperty_WebView2
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.WebView2");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IWebView2Statics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebView2Statics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanGoForwardProperty_WebView2
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.WebView2");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IWebView2Statics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebView2Statics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanGoForwardProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanGoBackProperty_WebView2
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.WebView2");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IWebView2Statics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebView2Statics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanGoBackProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultBackgroundColorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.WebView2");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IWebView2Statics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebView2Statics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultBackgroundColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebView2

   function get_CoreWebView2
   (
      this : in out WebView2
   )
   return WinUI3.Microsoft.Web.WebView2.Core.CoreWebView2'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.Web.WebView2.Core.ICoreWebView2;
   begin
      return RetVal : WinUI3.Microsoft.Web.WebView2.Core.CoreWebView2 do
         Hr := this.m_IWebView2.all.get_CoreWebView2 (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreWebView2 := new WinUI3.Microsoft.Web.WebView2.Core.ICoreWebView2;
         Retval.m_ICoreWebView2.all := m_ComRetVal;
      end return;
   end;

   procedure EnsureCoreWebView2Async
   (
      this : in out WebView2
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IWebView2.all.EnsureCoreWebView2Async (m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   function ExecuteScriptAsync
   (
      this : in out WebView2;
      javascriptCode : WinUI3.WString
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_javascriptCode : constant WinUI3.HString := To_HString (javascriptCode);
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_HString.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_HString.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.HString;
      AdaRetval        : WString;
      m_IID            : aliased WinUI3.IID := (1042277891, 63639, 21091, (179, 40, 8, 6, 66, 107, 138, 121 )); -- HString;
      m_HandlerIID     : aliased WinUI3.IID := (3080352799, 32693, 20654, (158, 153, 145, 18, 1, 236, 61, 65 ));
      m_Handler        : AsyncOperationCompletedHandler_HString.Kind := new AsyncOperationCompletedHandler_HString.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_HString.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_HString.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_HString.Kind_Delegate, AsyncOperationCompletedHandler_HString.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IWebView2.all.ExecuteScriptAsync (HStr_javascriptCode, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      tmp := WindowsDeleteString (HStr_javascriptCode);
      AdaRetval := To_Ada (m_RetVal);
      tmp := WindowsDeleteString (m_RetVal);
      return AdaRetVal;
   end;

   function get_Source
   (
      this : in out WebView2
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebView2.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out WebView2;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.put_Source (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanGoForward
   (
      this : in out WebView2
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWebView2.all.get_CanGoForward (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanGoForward
   (
      this : in out WebView2;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.put_CanGoForward (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanGoBack
   (
      this : in out WebView2
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWebView2.all.get_CanGoBack (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanGoBack
   (
      this : in out WebView2;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.put_CanGoBack (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DefaultBackgroundColor
   (
      this : in out WebView2
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IWebView2.all.get_DefaultBackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultBackgroundColor
   (
      this : in out WebView2;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.put_DefaultBackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Reload
   (
      this : in out WebView2
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.Reload;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GoForward
   (
      this : in out WebView2
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.GoForward;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GoBack
   (
      this : in out WebView2
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.GoBack;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure NavigateToString
   (
      this : in out WebView2;
      htmlContent : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_htmlContent : constant WinUI3.HString := To_HString (htmlContent);
   begin
      Hr := this.m_IWebView2.all.NavigateToString (HStr_htmlContent);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_htmlContent);
   end;

   procedure Close
   (
      this : in out WebView2
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.Close;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_NavigationCompleted
   (
      this : in out WebView2;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWebView2.all.add_NavigationCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NavigationCompleted
   (
      this : in out WebView2;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.remove_NavigationCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_WebMessageReceived
   (
      this : in out WebView2;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWebView2.all.add_WebMessageReceived (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_WebMessageReceived
   (
      this : in out WebView2;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.remove_WebMessageReceived (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_NavigationStarting
   (
      this : in out WebView2;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWebView2.all.add_NavigationStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NavigationStarting
   (
      this : in out WebView2;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.remove_NavigationStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CoreProcessFailed
   (
      this : in out WebView2;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWebView2.all.add_CoreProcessFailed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CoreProcessFailed
   (
      this : in out WebView2;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.remove_CoreProcessFailed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CoreWebView2Initialized
   (
      this : in out WebView2;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWebView2.all.add_CoreWebView2Initialized (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CoreWebView2Initialized
   (
      this : in out WebView2;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView2.all.remove_CoreWebView2Initialized (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure EnsureCoreWebView2Async
   (
      this : in out WebView2;
      environment : WinUI3.Microsoft.Web.WebView2.Core.CoreWebView2Environment'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IWebView22 := null;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IWebView2_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IWebView22, WinUI3.Microsoft.UI.Xaml.Controls.IID_IWebView22'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView2.all);
      Hr := m_Interface.EnsureCoreWebView2Async (environment.m_ICoreWebView2Environment.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   procedure EnsureCoreWebView2Async
   (
      this : in out WebView2;
      environment : WinUI3.Microsoft.Web.WebView2.Core.CoreWebView2Environment'Class;
      controllerOptions : WinUI3.Microsoft.Web.WebView2.Core.CoreWebView2ControllerOptions'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IWebView22 := null;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.IWebView2_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IWebView22, WinUI3.Microsoft.UI.Xaml.Controls.IID_IWebView22'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView2.all);
      Hr := m_Interface.EnsureCoreWebView2Async (environment.m_ICoreWebView2Environment.all, controllerOptions.m_ICoreWebView2ControllerOptions.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WrapGrid

   procedure Initialize (this : in out WrapGrid) is
   begin
      null;
   end;

   procedure Finalize (this : in out WrapGrid) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWrapGrid, IWrapGrid_Ptr);
   begin
      if this.m_IWrapGrid /= null then
         if this.m_IWrapGrid.all /= null then
            temp := this.m_IWrapGrid.all.Release;
            Free (this.m_IWrapGrid);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for WrapGrid

   function Constructor return WrapGrid is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IWrapGrid");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IWrapGrid;
   begin
      return RetVal : WrapGrid do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IWrapGrid := new WinUI3.Microsoft.UI.Xaml.Controls.IWrapGrid;
            Retval.m_IWrapGrid.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for WrapGrid

   function get_ItemWidthProperty_WrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemHeightProperty_WrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_WrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalChildrenAlignmentProperty_WrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalChildrenAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalChildrenAlignmentProperty_WrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalChildrenAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaximumRowsOrColumnsProperty_WrapGrid
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaximumRowsOrColumnsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WrapGrid

   function get_ItemWidth
   (
      this : in out WrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IWrapGrid.all.get_ItemWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemWidth
   (
      this : in out WrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_ItemWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemHeight
   (
      this : in out WrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IWrapGrid.all.get_ItemHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemHeight
   (
      this : in out WrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_ItemHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out WrapGrid
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IWrapGrid.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out WrapGrid;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalChildrenAlignment
   (
      this : in out WrapGrid
   )
   return WinUI3.Microsoft.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_IWrapGrid.all.get_HorizontalChildrenAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalChildrenAlignment
   (
      this : in out WrapGrid;
      value : WinUI3.Microsoft.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_HorizontalChildrenAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalChildrenAlignment
   (
      this : in out WrapGrid
   )
   return WinUI3.Microsoft.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_IWrapGrid.all.get_VerticalChildrenAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalChildrenAlignment
   (
      this : in out WrapGrid;
      value : WinUI3.Microsoft.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_VerticalChildrenAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaximumRowsOrColumns
   (
      this : in out WrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IWrapGrid.all.get_MaximumRowsOrColumns (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaximumRowsOrColumns
   (
      this : in out WrapGrid;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_MaximumRowsOrColumns (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for XamlControlsResources

   procedure Initialize (this : in out XamlControlsResources) is
   begin
      null;
   end;

   procedure Finalize (this : in out XamlControlsResources) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IXamlControlsResources, IXamlControlsResources_Ptr);
   begin
      if this.m_IXamlControlsResources /= null then
         if this.m_IXamlControlsResources.all /= null then
            temp := this.m_IXamlControlsResources.all.Release;
            Free (this.m_IXamlControlsResources);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for XamlControlsResources

   function Constructor return XamlControlsResources is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.IXamlControlsResources");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.IXamlControlsResources;
   begin
      return RetVal : XamlControlsResources do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IXamlControlsResources := new WinUI3.Microsoft.UI.Xaml.Controls.IXamlControlsResources;
            Retval.m_IXamlControlsResources.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for XamlControlsResources

   procedure EnsureRevealLights
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.XamlControlsResources");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IXamlControlsResourcesStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IXamlControlsResourcesStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.EnsureRevealLights (element.m_IUIElement.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_UseCompactResourcesProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.XamlControlsResources");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.IXamlControlsResourcesStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlControlsResourcesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UseCompactResourcesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for XamlControlsResources

   function get_UseCompactResources
   (
      this : in out XamlControlsResources
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IXamlControlsResources.all.get_UseCompactResources (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_UseCompactResources
   (
      this : in out XamlControlsResources;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IXamlControlsResources.all.put_UseCompactResources (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

end WinUI3.Microsoft.UI.Xaml.Controls;
