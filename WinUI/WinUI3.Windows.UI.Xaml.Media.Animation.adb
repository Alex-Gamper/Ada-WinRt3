--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with WinUI3.Windows.UI.Composition;
with WinUI3.Windows.UI.Xaml.Controls;
with WinUI3.Windows.UI.Xaml.Controls.Primitives;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Windows.UI.Xaml.Media.Animation is

   package IVector_IColorKeyFrame is new WinUI3.Windows.Foundation.Collections.IVector (IColorKeyFrame);
   package IIterable_IColorKeyFrame is new WinUI3.Windows.Foundation.Collections.IIterable (IColorKeyFrame);
   package IVector_IDoubleKeyFrame is new WinUI3.Windows.Foundation.Collections.IVector (IDoubleKeyFrame);
   package IIterable_IDoubleKeyFrame is new WinUI3.Windows.Foundation.Collections.IIterable (IDoubleKeyFrame);
   package IVector_IObjectKeyFrame is new WinUI3.Windows.Foundation.Collections.IVector (IObjectKeyFrame);
   package IIterable_IObjectKeyFrame is new WinUI3.Windows.Foundation.Collections.IIterable (IObjectKeyFrame);
   package IVector_IPointKeyFrame is new WinUI3.Windows.Foundation.Collections.IVector (IPointKeyFrame);
   package IIterable_IPointKeyFrame is new WinUI3.Windows.Foundation.Collections.IIterable (IPointKeyFrame);
   package IVector_ITimeline is new WinUI3.Windows.Foundation.Collections.IVector (ITimeline);
   package IIterable_ITimeline is new WinUI3.Windows.Foundation.Collections.IIterable (ITimeline);
   package IVector_ITransition is new WinUI3.Windows.Foundation.Collections.IVector (ITransition);
   package IIterable_ITransition is new WinUI3.Windows.Foundation.Collections.IIterable (ITransition);
   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Transition

   procedure Initialize (this : in out Transition) is
   begin
      null;
   end;

   procedure Finalize (this : in out Transition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITransition, ITransition_Ptr);
   begin
      if this.m_ITransition /= null then
         if this.m_ITransition.all /= null then
            temp := this.m_ITransition.all.Release;
            Free (this.m_ITransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Transition

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Transition

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AddDeleteThemeTransition

   procedure Initialize (this : in out AddDeleteThemeTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out AddDeleteThemeTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAddDeleteThemeTransition, IAddDeleteThemeTransition_Ptr);
   begin
      if this.m_IAddDeleteThemeTransition /= null then
         if this.m_IAddDeleteThemeTransition.all /= null then
            temp := this.m_IAddDeleteThemeTransition.all.Release;
            Free (this.m_IAddDeleteThemeTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AddDeleteThemeTransition

   function Constructor return AddDeleteThemeTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IAddDeleteThemeTransition");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IAddDeleteThemeTransition;
   begin
      return RetVal : AddDeleteThemeTransition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAddDeleteThemeTransition := new WinUI3.Windows.UI.Xaml.Media.Animation.IAddDeleteThemeTransition;
            Retval.m_IAddDeleteThemeTransition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AddDeleteThemeTransition

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EasingFunctionBase

   procedure Initialize (this : in out EasingFunctionBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out EasingFunctionBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEasingFunctionBase, IEasingFunctionBase_Ptr);
   begin
      if this.m_IEasingFunctionBase /= null then
         if this.m_IEasingFunctionBase.all /= null then
            temp := this.m_IEasingFunctionBase.all.Release;
            Free (this.m_IEasingFunctionBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for EasingFunctionBase

   -----------------------------------------------------------------------------
   -- Static Interfaces for EasingFunctionBase

   function get_EasingModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.EasingFunctionBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEasingFunctionBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EasingModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EasingFunctionBase

   function get_EasingMode
   (
      this : in out EasingFunctionBase
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.EasingMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.EasingMode;
   begin
      Hr := this.m_IEasingFunctionBase.all.get_EasingMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EasingMode
   (
      this : in out EasingFunctionBase;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.EasingMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEasingFunctionBase.all.put_EasingMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function Ease
   (
      this : in out EasingFunctionBase;
      normalizedTime : WinUI3.Double
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IEasingFunctionBase.all.Ease (normalizedTime, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BackEase

   procedure Initialize (this : in out BackEase) is
   begin
      null;
   end;

   procedure Finalize (this : in out BackEase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBackEase, IBackEase_Ptr);
   begin
      if this.m_IBackEase /= null then
         if this.m_IBackEase.all /= null then
            temp := this.m_IBackEase.all.Release;
            Free (this.m_IBackEase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BackEase

   function Constructor return BackEase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IBackEase");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IBackEase;
   begin
      return RetVal : BackEase do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IBackEase := new WinUI3.Windows.UI.Xaml.Media.Animation.IBackEase;
            Retval.m_IBackEase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BackEase

   function get_AmplitudeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.BackEase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IBackEaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBackEaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AmplitudeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BackEase

   function get_Amplitude
   (
      this : in out BackEase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IBackEase.all.get_Amplitude (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Amplitude
   (
      this : in out BackEase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBackEase.all.put_Amplitude (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ConnectedAnimationConfiguration

   procedure Initialize (this : in out ConnectedAnimationConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out ConnectedAnimationConfiguration) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IConnectedAnimationConfiguration, IConnectedAnimationConfiguration_Ptr);
   begin
      if this.m_IConnectedAnimationConfiguration /= null then
         if this.m_IConnectedAnimationConfiguration.all /= null then
            temp := this.m_IConnectedAnimationConfiguration.all.Release;
            Free (this.m_IConnectedAnimationConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ConnectedAnimationConfiguration

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ConnectedAnimationConfiguration

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BasicConnectedAnimationConfiguration

   procedure Initialize (this : in out BasicConnectedAnimationConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out BasicConnectedAnimationConfiguration) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBasicConnectedAnimationConfiguration, IBasicConnectedAnimationConfiguration_Ptr);
   begin
      if this.m_IBasicConnectedAnimationConfiguration /= null then
         if this.m_IBasicConnectedAnimationConfiguration.all /= null then
            temp := this.m_IBasicConnectedAnimationConfiguration.all.Release;
            Free (this.m_IBasicConnectedAnimationConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BasicConnectedAnimationConfiguration

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return BasicConnectedAnimationConfiguration is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IBasicConnectedAnimationConfiguration");
      m_Factory    : access IBasicConnectedAnimationConfigurationFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IBasicConnectedAnimationConfiguration;
   begin
      return RetVal : BasicConnectedAnimationConfiguration do
         Hr := RoGetActivationFactory (m_hString, IID_IBasicConnectedAnimationConfigurationFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBasicConnectedAnimationConfiguration := new WinUI3.Windows.UI.Xaml.Media.Animation.IBasicConnectedAnimationConfiguration;
            Retval.m_IBasicConnectedAnimationConfiguration.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BasicConnectedAnimationConfiguration

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BeginStoryboard

   procedure Initialize (this : in out BeginStoryboard) is
   begin
      null;
   end;

   procedure Finalize (this : in out BeginStoryboard) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBeginStoryboard, IBeginStoryboard_Ptr);
   begin
      if this.m_IBeginStoryboard /= null then
         if this.m_IBeginStoryboard.all /= null then
            temp := this.m_IBeginStoryboard.all.Release;
            Free (this.m_IBeginStoryboard);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BeginStoryboard

   function Constructor return BeginStoryboard is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IBeginStoryboard");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IBeginStoryboard;
   begin
      return RetVal : BeginStoryboard do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IBeginStoryboard := new WinUI3.Windows.UI.Xaml.Media.Animation.IBeginStoryboard;
            Retval.m_IBeginStoryboard.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BeginStoryboard

   function get_StoryboardProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.BeginStoryboard");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IBeginStoryboardStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBeginStoryboardStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StoryboardProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BeginStoryboard

   function get_Storyboard
   (
      this : in out BeginStoryboard
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.Storyboard'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboard;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.Storyboard do
         Hr := this.m_IBeginStoryboard.all.get_Storyboard (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStoryboard := new WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboard;
         Retval.m_IStoryboard.all := m_ComRetVal;
      end return;
   end;

   procedure put_Storyboard
   (
      this : in out BeginStoryboard;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.Storyboard'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBeginStoryboard.all.put_Storyboard (value.m_IStoryboard.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BounceEase

   procedure Initialize (this : in out BounceEase) is
   begin
      null;
   end;

   procedure Finalize (this : in out BounceEase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBounceEase, IBounceEase_Ptr);
   begin
      if this.m_IBounceEase /= null then
         if this.m_IBounceEase.all /= null then
            temp := this.m_IBounceEase.all.Release;
            Free (this.m_IBounceEase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BounceEase

   function Constructor return BounceEase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IBounceEase");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IBounceEase;
   begin
      return RetVal : BounceEase do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IBounceEase := new WinUI3.Windows.UI.Xaml.Media.Animation.IBounceEase;
            Retval.m_IBounceEase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BounceEase

   function get_BouncesProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.BounceEase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IBounceEaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBounceEaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BouncesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BouncinessProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.BounceEase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IBounceEaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBounceEaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BouncinessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BounceEase

   function get_Bounces
   (
      this : in out BounceEase
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IBounceEase.all.get_Bounces (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Bounces
   (
      this : in out BounceEase;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBounceEase.all.put_Bounces (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Bounciness
   (
      this : in out BounceEase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IBounceEase.all.get_Bounciness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Bounciness
   (
      this : in out BounceEase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBounceEase.all.put_Bounciness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CircleEase

   procedure Initialize (this : in out CircleEase) is
   begin
      null;
   end;

   procedure Finalize (this : in out CircleEase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICircleEase, ICircleEase_Ptr);
   begin
      if this.m_ICircleEase /= null then
         if this.m_ICircleEase.all /= null then
            temp := this.m_ICircleEase.all.Release;
            Free (this.m_ICircleEase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CircleEase

   function Constructor return CircleEase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ICircleEase");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ICircleEase;
   begin
      return RetVal : CircleEase do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICircleEase := new WinUI3.Windows.UI.Xaml.Media.Animation.ICircleEase;
            Retval.m_ICircleEase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CircleEase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Timeline

   procedure Initialize (this : in out Timeline) is
   begin
      null;
   end;

   procedure Finalize (this : in out Timeline) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimeline, ITimeline_Ptr);
   begin
      if this.m_ITimeline /= null then
         if this.m_ITimeline.all /= null then
            temp := this.m_ITimeline.all.Release;
            Free (this.m_ITimeline);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Timeline

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Timeline is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ITimeline");
      m_Factory    : access ITimelineFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ITimeline;
   begin
      return RetVal : Timeline do
         Hr := RoGetActivationFactory (m_hString, IID_ITimelineFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITimeline := new WinUI3.Windows.UI.Xaml.Media.Animation.ITimeline;
            Retval.m_ITimeline.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Timeline

   function get_AllowDependentAnimations
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Timeline");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ITimelineStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ITimelineStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_AllowDependentAnimations (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure put_AllowDependentAnimations
   (
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Timeline");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ITimelineStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ITimelineStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.put_AllowDependentAnimations (value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AutoReverseProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Timeline");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ITimelineStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimelineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoReverseProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BeginTimeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Timeline");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ITimelineStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimelineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BeginTimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DurationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Timeline");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ITimelineStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimelineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DurationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SpeedRatioProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Timeline");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ITimelineStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimelineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SpeedRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FillBehaviorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Timeline");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ITimelineStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimelineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FillBehaviorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RepeatBehaviorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Timeline");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ITimelineStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimelineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RepeatBehaviorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Timeline

   function get_AutoReverse
   (
      this : in out Timeline
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITimeline.all.get_AutoReverse (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutoReverse
   (
      this : in out Timeline;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimeline.all.put_AutoReverse (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BeginTime
   (
      this : in out Timeline
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
   begin
      Hr := this.m_ITimeline.all.get_BeginTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_BeginTime
   (
      this : in out Timeline;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimeline.all.put_BeginTime (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Duration
   (
      this : in out Timeline
   )
   return WinUI3.Windows.UI.Xaml.Duration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Duration;
   begin
      Hr := this.m_ITimeline.all.get_Duration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Duration
   (
      this : in out Timeline;
      value : WinUI3.Windows.UI.Xaml.Duration
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimeline.all.put_Duration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SpeedRatio
   (
      this : in out Timeline
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITimeline.all.get_SpeedRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SpeedRatio
   (
      this : in out Timeline;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimeline.all.put_SpeedRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FillBehavior
   (
      this : in out Timeline
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.FillBehavior is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.FillBehavior;
   begin
      Hr := this.m_ITimeline.all.get_FillBehavior (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FillBehavior
   (
      this : in out Timeline;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.FillBehavior
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimeline.all.put_FillBehavior (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RepeatBehavior
   (
      this : in out Timeline
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior;
   begin
      Hr := this.m_ITimeline.all.get_RepeatBehavior (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RepeatBehavior
   (
      this : in out Timeline;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimeline.all.put_RepeatBehavior (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Completed
   (
      this : in out Timeline;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITimeline.all.add_Completed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Completed
   (
      this : in out Timeline;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimeline.all.remove_Completed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorAnimation

   procedure Initialize (this : in out ColorAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColorAnimation, IColorAnimation_Ptr);
   begin
      if this.m_IColorAnimation /= null then
         if this.m_IColorAnimation.all /= null then
            temp := this.m_IColorAnimation.all.Release;
            Free (this.m_IColorAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColorAnimation

   function Constructor return ColorAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IColorAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IColorAnimation;
   begin
      return RetVal : ColorAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IColorAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IColorAnimation;
            Retval.m_IColorAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ColorAnimation

   function get_FromProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ColorAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IColorAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ToProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ColorAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IColorAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ToProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ByProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ColorAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IColorAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ByProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_EasingFunctionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ColorAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IColorAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EasingFunctionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_EnableDependentAnimationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ColorAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IColorAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EnableDependentAnimationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorAnimation

   function get_From
   (
      this : in out ColorAnimation
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorAnimation.all.get_From (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_From
   (
      this : in out ColorAnimation;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorAnimation.all.put_From (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_To
   (
      this : in out ColorAnimation
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorAnimation.all.get_To (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_To
   (
      this : in out ColorAnimation;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorAnimation.all.put_To (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_By
   (
      this : in out ColorAnimation
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorAnimation.all.get_By (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_By
   (
      this : in out ColorAnimation;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorAnimation.all.put_By (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EasingFunction
   (
      this : in out ColorAnimation
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase do
         Hr := this.m_IColorAnimation.all.get_EasingFunction (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IEasingFunctionBase := new WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
         Retval.m_IEasingFunctionBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_EasingFunction
   (
      this : in out ColorAnimation;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorAnimation.all.put_EasingFunction (value.m_IEasingFunctionBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EnableDependentAnimation
   (
      this : in out ColorAnimation
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorAnimation.all.get_EnableDependentAnimation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EnableDependentAnimation
   (
      this : in out ColorAnimation;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorAnimation.all.put_EnableDependentAnimation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorAnimationUsingKeyFrames

   procedure Initialize (this : in out ColorAnimationUsingKeyFrames) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorAnimationUsingKeyFrames) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColorAnimationUsingKeyFrames, IColorAnimationUsingKeyFrames_Ptr);
   begin
      if this.m_IColorAnimationUsingKeyFrames /= null then
         if this.m_IColorAnimationUsingKeyFrames.all /= null then
            temp := this.m_IColorAnimationUsingKeyFrames.all.Release;
            Free (this.m_IColorAnimationUsingKeyFrames);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColorAnimationUsingKeyFrames

   function Constructor return ColorAnimationUsingKeyFrames is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IColorAnimationUsingKeyFrames");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IColorAnimationUsingKeyFrames;
   begin
      return RetVal : ColorAnimationUsingKeyFrames do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IColorAnimationUsingKeyFrames := new WinUI3.Windows.UI.Xaml.Media.Animation.IColorAnimationUsingKeyFrames;
            Retval.m_IColorAnimationUsingKeyFrames.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ColorAnimationUsingKeyFrames

   function get_EnableDependentAnimationProperty_ColorAnimationUsingKeyFrames
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ColorAnimationUsingKeyFrames");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IColorAnimationUsingKeyFramesStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorAnimationUsingKeyFramesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EnableDependentAnimationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorAnimationUsingKeyFrames

   function get_KeyFrames
   (
      this : in out ColorAnimationUsingKeyFrames
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection do
         Hr := this.m_IColorAnimationUsingKeyFrames.all.get_KeyFrames (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_EnableDependentAnimation
   (
      this : in out ColorAnimationUsingKeyFrames
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorAnimationUsingKeyFrames.all.get_EnableDependentAnimation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EnableDependentAnimation
   (
      this : in out ColorAnimationUsingKeyFrames;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorAnimationUsingKeyFrames.all.put_EnableDependentAnimation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorKeyFrame

   procedure Initialize (this : in out ColorKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColorKeyFrame, IColorKeyFrame_Ptr);
   begin
      if this.m_IColorKeyFrame /= null then
         if this.m_IColorKeyFrame.all /= null then
            temp := this.m_IColorKeyFrame.all.Release;
            Free (this.m_IColorKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColorKeyFrame

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ColorKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IColorKeyFrame");
      m_Factory    : access IColorKeyFrameFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrame;
   begin
      return RetVal : ColorKeyFrame do
         Hr := RoGetActivationFactory (m_hString, IID_IColorKeyFrameFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IColorKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrame;
            Retval.m_IColorKeyFrame.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ColorKeyFrame

   function get_ValueProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ColorKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyTimeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ColorKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyTimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorKeyFrame

   function get_Value
   (
      this : in out ColorKeyFrame
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IColorKeyFrame.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out ColorKeyFrame;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorKeyFrame.all.put_Value (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyTime
   (
      this : in out ColorKeyFrame
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime;
   begin
      Hr := this.m_IColorKeyFrame.all.get_KeyTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_KeyTime
   (
      this : in out ColorKeyFrame;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorKeyFrame.all.put_KeyTime (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorKeyFrameCollection

   procedure Initialize (this : in out ColorKeyFrameCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorKeyFrameCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColorKeyFrameCollection

   function Constructor return ColorKeyFrameCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("GenericObject");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : ColorKeyFrameCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorKeyFrameCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.Animation.ColorKeyFrame>
   function GetAt
   (
      this : in out ColorKeyFrameCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IColorKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrame;
         Retval.m_IColorKeyFrame.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out ColorKeyFrameCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out ColorKeyFrameCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IColorKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrame;
         Retval.m_IColorKeyFrame.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out ColorKeyFrameCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrame'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IColorKeyFrame.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out ColorKeyFrameCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IColorKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out ColorKeyFrameCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IColorKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out ColorKeyFrameCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out ColorKeyFrameCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IColorKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out ColorKeyFrameCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out ColorKeyFrameCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out ColorKeyFrameCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrame_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out ColorKeyFrameCollection;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrame_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2463256504, 44884, 20864, (152, 136, 87, 86, 86, 106, 19, 255 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.Animation.ColorKeyFrame>
   function First
   (
      this : in out ColorKeyFrameCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IColorKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (408542472, 22573, 20956, (130, 161, 70, 97, 17, 202, 249, 68 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IColorKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ColorKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IColorKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IColorKeyFrame;
         Retval.m_IColorKeyFrame.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationTransitionInfo

   procedure Initialize (this : in out NavigationTransitionInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationTransitionInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationTransitionInfo, INavigationTransitionInfo_Ptr);
   begin
      if this.m_INavigationTransitionInfo /= null then
         if this.m_INavigationTransitionInfo.all /= null then
            temp := this.m_INavigationTransitionInfo.all.Release;
            Free (this.m_INavigationTransitionInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationTransitionInfo

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationTransitionInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.INavigationTransitionInfo");
      m_Factory    : access INavigationTransitionInfoFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfo;
   begin
      return RetVal : NavigationTransitionInfo do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationTransitionInfoFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationTransitionInfo := new WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfo;
            Retval.m_INavigationTransitionInfo.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationTransitionInfo

   function GetNavigationStateCore
   (
      this : in out NavigationTransitionInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfoOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfo_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfoOverrides, WinUI3.Windows.UI.Xaml.Media.Animation.IID_INavigationTransitionInfoOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationTransitionInfo.all);
      Hr := m_Interface.GetNavigationStateCore (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure SetNavigationStateCore
   (
      this : in out NavigationTransitionInfo;
      navigationState : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfoOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_navigationState : constant WinUI3.HString := To_HString (navigationState);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfo_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfoOverrides, WinUI3.Windows.UI.Xaml.Media.Animation.IID_INavigationTransitionInfoOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationTransitionInfo.all);
      Hr := m_Interface.SetNavigationStateCore (HStr_navigationState);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_navigationState);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CommonNavigationTransitionInfo

   procedure Initialize (this : in out CommonNavigationTransitionInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out CommonNavigationTransitionInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICommonNavigationTransitionInfo, ICommonNavigationTransitionInfo_Ptr);
   begin
      if this.m_ICommonNavigationTransitionInfo /= null then
         if this.m_ICommonNavigationTransitionInfo.all /= null then
            temp := this.m_ICommonNavigationTransitionInfo.all.Release;
            Free (this.m_ICommonNavigationTransitionInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CommonNavigationTransitionInfo

   function Constructor return CommonNavigationTransitionInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ICommonNavigationTransitionInfo");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ICommonNavigationTransitionInfo;
   begin
      return RetVal : CommonNavigationTransitionInfo do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICommonNavigationTransitionInfo := new WinUI3.Windows.UI.Xaml.Media.Animation.ICommonNavigationTransitionInfo;
            Retval.m_ICommonNavigationTransitionInfo.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CommonNavigationTransitionInfo

   function get_IsStaggeringEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.CommonNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ICommonNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommonNavigationTransitionInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStaggeringEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsStaggerElementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.CommonNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ICommonNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommonNavigationTransitionInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStaggerElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsStaggerElement
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.CommonNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ICommonNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICommonNavigationTransitionInfoStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsStaggerElement (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsStaggerElement
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.CommonNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ICommonNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICommonNavigationTransitionInfoStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsStaggerElement (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CommonNavigationTransitionInfo

   function get_IsStaggeringEnabled
   (
      this : in out CommonNavigationTransitionInfo
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICommonNavigationTransitionInfo.all.get_IsStaggeringEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsStaggeringEnabled
   (
      this : in out CommonNavigationTransitionInfo;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICommonNavigationTransitionInfo.all.put_IsStaggeringEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ConnectedAnimation

   procedure Initialize (this : in out ConnectedAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out ConnectedAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IConnectedAnimation, IConnectedAnimation_Ptr);
   begin
      if this.m_IConnectedAnimation /= null then
         if this.m_IConnectedAnimation.all /= null then
            temp := this.m_IConnectedAnimation.all.Release;
            Free (this.m_IConnectedAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ConnectedAnimation

   function add_Completed
   (
      this : in out ConnectedAnimation;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IConnectedAnimation.all.add_Completed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Completed
   (
      this : in out ConnectedAnimation;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IConnectedAnimation.all.remove_Completed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryStart
   (
      this : in out ConnectedAnimation;
      destination : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IConnectedAnimation.all.TryStart (destination.m_IUIElement.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Cancel
   (
      this : in out ConnectedAnimation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IConnectedAnimation.all.Cancel;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsScaleAnimationEnabled
   (
      this : in out ConnectedAnimation
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation2, WinUI3.Windows.UI.Xaml.Media.Animation.IID_IConnectedAnimation2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IConnectedAnimation.all);
      Hr := m_Interface.get_IsScaleAnimationEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsScaleAnimationEnabled
   (
      this : in out ConnectedAnimation;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation2, WinUI3.Windows.UI.Xaml.Media.Animation.IID_IConnectedAnimation2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IConnectedAnimation.all);
      Hr := m_Interface.put_IsScaleAnimationEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryStart
   (
      this : in out ConnectedAnimation;
      destination : WinUI3.Windows.UI.Xaml.UIElement'Class;
      coordinatedElements : GenericObject
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation2, WinUI3.Windows.UI.Xaml.Media.Animation.IID_IConnectedAnimation2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IConnectedAnimation.all);
      Hr := m_Interface.TryStart (destination.m_IUIElement.all, coordinatedElements, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAnimationComponent
   (
      this : in out ConnectedAnimation;
      component : WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimationComponent;
      animation : WinUI3.Windows.UI.Composition.ICompositionAnimationBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation2, WinUI3.Windows.UI.Xaml.Media.Animation.IID_IConnectedAnimation2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IConnectedAnimation.all);
      Hr := m_Interface.SetAnimationComponent (component, animation);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Configuration
   (
      this : in out ConnectedAnimation
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimationConfiguration'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimationConfiguration;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation3, WinUI3.Windows.UI.Xaml.Media.Animation.IID_IConnectedAnimation3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimationConfiguration do
         m_Interface := QInterface (this.m_IConnectedAnimation.all);
         Hr := m_Interface.get_Configuration (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IConnectedAnimationConfiguration := new WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimationConfiguration;
         Retval.m_IConnectedAnimationConfiguration.all := m_ComRetVal;
      end return;
   end;

   procedure put_Configuration
   (
      this : in out ConnectedAnimation;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimationConfiguration'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation3, WinUI3.Windows.UI.Xaml.Media.Animation.IID_IConnectedAnimation3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IConnectedAnimation.all);
      Hr := m_Interface.put_Configuration (value.m_IConnectedAnimationConfiguration.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ConnectedAnimationService

   procedure Initialize (this : in out ConnectedAnimationService) is
   begin
      null;
   end;

   procedure Finalize (this : in out ConnectedAnimationService) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IConnectedAnimationService, IConnectedAnimationService_Ptr);
   begin
      if this.m_IConnectedAnimationService /= null then
         if this.m_IConnectedAnimationService.all /= null then
            temp := this.m_IConnectedAnimationService.all.Release;
            Free (this.m_IConnectedAnimationService);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ConnectedAnimationService

   function GetForCurrentView
   return WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimationService is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ConnectedAnimationService");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimationServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimationService;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimationService do
         Hr := RoGetActivationFactory (m_hString, IID_IConnectedAnimationServiceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForCurrentView (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IConnectedAnimationService := new WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimationService;
            Retval.m_IConnectedAnimationService.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ConnectedAnimationService

   function get_DefaultDuration
   (
      this : in out ConnectedAnimationService
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IConnectedAnimationService.all.get_DefaultDuration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultDuration
   (
      this : in out ConnectedAnimationService;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IConnectedAnimationService.all.put_DefaultDuration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DefaultEasingFunction
   (
      this : in out ConnectedAnimationService
   )
   return WinUI3.Windows.UI.Composition.CompositionEasingFunction'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Composition.ICompositionEasingFunction;
   begin
      return RetVal : WinUI3.Windows.UI.Composition.CompositionEasingFunction do
         Hr := this.m_IConnectedAnimationService.all.get_DefaultEasingFunction (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionEasingFunction := new WinUI3.Windows.UI.Composition.ICompositionEasingFunction;
         Retval.m_ICompositionEasingFunction.all := m_ComRetVal;
      end return;
   end;

   procedure put_DefaultEasingFunction
   (
      this : in out ConnectedAnimationService;
      value : WinUI3.Windows.UI.Composition.CompositionEasingFunction'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IConnectedAnimationService.all.put_DefaultEasingFunction (value.m_ICompositionEasingFunction.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function PrepareToAnimate
   (
      this : in out ConnectedAnimationService;
      key : WinUI3.WString;
      source : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation;
      HStr_key : constant WinUI3.HString := To_HString (key);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimation do
         Hr := this.m_IConnectedAnimationService.all.PrepareToAnimate (HStr_key, source.m_IUIElement.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IConnectedAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation;
         Retval.m_IConnectedAnimation.all := m_ComRetVal;
         tmp := WindowsDeleteString (HStr_key);
      end return;
   end;

   function GetAnimation
   (
      this : in out ConnectedAnimationService;
      key : WinUI3.WString
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation;
      HStr_key : constant WinUI3.HString := To_HString (key);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimation do
         Hr := this.m_IConnectedAnimationService.all.GetAnimation (HStr_key, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IConnectedAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation;
         Retval.m_IConnectedAnimation.all := m_ComRetVal;
         tmp := WindowsDeleteString (HStr_key);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentThemeTransition

   procedure Initialize (this : in out ContentThemeTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentThemeTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentThemeTransition, IContentThemeTransition_Ptr);
   begin
      if this.m_IContentThemeTransition /= null then
         if this.m_IContentThemeTransition.all /= null then
            temp := this.m_IContentThemeTransition.all.Release;
            Free (this.m_IContentThemeTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContentThemeTransition

   function Constructor return ContentThemeTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IContentThemeTransition");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IContentThemeTransition;
   begin
      return RetVal : ContentThemeTransition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IContentThemeTransition := new WinUI3.Windows.UI.Xaml.Media.Animation.IContentThemeTransition;
            Retval.m_IContentThemeTransition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ContentThemeTransition

   function get_HorizontalOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContentThemeTransition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContentThemeTransitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentThemeTransitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContentThemeTransition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContentThemeTransitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentThemeTransitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentThemeTransition

   function get_HorizontalOffset
   (
      this : in out ContentThemeTransition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IContentThemeTransition.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalOffset
   (
      this : in out ContentThemeTransition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentThemeTransition.all.put_HorizontalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalOffset
   (
      this : in out ContentThemeTransition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IContentThemeTransition.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalOffset
   (
      this : in out ContentThemeTransition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentThemeTransition.all.put_VerticalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContinuumNavigationTransitionInfo

   procedure Initialize (this : in out ContinuumNavigationTransitionInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContinuumNavigationTransitionInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContinuumNavigationTransitionInfo, IContinuumNavigationTransitionInfo_Ptr);
   begin
      if this.m_IContinuumNavigationTransitionInfo /= null then
         if this.m_IContinuumNavigationTransitionInfo.all /= null then
            temp := this.m_IContinuumNavigationTransitionInfo.all.Release;
            Free (this.m_IContinuumNavigationTransitionInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContinuumNavigationTransitionInfo

   function Constructor return ContinuumNavigationTransitionInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfo");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfo;
   begin
      return RetVal : ContinuumNavigationTransitionInfo do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IContinuumNavigationTransitionInfo := new WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfo;
            Retval.m_IContinuumNavigationTransitionInfo.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ContinuumNavigationTransitionInfo

   function get_ExitElementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContinuumNavigationTransitionInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExitElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsEntranceElementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContinuumNavigationTransitionInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsEntranceElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsEntranceElement
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IContinuumNavigationTransitionInfoStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsEntranceElement (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsEntranceElement
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IContinuumNavigationTransitionInfoStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsEntranceElement (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsExitElementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContinuumNavigationTransitionInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsExitElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsExitElement
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IContinuumNavigationTransitionInfoStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsExitElement (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsExitElement
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IContinuumNavigationTransitionInfoStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsExitElement (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ExitElementContainerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContinuumNavigationTransitionInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExitElementContainerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetExitElementContainer
   (
      element : WinUI3.Windows.UI.Xaml.Controls.ListViewBase'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IContinuumNavigationTransitionInfoStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetExitElementContainer (element.m_IListViewBase.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetExitElementContainer
   (
      element : WinUI3.Windows.UI.Xaml.Controls.ListViewBase'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IContinuumNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IContinuumNavigationTransitionInfoStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetExitElementContainer (element.m_IListViewBase.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContinuumNavigationTransitionInfo

   function get_ExitElement
   (
      this : in out ContinuumNavigationTransitionInfo
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IContinuumNavigationTransitionInfo.all.get_ExitElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_ExitElement
   (
      this : in out ContinuumNavigationTransitionInfo;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContinuumNavigationTransitionInfo.all.put_ExitElement (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CubicEase

   procedure Initialize (this : in out CubicEase) is
   begin
      null;
   end;

   procedure Finalize (this : in out CubicEase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICubicEase, ICubicEase_Ptr);
   begin
      if this.m_ICubicEase /= null then
         if this.m_ICubicEase.all /= null then
            temp := this.m_ICubicEase.all.Release;
            Free (this.m_ICubicEase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CubicEase

   function Constructor return CubicEase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ICubicEase");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ICubicEase;
   begin
      return RetVal : CubicEase do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICubicEase := new WinUI3.Windows.UI.Xaml.Media.Animation.ICubicEase;
            Retval.m_ICubicEase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CubicEase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DirectConnectedAnimationConfiguration

   procedure Initialize (this : in out DirectConnectedAnimationConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out DirectConnectedAnimationConfiguration) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDirectConnectedAnimationConfiguration, IDirectConnectedAnimationConfiguration_Ptr);
   begin
      if this.m_IDirectConnectedAnimationConfiguration /= null then
         if this.m_IDirectConnectedAnimationConfiguration.all /= null then
            temp := this.m_IDirectConnectedAnimationConfiguration.all.Release;
            Free (this.m_IDirectConnectedAnimationConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DirectConnectedAnimationConfiguration

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DirectConnectedAnimationConfiguration is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDirectConnectedAnimationConfiguration");
      m_Factory    : access IDirectConnectedAnimationConfigurationFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDirectConnectedAnimationConfiguration;
   begin
      return RetVal : DirectConnectedAnimationConfiguration do
         Hr := RoGetActivationFactory (m_hString, IID_IDirectConnectedAnimationConfigurationFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDirectConnectedAnimationConfiguration := new WinUI3.Windows.UI.Xaml.Media.Animation.IDirectConnectedAnimationConfiguration;
            Retval.m_IDirectConnectedAnimationConfiguration.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DirectConnectedAnimationConfiguration

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DiscreteColorKeyFrame

   procedure Initialize (this : in out DiscreteColorKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out DiscreteColorKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDiscreteColorKeyFrame, IDiscreteColorKeyFrame_Ptr);
   begin
      if this.m_IDiscreteColorKeyFrame /= null then
         if this.m_IDiscreteColorKeyFrame.all /= null then
            temp := this.m_IDiscreteColorKeyFrame.all.Release;
            Free (this.m_IDiscreteColorKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DiscreteColorKeyFrame

   function Constructor return DiscreteColorKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDiscreteColorKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDiscreteColorKeyFrame;
   begin
      return RetVal : DiscreteColorKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDiscreteColorKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IDiscreteColorKeyFrame;
            Retval.m_IDiscreteColorKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DiscreteColorKeyFrame

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DoubleKeyFrame

   procedure Initialize (this : in out DoubleKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out DoubleKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDoubleKeyFrame, IDoubleKeyFrame_Ptr);
   begin
      if this.m_IDoubleKeyFrame /= null then
         if this.m_IDoubleKeyFrame.all /= null then
            temp := this.m_IDoubleKeyFrame.all.Release;
            Free (this.m_IDoubleKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DoubleKeyFrame

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DoubleKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame");
      m_Factory    : access IDoubleKeyFrameFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame;
   begin
      return RetVal : DoubleKeyFrame do
         Hr := RoGetActivationFactory (m_hString, IID_IDoubleKeyFrameFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDoubleKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame;
            Retval.m_IDoubleKeyFrame.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DoubleKeyFrame

   function get_ValueProperty_DoubleKeyFrame
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DoubleKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDoubleKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyTimeProperty_DoubleKeyFrame
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DoubleKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDoubleKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyTimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DoubleKeyFrame

   function get_Value
   (
      this : in out DoubleKeyFrame
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IDoubleKeyFrame.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out DoubleKeyFrame;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDoubleKeyFrame.all.put_Value (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyTime
   (
      this : in out DoubleKeyFrame
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime;
   begin
      Hr := this.m_IDoubleKeyFrame.all.get_KeyTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_KeyTime
   (
      this : in out DoubleKeyFrame;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDoubleKeyFrame.all.put_KeyTime (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DiscreteDoubleKeyFrame

   procedure Initialize (this : in out DiscreteDoubleKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out DiscreteDoubleKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDiscreteDoubleKeyFrame, IDiscreteDoubleKeyFrame_Ptr);
   begin
      if this.m_IDiscreteDoubleKeyFrame /= null then
         if this.m_IDiscreteDoubleKeyFrame.all /= null then
            temp := this.m_IDiscreteDoubleKeyFrame.all.Release;
            Free (this.m_IDiscreteDoubleKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DiscreteDoubleKeyFrame

   function Constructor return DiscreteDoubleKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDiscreteDoubleKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDiscreteDoubleKeyFrame;
   begin
      return RetVal : DiscreteDoubleKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDiscreteDoubleKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IDiscreteDoubleKeyFrame;
            Retval.m_IDiscreteDoubleKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DiscreteDoubleKeyFrame

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ObjectKeyFrame

   procedure Initialize (this : in out ObjectKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out ObjectKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IObjectKeyFrame, IObjectKeyFrame_Ptr);
   begin
      if this.m_IObjectKeyFrame /= null then
         if this.m_IObjectKeyFrame.all /= null then
            temp := this.m_IObjectKeyFrame.all.Release;
            Free (this.m_IObjectKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ObjectKeyFrame

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ObjectKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IObjectKeyFrame");
      m_Factory    : access IObjectKeyFrameFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrame;
   begin
      return RetVal : ObjectKeyFrame do
         Hr := RoGetActivationFactory (m_hString, IID_IObjectKeyFrameFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IObjectKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrame;
            Retval.m_IObjectKeyFrame.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ObjectKeyFrame

   function get_ValueProperty_ObjectKeyFrame
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ObjectKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IObjectKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyTimeProperty_ObjectKeyFrame
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ObjectKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IObjectKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyTimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ObjectKeyFrame

   function get_Value
   (
      this : in out ObjectKeyFrame
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IObjectKeyFrame.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out ObjectKeyFrame;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IObjectKeyFrame.all.put_Value (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyTime
   (
      this : in out ObjectKeyFrame
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime;
   begin
      Hr := this.m_IObjectKeyFrame.all.get_KeyTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_KeyTime
   (
      this : in out ObjectKeyFrame;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IObjectKeyFrame.all.put_KeyTime (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DiscreteObjectKeyFrame

   procedure Initialize (this : in out DiscreteObjectKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out DiscreteObjectKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDiscreteObjectKeyFrame, IDiscreteObjectKeyFrame_Ptr);
   begin
      if this.m_IDiscreteObjectKeyFrame /= null then
         if this.m_IDiscreteObjectKeyFrame.all /= null then
            temp := this.m_IDiscreteObjectKeyFrame.all.Release;
            Free (this.m_IDiscreteObjectKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DiscreteObjectKeyFrame

   function Constructor return DiscreteObjectKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDiscreteObjectKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDiscreteObjectKeyFrame;
   begin
      return RetVal : DiscreteObjectKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDiscreteObjectKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IDiscreteObjectKeyFrame;
            Retval.m_IDiscreteObjectKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DiscreteObjectKeyFrame

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointKeyFrame

   procedure Initialize (this : in out PointKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointKeyFrame, IPointKeyFrame_Ptr);
   begin
      if this.m_IPointKeyFrame /= null then
         if this.m_IPointKeyFrame.all /= null then
            temp := this.m_IPointKeyFrame.all.Release;
            Free (this.m_IPointKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PointKeyFrame

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PointKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IPointKeyFrame");
      m_Factory    : access IPointKeyFrameFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrame;
   begin
      return RetVal : PointKeyFrame do
         Hr := RoGetActivationFactory (m_hString, IID_IPointKeyFrameFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPointKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrame;
            Retval.m_IPointKeyFrame.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PointKeyFrame

   function get_ValueProperty_PointKeyFrame
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PointKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPointKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyTimeProperty_PointKeyFrame
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PointKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPointKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyTimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointKeyFrame

   function get_Value
   (
      this : in out PointKeyFrame
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IPointKeyFrame.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out PointKeyFrame;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPointKeyFrame.all.put_Value (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyTime
   (
      this : in out PointKeyFrame
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime;
   begin
      Hr := this.m_IPointKeyFrame.all.get_KeyTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_KeyTime
   (
      this : in out PointKeyFrame;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPointKeyFrame.all.put_KeyTime (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DiscretePointKeyFrame

   procedure Initialize (this : in out DiscretePointKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out DiscretePointKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDiscretePointKeyFrame, IDiscretePointKeyFrame_Ptr);
   begin
      if this.m_IDiscretePointKeyFrame /= null then
         if this.m_IDiscretePointKeyFrame.all /= null then
            temp := this.m_IDiscretePointKeyFrame.all.Release;
            Free (this.m_IDiscretePointKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DiscretePointKeyFrame

   function Constructor return DiscretePointKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDiscretePointKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDiscretePointKeyFrame;
   begin
      return RetVal : DiscretePointKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDiscretePointKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IDiscretePointKeyFrame;
            Retval.m_IDiscretePointKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DiscretePointKeyFrame

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DoubleAnimation

   procedure Initialize (this : in out DoubleAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out DoubleAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDoubleAnimation, IDoubleAnimation_Ptr);
   begin
      if this.m_IDoubleAnimation /= null then
         if this.m_IDoubleAnimation.all /= null then
            temp := this.m_IDoubleAnimation.all.Release;
            Free (this.m_IDoubleAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DoubleAnimation

   function Constructor return DoubleAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDoubleAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleAnimation;
   begin
      return RetVal : DoubleAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDoubleAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleAnimation;
            Retval.m_IDoubleAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DoubleAnimation

   function get_FromProperty_DoubleAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DoubleAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDoubleAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ToProperty_DoubleAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DoubleAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDoubleAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ToProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ByProperty_DoubleAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DoubleAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDoubleAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ByProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_EasingFunctionProperty_DoubleAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DoubleAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDoubleAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EasingFunctionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_EnableDependentAnimationProperty_DoubleAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DoubleAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDoubleAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EnableDependentAnimationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DoubleAnimation

   function get_From
   (
      this : in out DoubleAnimation
   )
   return IReference_Double.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_IDoubleAnimation.all.get_From (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_From
   (
      this : in out DoubleAnimation;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDoubleAnimation.all.put_From (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_To
   (
      this : in out DoubleAnimation
   )
   return IReference_Double.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_IDoubleAnimation.all.get_To (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_To
   (
      this : in out DoubleAnimation;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDoubleAnimation.all.put_To (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_By
   (
      this : in out DoubleAnimation
   )
   return IReference_Double.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_IDoubleAnimation.all.get_By (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_By
   (
      this : in out DoubleAnimation;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDoubleAnimation.all.put_By (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EasingFunction
   (
      this : in out DoubleAnimation
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase do
         Hr := this.m_IDoubleAnimation.all.get_EasingFunction (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IEasingFunctionBase := new WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
         Retval.m_IEasingFunctionBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_EasingFunction
   (
      this : in out DoubleAnimation;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDoubleAnimation.all.put_EasingFunction (value.m_IEasingFunctionBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EnableDependentAnimation
   (
      this : in out DoubleAnimation
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDoubleAnimation.all.get_EnableDependentAnimation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EnableDependentAnimation
   (
      this : in out DoubleAnimation;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDoubleAnimation.all.put_EnableDependentAnimation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DoubleAnimationUsingKeyFrames

   procedure Initialize (this : in out DoubleAnimationUsingKeyFrames) is
   begin
      null;
   end;

   procedure Finalize (this : in out DoubleAnimationUsingKeyFrames) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDoubleAnimationUsingKeyFrames, IDoubleAnimationUsingKeyFrames_Ptr);
   begin
      if this.m_IDoubleAnimationUsingKeyFrames /= null then
         if this.m_IDoubleAnimationUsingKeyFrames.all /= null then
            temp := this.m_IDoubleAnimationUsingKeyFrames.all.Release;
            Free (this.m_IDoubleAnimationUsingKeyFrames);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DoubleAnimationUsingKeyFrames

   function Constructor return DoubleAnimationUsingKeyFrames is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDoubleAnimationUsingKeyFrames");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleAnimationUsingKeyFrames;
   begin
      return RetVal : DoubleAnimationUsingKeyFrames do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDoubleAnimationUsingKeyFrames := new WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleAnimationUsingKeyFrames;
            Retval.m_IDoubleAnimationUsingKeyFrames.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DoubleAnimationUsingKeyFrames

   function get_EnableDependentAnimationProperty_DoubleAnimationUsingKeyFrames
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DoubleAnimationUsingKeyFrames");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleAnimationUsingKeyFramesStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDoubleAnimationUsingKeyFramesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EnableDependentAnimationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DoubleAnimationUsingKeyFrames

   function get_KeyFrames
   (
      this : in out DoubleAnimationUsingKeyFrames
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection do
         Hr := this.m_IDoubleAnimationUsingKeyFrames.all.get_KeyFrames (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_EnableDependentAnimation
   (
      this : in out DoubleAnimationUsingKeyFrames
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDoubleAnimationUsingKeyFrames.all.get_EnableDependentAnimation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EnableDependentAnimation
   (
      this : in out DoubleAnimationUsingKeyFrames;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDoubleAnimationUsingKeyFrames.all.put_EnableDependentAnimation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DoubleKeyFrameCollection

   procedure Initialize (this : in out DoubleKeyFrameCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out DoubleKeyFrameCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DoubleKeyFrameCollection

   function Constructor return DoubleKeyFrameCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("GenericObject");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : DoubleKeyFrameCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DoubleKeyFrameCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.Animation.DoubleKeyFrame>
   function GetAt
   (
      this : in out DoubleKeyFrameCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDoubleKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame;
         Retval.m_IDoubleKeyFrame.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out DoubleKeyFrameCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out DoubleKeyFrameCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDoubleKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame;
         Retval.m_IDoubleKeyFrame.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out DoubleKeyFrameCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrame'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IDoubleKeyFrame.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out DoubleKeyFrameCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IDoubleKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out DoubleKeyFrameCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IDoubleKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out DoubleKeyFrameCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out DoubleKeyFrameCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IDoubleKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out DoubleKeyFrameCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out DoubleKeyFrameCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out DoubleKeyFrameCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out DoubleKeyFrameCollection;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3620462114, 34495, 22319, (132, 115, 7, 157, 21, 7, 108, 62 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.Animation.DoubleKeyFrame>
   function First
   (
      this : in out DoubleKeyFrameCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IDoubleKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (1595307738, 41989, 23418, (186, 241, 150, 141, 228, 57, 31, 183 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IDoubleKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.DoubleKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDoubleKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame;
         Retval.m_IDoubleKeyFrame.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragItemThemeAnimation

   procedure Initialize (this : in out DragItemThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragItemThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragItemThemeAnimation, IDragItemThemeAnimation_Ptr);
   begin
      if this.m_IDragItemThemeAnimation /= null then
         if this.m_IDragItemThemeAnimation.all /= null then
            temp := this.m_IDragItemThemeAnimation.all.Release;
            Free (this.m_IDragItemThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DragItemThemeAnimation

   function Constructor return DragItemThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDragItemThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDragItemThemeAnimation;
   begin
      return RetVal : DragItemThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDragItemThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IDragItemThemeAnimation;
            Retval.m_IDragItemThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DragItemThemeAnimation

   function get_TargetNameProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DragItemThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDragItemThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDragItemThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragItemThemeAnimation

   function get_TargetName
   (
      this : in out DragItemThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDragItemThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out DragItemThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDragItemThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragOverThemeAnimation

   procedure Initialize (this : in out DragOverThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragOverThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragOverThemeAnimation, IDragOverThemeAnimation_Ptr);
   begin
      if this.m_IDragOverThemeAnimation /= null then
         if this.m_IDragOverThemeAnimation.all /= null then
            temp := this.m_IDragOverThemeAnimation.all.Release;
            Free (this.m_IDragOverThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DragOverThemeAnimation

   function Constructor return DragOverThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDragOverThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDragOverThemeAnimation;
   begin
      return RetVal : DragOverThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDragOverThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IDragOverThemeAnimation;
            Retval.m_IDragOverThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DragOverThemeAnimation

   function get_TargetNameProperty_DragOverThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDragOverThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDragOverThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ToOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDragOverThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDragOverThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ToOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DirectionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDragOverThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDragOverThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DirectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragOverThemeAnimation

   function get_TargetName
   (
      this : in out DragOverThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDragOverThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out DragOverThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDragOverThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ToOffset
   (
      this : in out DragOverThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IDragOverThemeAnimation.all.get_ToOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ToOffset
   (
      this : in out DragOverThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragOverThemeAnimation.all.put_ToOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Direction
   (
      this : in out DragOverThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.AnimationDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.AnimationDirection;
   begin
      Hr := this.m_IDragOverThemeAnimation.all.get_Direction (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Direction
   (
      this : in out DragOverThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.AnimationDirection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragOverThemeAnimation.all.put_Direction (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DrillInNavigationTransitionInfo

   procedure Initialize (this : in out DrillInNavigationTransitionInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out DrillInNavigationTransitionInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDrillInNavigationTransitionInfo, IDrillInNavigationTransitionInfo_Ptr);
   begin
      if this.m_IDrillInNavigationTransitionInfo /= null then
         if this.m_IDrillInNavigationTransitionInfo.all /= null then
            temp := this.m_IDrillInNavigationTransitionInfo.all.Release;
            Free (this.m_IDrillInNavigationTransitionInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DrillInNavigationTransitionInfo

   function Constructor return DrillInNavigationTransitionInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDrillInNavigationTransitionInfo");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDrillInNavigationTransitionInfo;
   begin
      return RetVal : DrillInNavigationTransitionInfo do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDrillInNavigationTransitionInfo := new WinUI3.Windows.UI.Xaml.Media.Animation.IDrillInNavigationTransitionInfo;
            Retval.m_IDrillInNavigationTransitionInfo.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DrillInNavigationTransitionInfo

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DrillInThemeAnimation

   procedure Initialize (this : in out DrillInThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out DrillInThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDrillInThemeAnimation, IDrillInThemeAnimation_Ptr);
   begin
      if this.m_IDrillInThemeAnimation /= null then
         if this.m_IDrillInThemeAnimation.all /= null then
            temp := this.m_IDrillInThemeAnimation.all.Release;
            Free (this.m_IDrillInThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DrillInThemeAnimation

   function Constructor return DrillInThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDrillInThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDrillInThemeAnimation;
   begin
      return RetVal : DrillInThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDrillInThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IDrillInThemeAnimation;
            Retval.m_IDrillInThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DrillInThemeAnimation

   function get_EntranceTargetNameProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDrillInThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDrillInThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EntranceTargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_EntranceTargetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDrillInThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDrillInThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EntranceTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExitTargetNameProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDrillInThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDrillInThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExitTargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExitTargetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDrillInThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDrillInThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExitTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DrillInThemeAnimation

   function get_EntranceTargetName
   (
      this : in out DrillInThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDrillInThemeAnimation.all.get_EntranceTargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_EntranceTargetName
   (
      this : in out DrillInThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDrillInThemeAnimation.all.put_EntranceTargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_EntranceTarget
   (
      this : in out DrillInThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IDrillInThemeAnimation.all.get_EntranceTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_EntranceTarget
   (
      this : in out DrillInThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDrillInThemeAnimation.all.put_EntranceTarget (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExitTargetName
   (
      this : in out DrillInThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDrillInThemeAnimation.all.get_ExitTargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ExitTargetName
   (
      this : in out DrillInThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDrillInThemeAnimation.all.put_ExitTargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ExitTarget
   (
      this : in out DrillInThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IDrillInThemeAnimation.all.get_ExitTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ExitTarget
   (
      this : in out DrillInThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDrillInThemeAnimation.all.put_ExitTarget (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DrillOutThemeAnimation

   procedure Initialize (this : in out DrillOutThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out DrillOutThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDrillOutThemeAnimation, IDrillOutThemeAnimation_Ptr);
   begin
      if this.m_IDrillOutThemeAnimation /= null then
         if this.m_IDrillOutThemeAnimation.all /= null then
            temp := this.m_IDrillOutThemeAnimation.all.Release;
            Free (this.m_IDrillOutThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DrillOutThemeAnimation

   function Constructor return DrillOutThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDrillOutThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDrillOutThemeAnimation;
   begin
      return RetVal : DrillOutThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDrillOutThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IDrillOutThemeAnimation;
            Retval.m_IDrillOutThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DrillOutThemeAnimation

   function get_EntranceTargetNameProperty_DrillOutThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDrillOutThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDrillOutThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EntranceTargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_EntranceTargetProperty_DrillOutThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDrillOutThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDrillOutThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EntranceTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExitTargetNameProperty_DrillOutThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDrillOutThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDrillOutThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExitTargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExitTargetProperty_DrillOutThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDrillOutThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDrillOutThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExitTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DrillOutThemeAnimation

   function get_EntranceTargetName
   (
      this : in out DrillOutThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDrillOutThemeAnimation.all.get_EntranceTargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_EntranceTargetName
   (
      this : in out DrillOutThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDrillOutThemeAnimation.all.put_EntranceTargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_EntranceTarget
   (
      this : in out DrillOutThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IDrillOutThemeAnimation.all.get_EntranceTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_EntranceTarget
   (
      this : in out DrillOutThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDrillOutThemeAnimation.all.put_EntranceTarget (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExitTargetName
   (
      this : in out DrillOutThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDrillOutThemeAnimation.all.get_ExitTargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ExitTargetName
   (
      this : in out DrillOutThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDrillOutThemeAnimation.all.put_ExitTargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ExitTarget
   (
      this : in out DrillOutThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IDrillOutThemeAnimation.all.get_ExitTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ExitTarget
   (
      this : in out DrillOutThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDrillOutThemeAnimation.all.put_ExitTarget (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DropTargetItemThemeAnimation

   procedure Initialize (this : in out DropTargetItemThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out DropTargetItemThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDropTargetItemThemeAnimation, IDropTargetItemThemeAnimation_Ptr);
   begin
      if this.m_IDropTargetItemThemeAnimation /= null then
         if this.m_IDropTargetItemThemeAnimation.all /= null then
            temp := this.m_IDropTargetItemThemeAnimation.all.Release;
            Free (this.m_IDropTargetItemThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DropTargetItemThemeAnimation

   function Constructor return DropTargetItemThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IDropTargetItemThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IDropTargetItemThemeAnimation;
   begin
      return RetVal : DropTargetItemThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDropTargetItemThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IDropTargetItemThemeAnimation;
            Retval.m_IDropTargetItemThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DropTargetItemThemeAnimation

   function get_TargetNameProperty_DropTargetItemThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.DropTargetItemThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IDropTargetItemThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDropTargetItemThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DropTargetItemThemeAnimation

   function get_TargetName
   (
      this : in out DropTargetItemThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDropTargetItemThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out DropTargetItemThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDropTargetItemThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EasingColorKeyFrame

   procedure Initialize (this : in out EasingColorKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out EasingColorKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEasingColorKeyFrame, IEasingColorKeyFrame_Ptr);
   begin
      if this.m_IEasingColorKeyFrame /= null then
         if this.m_IEasingColorKeyFrame.all /= null then
            temp := this.m_IEasingColorKeyFrame.all.Release;
            Free (this.m_IEasingColorKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for EasingColorKeyFrame

   function Constructor return EasingColorKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IEasingColorKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEasingColorKeyFrame;
   begin
      return RetVal : EasingColorKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IEasingColorKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IEasingColorKeyFrame;
            Retval.m_IEasingColorKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for EasingColorKeyFrame

   function get_EasingFunctionProperty_EasingColorKeyFrame
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.EasingColorKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IEasingColorKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEasingColorKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EasingFunctionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EasingColorKeyFrame

   function get_EasingFunction
   (
      this : in out EasingColorKeyFrame
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase do
         Hr := this.m_IEasingColorKeyFrame.all.get_EasingFunction (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IEasingFunctionBase := new WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
         Retval.m_IEasingFunctionBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_EasingFunction
   (
      this : in out EasingColorKeyFrame;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEasingColorKeyFrame.all.put_EasingFunction (value.m_IEasingFunctionBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EasingDoubleKeyFrame

   procedure Initialize (this : in out EasingDoubleKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out EasingDoubleKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEasingDoubleKeyFrame, IEasingDoubleKeyFrame_Ptr);
   begin
      if this.m_IEasingDoubleKeyFrame /= null then
         if this.m_IEasingDoubleKeyFrame.all /= null then
            temp := this.m_IEasingDoubleKeyFrame.all.Release;
            Free (this.m_IEasingDoubleKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for EasingDoubleKeyFrame

   function Constructor return EasingDoubleKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IEasingDoubleKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEasingDoubleKeyFrame;
   begin
      return RetVal : EasingDoubleKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IEasingDoubleKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IEasingDoubleKeyFrame;
            Retval.m_IEasingDoubleKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for EasingDoubleKeyFrame

   function get_EasingFunctionProperty_EasingDoubleKeyFrame
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.EasingDoubleKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IEasingDoubleKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEasingDoubleKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EasingFunctionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EasingDoubleKeyFrame

   function get_EasingFunction
   (
      this : in out EasingDoubleKeyFrame
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase do
         Hr := this.m_IEasingDoubleKeyFrame.all.get_EasingFunction (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IEasingFunctionBase := new WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
         Retval.m_IEasingFunctionBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_EasingFunction
   (
      this : in out EasingDoubleKeyFrame;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEasingDoubleKeyFrame.all.put_EasingFunction (value.m_IEasingFunctionBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EasingPointKeyFrame

   procedure Initialize (this : in out EasingPointKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out EasingPointKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEasingPointKeyFrame, IEasingPointKeyFrame_Ptr);
   begin
      if this.m_IEasingPointKeyFrame /= null then
         if this.m_IEasingPointKeyFrame.all /= null then
            temp := this.m_IEasingPointKeyFrame.all.Release;
            Free (this.m_IEasingPointKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for EasingPointKeyFrame

   function Constructor return EasingPointKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IEasingPointKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEasingPointKeyFrame;
   begin
      return RetVal : EasingPointKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IEasingPointKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IEasingPointKeyFrame;
            Retval.m_IEasingPointKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for EasingPointKeyFrame

   function get_EasingFunctionProperty_EasingPointKeyFrame
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.EasingPointKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IEasingPointKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEasingPointKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EasingFunctionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EasingPointKeyFrame

   function get_EasingFunction
   (
      this : in out EasingPointKeyFrame
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase do
         Hr := this.m_IEasingPointKeyFrame.all.get_EasingFunction (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IEasingFunctionBase := new WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
         Retval.m_IEasingFunctionBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_EasingFunction
   (
      this : in out EasingPointKeyFrame;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEasingPointKeyFrame.all.put_EasingFunction (value.m_IEasingFunctionBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EdgeUIThemeTransition

   procedure Initialize (this : in out EdgeUIThemeTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out EdgeUIThemeTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEdgeUIThemeTransition, IEdgeUIThemeTransition_Ptr);
   begin
      if this.m_IEdgeUIThemeTransition /= null then
         if this.m_IEdgeUIThemeTransition.all /= null then
            temp := this.m_IEdgeUIThemeTransition.all.Release;
            Free (this.m_IEdgeUIThemeTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for EdgeUIThemeTransition

   function Constructor return EdgeUIThemeTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IEdgeUIThemeTransition");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEdgeUIThemeTransition;
   begin
      return RetVal : EdgeUIThemeTransition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IEdgeUIThemeTransition := new WinUI3.Windows.UI.Xaml.Media.Animation.IEdgeUIThemeTransition;
            Retval.m_IEdgeUIThemeTransition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for EdgeUIThemeTransition

   function get_EdgeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.EdgeUIThemeTransition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IEdgeUIThemeTransitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEdgeUIThemeTransitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EdgeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EdgeUIThemeTransition

   function get_Edge
   (
      this : in out EdgeUIThemeTransition
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.EdgeTransitionLocation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.EdgeTransitionLocation;
   begin
      Hr := this.m_IEdgeUIThemeTransition.all.get_Edge (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Edge
   (
      this : in out EdgeUIThemeTransition;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.EdgeTransitionLocation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEdgeUIThemeTransition.all.put_Edge (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ElasticEase

   procedure Initialize (this : in out ElasticEase) is
   begin
      null;
   end;

   procedure Finalize (this : in out ElasticEase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IElasticEase, IElasticEase_Ptr);
   begin
      if this.m_IElasticEase /= null then
         if this.m_IElasticEase.all /= null then
            temp := this.m_IElasticEase.all.Release;
            Free (this.m_IElasticEase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ElasticEase

   function Constructor return ElasticEase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IElasticEase");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IElasticEase;
   begin
      return RetVal : ElasticEase do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IElasticEase := new WinUI3.Windows.UI.Xaml.Media.Animation.IElasticEase;
            Retval.m_IElasticEase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ElasticEase

   function get_OscillationsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ElasticEase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IElasticEaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IElasticEaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OscillationsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SpringinessProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ElasticEase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IElasticEaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IElasticEaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SpringinessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ElasticEase

   function get_Oscillations
   (
      this : in out ElasticEase
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IElasticEase.all.get_Oscillations (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Oscillations
   (
      this : in out ElasticEase;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IElasticEase.all.put_Oscillations (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Springiness
   (
      this : in out ElasticEase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IElasticEase.all.get_Springiness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Springiness
   (
      this : in out ElasticEase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IElasticEase.all.put_Springiness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EntranceNavigationTransitionInfo

   procedure Initialize (this : in out EntranceNavigationTransitionInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out EntranceNavigationTransitionInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEntranceNavigationTransitionInfo, IEntranceNavigationTransitionInfo_Ptr);
   begin
      if this.m_IEntranceNavigationTransitionInfo /= null then
         if this.m_IEntranceNavigationTransitionInfo.all /= null then
            temp := this.m_IEntranceNavigationTransitionInfo.all.Release;
            Free (this.m_IEntranceNavigationTransitionInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for EntranceNavigationTransitionInfo

   function Constructor return EntranceNavigationTransitionInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IEntranceNavigationTransitionInfo");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEntranceNavigationTransitionInfo;
   begin
      return RetVal : EntranceNavigationTransitionInfo do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IEntranceNavigationTransitionInfo := new WinUI3.Windows.UI.Xaml.Media.Animation.IEntranceNavigationTransitionInfo;
            Retval.m_IEntranceNavigationTransitionInfo.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for EntranceNavigationTransitionInfo

   function get_IsTargetElementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.EntranceNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IEntranceNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEntranceNavigationTransitionInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTargetElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsTargetElement
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.EntranceNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IEntranceNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IEntranceNavigationTransitionInfoStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsTargetElement (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsTargetElement
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.EntranceNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IEntranceNavigationTransitionInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IEntranceNavigationTransitionInfoStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsTargetElement (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EntranceNavigationTransitionInfo

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EntranceThemeTransition

   procedure Initialize (this : in out EntranceThemeTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out EntranceThemeTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEntranceThemeTransition, IEntranceThemeTransition_Ptr);
   begin
      if this.m_IEntranceThemeTransition /= null then
         if this.m_IEntranceThemeTransition.all /= null then
            temp := this.m_IEntranceThemeTransition.all.Release;
            Free (this.m_IEntranceThemeTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for EntranceThemeTransition

   function Constructor return EntranceThemeTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IEntranceThemeTransition");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEntranceThemeTransition;
   begin
      return RetVal : EntranceThemeTransition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IEntranceThemeTransition := new WinUI3.Windows.UI.Xaml.Media.Animation.IEntranceThemeTransition;
            Retval.m_IEntranceThemeTransition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for EntranceThemeTransition

   function get_FromHorizontalOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.EntranceThemeTransition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IEntranceThemeTransitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEntranceThemeTransitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromHorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FromVerticalOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.EntranceThemeTransition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IEntranceThemeTransitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEntranceThemeTransitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromVerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsStaggeringEnabledProperty_EntranceThemeTransition
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.EntranceThemeTransition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IEntranceThemeTransitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEntranceThemeTransitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStaggeringEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EntranceThemeTransition

   function get_FromHorizontalOffset
   (
      this : in out EntranceThemeTransition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IEntranceThemeTransition.all.get_FromHorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FromHorizontalOffset
   (
      this : in out EntranceThemeTransition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEntranceThemeTransition.all.put_FromHorizontalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FromVerticalOffset
   (
      this : in out EntranceThemeTransition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IEntranceThemeTransition.all.get_FromVerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FromVerticalOffset
   (
      this : in out EntranceThemeTransition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEntranceThemeTransition.all.put_FromVerticalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsStaggeringEnabled
   (
      this : in out EntranceThemeTransition
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IEntranceThemeTransition.all.get_IsStaggeringEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsStaggeringEnabled
   (
      this : in out EntranceThemeTransition;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEntranceThemeTransition.all.put_IsStaggeringEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ExponentialEase

   procedure Initialize (this : in out ExponentialEase) is
   begin
      null;
   end;

   procedure Finalize (this : in out ExponentialEase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IExponentialEase, IExponentialEase_Ptr);
   begin
      if this.m_IExponentialEase /= null then
         if this.m_IExponentialEase.all /= null then
            temp := this.m_IExponentialEase.all.Release;
            Free (this.m_IExponentialEase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ExponentialEase

   function Constructor return ExponentialEase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IExponentialEase");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IExponentialEase;
   begin
      return RetVal : ExponentialEase do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IExponentialEase := new WinUI3.Windows.UI.Xaml.Media.Animation.IExponentialEase;
            Retval.m_IExponentialEase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ExponentialEase

   function get_ExponentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ExponentialEase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IExponentialEaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IExponentialEaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExponentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ExponentialEase

   function get_Exponent
   (
      this : in out ExponentialEase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IExponentialEase.all.get_Exponent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Exponent
   (
      this : in out ExponentialEase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IExponentialEase.all.put_Exponent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FadeInThemeAnimation

   procedure Initialize (this : in out FadeInThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out FadeInThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFadeInThemeAnimation, IFadeInThemeAnimation_Ptr);
   begin
      if this.m_IFadeInThemeAnimation /= null then
         if this.m_IFadeInThemeAnimation.all /= null then
            temp := this.m_IFadeInThemeAnimation.all.Release;
            Free (this.m_IFadeInThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FadeInThemeAnimation

   function Constructor return FadeInThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IFadeInThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IFadeInThemeAnimation;
   begin
      return RetVal : FadeInThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IFadeInThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IFadeInThemeAnimation;
            Retval.m_IFadeInThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FadeInThemeAnimation

   function get_TargetNameProperty_FadeInThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.FadeInThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IFadeInThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFadeInThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FadeInThemeAnimation

   function get_TargetName
   (
      this : in out FadeInThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFadeInThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out FadeInThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IFadeInThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FadeOutThemeAnimation

   procedure Initialize (this : in out FadeOutThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out FadeOutThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFadeOutThemeAnimation, IFadeOutThemeAnimation_Ptr);
   begin
      if this.m_IFadeOutThemeAnimation /= null then
         if this.m_IFadeOutThemeAnimation.all /= null then
            temp := this.m_IFadeOutThemeAnimation.all.Release;
            Free (this.m_IFadeOutThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FadeOutThemeAnimation

   function Constructor return FadeOutThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IFadeOutThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IFadeOutThemeAnimation;
   begin
      return RetVal : FadeOutThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IFadeOutThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IFadeOutThemeAnimation;
            Retval.m_IFadeOutThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FadeOutThemeAnimation

   function get_TargetNameProperty_FadeOutThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.FadeOutThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IFadeOutThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFadeOutThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FadeOutThemeAnimation

   function get_TargetName
   (
      this : in out FadeOutThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFadeOutThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out FadeOutThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IFadeOutThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GravityConnectedAnimationConfiguration

   procedure Initialize (this : in out GravityConnectedAnimationConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out GravityConnectedAnimationConfiguration) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGravityConnectedAnimationConfiguration, IGravityConnectedAnimationConfiguration_Ptr);
   begin
      if this.m_IGravityConnectedAnimationConfiguration /= null then
         if this.m_IGravityConnectedAnimationConfiguration.all /= null then
            temp := this.m_IGravityConnectedAnimationConfiguration.all.Release;
            Free (this.m_IGravityConnectedAnimationConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GravityConnectedAnimationConfiguration

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GravityConnectedAnimationConfiguration is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IGravityConnectedAnimationConfiguration");
      m_Factory    : access IGravityConnectedAnimationConfigurationFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IGravityConnectedAnimationConfiguration;
   begin
      return RetVal : GravityConnectedAnimationConfiguration do
         Hr := RoGetActivationFactory (m_hString, IID_IGravityConnectedAnimationConfigurationFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGravityConnectedAnimationConfiguration := new WinUI3.Windows.UI.Xaml.Media.Animation.IGravityConnectedAnimationConfiguration;
            Retval.m_IGravityConnectedAnimationConfiguration.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GravityConnectedAnimationConfiguration

   function get_IsShadowEnabled
   (
      this : in out GravityConnectedAnimationConfiguration
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.IGravityConnectedAnimationConfiguration2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.IGravityConnectedAnimationConfiguration_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.IGravityConnectedAnimationConfiguration2, WinUI3.Windows.UI.Xaml.Media.Animation.IID_IGravityConnectedAnimationConfiguration2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGravityConnectedAnimationConfiguration.all);
      Hr := m_Interface.get_IsShadowEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsShadowEnabled
   (
      this : in out GravityConnectedAnimationConfiguration;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.IGravityConnectedAnimationConfiguration2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.IGravityConnectedAnimationConfiguration_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.IGravityConnectedAnimationConfiguration2, WinUI3.Windows.UI.Xaml.Media.Animation.IID_IGravityConnectedAnimationConfiguration2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGravityConnectedAnimationConfiguration.all);
      Hr := m_Interface.put_IsShadowEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for KeySpline

   procedure Initialize (this : in out KeySpline) is
   begin
      null;
   end;

   procedure Finalize (this : in out KeySpline) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IKeySpline, IKeySpline_Ptr);
   begin
      if this.m_IKeySpline /= null then
         if this.m_IKeySpline.all /= null then
            temp := this.m_IKeySpline.all.Release;
            Free (this.m_IKeySpline);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for KeySpline

   function Constructor return KeySpline is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IKeySpline");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IKeySpline;
   begin
      return RetVal : KeySpline do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IKeySpline := new WinUI3.Windows.UI.Xaml.Media.Animation.IKeySpline;
            Retval.m_IKeySpline.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for KeySpline

   function get_ControlPoint1
   (
      this : in out KeySpline
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IKeySpline.all.get_ControlPoint1 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ControlPoint1
   (
      this : in out KeySpline;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IKeySpline.all.put_ControlPoint1 (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ControlPoint2
   (
      this : in out KeySpline
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IKeySpline.all.get_ControlPoint2 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ControlPoint2
   (
      this : in out KeySpline;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IKeySpline.all.put_ControlPoint2 (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for KeyTimeHelper

   procedure Initialize (this : in out KeyTimeHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out KeyTimeHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IKeyTimeHelper, IKeyTimeHelper_Ptr);
   begin
      if this.m_IKeyTimeHelper /= null then
         if this.m_IKeyTimeHelper.all /= null then
            temp := this.m_IKeyTimeHelper.all.Release;
            Free (this.m_IKeyTimeHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for KeyTimeHelper

   function FromTimeSpan
   (
      timeSpan : WinUI3.Windows.Foundation.TimeSpan
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.KeyTimeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IKeyTimeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.KeyTime;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IKeyTimeHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromTimeSpan (timeSpan, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for KeyTimeHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LinearColorKeyFrame

   procedure Initialize (this : in out LinearColorKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out LinearColorKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILinearColorKeyFrame, ILinearColorKeyFrame_Ptr);
   begin
      if this.m_ILinearColorKeyFrame /= null then
         if this.m_ILinearColorKeyFrame.all /= null then
            temp := this.m_ILinearColorKeyFrame.all.Release;
            Free (this.m_ILinearColorKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LinearColorKeyFrame

   function Constructor return LinearColorKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ILinearColorKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ILinearColorKeyFrame;
   begin
      return RetVal : LinearColorKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ILinearColorKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.ILinearColorKeyFrame;
            Retval.m_ILinearColorKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LinearColorKeyFrame

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LinearDoubleKeyFrame

   procedure Initialize (this : in out LinearDoubleKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out LinearDoubleKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILinearDoubleKeyFrame, ILinearDoubleKeyFrame_Ptr);
   begin
      if this.m_ILinearDoubleKeyFrame /= null then
         if this.m_ILinearDoubleKeyFrame.all /= null then
            temp := this.m_ILinearDoubleKeyFrame.all.Release;
            Free (this.m_ILinearDoubleKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LinearDoubleKeyFrame

   function Constructor return LinearDoubleKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ILinearDoubleKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ILinearDoubleKeyFrame;
   begin
      return RetVal : LinearDoubleKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ILinearDoubleKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.ILinearDoubleKeyFrame;
            Retval.m_ILinearDoubleKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LinearDoubleKeyFrame

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LinearPointKeyFrame

   procedure Initialize (this : in out LinearPointKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out LinearPointKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILinearPointKeyFrame, ILinearPointKeyFrame_Ptr);
   begin
      if this.m_ILinearPointKeyFrame /= null then
         if this.m_ILinearPointKeyFrame.all /= null then
            temp := this.m_ILinearPointKeyFrame.all.Release;
            Free (this.m_ILinearPointKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LinearPointKeyFrame

   function Constructor return LinearPointKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ILinearPointKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ILinearPointKeyFrame;
   begin
      return RetVal : LinearPointKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ILinearPointKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.ILinearPointKeyFrame;
            Retval.m_ILinearPointKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LinearPointKeyFrame

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationThemeTransition

   procedure Initialize (this : in out NavigationThemeTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationThemeTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationThemeTransition, INavigationThemeTransition_Ptr);
   begin
      if this.m_INavigationThemeTransition /= null then
         if this.m_INavigationThemeTransition.all /= null then
            temp := this.m_INavigationThemeTransition.all.Release;
            Free (this.m_INavigationThemeTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationThemeTransition

   function Constructor return NavigationThemeTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.INavigationThemeTransition");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.INavigationThemeTransition;
   begin
      return RetVal : NavigationThemeTransition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_INavigationThemeTransition := new WinUI3.Windows.UI.Xaml.Media.Animation.INavigationThemeTransition;
            Retval.m_INavigationThemeTransition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for NavigationThemeTransition

   function get_DefaultNavigationTransitionInfoProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.NavigationThemeTransition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.INavigationThemeTransitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationThemeTransitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultNavigationTransitionInfoProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationThemeTransition

   function get_DefaultNavigationTransitionInfo
   (
      this : in out NavigationThemeTransition
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.NavigationTransitionInfo'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfo;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.NavigationTransitionInfo do
         Hr := this.m_INavigationThemeTransition.all.get_DefaultNavigationTransitionInfo (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationTransitionInfo := new WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfo;
         Retval.m_INavigationTransitionInfo.all := m_ComRetVal;
      end return;
   end;

   procedure put_DefaultNavigationTransitionInfo
   (
      this : in out NavigationThemeTransition;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.NavigationTransitionInfo'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationThemeTransition.all.put_DefaultNavigationTransitionInfo (value.m_INavigationTransitionInfo.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ObjectAnimationUsingKeyFrames

   procedure Initialize (this : in out ObjectAnimationUsingKeyFrames) is
   begin
      null;
   end;

   procedure Finalize (this : in out ObjectAnimationUsingKeyFrames) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IObjectAnimationUsingKeyFrames, IObjectAnimationUsingKeyFrames_Ptr);
   begin
      if this.m_IObjectAnimationUsingKeyFrames /= null then
         if this.m_IObjectAnimationUsingKeyFrames.all /= null then
            temp := this.m_IObjectAnimationUsingKeyFrames.all.Release;
            Free (this.m_IObjectAnimationUsingKeyFrames);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ObjectAnimationUsingKeyFrames

   function Constructor return ObjectAnimationUsingKeyFrames is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IObjectAnimationUsingKeyFrames");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IObjectAnimationUsingKeyFrames;
   begin
      return RetVal : ObjectAnimationUsingKeyFrames do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IObjectAnimationUsingKeyFrames := new WinUI3.Windows.UI.Xaml.Media.Animation.IObjectAnimationUsingKeyFrames;
            Retval.m_IObjectAnimationUsingKeyFrames.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ObjectAnimationUsingKeyFrames

   function get_EnableDependentAnimationProperty_ObjectAnimationUsingKeyFrames
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ObjectAnimationUsingKeyFrames");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IObjectAnimationUsingKeyFramesStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IObjectAnimationUsingKeyFramesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EnableDependentAnimationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ObjectAnimationUsingKeyFrames

   function get_KeyFrames
   (
      this : in out ObjectAnimationUsingKeyFrames
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection do
         Hr := this.m_IObjectAnimationUsingKeyFrames.all.get_KeyFrames (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_EnableDependentAnimation
   (
      this : in out ObjectAnimationUsingKeyFrames
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IObjectAnimationUsingKeyFrames.all.get_EnableDependentAnimation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EnableDependentAnimation
   (
      this : in out ObjectAnimationUsingKeyFrames;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IObjectAnimationUsingKeyFrames.all.put_EnableDependentAnimation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ObjectKeyFrameCollection

   procedure Initialize (this : in out ObjectKeyFrameCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out ObjectKeyFrameCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ObjectKeyFrameCollection

   function Constructor return ObjectKeyFrameCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("GenericObject");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : ObjectKeyFrameCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ObjectKeyFrameCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.Animation.ObjectKeyFrame>
   function GetAt
   (
      this : in out ObjectKeyFrameCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IObjectKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrame;
         Retval.m_IObjectKeyFrame.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out ObjectKeyFrameCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out ObjectKeyFrameCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IObjectKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrame;
         Retval.m_IObjectKeyFrame.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out ObjectKeyFrameCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrame'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IObjectKeyFrame.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out ObjectKeyFrameCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IObjectKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out ObjectKeyFrameCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IObjectKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out ObjectKeyFrameCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out ObjectKeyFrameCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IObjectKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out ObjectKeyFrameCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out ObjectKeyFrameCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out ObjectKeyFrameCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrame_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out ObjectKeyFrameCollection;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrame_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1601387839, 29350, 21251, (151, 39, 43, 3, 234, 231, 221, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.Animation.ObjectKeyFrame>
   function First
   (
      this : in out ObjectKeyFrameCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IObjectKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (2424613089, 36685, 24035, (177, 198, 229, 240, 87, 36, 202, 237 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IObjectKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ObjectKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IObjectKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IObjectKeyFrame;
         Retval.m_IObjectKeyFrame.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PaneThemeTransition

   procedure Initialize (this : in out PaneThemeTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out PaneThemeTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPaneThemeTransition, IPaneThemeTransition_Ptr);
   begin
      if this.m_IPaneThemeTransition /= null then
         if this.m_IPaneThemeTransition.all /= null then
            temp := this.m_IPaneThemeTransition.all.Release;
            Free (this.m_IPaneThemeTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PaneThemeTransition

   function Constructor return PaneThemeTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IPaneThemeTransition");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPaneThemeTransition;
   begin
      return RetVal : PaneThemeTransition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPaneThemeTransition := new WinUI3.Windows.UI.Xaml.Media.Animation.IPaneThemeTransition;
            Retval.m_IPaneThemeTransition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PaneThemeTransition

   function get_EdgeProperty_PaneThemeTransition
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PaneThemeTransition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPaneThemeTransitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPaneThemeTransitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EdgeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PaneThemeTransition

   function get_Edge
   (
      this : in out PaneThemeTransition
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.EdgeTransitionLocation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.EdgeTransitionLocation;
   begin
      Hr := this.m_IPaneThemeTransition.all.get_Edge (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Edge
   (
      this : in out PaneThemeTransition;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.EdgeTransitionLocation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPaneThemeTransition.all.put_Edge (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointAnimation

   procedure Initialize (this : in out PointAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointAnimation, IPointAnimation_Ptr);
   begin
      if this.m_IPointAnimation /= null then
         if this.m_IPointAnimation.all /= null then
            temp := this.m_IPointAnimation.all.Release;
            Free (this.m_IPointAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PointAnimation

   function Constructor return PointAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IPointAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPointAnimation;
   begin
      return RetVal : PointAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPointAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IPointAnimation;
            Retval.m_IPointAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PointAnimation

   function get_FromProperty_PointAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PointAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPointAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPointAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ToProperty_PointAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PointAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPointAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPointAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ToProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ByProperty_PointAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PointAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPointAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPointAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ByProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_EasingFunctionProperty_PointAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PointAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPointAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPointAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EasingFunctionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_EnableDependentAnimationProperty_PointAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PointAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPointAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPointAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EnableDependentAnimationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointAnimation

   function get_From
   (
      this : in out PointAnimation
   )
   return IReference_Point.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Point.Kind;
   begin
      Hr := this.m_IPointAnimation.all.get_From (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Point (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_From
   (
      this : in out PointAnimation;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPointAnimation.all.put_From (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_To
   (
      this : in out PointAnimation
   )
   return IReference_Point.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Point.Kind;
   begin
      Hr := this.m_IPointAnimation.all.get_To (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Point (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_To
   (
      this : in out PointAnimation;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPointAnimation.all.put_To (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_By
   (
      this : in out PointAnimation
   )
   return IReference_Point.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Point.Kind;
   begin
      Hr := this.m_IPointAnimation.all.get_By (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Point (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_By
   (
      this : in out PointAnimation;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPointAnimation.all.put_By (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EasingFunction
   (
      this : in out PointAnimation
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase do
         Hr := this.m_IPointAnimation.all.get_EasingFunction (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IEasingFunctionBase := new WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
         Retval.m_IEasingFunctionBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_EasingFunction
   (
      this : in out PointAnimation;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPointAnimation.all.put_EasingFunction (value.m_IEasingFunctionBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EnableDependentAnimation
   (
      this : in out PointAnimation
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointAnimation.all.get_EnableDependentAnimation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EnableDependentAnimation
   (
      this : in out PointAnimation;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPointAnimation.all.put_EnableDependentAnimation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointAnimationUsingKeyFrames

   procedure Initialize (this : in out PointAnimationUsingKeyFrames) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointAnimationUsingKeyFrames) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointAnimationUsingKeyFrames, IPointAnimationUsingKeyFrames_Ptr);
   begin
      if this.m_IPointAnimationUsingKeyFrames /= null then
         if this.m_IPointAnimationUsingKeyFrames.all /= null then
            temp := this.m_IPointAnimationUsingKeyFrames.all.Release;
            Free (this.m_IPointAnimationUsingKeyFrames);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PointAnimationUsingKeyFrames

   function Constructor return PointAnimationUsingKeyFrames is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IPointAnimationUsingKeyFrames");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPointAnimationUsingKeyFrames;
   begin
      return RetVal : PointAnimationUsingKeyFrames do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPointAnimationUsingKeyFrames := new WinUI3.Windows.UI.Xaml.Media.Animation.IPointAnimationUsingKeyFrames;
            Retval.m_IPointAnimationUsingKeyFrames.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PointAnimationUsingKeyFrames

   function get_EnableDependentAnimationProperty_PointAnimationUsingKeyFrames
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PointAnimationUsingKeyFrames");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPointAnimationUsingKeyFramesStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPointAnimationUsingKeyFramesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EnableDependentAnimationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointAnimationUsingKeyFrames

   function get_KeyFrames
   (
      this : in out PointAnimationUsingKeyFrames
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection do
         Hr := this.m_IPointAnimationUsingKeyFrames.all.get_KeyFrames (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_EnableDependentAnimation
   (
      this : in out PointAnimationUsingKeyFrames
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointAnimationUsingKeyFrames.all.get_EnableDependentAnimation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EnableDependentAnimation
   (
      this : in out PointAnimationUsingKeyFrames;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPointAnimationUsingKeyFrames.all.put_EnableDependentAnimation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointKeyFrameCollection

   procedure Initialize (this : in out PointKeyFrameCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointKeyFrameCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PointKeyFrameCollection

   function Constructor return PointKeyFrameCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("GenericObject");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : PointKeyFrameCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointKeyFrameCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.Animation.PointKeyFrame>
   function GetAt
   (
      this : in out PointKeyFrameCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrame;
         Retval.m_IPointKeyFrame.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out PointKeyFrameCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out PointKeyFrameCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrame;
         Retval.m_IPointKeyFrame.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out PointKeyFrameCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrame'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IPointKeyFrame.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out PointKeyFrameCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IPointKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out PointKeyFrameCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IPointKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out PointKeyFrameCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out PointKeyFrameCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrame'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IPointKeyFrame.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out PointKeyFrameCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out PointKeyFrameCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out PointKeyFrameCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrame_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out PointKeyFrameCollection;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrame_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2977834718, 40151, 21590, (190, 224, 73, 136, 42, 135, 249, 69 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.Animation.PointKeyFrame>
   function First
   (
      this : in out PointKeyFrameCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IPointKeyFrame.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrame;
      m_GenericIID     : aliased WinUI3.IID := (3101576649, 35945, 22003, (175, 88, 4, 15, 19, 25, 100, 156 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IPointKeyFrame.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.PointKeyFrame do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.IPointKeyFrame;
         Retval.m_IPointKeyFrame.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointerDownThemeAnimation

   procedure Initialize (this : in out PointerDownThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointerDownThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointerDownThemeAnimation, IPointerDownThemeAnimation_Ptr);
   begin
      if this.m_IPointerDownThemeAnimation /= null then
         if this.m_IPointerDownThemeAnimation.all /= null then
            temp := this.m_IPointerDownThemeAnimation.all.Release;
            Free (this.m_IPointerDownThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PointerDownThemeAnimation

   function Constructor return PointerDownThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IPointerDownThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPointerDownThemeAnimation;
   begin
      return RetVal : PointerDownThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPointerDownThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IPointerDownThemeAnimation;
            Retval.m_IPointerDownThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PointerDownThemeAnimation

   function get_TargetNameProperty_PointerDownThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PointerDownThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPointerDownThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPointerDownThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointerDownThemeAnimation

   function get_TargetName
   (
      this : in out PointerDownThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPointerDownThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out PointerDownThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPointerDownThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointerUpThemeAnimation

   procedure Initialize (this : in out PointerUpThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointerUpThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointerUpThemeAnimation, IPointerUpThemeAnimation_Ptr);
   begin
      if this.m_IPointerUpThemeAnimation /= null then
         if this.m_IPointerUpThemeAnimation.all /= null then
            temp := this.m_IPointerUpThemeAnimation.all.Release;
            Free (this.m_IPointerUpThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PointerUpThemeAnimation

   function Constructor return PointerUpThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IPointerUpThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPointerUpThemeAnimation;
   begin
      return RetVal : PointerUpThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPointerUpThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IPointerUpThemeAnimation;
            Retval.m_IPointerUpThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PointerUpThemeAnimation

   function get_TargetNameProperty_PointerUpThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PointerUpThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPointerUpThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPointerUpThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointerUpThemeAnimation

   function get_TargetName
   (
      this : in out PointerUpThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPointerUpThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out PointerUpThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPointerUpThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PopInThemeAnimation

   procedure Initialize (this : in out PopInThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out PopInThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPopInThemeAnimation, IPopInThemeAnimation_Ptr);
   begin
      if this.m_IPopInThemeAnimation /= null then
         if this.m_IPopInThemeAnimation.all /= null then
            temp := this.m_IPopInThemeAnimation.all.Release;
            Free (this.m_IPopInThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PopInThemeAnimation

   function Constructor return PopInThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IPopInThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPopInThemeAnimation;
   begin
      return RetVal : PopInThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPopInThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IPopInThemeAnimation;
            Retval.m_IPopInThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PopInThemeAnimation

   function get_TargetNameProperty_PopInThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PopInThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPopInThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopInThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FromHorizontalOffsetProperty_PopInThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PopInThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPopInThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopInThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromHorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FromVerticalOffsetProperty_PopInThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PopInThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPopInThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopInThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromVerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PopInThemeAnimation

   function get_TargetName
   (
      this : in out PopInThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPopInThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out PopInThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPopInThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_FromHorizontalOffset
   (
      this : in out PopInThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPopInThemeAnimation.all.get_FromHorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FromHorizontalOffset
   (
      this : in out PopInThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopInThemeAnimation.all.put_FromHorizontalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FromVerticalOffset
   (
      this : in out PopInThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPopInThemeAnimation.all.get_FromVerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FromVerticalOffset
   (
      this : in out PopInThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopInThemeAnimation.all.put_FromVerticalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PopOutThemeAnimation

   procedure Initialize (this : in out PopOutThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out PopOutThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPopOutThemeAnimation, IPopOutThemeAnimation_Ptr);
   begin
      if this.m_IPopOutThemeAnimation /= null then
         if this.m_IPopOutThemeAnimation.all /= null then
            temp := this.m_IPopOutThemeAnimation.all.Release;
            Free (this.m_IPopOutThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PopOutThemeAnimation

   function Constructor return PopOutThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IPopOutThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPopOutThemeAnimation;
   begin
      return RetVal : PopOutThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPopOutThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IPopOutThemeAnimation;
            Retval.m_IPopOutThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PopOutThemeAnimation

   function get_TargetNameProperty_PopOutThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PopOutThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPopOutThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopOutThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PopOutThemeAnimation

   function get_TargetName
   (
      this : in out PopOutThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPopOutThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out PopOutThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPopOutThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PopupThemeTransition

   procedure Initialize (this : in out PopupThemeTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out PopupThemeTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPopupThemeTransition, IPopupThemeTransition_Ptr);
   begin
      if this.m_IPopupThemeTransition /= null then
         if this.m_IPopupThemeTransition.all /= null then
            temp := this.m_IPopupThemeTransition.all.Release;
            Free (this.m_IPopupThemeTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PopupThemeTransition

   function Constructor return PopupThemeTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IPopupThemeTransition");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPopupThemeTransition;
   begin
      return RetVal : PopupThemeTransition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPopupThemeTransition := new WinUI3.Windows.UI.Xaml.Media.Animation.IPopupThemeTransition;
            Retval.m_IPopupThemeTransition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PopupThemeTransition

   function get_FromHorizontalOffsetProperty_PopupThemeTransition
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PopupThemeTransition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPopupThemeTransitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupThemeTransitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromHorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FromVerticalOffsetProperty_PopupThemeTransition
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PopupThemeTransition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPopupThemeTransitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupThemeTransitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromVerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PopupThemeTransition

   function get_FromHorizontalOffset
   (
      this : in out PopupThemeTransition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPopupThemeTransition.all.get_FromHorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FromHorizontalOffset
   (
      this : in out PopupThemeTransition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopupThemeTransition.all.put_FromHorizontalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FromVerticalOffset
   (
      this : in out PopupThemeTransition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPopupThemeTransition.all.get_FromVerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FromVerticalOffset
   (
      this : in out PopupThemeTransition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopupThemeTransition.all.put_FromVerticalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PowerEase

   procedure Initialize (this : in out PowerEase) is
   begin
      null;
   end;

   procedure Finalize (this : in out PowerEase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPowerEase, IPowerEase_Ptr);
   begin
      if this.m_IPowerEase /= null then
         if this.m_IPowerEase.all /= null then
            temp := this.m_IPowerEase.all.Release;
            Free (this.m_IPowerEase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PowerEase

   function Constructor return PowerEase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IPowerEase");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IPowerEase;
   begin
      return RetVal : PowerEase do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPowerEase := new WinUI3.Windows.UI.Xaml.Media.Animation.IPowerEase;
            Retval.m_IPowerEase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PowerEase

   function get_PowerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.PowerEase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IPowerEaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPowerEaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PowerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PowerEase

   function get_Power
   (
      this : in out PowerEase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPowerEase.all.get_Power (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Power
   (
      this : in out PowerEase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPowerEase.all.put_Power (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for QuadraticEase

   procedure Initialize (this : in out QuadraticEase) is
   begin
      null;
   end;

   procedure Finalize (this : in out QuadraticEase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IQuadraticEase, IQuadraticEase_Ptr);
   begin
      if this.m_IQuadraticEase /= null then
         if this.m_IQuadraticEase.all /= null then
            temp := this.m_IQuadraticEase.all.Release;
            Free (this.m_IQuadraticEase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for QuadraticEase

   function Constructor return QuadraticEase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IQuadraticEase");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IQuadraticEase;
   begin
      return RetVal : QuadraticEase do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IQuadraticEase := new WinUI3.Windows.UI.Xaml.Media.Animation.IQuadraticEase;
            Retval.m_IQuadraticEase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for QuadraticEase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for QuarticEase

   procedure Initialize (this : in out QuarticEase) is
   begin
      null;
   end;

   procedure Finalize (this : in out QuarticEase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IQuarticEase, IQuarticEase_Ptr);
   begin
      if this.m_IQuarticEase /= null then
         if this.m_IQuarticEase.all /= null then
            temp := this.m_IQuarticEase.all.Release;
            Free (this.m_IQuarticEase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for QuarticEase

   function Constructor return QuarticEase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IQuarticEase");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IQuarticEase;
   begin
      return RetVal : QuarticEase do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IQuarticEase := new WinUI3.Windows.UI.Xaml.Media.Animation.IQuarticEase;
            Retval.m_IQuarticEase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for QuarticEase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for QuinticEase

   procedure Initialize (this : in out QuinticEase) is
   begin
      null;
   end;

   procedure Finalize (this : in out QuinticEase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IQuinticEase, IQuinticEase_Ptr);
   begin
      if this.m_IQuinticEase /= null then
         if this.m_IQuinticEase.all /= null then
            temp := this.m_IQuinticEase.all.Release;
            Free (this.m_IQuinticEase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for QuinticEase

   function Constructor return QuinticEase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IQuinticEase");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IQuinticEase;
   begin
      return RetVal : QuinticEase do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IQuinticEase := new WinUI3.Windows.UI.Xaml.Media.Animation.IQuinticEase;
            Retval.m_IQuinticEase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for QuinticEase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ReorderThemeTransition

   procedure Initialize (this : in out ReorderThemeTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out ReorderThemeTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IReorderThemeTransition, IReorderThemeTransition_Ptr);
   begin
      if this.m_IReorderThemeTransition /= null then
         if this.m_IReorderThemeTransition.all /= null then
            temp := this.m_IReorderThemeTransition.all.Release;
            Free (this.m_IReorderThemeTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ReorderThemeTransition

   function Constructor return ReorderThemeTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IReorderThemeTransition");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IReorderThemeTransition;
   begin
      return RetVal : ReorderThemeTransition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IReorderThemeTransition := new WinUI3.Windows.UI.Xaml.Media.Animation.IReorderThemeTransition;
            Retval.m_IReorderThemeTransition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ReorderThemeTransition

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RepeatBehaviorHelper

   procedure Initialize (this : in out RepeatBehaviorHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out RepeatBehaviorHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRepeatBehaviorHelper, IRepeatBehaviorHelper_Ptr);
   begin
      if this.m_IRepeatBehaviorHelper /= null then
         if this.m_IRepeatBehaviorHelper.all /= null then
            temp := this.m_IRepeatBehaviorHelper.all.Release;
            Free (this.m_IRepeatBehaviorHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RepeatBehaviorHelper

   function get_Forever
   return WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IRepeatBehaviorHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRepeatBehaviorHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Forever (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromCount
   (
      count : WinUI3.Double
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IRepeatBehaviorHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRepeatBehaviorHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromCount (count, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromDuration
   (
      duration : WinUI3.Windows.Foundation.TimeSpan
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IRepeatBehaviorHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRepeatBehaviorHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromDuration (duration, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetHasCount
   (
      target : WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IRepeatBehaviorHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRepeatBehaviorHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetHasCount (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetHasDuration
   (
      target : WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IRepeatBehaviorHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRepeatBehaviorHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetHasDuration (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Equals
   (
      target : WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.RepeatBehavior
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IRepeatBehaviorHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRepeatBehaviorHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Equals (target, value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RepeatBehaviorHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RepositionThemeAnimation

   procedure Initialize (this : in out RepositionThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out RepositionThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRepositionThemeAnimation, IRepositionThemeAnimation_Ptr);
   begin
      if this.m_IRepositionThemeAnimation /= null then
         if this.m_IRepositionThemeAnimation.all /= null then
            temp := this.m_IRepositionThemeAnimation.all.Release;
            Free (this.m_IRepositionThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RepositionThemeAnimation

   function Constructor return RepositionThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IRepositionThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeAnimation;
   begin
      return RetVal : RepositionThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRepositionThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeAnimation;
            Retval.m_IRepositionThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RepositionThemeAnimation

   function get_TargetNameProperty_RepositionThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRepositionThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FromHorizontalOffsetProperty_RepositionThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRepositionThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromHorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FromVerticalOffsetProperty_RepositionThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRepositionThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromVerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RepositionThemeAnimation

   function get_TargetName
   (
      this : in out RepositionThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRepositionThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out RepositionThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRepositionThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_FromHorizontalOffset
   (
      this : in out RepositionThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRepositionThemeAnimation.all.get_FromHorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FromHorizontalOffset
   (
      this : in out RepositionThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRepositionThemeAnimation.all.put_FromHorizontalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FromVerticalOffset
   (
      this : in out RepositionThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRepositionThemeAnimation.all.get_FromVerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FromVerticalOffset
   (
      this : in out RepositionThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRepositionThemeAnimation.all.put_FromVerticalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RepositionThemeTransition

   procedure Initialize (this : in out RepositionThemeTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out RepositionThemeTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRepositionThemeTransition, IRepositionThemeTransition_Ptr);
   begin
      if this.m_IRepositionThemeTransition /= null then
         if this.m_IRepositionThemeTransition.all /= null then
            temp := this.m_IRepositionThemeTransition.all.Release;
            Free (this.m_IRepositionThemeTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RepositionThemeTransition

   function Constructor return RepositionThemeTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IRepositionThemeTransition");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeTransition;
   begin
      return RetVal : RepositionThemeTransition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRepositionThemeTransition := new WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeTransition;
            Retval.m_IRepositionThemeTransition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RepositionThemeTransition

   function get_IsStaggeringEnabledProperty_RepositionThemeTransition
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.RepositionThemeTransition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeTransitionStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRepositionThemeTransitionStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStaggeringEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RepositionThemeTransition

   function get_IsStaggeringEnabled
   (
      this : in out RepositionThemeTransition
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeTransition2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeTransition_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeTransition2, WinUI3.Windows.UI.Xaml.Media.Animation.IID_IRepositionThemeTransition2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRepositionThemeTransition.all);
      Hr := m_Interface.get_IsStaggeringEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsStaggeringEnabled
   (
      this : in out RepositionThemeTransition;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeTransition2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeTransition_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.IRepositionThemeTransition2, WinUI3.Windows.UI.Xaml.Media.Animation.IID_IRepositionThemeTransition2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRepositionThemeTransition.all);
      Hr := m_Interface.put_IsStaggeringEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SineEase

   procedure Initialize (this : in out SineEase) is
   begin
      null;
   end;

   procedure Finalize (this : in out SineEase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISineEase, ISineEase_Ptr);
   begin
      if this.m_ISineEase /= null then
         if this.m_ISineEase.all /= null then
            temp := this.m_ISineEase.all.Release;
            Free (this.m_ISineEase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SineEase

   function Constructor return SineEase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ISineEase");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ISineEase;
   begin
      return RetVal : SineEase do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISineEase := new WinUI3.Windows.UI.Xaml.Media.Animation.ISineEase;
            Retval.m_ISineEase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SineEase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SlideNavigationTransitionInfo

   procedure Initialize (this : in out SlideNavigationTransitionInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out SlideNavigationTransitionInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISlideNavigationTransitionInfo, ISlideNavigationTransitionInfo_Ptr);
   begin
      if this.m_ISlideNavigationTransitionInfo /= null then
         if this.m_ISlideNavigationTransitionInfo.all /= null then
            temp := this.m_ISlideNavigationTransitionInfo.all.Release;
            Free (this.m_ISlideNavigationTransitionInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SlideNavigationTransitionInfo

   function Constructor return SlideNavigationTransitionInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ISlideNavigationTransitionInfo");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ISlideNavigationTransitionInfo;
   begin
      return RetVal : SlideNavigationTransitionInfo do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISlideNavigationTransitionInfo := new WinUI3.Windows.UI.Xaml.Media.Animation.ISlideNavigationTransitionInfo;
            Retval.m_ISlideNavigationTransitionInfo.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SlideNavigationTransitionInfo

   function get_EffectProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SlideNavigationTransitionInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISlideNavigationTransitionInfoStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISlideNavigationTransitionInfoStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EffectProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SlideNavigationTransitionInfo

   function get_Effect
   (
      this : in out SlideNavigationTransitionInfo
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.SlideNavigationTransitionEffect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.ISlideNavigationTransitionInfo2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.SlideNavigationTransitionEffect;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.ISlideNavigationTransitionInfo_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.ISlideNavigationTransitionInfo2, WinUI3.Windows.UI.Xaml.Media.Animation.IID_ISlideNavigationTransitionInfo2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISlideNavigationTransitionInfo.all);
      Hr := m_Interface.get_Effect (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Effect
   (
      this : in out SlideNavigationTransitionInfo;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.SlideNavigationTransitionEffect
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.Animation.ISlideNavigationTransitionInfo2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.Animation.ISlideNavigationTransitionInfo_Interface, WinUI3.Windows.UI.Xaml.Media.Animation.ISlideNavigationTransitionInfo2, WinUI3.Windows.UI.Xaml.Media.Animation.IID_ISlideNavigationTransitionInfo2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISlideNavigationTransitionInfo.all);
      Hr := m_Interface.put_Effect (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplineColorKeyFrame

   procedure Initialize (this : in out SplineColorKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplineColorKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplineColorKeyFrame, ISplineColorKeyFrame_Ptr);
   begin
      if this.m_ISplineColorKeyFrame /= null then
         if this.m_ISplineColorKeyFrame.all /= null then
            temp := this.m_ISplineColorKeyFrame.all.Release;
            Free (this.m_ISplineColorKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SplineColorKeyFrame

   function Constructor return SplineColorKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ISplineColorKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ISplineColorKeyFrame;
   begin
      return RetVal : SplineColorKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISplineColorKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.ISplineColorKeyFrame;
            Retval.m_ISplineColorKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SplineColorKeyFrame

   function get_KeySplineProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplineColorKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplineColorKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplineColorKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeySplineProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplineColorKeyFrame

   function get_KeySpline
   (
      this : in out SplineColorKeyFrame
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.KeySpline'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IKeySpline;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.KeySpline do
         Hr := this.m_ISplineColorKeyFrame.all.get_KeySpline (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IKeySpline := new WinUI3.Windows.UI.Xaml.Media.Animation.IKeySpline;
         Retval.m_IKeySpline.all := m_ComRetVal;
      end return;
   end;

   procedure put_KeySpline
   (
      this : in out SplineColorKeyFrame;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.KeySpline'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplineColorKeyFrame.all.put_KeySpline (value.m_IKeySpline.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplineDoubleKeyFrame

   procedure Initialize (this : in out SplineDoubleKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplineDoubleKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplineDoubleKeyFrame, ISplineDoubleKeyFrame_Ptr);
   begin
      if this.m_ISplineDoubleKeyFrame /= null then
         if this.m_ISplineDoubleKeyFrame.all /= null then
            temp := this.m_ISplineDoubleKeyFrame.all.Release;
            Free (this.m_ISplineDoubleKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SplineDoubleKeyFrame

   function Constructor return SplineDoubleKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ISplineDoubleKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ISplineDoubleKeyFrame;
   begin
      return RetVal : SplineDoubleKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISplineDoubleKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.ISplineDoubleKeyFrame;
            Retval.m_ISplineDoubleKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SplineDoubleKeyFrame

   function get_KeySplineProperty_SplineDoubleKeyFrame
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplineDoubleKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplineDoubleKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplineDoubleKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeySplineProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplineDoubleKeyFrame

   function get_KeySpline
   (
      this : in out SplineDoubleKeyFrame
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.KeySpline'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IKeySpline;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.KeySpline do
         Hr := this.m_ISplineDoubleKeyFrame.all.get_KeySpline (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IKeySpline := new WinUI3.Windows.UI.Xaml.Media.Animation.IKeySpline;
         Retval.m_IKeySpline.all := m_ComRetVal;
      end return;
   end;

   procedure put_KeySpline
   (
      this : in out SplineDoubleKeyFrame;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.KeySpline'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplineDoubleKeyFrame.all.put_KeySpline (value.m_IKeySpline.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplinePointKeyFrame

   procedure Initialize (this : in out SplinePointKeyFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplinePointKeyFrame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplinePointKeyFrame, ISplinePointKeyFrame_Ptr);
   begin
      if this.m_ISplinePointKeyFrame /= null then
         if this.m_ISplinePointKeyFrame.all /= null then
            temp := this.m_ISplinePointKeyFrame.all.Release;
            Free (this.m_ISplinePointKeyFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SplinePointKeyFrame

   function Constructor return SplinePointKeyFrame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ISplinePointKeyFrame");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ISplinePointKeyFrame;
   begin
      return RetVal : SplinePointKeyFrame do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISplinePointKeyFrame := new WinUI3.Windows.UI.Xaml.Media.Animation.ISplinePointKeyFrame;
            Retval.m_ISplinePointKeyFrame.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SplinePointKeyFrame

   function get_KeySplineProperty_SplinePointKeyFrame
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplinePointKeyFrame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplinePointKeyFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplinePointKeyFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeySplineProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplinePointKeyFrame

   function get_KeySpline
   (
      this : in out SplinePointKeyFrame
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.KeySpline'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IKeySpline;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.KeySpline do
         Hr := this.m_ISplinePointKeyFrame.all.get_KeySpline (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IKeySpline := new WinUI3.Windows.UI.Xaml.Media.Animation.IKeySpline;
         Retval.m_IKeySpline.all := m_ComRetVal;
      end return;
   end;

   procedure put_KeySpline
   (
      this : in out SplinePointKeyFrame;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.KeySpline'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplinePointKeyFrame.all.put_KeySpline (value.m_IKeySpline.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitCloseThemeAnimation

   procedure Initialize (this : in out SplitCloseThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitCloseThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitCloseThemeAnimation, ISplitCloseThemeAnimation_Ptr);
   begin
      if this.m_ISplitCloseThemeAnimation /= null then
         if this.m_ISplitCloseThemeAnimation.all /= null then
            temp := this.m_ISplitCloseThemeAnimation.all.Release;
            Free (this.m_ISplitCloseThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SplitCloseThemeAnimation

   function Constructor return SplitCloseThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimation;
   begin
      return RetVal : SplitCloseThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISplitCloseThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimation;
            Retval.m_ISplitCloseThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SplitCloseThemeAnimation

   function get_OpenedTargetNameProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitCloseThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpenedTargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpenedTargetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitCloseThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpenedTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClosedTargetNameProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitCloseThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClosedTargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClosedTargetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitCloseThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClosedTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTargetNameProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitCloseThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTargetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitCloseThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpenedLengthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitCloseThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpenedLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClosedLengthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitCloseThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClosedLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OffsetFromCenterProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitCloseThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OffsetFromCenterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTranslationDirectionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitCloseThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTranslationDirectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTranslationOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitCloseThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTranslationOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitCloseThemeAnimation

   function get_OpenedTargetName
   (
      this : in out SplitCloseThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.get_OpenedTargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_OpenedTargetName
   (
      this : in out SplitCloseThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.put_OpenedTargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_OpenedTarget
   (
      this : in out SplitCloseThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_ISplitCloseThemeAnimation.all.get_OpenedTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_OpenedTarget
   (
      this : in out SplitCloseThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.put_OpenedTarget (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ClosedTargetName
   (
      this : in out SplitCloseThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.get_ClosedTargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ClosedTargetName
   (
      this : in out SplitCloseThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.put_ClosedTargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ClosedTarget
   (
      this : in out SplitCloseThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_ISplitCloseThemeAnimation.all.get_ClosedTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ClosedTarget
   (
      this : in out SplitCloseThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.put_ClosedTarget (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTargetName
   (
      this : in out SplitCloseThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.get_ContentTargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ContentTargetName
   (
      this : in out SplitCloseThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.put_ContentTargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ContentTarget
   (
      this : in out SplitCloseThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_ISplitCloseThemeAnimation.all.get_ContentTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTarget
   (
      this : in out SplitCloseThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.put_ContentTarget (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpenedLength
   (
      this : in out SplitCloseThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.get_OpenedLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpenedLength
   (
      this : in out SplitCloseThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.put_OpenedLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ClosedLength
   (
      this : in out SplitCloseThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.get_ClosedLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ClosedLength
   (
      this : in out SplitCloseThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.put_ClosedLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OffsetFromCenter
   (
      this : in out SplitCloseThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.get_OffsetFromCenter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OffsetFromCenter
   (
      this : in out SplitCloseThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.put_OffsetFromCenter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTranslationDirection
   (
      this : in out SplitCloseThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.AnimationDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.AnimationDirection;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.get_ContentTranslationDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ContentTranslationDirection
   (
      this : in out SplitCloseThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.AnimationDirection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.put_ContentTranslationDirection (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTranslationOffset
   (
      this : in out SplitCloseThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.get_ContentTranslationOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ContentTranslationOffset
   (
      this : in out SplitCloseThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitCloseThemeAnimation.all.put_ContentTranslationOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitOpenThemeAnimation

   procedure Initialize (this : in out SplitOpenThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitOpenThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitOpenThemeAnimation, ISplitOpenThemeAnimation_Ptr);
   begin
      if this.m_ISplitOpenThemeAnimation /= null then
         if this.m_ISplitOpenThemeAnimation.all /= null then
            temp := this.m_ISplitOpenThemeAnimation.all.Release;
            Free (this.m_ISplitOpenThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SplitOpenThemeAnimation

   function Constructor return SplitOpenThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimation;
   begin
      return RetVal : SplitOpenThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISplitOpenThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimation;
            Retval.m_ISplitOpenThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SplitOpenThemeAnimation

   function get_OpenedTargetNameProperty_SplitOpenThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitOpenThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpenedTargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpenedTargetProperty_SplitOpenThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitOpenThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpenedTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClosedTargetNameProperty_SplitOpenThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitOpenThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClosedTargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClosedTargetProperty_SplitOpenThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitOpenThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClosedTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTargetNameProperty_SplitOpenThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitOpenThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTargetProperty_SplitOpenThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitOpenThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpenedLengthProperty_SplitOpenThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitOpenThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpenedLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClosedLengthProperty_SplitOpenThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitOpenThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClosedLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OffsetFromCenterProperty_SplitOpenThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitOpenThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OffsetFromCenterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTranslationDirectionProperty_SplitOpenThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitOpenThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTranslationDirectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTranslationOffsetProperty_SplitOpenThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitOpenThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTranslationOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitOpenThemeAnimation

   function get_OpenedTargetName
   (
      this : in out SplitOpenThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.get_OpenedTargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_OpenedTargetName
   (
      this : in out SplitOpenThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.put_OpenedTargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_OpenedTarget
   (
      this : in out SplitOpenThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_ISplitOpenThemeAnimation.all.get_OpenedTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_OpenedTarget
   (
      this : in out SplitOpenThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.put_OpenedTarget (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ClosedTargetName
   (
      this : in out SplitOpenThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.get_ClosedTargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ClosedTargetName
   (
      this : in out SplitOpenThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.put_ClosedTargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ClosedTarget
   (
      this : in out SplitOpenThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_ISplitOpenThemeAnimation.all.get_ClosedTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ClosedTarget
   (
      this : in out SplitOpenThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.put_ClosedTarget (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTargetName
   (
      this : in out SplitOpenThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.get_ContentTargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ContentTargetName
   (
      this : in out SplitOpenThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.put_ContentTargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ContentTarget
   (
      this : in out SplitOpenThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_ISplitOpenThemeAnimation.all.get_ContentTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTarget
   (
      this : in out SplitOpenThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.put_ContentTarget (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpenedLength
   (
      this : in out SplitOpenThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.get_OpenedLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpenedLength
   (
      this : in out SplitOpenThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.put_OpenedLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ClosedLength
   (
      this : in out SplitOpenThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.get_ClosedLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ClosedLength
   (
      this : in out SplitOpenThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.put_ClosedLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OffsetFromCenter
   (
      this : in out SplitOpenThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.get_OffsetFromCenter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OffsetFromCenter
   (
      this : in out SplitOpenThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.put_OffsetFromCenter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTranslationDirection
   (
      this : in out SplitOpenThemeAnimation
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.AnimationDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.AnimationDirection;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.get_ContentTranslationDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ContentTranslationDirection
   (
      this : in out SplitOpenThemeAnimation;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.AnimationDirection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.put_ContentTranslationDirection (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTranslationOffset
   (
      this : in out SplitOpenThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.get_ContentTranslationOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ContentTranslationOffset
   (
      this : in out SplitOpenThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitOpenThemeAnimation.all.put_ContentTranslationOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Storyboard

   procedure Initialize (this : in out Storyboard) is
   begin
      null;
   end;

   procedure Finalize (this : in out Storyboard) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStoryboard, IStoryboard_Ptr);
   begin
      if this.m_IStoryboard /= null then
         if this.m_IStoryboard.all /= null then
            temp := this.m_IStoryboard.all.Release;
            Free (this.m_IStoryboard);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Storyboard

   function Constructor return Storyboard is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.IStoryboard");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboard;
   begin
      return RetVal : Storyboard do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IStoryboard := new WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboard;
            Retval.m_IStoryboard.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Storyboard

   function get_TargetPropertyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Storyboard");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboardStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStoryboardStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetPropertyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetTargetProperty
   (
      element : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Storyboard");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboardStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IStoryboardStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetTargetProperty (element.m_ITimeline.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure SetTargetProperty
   (
      element : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class;
      path : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Storyboard");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboardStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_path : constant WinUI3.HString := To_HString (path);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IStoryboardStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetTargetProperty (element.m_ITimeline.all, HStr_path);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_path);
   end;

   function get_TargetNameProperty_Storyboard
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Storyboard");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboardStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStoryboardStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetTargetName
   (
      element : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Storyboard");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboardStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IStoryboardStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetTargetName (element.m_ITimeline.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure SetTargetName
   (
      element : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class;
      name : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Storyboard");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboardStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_name : constant WinUI3.HString := To_HString (name);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IStoryboardStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetTargetName (element.m_ITimeline.all, HStr_name);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_name);
   end;

   procedure SetTarget
   (
      timeline_p : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class;
      target : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.Storyboard");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboardStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IStoryboardStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetTarget (timeline_p.m_ITimeline.all, target.m_IDependencyObject.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Storyboard

   function get_Children
   (
      this : in out Storyboard
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TimelineCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TimelineCollection do
         Hr := this.m_IStoryboard.all.get_Children (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure Seek
   (
      this : in out Storyboard;
      offset : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStoryboard.all.Seek (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out Storyboard
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStoryboard.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Begin_x
   (
      this : in out Storyboard
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStoryboard.all.Begin_x;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Pause
   (
      this : in out Storyboard
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStoryboard.all.Pause;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Resume
   (
      this : in out Storyboard
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStoryboard.all.Resume;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetCurrentState
   (
      this : in out Storyboard
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ClockState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ClockState;
   begin
      Hr := this.m_IStoryboard.all.GetCurrentState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetCurrentTime
   (
      this : in out Storyboard
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IStoryboard.all.GetCurrentTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SeekAlignedToLastTick
   (
      this : in out Storyboard;
      offset : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStoryboard.all.SeekAlignedToLastTick (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SkipToFill
   (
      this : in out Storyboard
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStoryboard.all.SkipToFill;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SuppressNavigationTransitionInfo

   procedure Initialize (this : in out SuppressNavigationTransitionInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out SuppressNavigationTransitionInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISuppressNavigationTransitionInfo, ISuppressNavigationTransitionInfo_Ptr);
   begin
      if this.m_ISuppressNavigationTransitionInfo /= null then
         if this.m_ISuppressNavigationTransitionInfo.all /= null then
            temp := this.m_ISuppressNavigationTransitionInfo.all.Release;
            Free (this.m_ISuppressNavigationTransitionInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SuppressNavigationTransitionInfo

   function Constructor return SuppressNavigationTransitionInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ISuppressNavigationTransitionInfo");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ISuppressNavigationTransitionInfo;
   begin
      return RetVal : SuppressNavigationTransitionInfo do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISuppressNavigationTransitionInfo := new WinUI3.Windows.UI.Xaml.Media.Animation.ISuppressNavigationTransitionInfo;
            Retval.m_ISuppressNavigationTransitionInfo.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SuppressNavigationTransitionInfo

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwipeBackThemeAnimation

   procedure Initialize (this : in out SwipeBackThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwipeBackThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwipeBackThemeAnimation, ISwipeBackThemeAnimation_Ptr);
   begin
      if this.m_ISwipeBackThemeAnimation /= null then
         if this.m_ISwipeBackThemeAnimation.all /= null then
            temp := this.m_ISwipeBackThemeAnimation.all.Release;
            Free (this.m_ISwipeBackThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwipeBackThemeAnimation

   function Constructor return SwipeBackThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ISwipeBackThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ISwipeBackThemeAnimation;
   begin
      return RetVal : SwipeBackThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISwipeBackThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.ISwipeBackThemeAnimation;
            Retval.m_ISwipeBackThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SwipeBackThemeAnimation

   function get_TargetNameProperty_SwipeBackThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISwipeBackThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeBackThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FromHorizontalOffsetProperty_SwipeBackThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISwipeBackThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeBackThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromHorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FromVerticalOffsetProperty_SwipeBackThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISwipeBackThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeBackThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FromVerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwipeBackThemeAnimation

   function get_TargetName
   (
      this : in out SwipeBackThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISwipeBackThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out SwipeBackThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISwipeBackThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_FromHorizontalOffset
   (
      this : in out SwipeBackThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISwipeBackThemeAnimation.all.get_FromHorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FromHorizontalOffset
   (
      this : in out SwipeBackThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeBackThemeAnimation.all.put_FromHorizontalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FromVerticalOffset
   (
      this : in out SwipeBackThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISwipeBackThemeAnimation.all.get_FromVerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FromVerticalOffset
   (
      this : in out SwipeBackThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeBackThemeAnimation.all.put_FromVerticalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwipeHintThemeAnimation

   procedure Initialize (this : in out SwipeHintThemeAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwipeHintThemeAnimation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwipeHintThemeAnimation, ISwipeHintThemeAnimation_Ptr);
   begin
      if this.m_ISwipeHintThemeAnimation /= null then
         if this.m_ISwipeHintThemeAnimation.all /= null then
            temp := this.m_ISwipeHintThemeAnimation.all.Release;
            Free (this.m_ISwipeHintThemeAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwipeHintThemeAnimation

   function Constructor return SwipeHintThemeAnimation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.ISwipeHintThemeAnimation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ISwipeHintThemeAnimation;
   begin
      return RetVal : SwipeHintThemeAnimation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISwipeHintThemeAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.ISwipeHintThemeAnimation;
            Retval.m_ISwipeHintThemeAnimation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SwipeHintThemeAnimation

   function get_TargetNameProperty_SwipeHintThemeAnimation
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISwipeHintThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeHintThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ToHorizontalOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISwipeHintThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeHintThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ToHorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ToVerticalOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.Animation.ISwipeHintThemeAnimationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeHintThemeAnimationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ToVerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwipeHintThemeAnimation

   function get_TargetName
   (
      this : in out SwipeHintThemeAnimation
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISwipeHintThemeAnimation.all.get_TargetName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TargetName
   (
      this : in out SwipeHintThemeAnimation;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISwipeHintThemeAnimation.all.put_TargetName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ToHorizontalOffset
   (
      this : in out SwipeHintThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISwipeHintThemeAnimation.all.get_ToHorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ToHorizontalOffset
   (
      this : in out SwipeHintThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeHintThemeAnimation.all.put_ToHorizontalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ToVerticalOffset
   (
      this : in out SwipeHintThemeAnimation
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISwipeHintThemeAnimation.all.get_ToVerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ToVerticalOffset
   (
      this : in out SwipeHintThemeAnimation;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeHintThemeAnimation.all.put_ToVerticalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimelineCollection

   procedure Initialize (this : in out TimelineCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimelineCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TimelineCollection

   function Constructor return TimelineCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("GenericObject");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : TimelineCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimelineCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.Animation.Timeline>
   function GetAt
   (
      this : in out TimelineCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ITimeline;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITimeline := new WinUI3.Windows.UI.Xaml.Media.Animation.ITimeline;
         Retval.m_ITimeline.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out TimelineCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out TimelineCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ITimeline;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITimeline := new WinUI3.Windows.UI.Xaml.Media.Animation.ITimeline;
         Retval.m_ITimeline.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out TimelineCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_ITimeline.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out TimelineCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_ITimeline.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out TimelineCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_ITimeline.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out TimelineCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out TimelineCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_ITimeline.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out TimelineCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out TimelineCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out TimelineCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.ITimeline_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out TimelineCollection;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.ITimeline_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (537249785, 51159, 21019, (168, 28, 44, 157, 173, 119, 169, 232 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimeline.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.Animation.Timeline>
   function First
   (
      this : in out TimelineCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.Timeline'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_ITimeline.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ITimeline;
      m_GenericIID     : aliased WinUI3.IID := (2703401798, 59093, 23636, (133, 125, 3, 142, 96, 245, 217, 193 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_ITimeline.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.Timeline do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITimeline := new WinUI3.Windows.UI.Xaml.Media.Animation.ITimeline;
         Retval.m_ITimeline.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TransitionCollection

   procedure Initialize (this : in out TransitionCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out TransitionCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TransitionCollection

   function Constructor return TransitionCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("GenericObject");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : TransitionCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TransitionCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.Animation.Transition>
   function GetAt
   (
      this : in out TransitionCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.Transition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ITransition;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.Transition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITransition := new WinUI3.Windows.UI.Xaml.Media.Animation.ITransition;
         Retval.m_ITransition.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out TransitionCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out TransitionCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.Transition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ITransition;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.Transition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITransition := new WinUI3.Windows.UI.Xaml.Media.Animation.ITransition;
         Retval.m_ITransition.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out TransitionCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.Transition'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_ITransition.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out TransitionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.Transition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_ITransition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out TransitionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.Transition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_ITransition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out TransitionCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out TransitionCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.Transition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_ITransition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out TransitionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out TransitionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out TransitionCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.ITransition_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out TransitionCollection;
      items : WinUI3.Windows.UI.Xaml.Media.Animation.ITransition_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3885520671, 32318, 24090, (170, 85, 203, 201, 59, 131, 248, 33 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransition.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.Animation.Transition>
   function First
   (
      this : in out TransitionCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.Transition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_ITransition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.ITransition;
      m_GenericIID     : aliased WinUI3.IID := (4273279896, 20443, 20754, (138, 155, 106, 135, 134, 202, 1, 206 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_ITransition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.Transition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITransition := new WinUI3.Windows.UI.Xaml.Media.Animation.ITransition;
         Retval.m_ITransition.all := m_ComRetVal;
      end return;
   end;

end WinUI3.Windows.UI.Xaml.Media.Animation;
