--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Microsoft.UI.Composition;
with WinUI3.Microsoft.UI.Input;
with WinUI3.Microsoft.UI.Xaml.Automation.Peers;
with WinUI3.Microsoft.UI.Xaml.Data;
with WinUI3.Microsoft.UI.Xaml.Input;
with WinUI3.Microsoft.UI.Xaml.Media;
with WinUI3.Microsoft.UI.Xaml.Media.Animation;
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with WinUI3.Windows.UI;
with WinUI3.Windows.UI.Xaml.Interop;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Microsoft.UI.Xaml.Controls.Primitives is

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ButtonBase

   procedure Initialize (this : in out ButtonBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out ButtonBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IButtonBase, IButtonBase_Ptr);
   begin
      if this.m_IButtonBase /= null then
         if this.m_IButtonBase.all /= null then
            temp := this.m_IButtonBase.all.Release;
            if temp < 1 then
               Free (this.m_IButtonBase);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ButtonBase

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ButtonBase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ButtonBase");
      m_Factory    : access IButtonBaseFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IButtonBase;
   begin
      return RetVal : ButtonBase do
         Hr := RoGetActivationFactory (m_hString, IID_IButtonBaseFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IButtonBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IButtonBase;
            Retval.m_IButtonBase.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ButtonBase

   function get_ClickModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ButtonBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IButtonBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IButtonBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClickModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPointerOverProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ButtonBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IButtonBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IButtonBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPointerOverProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPressedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ButtonBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IButtonBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IButtonBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPressedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ButtonBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IButtonBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IButtonBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandParameterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ButtonBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IButtonBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IButtonBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ButtonBase

   function get_ClickMode
   (
      this : in out ButtonBase
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ClickMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ClickMode;
   begin
      Hr := this.m_IButtonBase.all.get_ClickMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ClickMode
   (
      this : in out ButtonBase;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ClickMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IButtonBase.all.put_ClickMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPointerOver
   (
      this : in out ButtonBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IButtonBase.all.get_IsPointerOver (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsPressed
   (
      this : in out ButtonBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IButtonBase.all.get_IsPressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Command
   (
      this : in out ButtonBase
   )
   return WinUI3.Microsoft.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_IButtonBase.all.get_Command (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Command
   (
      this : in out ButtonBase;
      value : WinUI3.Microsoft.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IButtonBase.all.put_Command (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CommandParameter
   (
      this : in out ButtonBase
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IButtonBase.all.get_CommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CommandParameter
   (
      this : in out ButtonBase;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IButtonBase.all.put_CommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Click
   (
      this : in out ButtonBase;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IButtonBase.all.add_Click (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Click
   (
      this : in out ButtonBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IButtonBase.all.remove_Click (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToggleButton

   procedure Initialize (this : in out ToggleButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToggleButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToggleButton, IToggleButton_Ptr);
   begin
      if this.m_IToggleButton /= null then
         if this.m_IToggleButton.all /= null then
            temp := this.m_IToggleButton.all.Release;
            if temp < 1 then
               Free (this.m_IToggleButton);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ToggleButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ToggleButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ToggleButton");
      m_Factory    : access IToggleButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IToggleButton;
   begin
      return RetVal : ToggleButton do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IToggleButton := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IToggleButton;
            Retval.m_IToggleButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ToggleButton

   function get_IsCheckedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ToggleButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCheckedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsThreeStateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ToggleButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsThreeStateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToggleButton

   function get_IsChecked
   (
      this : in out ToggleButton
   )
   return IReference_Boolean.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Boolean.Kind;
   begin
      Hr := this.m_IToggleButton.all.get_IsChecked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Boolean (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_IsChecked
   (
      this : in out ToggleButton;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleButton.all.put_IsChecked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsThreeState
   (
      this : in out ToggleButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IToggleButton.all.get_IsThreeState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsThreeState
   (
      this : in out ToggleButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleButton.all.put_IsThreeState (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Checked
   (
      this : in out ToggleButton;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IToggleButton.all.add_Checked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Checked
   (
      this : in out ToggleButton;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleButton.all.remove_Checked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Unchecked
   (
      this : in out ToggleButton;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IToggleButton.all.add_Unchecked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Unchecked
   (
      this : in out ToggleButton;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleButton.all.remove_Unchecked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Indeterminate
   (
      this : in out ToggleButton;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IToggleButton.all.add_Indeterminate (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Indeterminate
   (
      this : in out ToggleButton;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleButton.all.remove_Indeterminate (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnToggle
   (
      this : in out ToggleButton
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IToggleButtonOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IToggleButton_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IToggleButtonOverrides, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IToggleButtonOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleButton.all);
      Hr := m_Interface.OnToggle;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Selector

   procedure Initialize (this : in out Selector) is
   begin
      null;
   end;

   procedure Finalize (this : in out Selector) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISelector, ISelector_Ptr);
   begin
      if this.m_ISelector /= null then
         if this.m_ISelector.all /= null then
            temp := this.m_ISelector.all.Release;
            if temp < 1 then
               Free (this.m_ISelector);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Selector

   -----------------------------------------------------------------------------
   -- Static Interfaces for Selector

   function get_SelectedIndexProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Selector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Selector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedValueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Selector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedValuePathProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Selector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedValuePathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSynchronizedWithCurrentItemProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Selector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSynchronizedWithCurrentItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsSelectionActive
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Selector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ISelectorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsSelectionActive (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Selector

   function get_SelectedIndex
   (
      this : in out Selector
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ISelector.all.get_SelectedIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedIndex
   (
      this : in out Selector;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISelector.all.put_SelectedIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItem
   (
      this : in out Selector
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ISelector.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedItem
   (
      this : in out Selector;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISelector.all.put_SelectedItem (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedValue
   (
      this : in out Selector
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ISelector.all.get_SelectedValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedValue
   (
      this : in out Selector;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISelector.all.put_SelectedValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedValuePath
   (
      this : in out Selector
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISelector.all.get_SelectedValuePath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SelectedValuePath
   (
      this : in out Selector;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISelector.all.put_SelectedValuePath (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsSynchronizedWithCurrentItem
   (
      this : in out Selector
   )
   return IReference_Boolean.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Boolean.Kind;
   begin
      Hr := this.m_ISelector.all.get_IsSynchronizedWithCurrentItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Boolean (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_IsSynchronizedWithCurrentItem
   (
      this : in out Selector;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISelector.all.put_IsSynchronizedWithCurrentItem (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out Selector;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.SelectionChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISelector.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out Selector;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISelector.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SelectorItem

   procedure Initialize (this : in out SelectorItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out SelectorItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISelectorItem, ISelectorItem_Ptr);
   begin
      if this.m_ISelectorItem /= null then
         if this.m_ISelectorItem.all /= null then
            temp := this.m_ISelectorItem.all.Release;
            if temp < 1 then
               Free (this.m_ISelectorItem);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SelectorItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SelectorItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.SelectorItem");
      m_Factory    : access ISelectorItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorItem;
   begin
      return RetVal : SelectorItem do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISelectorItem := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorItem;
            Retval.m_ISelectorItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SelectorItem

   function get_IsSelectedProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.SelectorItem");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ISelectorItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectorItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSelectedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SelectorItem

   function get_IsSelected
   (
      this : in out SelectorItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISelectorItem.all.get_IsSelected (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSelected
   (
      this : in out SelectorItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISelectorItem.all.put_IsSelected (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FlyoutBase

   procedure Initialize (this : in out FlyoutBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out FlyoutBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlyoutBase, IFlyoutBase_Ptr);
   begin
      if this.m_IFlyoutBase /= null then
         if this.m_IFlyoutBase.all /= null then
            temp := this.m_IFlyoutBase.all.Release;
            if temp < 1 then
               Free (this.m_IFlyoutBase);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FlyoutBase

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FlyoutBase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory    : access IFlyoutBaseFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : FlyoutBase do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
            Retval.m_IFlyoutBase.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FlyoutBase

   function get_TargetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlacementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AllowFocusOnInteractionProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AllowFocusOnInteractionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AllowFocusWhenDisabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AllowFocusWhenDisabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShowModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InputDevicePrefersPrimaryCommandsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InputDevicePrefersPrimaryCommandsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AreOpenCloseAnimationsEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreOpenCloseAnimationsEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShouldConstrainToRootBoundsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShouldConstrainToRootBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ElementSoundModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ElementSoundModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OverlayInputPassThroughElementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OverlayInputPassThroughElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsOpenProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AttachedFlyoutProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AttachedFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAttachedFlyout
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetAttachedFlyout (element.m_IFrameworkElement.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase;
            Retval.m_IFlyoutBase.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetAttachedFlyout
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAttachedFlyout (element.m_IFrameworkElement.all, value.m_IFlyoutBase.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   procedure ShowAttachedFlyout
   (
      flyoutOwner : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.ShowAttachedFlyout (flyoutOwner.m_IFrameworkElement.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_SystemBackdropProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutBaseStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SystemBackdropProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FlyoutBase

   function get_Placement
   (
      this : in out FlyoutBase
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutPlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutPlacementMode;
   begin
      Hr := this.m_IFlyoutBase.all.get_Placement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Placement
   (
      this : in out FlyoutBase;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutPlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.put_Placement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Target
   (
      this : in out FlyoutBase
   )
   return WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IFrameworkElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.FrameworkElement do
         Hr := this.m_IFlyoutBase.all.get_Target (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFrameworkElement := new WinUI3.Microsoft.UI.Xaml.IFrameworkElement;
         Retval.m_IFrameworkElement.all := m_ComRetVal;
      end return;
   end;

   function get_AllowFocusOnInteraction
   (
      this : in out FlyoutBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFlyoutBase.all.get_AllowFocusOnInteraction (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AllowFocusOnInteraction
   (
      this : in out FlyoutBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.put_AllowFocusOnInteraction (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out FlyoutBase
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode;
   begin
      Hr := this.m_IFlyoutBase.all.get_LightDismissOverlayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out FlyoutBase;
      value : WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.put_LightDismissOverlayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AllowFocusWhenDisabled
   (
      this : in out FlyoutBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFlyoutBase.all.get_AllowFocusWhenDisabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AllowFocusWhenDisabled
   (
      this : in out FlyoutBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.put_AllowFocusWhenDisabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowMode
   (
      this : in out FlyoutBase
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowMode;
   begin
      Hr := this.m_IFlyoutBase.all.get_ShowMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowMode
   (
      this : in out FlyoutBase;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.put_ShowMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InputDevicePrefersPrimaryCommands
   (
      this : in out FlyoutBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFlyoutBase.all.get_InputDevicePrefersPrimaryCommands (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreOpenCloseAnimationsEnabled
   (
      this : in out FlyoutBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFlyoutBase.all.get_AreOpenCloseAnimationsEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreOpenCloseAnimationsEnabled
   (
      this : in out FlyoutBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.put_AreOpenCloseAnimationsEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShouldConstrainToRootBounds
   (
      this : in out FlyoutBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFlyoutBase.all.get_ShouldConstrainToRootBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShouldConstrainToRootBounds
   (
      this : in out FlyoutBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.put_ShouldConstrainToRootBounds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsConstrainedToRootBounds
   (
      this : in out FlyoutBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFlyoutBase.all.get_IsConstrainedToRootBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ElementSoundMode
   (
      this : in out FlyoutBase
   )
   return WinUI3.Microsoft.UI.Xaml.ElementSoundMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.ElementSoundMode;
   begin
      Hr := this.m_IFlyoutBase.all.get_ElementSoundMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ElementSoundMode
   (
      this : in out FlyoutBase;
      value : WinUI3.Microsoft.UI.Xaml.ElementSoundMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.put_ElementSoundMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OverlayInputPassThroughElement
   (
      this : in out FlyoutBase
   )
   return WinUI3.Microsoft.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyObject do
         Hr := this.m_IFlyoutBase.all.get_OverlayInputPassThroughElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Microsoft.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_OverlayInputPassThroughElement
   (
      this : in out FlyoutBase;
      value : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.put_OverlayInputPassThroughElement (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsOpen
   (
      this : in out FlyoutBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFlyoutBase.all.get_IsOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_XamlRoot
   (
      this : in out FlyoutBase
   )
   return WinUI3.Microsoft.UI.Xaml.XamlRoot'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IXamlRoot;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.XamlRoot do
         Hr := this.m_IFlyoutBase.all.get_XamlRoot (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IXamlRoot := new WinUI3.Microsoft.UI.Xaml.IXamlRoot;
         Retval.m_IXamlRoot.all := m_ComRetVal;
      end return;
   end;

   procedure put_XamlRoot
   (
      this : in out FlyoutBase;
      value : WinUI3.Microsoft.UI.Xaml.XamlRoot'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.put_XamlRoot (value.m_IXamlRoot.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opened
   (
      this : in out FlyoutBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFlyoutBase.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out FlyoutBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out FlyoutBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFlyoutBase.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out FlyoutBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opening
   (
      this : in out FlyoutBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFlyoutBase.all.add_Opening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opening
   (
      this : in out FlyoutBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.remove_Opening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closing
   (
      this : in out FlyoutBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFlyoutBase.all.add_Closing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closing
   (
      this : in out FlyoutBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.remove_Closing (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ShowAt
   (
      this : in out FlyoutBase;
      placementTarget : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.ShowAt (placementTarget.m_IFrameworkElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ShowAt
   (
      this : in out FlyoutBase;
      placementTarget : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      showOptions : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.ShowAt (placementTarget.m_IDependencyObject.all, showOptions.m_IFlyoutShowOptions.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Hide
   (
      this : in out FlyoutBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.Hide;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure TryInvokeKeyboardAccelerator
   (
      this : in out FlyoutBase;
      args : WinUI3.Microsoft.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBase.all.TryInvokeKeyboardAccelerator (args.m_IProcessKeyboardAcceleratorEventArgs.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SystemBackdrop
   (
      this : in out FlyoutBase
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISystemBackdrop;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IFlyoutBase2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop do
         m_Interface := QInterface (this.m_IFlyoutBase.all);
         Hr := m_Interface.get_SystemBackdrop (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISystemBackdrop := new WinUI3.Microsoft.UI.Xaml.Media.ISystemBackdrop;
         Retval.m_ISystemBackdrop.all := m_ComRetVal;
      end return;
   end;

   procedure put_SystemBackdrop
   (
      this : in out FlyoutBase;
      value : WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IFlyoutBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlyoutBase.all);
      Hr := m_Interface.put_SystemBackdrop (value.m_ISystemBackdrop.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CreatePresenter
   (
      this : in out FlyoutBase
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Control'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IControl;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseOverrides, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IFlyoutBaseOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Control do
         m_Interface := QInterface (this.m_IFlyoutBase.all);
         Hr := m_Interface.CreatePresenter (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IControl := new WinUI3.Microsoft.UI.Xaml.Controls.IControl;
         Retval.m_IControl.all := m_ComRetVal;
      end return;
   end;

   procedure OnProcessKeyboardAccelerators
   (
      this : in out FlyoutBase;
      args : WinUI3.Microsoft.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutBaseOverrides, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IFlyoutBaseOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlyoutBase.all);
      Hr := m_Interface.OnProcessKeyboardAccelerators (args.m_IProcessKeyboardAcceleratorEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PickerFlyoutBase

   procedure Initialize (this : in out PickerFlyoutBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out PickerFlyoutBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPickerFlyoutBase, IPickerFlyoutBase_Ptr);
   begin
      if this.m_IPickerFlyoutBase /= null then
         if this.m_IPickerFlyoutBase.all /= null then
            temp := this.m_IPickerFlyoutBase.all.Release;
            if temp < 1 then
               Free (this.m_IPickerFlyoutBase);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PickerFlyoutBase

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PickerFlyoutBase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase");
      m_Factory    : access IPickerFlyoutBaseFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPickerFlyoutBase;
   begin
      return RetVal : PickerFlyoutBase do
         Hr := RoGetActivationFactory (m_hString, IID_IPickerFlyoutBaseFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPickerFlyoutBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPickerFlyoutBase;
            Retval.m_IPickerFlyoutBase.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PickerFlyoutBase

   function get_TitleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPickerFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPickerFlyoutBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetTitle
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPickerFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPickerFlyoutBaseStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetTitle (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure SetTitle
   (
      element : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.PickerFlyoutBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPickerFlyoutBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPickerFlyoutBaseStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetTitle (element.m_IDependencyObject.all, HStr_value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PickerFlyoutBase

   procedure OnConfirmed
   (
      this : in out PickerFlyoutBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPickerFlyoutBaseOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPickerFlyoutBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPickerFlyoutBaseOverrides, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IPickerFlyoutBaseOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPickerFlyoutBase.all);
      Hr := m_Interface.OnConfirmed;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShouldShowConfirmationButtons
   (
      this : in out PickerFlyoutBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPickerFlyoutBaseOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPickerFlyoutBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPickerFlyoutBaseOverrides, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IPickerFlyoutBaseOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPickerFlyoutBase.all);
      Hr := m_Interface.ShouldShowConfirmationButtons (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBarButtonTemplateSettings

   procedure Initialize (this : in out AppBarButtonTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBarButtonTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBarButtonTemplateSettings, IAppBarButtonTemplateSettings_Ptr);
   begin
      if this.m_IAppBarButtonTemplateSettings /= null then
         if this.m_IAppBarButtonTemplateSettings.all /= null then
            temp := this.m_IAppBarButtonTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_IAppBarButtonTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBarButtonTemplateSettings

   function get_KeyboardAcceleratorTextMinWidth
   (
      this : in out AppBarButtonTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAppBarButtonTemplateSettings.all.get_KeyboardAcceleratorTextMinWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBarTemplateSettings

   procedure Initialize (this : in out AppBarTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBarTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBarTemplateSettings, IAppBarTemplateSettings_Ptr);
   begin
      if this.m_IAppBarTemplateSettings /= null then
         if this.m_IAppBarTemplateSettings.all /= null then
            temp := this.m_IAppBarTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_IAppBarTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBarTemplateSettings

   function get_ClipRect
   (
      this : in out AppBarTemplateSettings
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IAppBarTemplateSettings.all.get_ClipRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CompactVerticalDelta
   (
      this : in out AppBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAppBarTemplateSettings.all.get_CompactVerticalDelta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CompactRootMargin
   (
      this : in out AppBarTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IAppBarTemplateSettings.all.get_CompactRootMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MinimalVerticalDelta
   (
      this : in out AppBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAppBarTemplateSettings.all.get_MinimalVerticalDelta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MinimalRootMargin
   (
      this : in out AppBarTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IAppBarTemplateSettings.all.get_MinimalRootMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HiddenVerticalDelta
   (
      this : in out AppBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAppBarTemplateSettings.all.get_HiddenVerticalDelta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HiddenRootMargin
   (
      this : in out AppBarTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IAppBarTemplateSettings.all.get_HiddenRootMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NegativeCompactVerticalDelta
   (
      this : in out AppBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAppBarTemplateSettings.all.get_NegativeCompactVerticalDelta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NegativeMinimalVerticalDelta
   (
      this : in out AppBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAppBarTemplateSettings.all.get_NegativeMinimalVerticalDelta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NegativeHiddenVerticalDelta
   (
      this : in out AppBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAppBarTemplateSettings.all.get_NegativeHiddenVerticalDelta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBarToggleButtonTemplateSettings

   procedure Initialize (this : in out AppBarToggleButtonTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBarToggleButtonTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBarToggleButtonTemplateSettings, IAppBarToggleButtonTemplateSettings_Ptr);
   begin
      if this.m_IAppBarToggleButtonTemplateSettings /= null then
         if this.m_IAppBarToggleButtonTemplateSettings.all /= null then
            temp := this.m_IAppBarToggleButtonTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_IAppBarToggleButtonTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBarToggleButtonTemplateSettings

   function get_KeyboardAcceleratorTextMinWidth
   (
      this : in out AppBarToggleButtonTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAppBarToggleButtonTemplateSettings.all.get_KeyboardAcceleratorTextMinWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AutoSuggestBoxHelper

   procedure Initialize (this : in out AutoSuggestBoxHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out AutoSuggestBoxHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAutoSuggestBoxHelper, IAutoSuggestBoxHelper_Ptr);
   begin
      if this.m_IAutoSuggestBoxHelper /= null then
         if this.m_IAutoSuggestBoxHelper.all /= null then
            temp := this.m_IAutoSuggestBoxHelper.all.Release;
            if temp < 1 then
               Free (this.m_IAutoSuggestBoxHelper);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AutoSuggestBoxHelper

   function get_KeepInteriorCornersSquareProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IAutoSuggestBoxHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxHelperStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeepInteriorCornersSquareProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetKeepInteriorCornersSquare
   (
      autoSuggestBox : WinUI3.Microsoft.UI.Xaml.Controls.AutoSuggestBox'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IAutoSuggestBoxHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetKeepInteriorCornersSquare (autoSuggestBox.m_IAutoSuggestBox.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function GetKeepInteriorCornersSquare
   (
      autoSuggestBox : WinUI3.Microsoft.UI.Xaml.Controls.AutoSuggestBox'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.AutoSuggestBoxHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IAutoSuggestBoxHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetKeepInteriorCornersSquare (autoSuggestBox.m_IAutoSuggestBox.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AutoSuggestBoxHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarPanel

   procedure Initialize (this : in out CalendarPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarPanel, ICalendarPanel_Ptr);
   begin
      if this.m_ICalendarPanel /= null then
         if this.m_ICalendarPanel.all /= null then
            temp := this.m_ICalendarPanel.all.Release;
            if temp < 1 then
               Free (this.m_ICalendarPanel);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CalendarPanel

   function Constructor return CalendarPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CalendarPanel");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICalendarPanel;
   begin
      return RetVal : CalendarPanel do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICalendarPanel := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICalendarPanel;
            Retval.m_ICalendarPanel.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarPanel

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarViewTemplateSettings

   procedure Initialize (this : in out CalendarViewTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarViewTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarViewTemplateSettings, ICalendarViewTemplateSettings_Ptr);
   begin
      if this.m_ICalendarViewTemplateSettings /= null then
         if this.m_ICalendarViewTemplateSettings.all /= null then
            temp := this.m_ICalendarViewTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_ICalendarViewTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarViewTemplateSettings

   function get_MinViewWidth
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_MinViewWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HeaderText
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_HeaderText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_WeekDay1
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_WeekDay1 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_WeekDay2
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_WeekDay2 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_WeekDay3
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_WeekDay3 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_WeekDay4
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_WeekDay4 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_WeekDay5
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_WeekDay5 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_WeekDay6
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_WeekDay6 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_WeekDay7
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_WeekDay7 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_HasMoreContentAfter
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_HasMoreContentAfter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HasMoreContentBefore
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_HasMoreContentBefore (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HasMoreViews
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_HasMoreViews (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ClipRect
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_ClipRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CenterX
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_CenterX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CenterY
   (
      this : in out CalendarViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICalendarViewTemplateSettings.all.get_CenterY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CarouselPanel

   procedure Initialize (this : in out CarouselPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out CarouselPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICarouselPanel, ICarouselPanel_Ptr);
   begin
      if this.m_ICarouselPanel /= null then
         if this.m_ICarouselPanel.all /= null then
            temp := this.m_ICarouselPanel.all.Release;
            if temp < 1 then
               Free (this.m_ICarouselPanel);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CarouselPanel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CarouselPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CarouselPanel");
      m_Factory    : access ICarouselPanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICarouselPanel;
   begin
      return RetVal : CarouselPanel do
         Hr := RoGetActivationFactory (m_hString, IID_ICarouselPanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICarouselPanel := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICarouselPanel;
            Retval.m_ICarouselPanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CarouselPanel

   function get_CanVerticallyScroll
   (
      this : in out CarouselPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICarouselPanel.all.get_CanVerticallyScroll (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanVerticallyScroll
   (
      this : in out CarouselPanel;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.put_CanVerticallyScroll (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanHorizontallyScroll
   (
      this : in out CarouselPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICarouselPanel.all.get_CanHorizontallyScroll (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanHorizontallyScroll
   (
      this : in out CarouselPanel;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.put_CanHorizontallyScroll (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExtentWidth
   (
      this : in out CarouselPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICarouselPanel.all.get_ExtentWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentHeight
   (
      this : in out CarouselPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICarouselPanel.all.get_ExtentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportWidth
   (
      this : in out CarouselPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICarouselPanel.all.get_ViewportWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportHeight
   (
      this : in out CarouselPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICarouselPanel.all.get_ViewportHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HorizontalOffset
   (
      this : in out CarouselPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICarouselPanel.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalOffset
   (
      this : in out CarouselPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICarouselPanel.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollOwner
   (
      this : in out CarouselPanel
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ICarouselPanel.all.get_ScrollOwner (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ScrollOwner
   (
      this : in out CarouselPanel;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.put_ScrollOwner (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineUp
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.LineUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineDown
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.LineDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineLeft
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.LineLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineRight
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.LineRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageUp
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.PageUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageDown
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.PageDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageLeft
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.PageLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageRight
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.PageRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelUp
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.MouseWheelUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelDown
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.MouseWheelDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelLeft
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.MouseWheelLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelRight
   (
      this : in out CarouselPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.MouseWheelRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetHorizontalOffset
   (
      this : in out CarouselPanel;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.SetHorizontalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetVerticalOffset
   (
      this : in out CarouselPanel;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICarouselPanel.all.SetVerticalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function MakeVisible
   (
      this : in out CarouselPanel;
      visual : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      rectangle : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_ICarouselPanel.all.MakeVisible (visual.m_IUIElement.all, rectangle, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreHorizontalSnapPointsRegular
   (
      this : in out CarouselPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICarouselPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICarouselPanel.all);
      Hr := m_Interface.get_AreHorizontalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreVerticalSnapPointsRegular
   (
      this : in out CarouselPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICarouselPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICarouselPanel.all);
      Hr := m_Interface.get_AreVerticalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HorizontalSnapPointsChanged
   (
      this : in out CarouselPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICarouselPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICarouselPanel.all);
      Hr := m_Interface.add_HorizontalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HorizontalSnapPointsChanged
   (
      this : in out CarouselPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICarouselPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICarouselPanel.all);
      Hr := m_Interface.remove_HorizontalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_VerticalSnapPointsChanged
   (
      this : in out CarouselPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICarouselPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICarouselPanel.all);
      Hr := m_Interface.add_VerticalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VerticalSnapPointsChanged
   (
      this : in out CarouselPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICarouselPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICarouselPanel.all);
      Hr := m_Interface.remove_VerticalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetIrregularSnapPoints
   (
      this : in out CarouselPanel;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   )
   return IVectorView_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_Single.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICarouselPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICarouselPanel.all);
      Hr := m_Interface.GetIrregularSnapPoints (orientation, alignment, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetRegularSnapPoints
   (
      this : in out CarouselPanel;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
      offset : WinUI3.Single_Ptr
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICarouselPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICarouselPanel.all);
      Hr := m_Interface.GetRegularSnapPoints (orientation, alignment, offset, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RangeBase

   procedure Initialize (this : in out RangeBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out RangeBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRangeBase, IRangeBase_Ptr);
   begin
      if this.m_IRangeBase /= null then
         if this.m_IRangeBase.all /= null then
            temp := this.m_IRangeBase.all.Release;
            if temp < 1 then
               Free (this.m_IRangeBase);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RangeBase

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RangeBase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.RangeBase");
      m_Factory    : access IRangeBaseFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBase;
   begin
      return RetVal : RangeBase do
         Hr := RoGetActivationFactory (m_hString, IID_IRangeBaseFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRangeBase := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBase;
            Retval.m_IRangeBase.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RangeBase

   function get_MinimumProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.RangeBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRangeBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinimumProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaximumProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.RangeBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRangeBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaximumProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SmallChangeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.RangeBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRangeBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SmallChangeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LargeChangeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.RangeBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRangeBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LargeChangeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ValueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.RangeBase");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRangeBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RangeBase

   function get_Minimum
   (
      this : in out RangeBase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRangeBase.all.get_Minimum (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Minimum
   (
      this : in out RangeBase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRangeBase.all.put_Minimum (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Maximum
   (
      this : in out RangeBase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRangeBase.all.get_Maximum (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Maximum
   (
      this : in out RangeBase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRangeBase.all.put_Maximum (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SmallChange
   (
      this : in out RangeBase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRangeBase.all.get_SmallChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SmallChange
   (
      this : in out RangeBase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRangeBase.all.put_SmallChange (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LargeChange
   (
      this : in out RangeBase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRangeBase.all.get_LargeChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LargeChange
   (
      this : in out RangeBase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRangeBase.all.put_LargeChange (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Value
   (
      this : in out RangeBase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRangeBase.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out RangeBase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRangeBase.all.put_Value (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ValueChanged
   (
      this : in out RangeBase;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRangeBase.all.add_ValueChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ValueChanged
   (
      this : in out RangeBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRangeBase.all.remove_ValueChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnMinimumChanged
   (
      this : in out RangeBase;
      oldMinimum : WinUI3.Double;
      newMinimum : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseOverrides, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IRangeBaseOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRangeBase.all);
      Hr := m_Interface.OnMinimumChanged (oldMinimum, newMinimum);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnMaximumChanged
   (
      this : in out RangeBase;
      oldMaximum : WinUI3.Double;
      newMaximum : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseOverrides, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IRangeBaseOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRangeBase.all);
      Hr := m_Interface.OnMaximumChanged (oldMaximum, newMaximum);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnValueChanged
   (
      this : in out RangeBase;
      oldValue : WinUI3.Double;
      newValue : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBase_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseOverrides, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IRangeBaseOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRangeBase.all);
      Hr := m_Interface.OnValueChanged (oldValue, newValue);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorPickerSlider

   procedure Initialize (this : in out ColorPickerSlider) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorPickerSlider) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColorPickerSlider, IColorPickerSlider_Ptr);
   begin
      if this.m_IColorPickerSlider /= null then
         if this.m_IColorPickerSlider.all /= null then
            temp := this.m_IColorPickerSlider.all.Release;
            if temp < 1 then
               Free (this.m_IColorPickerSlider);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColorPickerSlider

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ColorPickerSlider is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorPickerSlider");
      m_Factory    : access IColorPickerSliderFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorPickerSlider;
   begin
      return RetVal : ColorPickerSlider do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerSliderFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IColorPickerSlider := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorPickerSlider;
            Retval.m_IColorPickerSlider.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ColorPickerSlider

   function get_ColorChannelProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorPickerSlider");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorPickerSliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerSliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorChannelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorPickerSlider

   function get_ColorChannel
   (
      this : in out ColorPickerSlider
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ColorPickerHsvChannel is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ColorPickerHsvChannel;
   begin
      Hr := this.m_IColorPickerSlider.all.get_ColorChannel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ColorChannel
   (
      this : in out ColorPickerSlider;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ColorPickerHsvChannel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPickerSlider.all.put_ColorChannel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorSpectrum

   procedure Initialize (this : in out ColorSpectrum) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorSpectrum) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColorSpectrum, IColorSpectrum_Ptr);
   begin
      if this.m_IColorSpectrum /= null then
         if this.m_IColorSpectrum.all /= null then
            temp := this.m_IColorSpectrum.all.Release;
            if temp < 1 then
               Free (this.m_IColorSpectrum);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColorSpectrum

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ColorSpectrum is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum");
      m_Factory    : access IColorSpectrumFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrum;
   begin
      return RetVal : ColorSpectrum do
         Hr := RoGetActivationFactory (m_hString, IID_IColorSpectrumFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IColorSpectrum := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrum;
            Retval.m_IColorSpectrum.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ColorSpectrum

   function get_ColorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrumStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorSpectrumStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HsvColorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrumStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorSpectrumStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HsvColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinHueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrumStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorSpectrumStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinHueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxHueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrumStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorSpectrumStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxHueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinSaturationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrumStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorSpectrumStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinSaturationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxSaturationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrumStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorSpectrumStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxSaturationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinValueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrumStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorSpectrumStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxValueProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrumStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorSpectrumStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShapeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrumStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorSpectrumStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShapeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ComponentsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColorSpectrum");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColorSpectrumStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorSpectrumStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ComponentsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorSpectrum

   function get_Color
   (
      this : in out ColorSpectrum
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IColorSpectrum.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out ColorSpectrum;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorSpectrum.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HsvColor
   (
      this : in out ColorSpectrum
   )
   return WinUI3.Windows.Foundation.Numerics.Vector4 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector4;
   begin
      Hr := this.m_IColorSpectrum.all.get_HsvColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HsvColor
   (
      this : in out ColorSpectrum;
      value : WinUI3.Windows.Foundation.Numerics.Vector4
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorSpectrum.all.put_HsvColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinHue
   (
      this : in out ColorSpectrum
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorSpectrum.all.get_MinHue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinHue
   (
      this : in out ColorSpectrum;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorSpectrum.all.put_MinHue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxHue
   (
      this : in out ColorSpectrum
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorSpectrum.all.get_MaxHue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxHue
   (
      this : in out ColorSpectrum;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorSpectrum.all.put_MaxHue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinSaturation
   (
      this : in out ColorSpectrum
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorSpectrum.all.get_MinSaturation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinSaturation
   (
      this : in out ColorSpectrum;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorSpectrum.all.put_MinSaturation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxSaturation
   (
      this : in out ColorSpectrum
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorSpectrum.all.get_MaxSaturation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxSaturation
   (
      this : in out ColorSpectrum;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorSpectrum.all.put_MaxSaturation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinValue
   (
      this : in out ColorSpectrum
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorSpectrum.all.get_MinValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinValue
   (
      this : in out ColorSpectrum;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorSpectrum.all.put_MinValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxValue
   (
      this : in out ColorSpectrum
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorSpectrum.all.get_MaxValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxValue
   (
      this : in out ColorSpectrum;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorSpectrum.all.put_MaxValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Shape
   (
      this : in out ColorSpectrum
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumShape is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumShape;
   begin
      Hr := this.m_IColorSpectrum.all.get_Shape (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Shape
   (
      this : in out ColorSpectrum;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumShape
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorSpectrum.all.put_Shape (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Components
   (
      this : in out ColorSpectrum
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumComponents is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumComponents;
   begin
      Hr := this.m_IColorSpectrum.all.get_Components (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Components
   (
      this : in out ColorSpectrum;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ColorSpectrumComponents
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorSpectrum.all.put_Components (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ColorChanged
   (
      this : in out ColorSpectrum;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IColorSpectrum.all.add_ColorChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ColorChanged
   (
      this : in out ColorSpectrum;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorSpectrum.all.remove_ColorChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColumnMajorUniformToLargestGridLayout

   procedure Initialize (this : in out ColumnMajorUniformToLargestGridLayout) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColumnMajorUniformToLargestGridLayout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColumnMajorUniformToLargestGridLayout, IColumnMajorUniformToLargestGridLayout_Ptr);
   begin
      if this.m_IColumnMajorUniformToLargestGridLayout /= null then
         if this.m_IColumnMajorUniformToLargestGridLayout.all /= null then
            temp := this.m_IColumnMajorUniformToLargestGridLayout.all.Release;
            if temp < 1 then
               Free (this.m_IColumnMajorUniformToLargestGridLayout);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColumnMajorUniformToLargestGridLayout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ColumnMajorUniformToLargestGridLayout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout");
      m_Factory    : access IColumnMajorUniformToLargestGridLayoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColumnMajorUniformToLargestGridLayout;
   begin
      return RetVal : ColumnMajorUniformToLargestGridLayout do
         Hr := RoGetActivationFactory (m_hString, IID_IColumnMajorUniformToLargestGridLayoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IColumnMajorUniformToLargestGridLayout := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColumnMajorUniformToLargestGridLayout;
            Retval.m_IColumnMajorUniformToLargestGridLayout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ColumnMajorUniformToLargestGridLayout

   function get_MaxColumnsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColumnMajorUniformToLargestGridLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColumnMajorUniformToLargestGridLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxColumnsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ColumnSpacingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColumnMajorUniformToLargestGridLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColumnMajorUniformToLargestGridLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColumnSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RowSpacingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ColumnMajorUniformToLargestGridLayout");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IColumnMajorUniformToLargestGridLayoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColumnMajorUniformToLargestGridLayoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RowSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColumnMajorUniformToLargestGridLayout

   function get_MaxColumns
   (
      this : in out ColumnMajorUniformToLargestGridLayout
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColumnMajorUniformToLargestGridLayout.all.get_MaxColumns (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxColumns
   (
      this : in out ColumnMajorUniformToLargestGridLayout;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColumnMajorUniformToLargestGridLayout.all.put_MaxColumns (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ColumnSpacing
   (
      this : in out ColumnMajorUniformToLargestGridLayout
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IColumnMajorUniformToLargestGridLayout.all.get_ColumnSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ColumnSpacing
   (
      this : in out ColumnMajorUniformToLargestGridLayout;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColumnMajorUniformToLargestGridLayout.all.put_ColumnSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RowSpacing
   (
      this : in out ColumnMajorUniformToLargestGridLayout
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IColumnMajorUniformToLargestGridLayout.all.get_RowSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RowSpacing
   (
      this : in out ColumnMajorUniformToLargestGridLayout;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColumnMajorUniformToLargestGridLayout.all.put_RowSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ComboBoxHelper

   procedure Initialize (this : in out ComboBoxHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out ComboBoxHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IComboBoxHelper, IComboBoxHelper_Ptr);
   begin
      if this.m_IComboBoxHelper /= null then
         if this.m_IComboBoxHelper.all /= null then
            temp := this.m_IComboBoxHelper.all.Release;
            if temp < 1 then
               Free (this.m_IComboBoxHelper);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ComboBoxHelper

   function get_KeepInteriorCornersSquareProperty_ComboBoxHelper
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IComboBoxHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxHelperStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeepInteriorCornersSquareProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetKeepInteriorCornersSquare
   (
      comboBox : WinUI3.Microsoft.UI.Xaml.Controls.ComboBox'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IComboBoxHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IComboBoxHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetKeepInteriorCornersSquare (comboBox.m_IComboBox.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function GetKeepInteriorCornersSquare
   (
      comboBox : WinUI3.Microsoft.UI.Xaml.Controls.ComboBox'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ComboBoxHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IComboBoxHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IComboBoxHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetKeepInteriorCornersSquare (comboBox.m_IComboBox.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ComboBoxHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ComboBoxTemplateSettings

   procedure Initialize (this : in out ComboBoxTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out ComboBoxTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IComboBoxTemplateSettings, IComboBoxTemplateSettings_Ptr);
   begin
      if this.m_IComboBoxTemplateSettings /= null then
         if this.m_IComboBoxTemplateSettings.all /= null then
            temp := this.m_IComboBoxTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_IComboBoxTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ComboBoxTemplateSettings

   function get_DropDownOpenedHeight
   (
      this : in out ComboBoxTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IComboBoxTemplateSettings.all.get_DropDownOpenedHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DropDownClosedHeight
   (
      this : in out ComboBoxTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IComboBoxTemplateSettings.all.get_DropDownClosedHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DropDownOffset
   (
      this : in out ComboBoxTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IComboBoxTemplateSettings.all.get_DropDownOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectedItemDirection
   (
      this : in out ComboBoxTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.AnimationDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.AnimationDirection;
   begin
      Hr := this.m_IComboBoxTemplateSettings.all.get_SelectedItemDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DropDownContentMinWidth
   (
      this : in out ComboBoxTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IComboBoxTemplateSettings.all.get_DropDownContentMinWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CommandBarFlyoutCommandBar

   procedure Initialize (this : in out CommandBarFlyoutCommandBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out CommandBarFlyoutCommandBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICommandBarFlyoutCommandBar, ICommandBarFlyoutCommandBar_Ptr);
   begin
      if this.m_ICommandBarFlyoutCommandBar /= null then
         if this.m_ICommandBarFlyoutCommandBar.all /= null then
            temp := this.m_ICommandBarFlyoutCommandBar.all.Release;
            if temp < 1 then
               Free (this.m_ICommandBarFlyoutCommandBar);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CommandBarFlyoutCommandBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CommandBarFlyoutCommandBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar");
      m_Factory    : access ICommandBarFlyoutCommandBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBar;
   begin
      return RetVal : CommandBarFlyoutCommandBar do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarFlyoutCommandBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICommandBarFlyoutCommandBar := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBar;
            Retval.m_ICommandBarFlyoutCommandBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CommandBarFlyoutCommandBar

   function get_SystemBackdropProperty_CommandBarFlyoutCommandBar
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarFlyoutCommandBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SystemBackdropProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CommandBarFlyoutCommandBar

   function get_FlyoutTemplateSettings
   (
      this : in out CommandBarFlyoutCommandBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBarTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings do
         Hr := this.m_ICommandBarFlyoutCommandBar.all.get_FlyoutTemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICommandBarFlyoutCommandBarTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBarTemplateSettings;
         Retval.m_ICommandBarFlyoutCommandBarTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_SystemBackdrop
   (
      this : in out CommandBarFlyoutCommandBar
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBar2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISystemBackdrop;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBar_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBar2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_ICommandBarFlyoutCommandBar2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop do
         m_Interface := QInterface (this.m_ICommandBarFlyoutCommandBar.all);
         Hr := m_Interface.get_SystemBackdrop (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISystemBackdrop := new WinUI3.Microsoft.UI.Xaml.Media.ISystemBackdrop;
         Retval.m_ISystemBackdrop.all := m_ComRetVal;
      end return;
   end;

   procedure put_SystemBackdrop
   (
      this : in out CommandBarFlyoutCommandBar;
      value : WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBar2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBar_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBar2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_ICommandBarFlyoutCommandBar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBarFlyoutCommandBar.all);
      Hr := m_Interface.put_SystemBackdrop (value.m_ISystemBackdrop.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body CommandBarFlyoutCommandBarAutomationProperties is

      function get_ControlTypeProperty
      return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
         Hr               : WinUI3.HResult := S_OK;
         tmp              : WinUI3.HResult := S_OK;
         m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties");
         m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBarAutomationPropertiesStatics_Interface'Class := null;
         temp             : WinUI3.UInt32 := 0;
         m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
      begin
         return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
            Hr := RoGetActivationFactory (m_hString, IID_ICommandBarFlyoutCommandBarAutomationPropertiesStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.get_ControlTypeProperty (m_ComRetVal'Access);
               temp := m_Factory.Release;
               if Hr /= S_OK then
                  raise Program_Error;
               end if;
               Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
               Retval.m_IDependencyProperty.all := m_ComRetVal;
            end if;
            tmp := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetControlType
      (
         element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
      )
      return WinUI3.Microsoft.UI.Xaml.Automation.Peers.AutomationControlType is
         Hr               : WinUI3.HResult := S_OK;
         tmp              : WinUI3.HResult := S_OK;
         m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties");
         m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBarAutomationPropertiesStatics_Interface'Class := null;
         temp             : WinUI3.UInt32 := 0;
         m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Automation.Peers.AutomationControlType;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarFlyoutCommandBarAutomationPropertiesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetControlType (element.m_IUIElement.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      procedure SetControlType
      (
         element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
         value : WinUI3.Microsoft.UI.Xaml.Automation.Peers.AutomationControlType
      ) is
         Hr               : WinUI3.HResult := S_OK;
         tmp              : WinUI3.HResult := S_OK;
         m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarAutomationProperties");
         m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICommandBarFlyoutCommandBarAutomationPropertiesStatics_Interface'Class := null;
         temp             : WinUI3.UInt32 := 0;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarFlyoutCommandBarAutomationPropertiesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.SetControlType (element.m_IUIElement.all, value);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end;

   end CommandBarFlyoutCommandBarAutomationProperties;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CommandBarFlyoutCommandBarTemplateSettings

   procedure Initialize (this : in out CommandBarFlyoutCommandBarTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out CommandBarFlyoutCommandBarTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICommandBarFlyoutCommandBarTemplateSettings, ICommandBarFlyoutCommandBarTemplateSettings_Ptr);
   begin
      if this.m_ICommandBarFlyoutCommandBarTemplateSettings /= null then
         if this.m_ICommandBarFlyoutCommandBarTemplateSettings.all /= null then
            temp := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_ICommandBarFlyoutCommandBarTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CommandBarFlyoutCommandBarTemplateSettings

   function get_OpenAnimationStartPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_OpenAnimationStartPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OpenAnimationEndPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_OpenAnimationEndPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CloseAnimationEndPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_CloseAnimationEndPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CurrentWidth
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_CurrentWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExpandedWidth
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_ExpandedWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WidthExpansionDelta
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_WidthExpansionDelta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WidthExpansionAnimationStartPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_WidthExpansionAnimationStartPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WidthExpansionAnimationEndPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_WidthExpansionAnimationEndPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WidthExpansionMoreButtonAnimationStartPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_WidthExpansionMoreButtonAnimationStartPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WidthExpansionMoreButtonAnimationEndPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_WidthExpansionMoreButtonAnimationEndPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExpandUpOverflowVerticalPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_ExpandUpOverflowVerticalPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExpandDownOverflowVerticalPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_ExpandDownOverflowVerticalPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExpandUpAnimationStartPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_ExpandUpAnimationStartPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExpandUpAnimationEndPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_ExpandUpAnimationEndPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExpandUpAnimationHoldPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_ExpandUpAnimationHoldPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExpandDownAnimationStartPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_ExpandDownAnimationStartPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExpandDownAnimationEndPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_ExpandDownAnimationEndPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExpandDownAnimationHoldPosition
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_ExpandDownAnimationHoldPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContentClipRect
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_ContentClipRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowContentClipRect
   (
      this : in out CommandBarFlyoutCommandBarTemplateSettings
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_ICommandBarFlyoutCommandBarTemplateSettings.all.get_OverflowContentClipRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CommandBarTemplateSettings

   procedure Initialize (this : in out CommandBarTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out CommandBarTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICommandBarTemplateSettings, ICommandBarTemplateSettings_Ptr);
   begin
      if this.m_ICommandBarTemplateSettings /= null then
         if this.m_ICommandBarTemplateSettings.all /= null then
            temp := this.m_ICommandBarTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_ICommandBarTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CommandBarTemplateSettings

   function get_ContentHeight
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_ContentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowContentClipRect
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_OverflowContentClipRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowContentMinWidth
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_OverflowContentMinWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowContentMaxWidth
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_OverflowContentMaxWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowContentMaxHeight
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_OverflowContentMaxHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowContentHorizontalOffset
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_OverflowContentHorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowContentHeight
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_OverflowContentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NegativeOverflowContentHeight
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_NegativeOverflowContentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_EffectiveOverflowButtonVisibility
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Visibility;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_EffectiveOverflowButtonVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowContentCompactYTranslation
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_OverflowContentCompactYTranslation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowContentMinimalYTranslation
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_OverflowContentMinimalYTranslation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowContentHiddenYTranslation
   (
      this : in out CommandBarTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICommandBarTemplateSettings.all.get_OverflowContentHiddenYTranslation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CornerRadiusFilterConverter

   procedure Initialize (this : in out CornerRadiusFilterConverter) is
   begin
      null;
   end;

   procedure Finalize (this : in out CornerRadiusFilterConverter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICornerRadiusFilterConverter, ICornerRadiusFilterConverter_Ptr);
   begin
      if this.m_ICornerRadiusFilterConverter /= null then
         if this.m_ICornerRadiusFilterConverter.all /= null then
            temp := this.m_ICornerRadiusFilterConverter.all.Release;
            if temp < 1 then
               Free (this.m_ICornerRadiusFilterConverter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CornerRadiusFilterConverter

   function Constructor return CornerRadiusFilterConverter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusFilterConverter;
   begin
      return RetVal : CornerRadiusFilterConverter do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICornerRadiusFilterConverter := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusFilterConverter;
            Retval.m_ICornerRadiusFilterConverter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CornerRadiusFilterConverter

   function get_FilterProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusFilterConverterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICornerRadiusFilterConverterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FilterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScaleProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterConverter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusFilterConverterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICornerRadiusFilterConverterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScaleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CornerRadiusFilterConverter

   function get_Filter
   (
      this : in out CornerRadiusFilterConverter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterKind;
   begin
      Hr := this.m_ICornerRadiusFilterConverter.all.get_Filter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Filter
   (
      this : in out CornerRadiusFilterConverter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusFilterKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICornerRadiusFilterConverter.all.put_Filter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Scale
   (
      this : in out CornerRadiusFilterConverter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICornerRadiusFilterConverter.all.get_Scale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Scale
   (
      this : in out CornerRadiusFilterConverter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICornerRadiusFilterConverter.all.put_Scale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function Convert
   (
      this : in out CornerRadiusFilterConverter;
      value : WinUI3.IInspectable;
      targetType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      language : WinUI3.WString
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.IValueConverter := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      HStr_language : constant WinUI3.HString := To_HString (language);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusFilterConverter_Interface, WinUI3.Microsoft.UI.Xaml.Data.IValueConverter, WinUI3.Microsoft.UI.Xaml.Data.IID_IValueConverter'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICornerRadiusFilterConverter.all);
      Hr := m_Interface.Convert (value, targetType, parameter, HStr_language, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_language);
      return m_ComRetVal;
   end;

   function ConvertBack
   (
      this : in out CornerRadiusFilterConverter;
      value : WinUI3.IInspectable;
      targetType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      language : WinUI3.WString
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.IValueConverter := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      HStr_language : constant WinUI3.HString := To_HString (language);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusFilterConverter_Interface, WinUI3.Microsoft.UI.Xaml.Data.IValueConverter, WinUI3.Microsoft.UI.Xaml.Data.IID_IValueConverter'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICornerRadiusFilterConverter.all);
      Hr := m_Interface.ConvertBack (value, targetType, parameter, HStr_language, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_language);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CornerRadiusToThicknessConverter

   procedure Initialize (this : in out CornerRadiusToThicknessConverter) is
   begin
      null;
   end;

   procedure Finalize (this : in out CornerRadiusToThicknessConverter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICornerRadiusToThicknessConverter, ICornerRadiusToThicknessConverter_Ptr);
   begin
      if this.m_ICornerRadiusToThicknessConverter /= null then
         if this.m_ICornerRadiusToThicknessConverter.all /= null then
            temp := this.m_ICornerRadiusToThicknessConverter.all.Release;
            if temp < 1 then
               Free (this.m_ICornerRadiusToThicknessConverter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CornerRadiusToThicknessConverter

   function Constructor return CornerRadiusToThicknessConverter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusToThicknessConverter;
   begin
      return RetVal : CornerRadiusToThicknessConverter do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICornerRadiusToThicknessConverter := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusToThicknessConverter;
            Retval.m_ICornerRadiusToThicknessConverter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CornerRadiusToThicknessConverter

   function get_ConversionKindProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusToThicknessConverterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICornerRadiusToThicknessConverterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ConversionKindProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MultiplierProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusToThicknessConverterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICornerRadiusToThicknessConverterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MultiplierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CornerRadiusToThicknessConverter

   function get_ConversionKind
   (
      this : in out CornerRadiusToThicknessConverter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverterKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverterKind;
   begin
      Hr := this.m_ICornerRadiusToThicknessConverter.all.get_ConversionKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ConversionKind
   (
      this : in out CornerRadiusToThicknessConverter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.CornerRadiusToThicknessConverterKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICornerRadiusToThicknessConverter.all.put_ConversionKind (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Multiplier
   (
      this : in out CornerRadiusToThicknessConverter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICornerRadiusToThicknessConverter.all.get_Multiplier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Multiplier
   (
      this : in out CornerRadiusToThicknessConverter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICornerRadiusToThicknessConverter.all.put_Multiplier (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function Convert
   (
      this : in out CornerRadiusToThicknessConverter;
      value : WinUI3.IInspectable;
      targetType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      language : WinUI3.WString
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.IValueConverter := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      HStr_language : constant WinUI3.HString := To_HString (language);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusToThicknessConverter_Interface, WinUI3.Microsoft.UI.Xaml.Data.IValueConverter, WinUI3.Microsoft.UI.Xaml.Data.IID_IValueConverter'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICornerRadiusToThicknessConverter.all);
      Hr := m_Interface.Convert (value, targetType, parameter, HStr_language, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_language);
      return m_ComRetVal;
   end;

   function ConvertBack
   (
      this : in out CornerRadiusToThicknessConverter;
      value : WinUI3.IInspectable;
      targetType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      language : WinUI3.WString
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.IValueConverter := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      HStr_language : constant WinUI3.HString := To_HString (language);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ICornerRadiusToThicknessConverter_Interface, WinUI3.Microsoft.UI.Xaml.Data.IValueConverter, WinUI3.Microsoft.UI.Xaml.Data.IID_IValueConverter'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICornerRadiusToThicknessConverter.all);
      Hr := m_Interface.ConvertBack (value, targetType, parameter, HStr_language, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_language);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragCompletedEventArgs

   procedure Initialize (this : in out DragCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragCompletedEventArgs, IDragCompletedEventArgs_Ptr);
   begin
      if this.m_IDragCompletedEventArgs /= null then
         if this.m_IDragCompletedEventArgs.all /= null then
            temp := this.m_IDragCompletedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IDragCompletedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DragCompletedEventArgs

   function Constructor
   (
      horizontalChange : WinUI3.Double;
      verticalChange : WinUI3.Double;
      canceled : WinUI3.Boolean;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DragCompletedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.DragCompletedEventArgs");
      m_Factory    : access IDragCompletedEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IDragCompletedEventArgs;
   begin
      return RetVal : DragCompletedEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IDragCompletedEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithHorizontalChangeVerticalChangeAndCanceled (horizontalChange, verticalChange, canceled, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDragCompletedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IDragCompletedEventArgs;
            Retval.m_IDragCompletedEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragCompletedEventArgs

   function get_HorizontalChange
   (
      this : in out DragCompletedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IDragCompletedEventArgs.all.get_HorizontalChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalChange
   (
      this : in out DragCompletedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IDragCompletedEventArgs.all.get_VerticalChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Canceled
   (
      this : in out DragCompletedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDragCompletedEventArgs.all.get_Canceled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate DragCompletedEventHandler

   function Invoke
   (
      this : access DragCompletedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IDragCompletedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragDeltaEventArgs

   procedure Initialize (this : in out DragDeltaEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragDeltaEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragDeltaEventArgs, IDragDeltaEventArgs_Ptr);
   begin
      if this.m_IDragDeltaEventArgs /= null then
         if this.m_IDragDeltaEventArgs.all /= null then
            temp := this.m_IDragDeltaEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IDragDeltaEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DragDeltaEventArgs

   function Constructor
   (
      horizontalChange : WinUI3.Double;
      verticalChange : WinUI3.Double;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DragDeltaEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.DragDeltaEventArgs");
      m_Factory    : access IDragDeltaEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IDragDeltaEventArgs;
   begin
      return RetVal : DragDeltaEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IDragDeltaEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithHorizontalChangeAndVerticalChange (horizontalChange, verticalChange, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDragDeltaEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IDragDeltaEventArgs;
            Retval.m_IDragDeltaEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragDeltaEventArgs

   function get_HorizontalChange
   (
      this : in out DragDeltaEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IDragDeltaEventArgs.all.get_HorizontalChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalChange
   (
      this : in out DragDeltaEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IDragDeltaEventArgs.all.get_VerticalChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate DragDeltaEventHandler

   function Invoke
   (
      this : access DragDeltaEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IDragDeltaEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragStartedEventArgs

   procedure Initialize (this : in out DragStartedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragStartedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragStartedEventArgs, IDragStartedEventArgs_Ptr);
   begin
      if this.m_IDragStartedEventArgs /= null then
         if this.m_IDragStartedEventArgs.all /= null then
            temp := this.m_IDragStartedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IDragStartedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DragStartedEventArgs

   function Constructor
   (
      horizontalOffset : WinUI3.Double;
      verticalOffset : WinUI3.Double;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DragStartedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.DragStartedEventArgs");
      m_Factory    : access IDragStartedEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IDragStartedEventArgs;
   begin
      return RetVal : DragStartedEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IDragStartedEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithHorizontalOffsetAndVerticalOffset (horizontalOffset, verticalOffset, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDragStartedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IDragStartedEventArgs;
            Retval.m_IDragStartedEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragStartedEventArgs

   function get_HorizontalOffset
   (
      this : in out DragStartedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IDragStartedEventArgs.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalOffset
   (
      this : in out DragStartedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IDragStartedEventArgs.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate DragStartedEventHandler

   function Invoke
   (
      this : access DragStartedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IDragStartedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FlyoutBaseClosingEventArgs

   procedure Initialize (this : in out FlyoutBaseClosingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out FlyoutBaseClosingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlyoutBaseClosingEventArgs, IFlyoutBaseClosingEventArgs_Ptr);
   begin
      if this.m_IFlyoutBaseClosingEventArgs /= null then
         if this.m_IFlyoutBaseClosingEventArgs.all /= null then
            temp := this.m_IFlyoutBaseClosingEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IFlyoutBaseClosingEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FlyoutBaseClosingEventArgs

   function get_Cancel
   (
      this : in out FlyoutBaseClosingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFlyoutBaseClosingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out FlyoutBaseClosingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutBaseClosingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FlyoutShowOptions

   procedure Initialize (this : in out FlyoutShowOptions) is
   begin
      null;
   end;

   procedure Finalize (this : in out FlyoutShowOptions) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlyoutShowOptions, IFlyoutShowOptions_Ptr);
   begin
      if this.m_IFlyoutShowOptions /= null then
         if this.m_IFlyoutShowOptions.all /= null then
            temp := this.m_IFlyoutShowOptions.all.Release;
            if temp < 1 then
               Free (this.m_IFlyoutShowOptions);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FlyoutShowOptions

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FlyoutShowOptions is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowOptions");
      m_Factory    : access IFlyoutShowOptionsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutShowOptions;
   begin
      return RetVal : FlyoutShowOptions do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutShowOptionsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFlyoutShowOptions := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IFlyoutShowOptions;
            Retval.m_IFlyoutShowOptions.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FlyoutShowOptions

   function get_Position
   (
      this : in out FlyoutShowOptions
   )
   return IReference_Point.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Point.Kind;
   begin
      Hr := this.m_IFlyoutShowOptions.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Point (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_Position
   (
      this : in out FlyoutShowOptions;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutShowOptions.all.put_Position (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExclusionRect
   (
      this : in out FlyoutShowOptions
   )
   return IReference_Rect.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Rect.Kind;
   begin
      Hr := this.m_IFlyoutShowOptions.all.get_ExclusionRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Rect (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ExclusionRect
   (
      this : in out FlyoutShowOptions;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutShowOptions.all.put_ExclusionRect (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowMode
   (
      this : in out FlyoutShowOptions
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowMode;
   begin
      Hr := this.m_IFlyoutShowOptions.all.get_ShowMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowMode
   (
      this : in out FlyoutShowOptions;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutShowMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutShowOptions.all.put_ShowMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Placement
   (
      this : in out FlyoutShowOptions
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutPlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutPlacementMode;
   begin
      Hr := this.m_IFlyoutShowOptions.all.get_Placement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Placement
   (
      this : in out FlyoutShowOptions;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.FlyoutPlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyoutShowOptions.all.put_Placement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GeneratorPositionHelper

   procedure Initialize (this : in out GeneratorPositionHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out GeneratorPositionHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeneratorPositionHelper, IGeneratorPositionHelper_Ptr);
   begin
      if this.m_IGeneratorPositionHelper /= null then
         if this.m_IGeneratorPositionHelper.all /= null then
            temp := this.m_IGeneratorPositionHelper.all.Release;
            if temp < 1 then
               Free (this.m_IGeneratorPositionHelper);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for GeneratorPositionHelper

   function FromIndexAndOffset
   (
      index : WinUI3.Int32;
      offset : WinUI3.Int32
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GeneratorPositionHelper");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGeneratorPositionHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGeneratorPositionHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromIndexAndOffset (index, offset, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GeneratorPositionHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GridViewItemPresenter

   procedure Initialize (this : in out GridViewItemPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out GridViewItemPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGridViewItemPresenter, IGridViewItemPresenter_Ptr);
   begin
      if this.m_IGridViewItemPresenter /= null then
         if this.m_IGridViewItemPresenter.all /= null then
            temp := this.m_IGridViewItemPresenter.all.Release;
            if temp < 1 then
               Free (this.m_IGridViewItemPresenter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GridViewItemPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GridViewItemPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory    : access IGridViewItemPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenter;
   begin
      return RetVal : GridViewItemPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGridViewItemPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenter;
            Retval.m_IGridViewItemPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for GridViewItemPresenter

   function get_SelectionCheckMarkVisualEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionCheckMarkVisualEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckHintBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckHintBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckSelectingBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckSelectingBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DragBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DragBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DragForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DragForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPointerOverBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPointerOverBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPointerOverBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPointerOverBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedBorderThicknessProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedBorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisabledOpacityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledOpacityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DragOpacityProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DragOpacityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ReorderHintOffsetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ReorderHintOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GridViewItemPresenterHorizontalContentAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GridViewItemPresenterHorizontalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GridViewItemPresenterVerticalContentAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GridViewItemPresenterVerticalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GridViewItemPresenterPaddingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GridViewItemPresenterPaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverBackgroundMarginProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverBackgroundMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentMarginProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.GridViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IGridViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GridViewItemPresenter

   function get_SelectionCheckMarkVisualEnabled
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGridViewItemPresenter.all.get_SelectionCheckMarkVisualEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionCheckMarkVisualEnabled
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_SelectionCheckMarkVisualEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckHintBrush
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_CheckHintBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckHintBrush
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_CheckHintBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckSelectingBrush
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_CheckSelectingBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckSelectingBrush
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_CheckSelectingBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBrush
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_CheckBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBrush
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_CheckBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DragBackground
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_DragBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_DragBackground
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_DragBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DragForeground
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_DragForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_DragForeground
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_DragForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusBorderBrush
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_FocusBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_FocusBorderBrush
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_FocusBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderBackground
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_PlaceholderBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlaceholderBackground
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_PlaceholderBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerOverBackground
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_PointerOverBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PointerOverBackground
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_PointerOverBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedBackground
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_SelectedBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedBackground
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_SelectedBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedForeground
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_SelectedForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedForeground
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_SelectedForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPointerOverBackground
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_SelectedPointerOverBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedPointerOverBackground
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_SelectedPointerOverBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPointerOverBorderBrush
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IGridViewItemPresenter.all.get_SelectedPointerOverBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedPointerOverBorderBrush
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_SelectedPointerOverBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedBorderThickness
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IGridViewItemPresenter.all.get_SelectedBorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedBorderThickness
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_SelectedBorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisabledOpacity
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IGridViewItemPresenter.all.get_DisabledOpacity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DisabledOpacity
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_DisabledOpacity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DragOpacity
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IGridViewItemPresenter.all.get_DragOpacity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DragOpacity
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_DragOpacity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ReorderHintOffset
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IGridViewItemPresenter.all.get_ReorderHintOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ReorderHintOffset
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_ReorderHintOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GridViewItemPresenterHorizontalContentAlignment
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_IGridViewItemPresenter.all.get_GridViewItemPresenterHorizontalContentAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GridViewItemPresenterHorizontalContentAlignment
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_GridViewItemPresenterHorizontalContentAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GridViewItemPresenterVerticalContentAlignment
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_IGridViewItemPresenter.all.get_GridViewItemPresenterVerticalContentAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GridViewItemPresenterVerticalContentAlignment
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_GridViewItemPresenterVerticalContentAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GridViewItemPresenterPadding
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IGridViewItemPresenter.all.get_GridViewItemPresenterPadding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GridViewItemPresenterPadding
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_GridViewItemPresenterPadding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerOverBackgroundMargin
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IGridViewItemPresenter.all.get_PointerOverBackgroundMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PointerOverBackgroundMargin
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_PointerOverBackgroundMargin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentMargin
   (
      this : in out GridViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IGridViewItemPresenter.all.get_ContentMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ContentMargin
   (
      this : in out GridViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGridViewItemPresenter.all.put_ContentMargin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GridViewItemTemplateSettings

   procedure Initialize (this : in out GridViewItemTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out GridViewItemTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGridViewItemTemplateSettings, IGridViewItemTemplateSettings_Ptr);
   begin
      if this.m_IGridViewItemTemplateSettings /= null then
         if this.m_IGridViewItemTemplateSettings.all /= null then
            temp := this.m_IGridViewItemTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_IGridViewItemTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GridViewItemTemplateSettings

   function get_DragItemsCount
   (
      this : in out GridViewItemTemplateSettings
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IGridViewItemTemplateSettings.all.get_DragItemsCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InfoBarPanel

   procedure Initialize (this : in out InfoBarPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out InfoBarPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInfoBarPanel, IInfoBarPanel_Ptr);
   begin
      if this.m_IInfoBarPanel /= null then
         if this.m_IInfoBarPanel.all /= null then
            temp := this.m_IInfoBarPanel.all.Release;
            if temp < 1 then
               Free (this.m_IInfoBarPanel);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InfoBarPanel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InfoBarPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel");
      m_Factory    : access IInfoBarPanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IInfoBarPanel;
   begin
      return RetVal : InfoBarPanel do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarPanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInfoBarPanel := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IInfoBarPanel;
            Retval.m_IInfoBarPanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InfoBarPanel

   function get_HorizontalOrientationPaddingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IInfoBarPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalOrientationPaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalOrientationPaddingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IInfoBarPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalOrientationPaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetHorizontalOrientationMargin
   (
      object : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IInfoBarPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IInfoBarPanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetHorizontalOrientationMargin (object.m_IDependencyObject.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function GetHorizontalOrientationMargin
   (
      object : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IInfoBarPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IInfoBarPanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetHorizontalOrientationMargin (object.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_HorizontalOrientationMarginProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IInfoBarPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalOrientationMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetVerticalOrientationMargin
   (
      object : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IInfoBarPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IInfoBarPanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetVerticalOrientationMargin (object.m_IDependencyObject.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function GetVerticalOrientationMargin
   (
      object : WinUI3.Microsoft.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IInfoBarPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IInfoBarPanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetVerticalOrientationMargin (object.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_VerticalOrientationMarginProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.InfoBarPanel");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IInfoBarPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInfoBarPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalOrientationMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InfoBarPanel

   function get_HorizontalOrientationPadding
   (
      this : in out InfoBarPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IInfoBarPanel.all.get_HorizontalOrientationPadding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalOrientationPadding
   (
      this : in out InfoBarPanel;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBarPanel.all.put_HorizontalOrientationPadding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalOrientationPadding
   (
      this : in out InfoBarPanel
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IInfoBarPanel.all.get_VerticalOrientationPadding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalOrientationPadding
   (
      this : in out InfoBarPanel;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInfoBarPanel.all.put_VerticalOrientationPadding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsChangedEventArgs

   procedure Initialize (this : in out ItemsChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsChangedEventArgs, IItemsChangedEventArgs_Ptr);
   begin
      if this.m_IItemsChangedEventArgs /= null then
         if this.m_IItemsChangedEventArgs.all /= null then
            temp := this.m_IItemsChangedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IItemsChangedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsChangedEventArgs

   function get_Action
   (
      this : in out ItemsChangedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsChangedEventArgs.all.get_Action (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out ItemsChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition;
   begin
      Hr := this.m_IItemsChangedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OldPosition
   (
      this : in out ItemsChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.GeneratorPosition;
   begin
      Hr := this.m_IItemsChangedEventArgs.all.get_OldPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ItemCount
   (
      this : in out ItemsChangedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsChangedEventArgs.all.get_ItemCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ItemUICount
   (
      this : in out ItemsChangedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsChangedEventArgs.all.get_ItemUICount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ItemsChangedEventHandler

   function Invoke
   (
      this : access ItemsChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IItemsChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for JumpListItemBackgroundConverter

   procedure Initialize (this : in out JumpListItemBackgroundConverter) is
   begin
      null;
   end;

   procedure Finalize (this : in out JumpListItemBackgroundConverter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IJumpListItemBackgroundConverter, IJumpListItemBackgroundConverter_Ptr);
   begin
      if this.m_IJumpListItemBackgroundConverter /= null then
         if this.m_IJumpListItemBackgroundConverter.all /= null then
            temp := this.m_IJumpListItemBackgroundConverter.all.Release;
            if temp < 1 then
               Free (this.m_IJumpListItemBackgroundConverter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for JumpListItemBackgroundConverter

   function Constructor return JumpListItemBackgroundConverter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemBackgroundConverter;
   begin
      return RetVal : JumpListItemBackgroundConverter do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IJumpListItemBackgroundConverter := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemBackgroundConverter;
            Retval.m_IJumpListItemBackgroundConverter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for JumpListItemBackgroundConverter

   function get_EnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemBackgroundConverterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IJumpListItemBackgroundConverterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemBackgroundConverterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IJumpListItemBackgroundConverterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for JumpListItemBackgroundConverter

   function get_Enabled
   (
      this : in out JumpListItemBackgroundConverter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IJumpListItemBackgroundConverter.all.get_Enabled (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Enabled
   (
      this : in out JumpListItemBackgroundConverter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IJumpListItemBackgroundConverter.all.put_Enabled (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Disabled
   (
      this : in out JumpListItemBackgroundConverter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IJumpListItemBackgroundConverter.all.get_Disabled (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Disabled
   (
      this : in out JumpListItemBackgroundConverter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IJumpListItemBackgroundConverter.all.put_Disabled (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function Convert
   (
      this : in out JumpListItemBackgroundConverter;
      value : WinUI3.IInspectable;
      targetType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      language : WinUI3.WString
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.IValueConverter := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      HStr_language : constant WinUI3.HString := To_HString (language);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemBackgroundConverter_Interface, WinUI3.Microsoft.UI.Xaml.Data.IValueConverter, WinUI3.Microsoft.UI.Xaml.Data.IID_IValueConverter'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IJumpListItemBackgroundConverter.all);
      Hr := m_Interface.Convert (value, targetType, parameter, HStr_language, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_language);
      return m_ComRetVal;
   end;

   function ConvertBack
   (
      this : in out JumpListItemBackgroundConverter;
      value : WinUI3.IInspectable;
      targetType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      language : WinUI3.WString
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.IValueConverter := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      HStr_language : constant WinUI3.HString := To_HString (language);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemBackgroundConverter_Interface, WinUI3.Microsoft.UI.Xaml.Data.IValueConverter, WinUI3.Microsoft.UI.Xaml.Data.IID_IValueConverter'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IJumpListItemBackgroundConverter.all);
      Hr := m_Interface.ConvertBack (value, targetType, parameter, HStr_language, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_language);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for JumpListItemForegroundConverter

   procedure Initialize (this : in out JumpListItemForegroundConverter) is
   begin
      null;
   end;

   procedure Finalize (this : in out JumpListItemForegroundConverter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IJumpListItemForegroundConverter, IJumpListItemForegroundConverter_Ptr);
   begin
      if this.m_IJumpListItemForegroundConverter /= null then
         if this.m_IJumpListItemForegroundConverter.all /= null then
            temp := this.m_IJumpListItemForegroundConverter.all.Release;
            if temp < 1 then
               Free (this.m_IJumpListItemForegroundConverter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for JumpListItemForegroundConverter

   function Constructor return JumpListItemForegroundConverter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemForegroundConverter;
   begin
      return RetVal : JumpListItemForegroundConverter do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IJumpListItemForegroundConverter := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemForegroundConverter;
            Retval.m_IJumpListItemForegroundConverter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for JumpListItemForegroundConverter

   function get_EnabledProperty_JumpListItemForegroundConverter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemForegroundConverterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IJumpListItemForegroundConverterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisabledProperty_JumpListItemForegroundConverter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemForegroundConverterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IJumpListItemForegroundConverterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for JumpListItemForegroundConverter

   function get_Enabled
   (
      this : in out JumpListItemForegroundConverter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IJumpListItemForegroundConverter.all.get_Enabled (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Enabled
   (
      this : in out JumpListItemForegroundConverter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IJumpListItemForegroundConverter.all.put_Enabled (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Disabled
   (
      this : in out JumpListItemForegroundConverter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IJumpListItemForegroundConverter.all.get_Disabled (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Disabled
   (
      this : in out JumpListItemForegroundConverter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IJumpListItemForegroundConverter.all.put_Disabled (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function Convert
   (
      this : in out JumpListItemForegroundConverter;
      value : WinUI3.IInspectable;
      targetType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      language : WinUI3.WString
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.IValueConverter := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      HStr_language : constant WinUI3.HString := To_HString (language);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemForegroundConverter_Interface, WinUI3.Microsoft.UI.Xaml.Data.IValueConverter, WinUI3.Microsoft.UI.Xaml.Data.IID_IValueConverter'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IJumpListItemForegroundConverter.all);
      Hr := m_Interface.Convert (value, targetType, parameter, HStr_language, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_language);
      return m_ComRetVal;
   end;

   function ConvertBack
   (
      this : in out JumpListItemForegroundConverter;
      value : WinUI3.IInspectable;
      targetType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      language : WinUI3.WString
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Data.IValueConverter := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      HStr_language : constant WinUI3.HString := To_HString (language);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IJumpListItemForegroundConverter_Interface, WinUI3.Microsoft.UI.Xaml.Data.IValueConverter, WinUI3.Microsoft.UI.Xaml.Data.IID_IValueConverter'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IJumpListItemForegroundConverter.all);
      Hr := m_Interface.ConvertBack (value, targetType, parameter, HStr_language, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_language);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LayoutInformation

   procedure Initialize (this : in out LayoutInformation) is
   begin
      null;
   end;

   procedure Finalize (this : in out LayoutInformation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILayoutInformation, ILayoutInformation_Ptr);
   begin
      if this.m_ILayoutInformation /= null then
         if this.m_ILayoutInformation.all /= null then
            temp := this.m_ILayoutInformation.all.Release;
            if temp < 1 then
               Free (this.m_ILayoutInformation);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for LayoutInformation

   function GetLayoutExceptionElement
   (
      dispatcher : WinUI3.IInspectable
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.LayoutInformation");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILayoutInformationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := RoGetActivationFactory (m_hString, IID_ILayoutInformationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetLayoutExceptionElement (dispatcher, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
            Retval.m_IUIElement.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetLayoutSlot
   (
      element : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.LayoutInformation");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILayoutInformationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ILayoutInformationStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetLayoutSlot (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetAvailableSize
   (
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.LayoutInformation");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILayoutInformationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ILayoutInformationStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAvailableSize (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LayoutInformation

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewItemPresenter

   procedure Initialize (this : in out ListViewItemPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewItemPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewItemPresenter, IListViewItemPresenter_Ptr);
   begin
      if this.m_IListViewItemPresenter /= null then
         if this.m_IListViewItemPresenter.all /= null then
            temp := this.m_IListViewItemPresenter.all.Release;
            if temp < 1 then
               Free (this.m_IListViewItemPresenter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListViewItemPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListViewItemPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory    : access IListViewItemPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenter;
   begin
      return RetVal : ListViewItemPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListViewItemPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenter;
            Retval.m_IListViewItemPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ListViewItemPresenter

   function get_SelectionCheckMarkVisualEnabledProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionCheckMarkVisualEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckHintBrushProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckHintBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckSelectingBrushProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckSelectingBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBrushProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DragBackgroundProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DragBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DragForegroundProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DragForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusBorderBrushProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderBackgroundProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverBackgroundProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedBackgroundProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedForegroundProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPointerOverBackgroundProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPointerOverBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPointerOverBorderBrushProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPointerOverBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedBorderThicknessProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedBorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisabledOpacityProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledOpacityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DragOpacityProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DragOpacityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ReorderHintOffsetProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ReorderHintOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ListViewItemPresenterHorizontalContentAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ListViewItemPresenterHorizontalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ListViewItemPresenterVerticalContentAlignmentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ListViewItemPresenterVerticalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ListViewItemPresenterPaddingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ListViewItemPresenterPaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverBackgroundMarginProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverBackgroundMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentMarginProperty_ListViewItemPresenter
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPressedBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPressedBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PressedBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PressedBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusSecondaryBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusSecondaryBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverForegroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RevealBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RevealBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RevealBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RevealBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RevealBorderThicknessProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RevealBorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RevealBackgroundShowsAboveContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RevealBackgroundShowsAboveContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedDisabledBackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedDisabledBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckPressedBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckPressedBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckDisabledBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckDisabledBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxPointerOverBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxPointerOverBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxPressedBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxPressedBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxDisabledBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxDisabledBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxSelectedBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxSelectedBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxSelectedPointerOverBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxSelectedPointerOverBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxSelectedPressedBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxSelectedPressedBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxSelectedDisabledBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxSelectedDisabledBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxPointerOverBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxPointerOverBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxPressedBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxPressedBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxDisabledBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxDisabledBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CheckBoxCornerRadiusProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CheckBoxCornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionIndicatorCornerRadiusProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionIndicatorCornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionIndicatorVisualEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionIndicatorVisualEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionIndicatorModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionIndicatorModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionIndicatorBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionIndicatorBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionIndicatorPointerOverBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionIndicatorPointerOverBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionIndicatorPressedBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionIndicatorPressedBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionIndicatorDisabledBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionIndicatorDisabledBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPressedBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPressedBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedDisabledBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedDisabledBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedInnerBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedInnerBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverBorderBrushProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IListViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewItemPresenter

   function get_SelectionCheckMarkVisualEnabled
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_SelectionCheckMarkVisualEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionCheckMarkVisualEnabled
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectionCheckMarkVisualEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckHintBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckHintBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckHintBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckHintBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckSelectingBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckSelectingBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckSelectingBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckSelectingBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DragBackground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_DragBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_DragBackground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_DragBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DragForeground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_DragForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_DragForeground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_DragForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_FocusBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_FocusBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_FocusBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderBackground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_PlaceholderBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlaceholderBackground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_PlaceholderBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerOverBackground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_PointerOverBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PointerOverBackground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_PointerOverBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedBackground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectedBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedBackground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectedBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedForeground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectedForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedForeground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectedForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPointerOverBackground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectedPointerOverBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedPointerOverBackground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectedPointerOverBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPointerOverBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectedPointerOverBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedPointerOverBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectedPointerOverBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedBorderThickness
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_SelectedBorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedBorderThickness
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectedBorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisabledOpacity
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_DisabledOpacity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DisabledOpacity
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_DisabledOpacity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DragOpacity
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_DragOpacity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DragOpacity
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_DragOpacity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ReorderHintOffset
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_ReorderHintOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ReorderHintOffset
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_ReorderHintOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ListViewItemPresenterHorizontalContentAlignment
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_ListViewItemPresenterHorizontalContentAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ListViewItemPresenterHorizontalContentAlignment
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_ListViewItemPresenterHorizontalContentAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ListViewItemPresenterVerticalContentAlignment
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_ListViewItemPresenterVerticalContentAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ListViewItemPresenterVerticalContentAlignment
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_ListViewItemPresenterVerticalContentAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ListViewItemPresenterPadding
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_ListViewItemPresenterPadding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ListViewItemPresenterPadding
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_ListViewItemPresenterPadding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerOverBackgroundMargin
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_PointerOverBackgroundMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PointerOverBackgroundMargin
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_PointerOverBackgroundMargin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentMargin
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_ContentMargin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ContentMargin
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_ContentMargin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPressedBackground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectedPressedBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedPressedBackground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectedPressedBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PressedBackground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_PressedBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PressedBackground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_PressedBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusSecondaryBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_FocusSecondaryBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_FocusSecondaryBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_FocusSecondaryBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckMode
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenterCheckMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenterCheckMode;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_CheckMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CheckMode
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenterCheckMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerOverForeground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_PointerOverForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PointerOverForeground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_PointerOverForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RevealBackground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_RevealBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_RevealBackground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_RevealBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RevealBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_RevealBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_RevealBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_RevealBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RevealBorderThickness
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Thickness;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_RevealBorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RevealBorderThickness
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_RevealBorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RevealBackgroundShowsAboveContent
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_RevealBackgroundShowsAboveContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RevealBackgroundShowsAboveContent
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_RevealBackgroundShowsAboveContent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedDisabledBackground
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectedDisabledBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedDisabledBackground
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectedDisabledBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckPressedBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckPressedBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckPressedBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckPressedBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckDisabledBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckDisabledBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckDisabledBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckDisabledBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxPointerOverBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxPointerOverBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxPointerOverBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxPointerOverBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxPressedBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxPressedBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxPressedBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxPressedBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxDisabledBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxDisabledBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxDisabledBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxDisabledBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxSelectedBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxSelectedBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxSelectedBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxSelectedBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxSelectedPointerOverBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxSelectedPointerOverBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxSelectedPointerOverBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxSelectedPointerOverBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxSelectedPressedBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxSelectedPressedBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxSelectedPressedBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxSelectedPressedBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxSelectedDisabledBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxSelectedDisabledBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxSelectedDisabledBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxSelectedDisabledBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxPointerOverBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxPointerOverBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxPointerOverBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxPointerOverBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxPressedBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxPressedBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxPressedBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxPressedBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxDisabledBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_CheckBoxDisabledBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CheckBoxDisabledBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxDisabledBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CheckBoxCornerRadius
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_CheckBoxCornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CheckBoxCornerRadius
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_CheckBoxCornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionIndicatorCornerRadius
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_SelectionIndicatorCornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionIndicatorCornerRadius
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectionIndicatorCornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionIndicatorVisualEnabled
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_SelectionIndicatorVisualEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionIndicatorVisualEnabled
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectionIndicatorVisualEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionIndicatorMode
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenterSelectionIndicatorMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenterSelectionIndicatorMode;
   begin
      Hr := this.m_IListViewItemPresenter.all.get_SelectionIndicatorMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionIndicatorMode
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ListViewItemPresenterSelectionIndicatorMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectionIndicatorMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionIndicatorBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectionIndicatorBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionIndicatorBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectionIndicatorBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionIndicatorPointerOverBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectionIndicatorPointerOverBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionIndicatorPointerOverBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectionIndicatorPointerOverBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionIndicatorPressedBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectionIndicatorPressedBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionIndicatorPressedBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectionIndicatorPressedBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionIndicatorDisabledBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectionIndicatorDisabledBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionIndicatorDisabledBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectionIndicatorDisabledBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectedBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectedBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPressedBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectedPressedBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedPressedBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectedPressedBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedDisabledBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectedDisabledBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedDisabledBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectedDisabledBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedInnerBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_SelectedInnerBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedInnerBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_SelectedInnerBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerOverBorderBrush
   (
      this : in out ListViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IListViewItemPresenter.all.get_PointerOverBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PointerOverBorderBrush
   (
      this : in out ListViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewItemPresenter.all.put_PointerOverBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewItemTemplateSettings

   procedure Initialize (this : in out ListViewItemTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewItemTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewItemTemplateSettings, IListViewItemTemplateSettings_Ptr);
   begin
      if this.m_IListViewItemTemplateSettings /= null then
         if this.m_IListViewItemTemplateSettings.all /= null then
            temp := this.m_IListViewItemTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_IListViewItemTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewItemTemplateSettings

   function get_DragItemsCount
   (
      this : in out ListViewItemTemplateSettings
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IListViewItemTemplateSettings.all.get_DragItemsCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LoopingSelector

   procedure Initialize (this : in out LoopingSelector) is
   begin
      null;
   end;

   procedure Finalize (this : in out LoopingSelector) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILoopingSelector, ILoopingSelector_Ptr);
   begin
      if this.m_ILoopingSelector /= null then
         if this.m_ILoopingSelector.all /= null then
            temp := this.m_ILoopingSelector.all.Release;
            if temp < 1 then
               Free (this.m_ILoopingSelector);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for LoopingSelector

   function get_ShouldLoopProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILoopingSelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShouldLoopProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILoopingSelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedIndexProperty_LoopingSelector
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILoopingSelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty_LoopingSelector
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILoopingSelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILoopingSelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILoopingSelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.LoopingSelector");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILoopingSelectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LoopingSelector

   function get_ShouldLoop
   (
      this : in out LoopingSelector
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ILoopingSelector.all.get_ShouldLoop (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShouldLoop
   (
      this : in out LoopingSelector;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILoopingSelector.all.put_ShouldLoop (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Items
   (
      this : in out LoopingSelector
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_ILoopingSelector.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_Items
   (
      this : in out LoopingSelector;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILoopingSelector.all.put_Items (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedIndex
   (
      this : in out LoopingSelector
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ILoopingSelector.all.get_SelectedIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedIndex
   (
      this : in out LoopingSelector;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILoopingSelector.all.put_SelectedIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItem
   (
      this : in out LoopingSelector
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ILoopingSelector.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedItem
   (
      this : in out LoopingSelector;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILoopingSelector.all.put_SelectedItem (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemWidth
   (
      this : in out LoopingSelector
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ILoopingSelector.all.get_ItemWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemWidth
   (
      this : in out LoopingSelector;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILoopingSelector.all.put_ItemWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemHeight
   (
      this : in out LoopingSelector
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ILoopingSelector.all.get_ItemHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemHeight
   (
      this : in out LoopingSelector;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILoopingSelector.all.put_ItemHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTemplate
   (
      this : in out LoopingSelector
   )
   return WinUI3.Microsoft.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DataTemplate do
         Hr := this.m_ILoopingSelector.all.get_ItemTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Microsoft.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplate
   (
      this : in out LoopingSelector;
      value : WinUI3.Microsoft.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILoopingSelector.all.put_ItemTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out LoopingSelector;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.SelectionChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ILoopingSelector.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out LoopingSelector;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILoopingSelector.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LoopingSelectorItem

   procedure Initialize (this : in out LoopingSelectorItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out LoopingSelectorItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILoopingSelectorItem, ILoopingSelectorItem_Ptr);
   begin
      if this.m_ILoopingSelectorItem /= null then
         if this.m_ILoopingSelectorItem.all /= null then
            temp := this.m_ILoopingSelectorItem.all.Release;
            if temp < 1 then
               Free (this.m_ILoopingSelectorItem);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LoopingSelectorItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LoopingSelectorPanel

   procedure Initialize (this : in out LoopingSelectorPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out LoopingSelectorPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILoopingSelectorPanel, ILoopingSelectorPanel_Ptr);
   begin
      if this.m_ILoopingSelectorPanel /= null then
         if this.m_ILoopingSelectorPanel.all /= null then
            temp := this.m_ILoopingSelectorPanel.all.Release;
            if temp < 1 then
               Free (this.m_ILoopingSelectorPanel);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LoopingSelectorPanel

   function get_AreHorizontalSnapPointsRegular
   (
      this : in out LoopingSelectorPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILoopingSelectorPanel.all);
      Hr := m_Interface.get_AreHorizontalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreVerticalSnapPointsRegular
   (
      this : in out LoopingSelectorPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILoopingSelectorPanel.all);
      Hr := m_Interface.get_AreVerticalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HorizontalSnapPointsChanged
   (
      this : in out LoopingSelectorPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILoopingSelectorPanel.all);
      Hr := m_Interface.add_HorizontalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HorizontalSnapPointsChanged
   (
      this : in out LoopingSelectorPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILoopingSelectorPanel.all);
      Hr := m_Interface.remove_HorizontalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_VerticalSnapPointsChanged
   (
      this : in out LoopingSelectorPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILoopingSelectorPanel.all);
      Hr := m_Interface.add_VerticalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VerticalSnapPointsChanged
   (
      this : in out LoopingSelectorPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILoopingSelectorPanel.all);
      Hr := m_Interface.remove_VerticalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetIrregularSnapPoints
   (
      this : in out LoopingSelectorPanel;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   )
   return IVectorView_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_Single.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILoopingSelectorPanel.all);
      Hr := m_Interface.GetIrregularSnapPoints (orientation, alignment, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetRegularSnapPoints
   (
      this : in out LoopingSelectorPanel;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
      offset : WinUI3.Single_Ptr
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ILoopingSelectorPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILoopingSelectorPanel.all);
      Hr := m_Interface.GetRegularSnapPoints (orientation, alignment, offset, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutItemTemplateSettings

   procedure Initialize (this : in out MenuFlyoutItemTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutItemTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutItemTemplateSettings, IMenuFlyoutItemTemplateSettings_Ptr);
   begin
      if this.m_IMenuFlyoutItemTemplateSettings /= null then
         if this.m_IMenuFlyoutItemTemplateSettings.all /= null then
            temp := this.m_IMenuFlyoutItemTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_IMenuFlyoutItemTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutItemTemplateSettings

   function get_KeyboardAcceleratorTextMinWidth
   (
      this : in out MenuFlyoutItemTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IMenuFlyoutItemTemplateSettings.all.get_KeyboardAcceleratorTextMinWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutPresenterTemplateSettings

   procedure Initialize (this : in out MenuFlyoutPresenterTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutPresenterTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutPresenterTemplateSettings, IMenuFlyoutPresenterTemplateSettings_Ptr);
   begin
      if this.m_IMenuFlyoutPresenterTemplateSettings /= null then
         if this.m_IMenuFlyoutPresenterTemplateSettings.all /= null then
            temp := this.m_IMenuFlyoutPresenterTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_IMenuFlyoutPresenterTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutPresenterTemplateSettings

   function get_FlyoutContentMinWidth
   (
      this : in out MenuFlyoutPresenterTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IMenuFlyoutPresenterTemplateSettings.all.get_FlyoutContentMinWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MonochromaticOverlayPresenter

   procedure Initialize (this : in out MonochromaticOverlayPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out MonochromaticOverlayPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMonochromaticOverlayPresenter, IMonochromaticOverlayPresenter_Ptr);
   begin
      if this.m_IMonochromaticOverlayPresenter /= null then
         if this.m_IMonochromaticOverlayPresenter.all /= null then
            temp := this.m_IMonochromaticOverlayPresenter.all.Release;
            if temp < 1 then
               Free (this.m_IMonochromaticOverlayPresenter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MonochromaticOverlayPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MonochromaticOverlayPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter");
      m_Factory    : access IMonochromaticOverlayPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IMonochromaticOverlayPresenter;
   begin
      return RetVal : MonochromaticOverlayPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IMonochromaticOverlayPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMonochromaticOverlayPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IMonochromaticOverlayPresenter;
            Retval.m_IMonochromaticOverlayPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MonochromaticOverlayPresenter

   function get_SourceElementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IMonochromaticOverlayPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMonochromaticOverlayPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ReplacementColorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.MonochromaticOverlayPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IMonochromaticOverlayPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMonochromaticOverlayPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ReplacementColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MonochromaticOverlayPresenter

   function get_SourceElement
   (
      this : in out MonochromaticOverlayPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IMonochromaticOverlayPresenter.all.get_SourceElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_SourceElement
   (
      this : in out MonochromaticOverlayPresenter;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMonochromaticOverlayPresenter.all.put_SourceElement (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ReplacementColor
   (
      this : in out MonochromaticOverlayPresenter
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IMonochromaticOverlayPresenter.all.get_ReplacementColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ReplacementColor
   (
      this : in out MonochromaticOverlayPresenter;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMonochromaticOverlayPresenter.all.put_ReplacementColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemPresenter

   procedure Initialize (this : in out NavigationViewItemPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemPresenter, INavigationViewItemPresenter_Ptr);
   begin
      if this.m_INavigationViewItemPresenter /= null then
         if this.m_INavigationViewItemPresenter.all /= null then
            temp := this.m_INavigationViewItemPresenter.all.Release;
            if temp < 1 then
               Free (this.m_INavigationViewItemPresenter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItemPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationViewItemPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter");
      m_Factory    : access INavigationViewItemPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenter;
   begin
      return RetVal : NavigationViewItemPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationViewItemPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenter;
            Retval.m_INavigationViewItemPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for NavigationViewItemPresenter

   function get_InfoBadgeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InfoBadgeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateSettingsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemPresenter

   function get_Icon
   (
      this : in out NavigationViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.IconElement do
         Hr := this.m_INavigationViewItemPresenter.all.get_Icon (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Microsoft.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out NavigationViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationViewItemPresenter.all.put_Icon (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out NavigationViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenterTemplateSettings;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings do
         Hr := this.m_INavigationViewItemPresenter.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationViewItemPresenterTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenterTemplateSettings;
         Retval.m_INavigationViewItemPresenterTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_InfoBadge
   (
      this : in out NavigationViewItemPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.InfoBadge'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadge;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenter2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_INavigationViewItemPresenter2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.InfoBadge do
         m_Interface := QInterface (this.m_INavigationViewItemPresenter.all);
         Hr := m_Interface.get_InfoBadge (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInfoBadge := new WinUI3.Microsoft.UI.Xaml.Controls.IInfoBadge;
         Retval.m_IInfoBadge.all := m_ComRetVal;
      end return;
   end;

   procedure put_InfoBadge
   (
      this : in out NavigationViewItemPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.InfoBadge'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenter2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_INavigationViewItemPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItemPresenter.all);
      Hr := m_Interface.put_InfoBadge (value.m_IInfoBadge.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemPresenterTemplateSettings

   procedure Initialize (this : in out NavigationViewItemPresenterTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemPresenterTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemPresenterTemplateSettings, INavigationViewItemPresenterTemplateSettings_Ptr);
   begin
      if this.m_INavigationViewItemPresenterTemplateSettings /= null then
         if this.m_INavigationViewItemPresenterTemplateSettings.all /= null then
            temp := this.m_INavigationViewItemPresenterTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_INavigationViewItemPresenterTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItemPresenterTemplateSettings

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationViewItemPresenterTemplateSettings is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings");
      m_Factory    : access INavigationViewItemPresenterTemplateSettingsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenterTemplateSettings;
   begin
      return RetVal : NavigationViewItemPresenterTemplateSettings do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemPresenterTemplateSettingsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationViewItemPresenterTemplateSettings := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenterTemplateSettings;
            Retval.m_INavigationViewItemPresenterTemplateSettings.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for NavigationViewItemPresenterTemplateSettings

   function get_IconWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenterTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemPresenterTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SmallerIconWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.NavigationViewItemPresenterTemplateSettings");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.INavigationViewItemPresenterTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemPresenterTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SmallerIconWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemPresenterTemplateSettings

   function get_IconWidth
   (
      this : in out NavigationViewItemPresenterTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationViewItemPresenterTemplateSettings.all.get_IconWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SmallerIconWidth
   (
      this : in out NavigationViewItemPresenterTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationViewItemPresenterTemplateSettings.all.get_SmallerIconWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for OrientedVirtualizingPanel

   procedure Initialize (this : in out OrientedVirtualizingPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out OrientedVirtualizingPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IOrientedVirtualizingPanel, IOrientedVirtualizingPanel_Ptr);
   begin
      if this.m_IOrientedVirtualizingPanel /= null then
         if this.m_IOrientedVirtualizingPanel.all /= null then
            temp := this.m_IOrientedVirtualizingPanel.all.Release;
            if temp < 1 then
               Free (this.m_IOrientedVirtualizingPanel);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for OrientedVirtualizingPanel

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for OrientedVirtualizingPanel

   function get_CanVerticallyScroll
   (
      this : in out OrientedVirtualizingPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.get_CanVerticallyScroll (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanVerticallyScroll
   (
      this : in out OrientedVirtualizingPanel;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.put_CanVerticallyScroll (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanHorizontallyScroll
   (
      this : in out OrientedVirtualizingPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.get_CanHorizontallyScroll (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanHorizontallyScroll
   (
      this : in out OrientedVirtualizingPanel;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.put_CanHorizontallyScroll (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExtentWidth
   (
      this : in out OrientedVirtualizingPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.get_ExtentWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentHeight
   (
      this : in out OrientedVirtualizingPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.get_ExtentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportWidth
   (
      this : in out OrientedVirtualizingPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.get_ViewportWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportHeight
   (
      this : in out OrientedVirtualizingPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.get_ViewportHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HorizontalOffset
   (
      this : in out OrientedVirtualizingPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalOffset
   (
      this : in out OrientedVirtualizingPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollOwner
   (
      this : in out OrientedVirtualizingPanel
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.get_ScrollOwner (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ScrollOwner
   (
      this : in out OrientedVirtualizingPanel;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.put_ScrollOwner (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineUp
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.LineUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineDown
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.LineDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineLeft
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.LineLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineRight
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.LineRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageUp
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.PageUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageDown
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.PageDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageLeft
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.PageLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageRight
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.PageRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelUp
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.MouseWheelUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelDown
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.MouseWheelDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelLeft
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.MouseWheelLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelRight
   (
      this : in out OrientedVirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.MouseWheelRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetHorizontalOffset
   (
      this : in out OrientedVirtualizingPanel;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.SetHorizontalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetVerticalOffset
   (
      this : in out OrientedVirtualizingPanel;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.SetVerticalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function MakeVisible
   (
      this : in out OrientedVirtualizingPanel;
      visual : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      rectangle : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IOrientedVirtualizingPanel.all.MakeVisible (visual.m_IUIElement.all, rectangle, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreHorizontalSnapPointsRegular
   (
      this : in out OrientedVirtualizingPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IOrientedVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientedVirtualizingPanel.all);
      Hr := m_Interface.get_AreHorizontalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreVerticalSnapPointsRegular
   (
      this : in out OrientedVirtualizingPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IOrientedVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientedVirtualizingPanel.all);
      Hr := m_Interface.get_AreVerticalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HorizontalSnapPointsChanged
   (
      this : in out OrientedVirtualizingPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IOrientedVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientedVirtualizingPanel.all);
      Hr := m_Interface.add_HorizontalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HorizontalSnapPointsChanged
   (
      this : in out OrientedVirtualizingPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IOrientedVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientedVirtualizingPanel.all);
      Hr := m_Interface.remove_HorizontalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_VerticalSnapPointsChanged
   (
      this : in out OrientedVirtualizingPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IOrientedVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientedVirtualizingPanel.all);
      Hr := m_Interface.add_VerticalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VerticalSnapPointsChanged
   (
      this : in out OrientedVirtualizingPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IOrientedVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientedVirtualizingPanel.all);
      Hr := m_Interface.remove_VerticalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetIrregularSnapPoints
   (
      this : in out OrientedVirtualizingPanel;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   )
   return IVectorView_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_Single.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IOrientedVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientedVirtualizingPanel.all);
      Hr := m_Interface.GetIrregularSnapPoints (orientation, alignment, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetRegularSnapPoints
   (
      this : in out OrientedVirtualizingPanel;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
      offset : WinUI3.Single_Ptr
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IOrientedVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientedVirtualizingPanel.all);
      Hr := m_Interface.GetRegularSnapPoints (orientation, alignment, offset, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure GetInsertionIndexes
   (
      this : in out OrientedVirtualizingPanel;
      position : WinUI3.Windows.Foundation.Point;
      first : WinUI3.Int32_Ptr;
      second : WinUI3.Int32_Ptr
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IInsertionPanel := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IOrientedVirtualizingPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IInsertionPanel, WinUI3.Microsoft.UI.Xaml.Controls.IID_IInsertionPanel'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientedVirtualizingPanel.all);
      Hr := m_Interface.GetInsertionIndexes (position, first, second);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PivotHeaderItem

   procedure Initialize (this : in out PivotHeaderItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out PivotHeaderItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPivotHeaderItem, IPivotHeaderItem_Ptr);
   begin
      if this.m_IPivotHeaderItem /= null then
         if this.m_IPivotHeaderItem.all /= null then
            temp := this.m_IPivotHeaderItem.all.Release;
            if temp < 1 then
               Free (this.m_IPivotHeaderItem);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PivotHeaderItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PivotHeaderItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.PivotHeaderItem");
      m_Factory    : access IPivotHeaderItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotHeaderItem;
   begin
      return RetVal : PivotHeaderItem do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotHeaderItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPivotHeaderItem := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotHeaderItem;
            Retval.m_IPivotHeaderItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PivotHeaderItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PivotHeaderPanel

   procedure Initialize (this : in out PivotHeaderPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out PivotHeaderPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPivotHeaderPanel, IPivotHeaderPanel_Ptr);
   begin
      if this.m_IPivotHeaderPanel /= null then
         if this.m_IPivotHeaderPanel.all /= null then
            temp := this.m_IPivotHeaderPanel.all.Release;
            if temp < 1 then
               Free (this.m_IPivotHeaderPanel);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PivotHeaderPanel

   function Constructor return PivotHeaderPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.PivotHeaderPanel");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotHeaderPanel;
   begin
      return RetVal : PivotHeaderPanel do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPivotHeaderPanel := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotHeaderPanel;
            Retval.m_IPivotHeaderPanel.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PivotHeaderPanel

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PivotPanel

   procedure Initialize (this : in out PivotPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out PivotPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPivotPanel, IPivotPanel_Ptr);
   begin
      if this.m_IPivotPanel /= null then
         if this.m_IPivotPanel.all /= null then
            temp := this.m_IPivotPanel.all.Release;
            if temp < 1 then
               Free (this.m_IPivotPanel);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PivotPanel

   function Constructor return PivotPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.PivotPanel");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotPanel;
   begin
      return RetVal : PivotPanel do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPivotPanel := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotPanel;
            Retval.m_IPivotPanel.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PivotPanel

   function get_AreHorizontalSnapPointsRegular
   (
      this : in out PivotPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivotPanel.all);
      Hr := m_Interface.get_AreHorizontalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreVerticalSnapPointsRegular
   (
      this : in out PivotPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivotPanel.all);
      Hr := m_Interface.get_AreVerticalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HorizontalSnapPointsChanged
   (
      this : in out PivotPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivotPanel.all);
      Hr := m_Interface.add_HorizontalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HorizontalSnapPointsChanged
   (
      this : in out PivotPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivotPanel.all);
      Hr := m_Interface.remove_HorizontalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_VerticalSnapPointsChanged
   (
      this : in out PivotPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivotPanel.all);
      Hr := m_Interface.add_VerticalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VerticalSnapPointsChanged
   (
      this : in out PivotPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivotPanel.all);
      Hr := m_Interface.remove_VerticalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetIrregularSnapPoints
   (
      this : in out PivotPanel;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   )
   return IVectorView_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_Single.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivotPanel.all);
      Hr := m_Interface.GetIrregularSnapPoints (orientation, alignment, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetRegularSnapPoints
   (
      this : in out PivotPanel;
      orientation : WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
      offset : WinUI3.Single_Ptr
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPivotPanel_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivotPanel.all);
      Hr := m_Interface.GetRegularSnapPoints (orientation, alignment, offset, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Popup

   procedure Initialize (this : in out Popup) is
   begin
      null;
   end;

   procedure Finalize (this : in out Popup) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPopup, IPopup_Ptr);
   begin
      if this.m_IPopup /= null then
         if this.m_IPopup.all /= null then
            temp := this.m_IPopup.all.Release;
            if temp < 1 then
               Free (this.m_IPopup);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Popup

   function Constructor return Popup is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup;
   begin
      return RetVal : Popup do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPopup := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup;
            Retval.m_IPopup.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Popup

   function get_ChildProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopupStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsOpenProperty_Popup
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopupStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalOffsetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopupStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalOffsetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopupStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ChildTransitionsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopupStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsLightDismissEnabledProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopupStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsLightDismissEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty_Popup
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopupStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShouldConstrainToRootBoundsProperty_Popup
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopupStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShouldConstrainToRootBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlacementTargetProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopupStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DesiredPlacementProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopupStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DesiredPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SystemBackdropProperty_Popup
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Popup");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopupStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPopupStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SystemBackdropProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Popup

   function get_Child
   (
      this : in out Popup
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IPopup.all.get_Child (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Child
   (
      this : in out Popup;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopup.all.put_Child (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsOpen
   (
      this : in out Popup
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPopup.all.get_IsOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOpen
   (
      this : in out Popup;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopup.all.put_IsOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalOffset
   (
      this : in out Popup
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPopup.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalOffset
   (
      this : in out Popup;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopup.all.put_HorizontalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalOffset
   (
      this : in out Popup
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPopup.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalOffset
   (
      this : in out Popup;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopup.all.put_VerticalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChildTransitions
   (
      this : in out Popup
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IPopup.all.get_ChildTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ChildTransitions
   (
      this : in out Popup;
      value : WinUI3.Microsoft.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopup.all.put_ChildTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsLightDismissEnabled
   (
      this : in out Popup
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPopup.all.get_IsLightDismissEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsLightDismissEnabled
   (
      this : in out Popup;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopup.all.put_IsLightDismissEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out Popup
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode;
   begin
      Hr := this.m_IPopup.all.get_LightDismissOverlayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out Popup;
      value : WinUI3.Microsoft.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopup.all.put_LightDismissOverlayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShouldConstrainToRootBounds
   (
      this : in out Popup
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPopup.all.get_ShouldConstrainToRootBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShouldConstrainToRootBounds
   (
      this : in out Popup;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopup.all.put_ShouldConstrainToRootBounds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsConstrainedToRootBounds
   (
      this : in out Popup
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPopup.all.get_IsConstrainedToRootBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_Opened
   (
      this : in out Popup;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPopup.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out Popup;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopup.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out Popup;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPopup.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out Popup;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPopup.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlacementTarget
   (
      this : in out Popup
   )
   return WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IFrameworkElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IPopup2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.FrameworkElement do
         m_Interface := QInterface (this.m_IPopup.all);
         Hr := m_Interface.get_PlacementTarget (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFrameworkElement := new WinUI3.Microsoft.UI.Xaml.IFrameworkElement;
         Retval.m_IFrameworkElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlacementTarget
   (
      this : in out Popup;
      value : WinUI3.Microsoft.UI.Xaml.FrameworkElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IPopup2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPopup.all);
      Hr := m_Interface.put_PlacementTarget (value.m_IFrameworkElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DesiredPlacement
   (
      this : in out Popup
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.PopupPlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.PopupPlacementMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IPopup2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPopup.all);
      Hr := m_Interface.get_DesiredPlacement (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredPlacement
   (
      this : in out Popup;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.PopupPlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IPopup2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPopup.all);
      Hr := m_Interface.put_DesiredPlacement (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActualPlacement
   (
      this : in out Popup
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.PopupPlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.PopupPlacementMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IPopup2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPopup.all);
      Hr := m_Interface.get_ActualPlacement (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_ActualPlacementChanged
   (
      this : in out Popup;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IPopup2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPopup.all);
      Hr := m_Interface.add_ActualPlacementChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ActualPlacementChanged
   (
      this : in out Popup;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup2, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IPopup2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPopup.all);
      Hr := m_Interface.remove_ActualPlacementChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SystemBackdrop
   (
      this : in out Popup
   )
   return WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.ISystemBackdrop;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup3, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IPopup3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop do
         m_Interface := QInterface (this.m_IPopup.all);
         Hr := m_Interface.get_SystemBackdrop (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISystemBackdrop := new WinUI3.Microsoft.UI.Xaml.Media.ISystemBackdrop;
         Retval.m_ISystemBackdrop.all := m_ComRetVal;
      end return;
   end;

   procedure put_SystemBackdrop
   (
      this : in out Popup;
      value : WinUI3.Microsoft.UI.Xaml.Media.SystemBackdrop'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup_Interface, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IPopup3, WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IID_IPopup3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPopup.all);
      Hr := m_Interface.put_SystemBackdrop (value.m_ISystemBackdrop.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RangeBaseValueChangedEventArgs

   procedure Initialize (this : in out RangeBaseValueChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RangeBaseValueChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRangeBaseValueChangedEventArgs, IRangeBaseValueChangedEventArgs_Ptr);
   begin
      if this.m_IRangeBaseValueChangedEventArgs /= null then
         if this.m_IRangeBaseValueChangedEventArgs.all /= null then
            temp := this.m_IRangeBaseValueChangedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IRangeBaseValueChangedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RangeBaseValueChangedEventArgs

   function get_OldValue
   (
      this : in out RangeBaseValueChangedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRangeBaseValueChangedEventArgs.all.get_OldValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewValue
   (
      this : in out RangeBaseValueChangedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRangeBaseValueChangedEventArgs.all.get_NewValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate RangeBaseValueChangedEventHandler

   function Invoke
   (
      this : access RangeBaseValueChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRangeBaseValueChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RepeatButton

   procedure Initialize (this : in out RepeatButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out RepeatButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRepeatButton, IRepeatButton_Ptr);
   begin
      if this.m_IRepeatButton /= null then
         if this.m_IRepeatButton.all /= null then
            temp := this.m_IRepeatButton.all.Release;
            if temp < 1 then
               Free (this.m_IRepeatButton);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RepeatButton

   function Constructor return RepeatButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.RepeatButton");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRepeatButton;
   begin
      return RetVal : RepeatButton do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRepeatButton := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRepeatButton;
            Retval.m_IRepeatButton.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RepeatButton

   function get_DelayProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.RepeatButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRepeatButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRepeatButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DelayProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IntervalProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.RepeatButton");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRepeatButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRepeatButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IntervalProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RepeatButton

   function get_Delay
   (
      this : in out RepeatButton
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRepeatButton.all.get_Delay (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Delay
   (
      this : in out RepeatButton;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRepeatButton.all.put_Delay (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Interval
   (
      this : in out RepeatButton
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRepeatButton.all.get_Interval (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Interval
   (
      this : in out RepeatButton;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRepeatButton.all.put_Interval (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SnapPointBase

   procedure Initialize (this : in out SnapPointBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out SnapPointBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISnapPointBase, ISnapPointBase_Ptr);
   begin
      if this.m_ISnapPointBase /= null then
         if this.m_ISnapPointBase.all /= null then
            temp := this.m_ISnapPointBase.all.Release;
            if temp < 1 then
               Free (this.m_ISnapPointBase);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SnapPointBase

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SnapPointBase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollSnapPointBase

   procedure Initialize (this : in out ScrollSnapPointBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollSnapPointBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollSnapPointBase, IScrollSnapPointBase_Ptr);
   begin
      if this.m_IScrollSnapPointBase /= null then
         if this.m_IScrollSnapPointBase.all /= null then
            temp := this.m_IScrollSnapPointBase.all.Release;
            if temp < 1 then
               Free (this.m_IScrollSnapPointBase);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollSnapPointBase

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollSnapPointBase

   function get_Alignment
   (
      this : in out ScrollSnapPointBase
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPointsAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPointsAlignment;
   begin
      Hr := this.m_IScrollSnapPointBase.all.get_Alignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RepeatedScrollSnapPoint

   procedure Initialize (this : in out RepeatedScrollSnapPoint) is
   begin
      null;
   end;

   procedure Finalize (this : in out RepeatedScrollSnapPoint) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRepeatedScrollSnapPoint, IRepeatedScrollSnapPoint_Ptr);
   begin
      if this.m_IRepeatedScrollSnapPoint /= null then
         if this.m_IRepeatedScrollSnapPoint.all /= null then
            temp := this.m_IRepeatedScrollSnapPoint.all.Release;
            if temp < 1 then
               Free (this.m_IRepeatedScrollSnapPoint);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RepeatedScrollSnapPoint

   function Constructor
   (
      offset : WinUI3.Double;
      interval : WinUI3.Double;
      start : WinUI3.Double;
      end_x : WinUI3.Double;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPointsAlignment;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RepeatedScrollSnapPoint is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.RepeatedScrollSnapPoint");
      m_Factory    : access IRepeatedScrollSnapPointFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRepeatedScrollSnapPoint;
   begin
      return RetVal : RepeatedScrollSnapPoint do
         Hr := RoGetActivationFactory (m_hString, IID_IRepeatedScrollSnapPointFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (offset, interval, start, end_x, alignment, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRepeatedScrollSnapPoint := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRepeatedScrollSnapPoint;
            Retval.m_IRepeatedScrollSnapPoint.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RepeatedScrollSnapPoint

   function get_Offset
   (
      this : in out RepeatedScrollSnapPoint
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRepeatedScrollSnapPoint.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Interval
   (
      this : in out RepeatedScrollSnapPoint
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRepeatedScrollSnapPoint.all.get_Interval (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Start
   (
      this : in out RepeatedScrollSnapPoint
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRepeatedScrollSnapPoint.all.get_Start (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_End
   (
      this : in out RepeatedScrollSnapPoint
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRepeatedScrollSnapPoint.all.get_End (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ZoomSnapPointBase

   procedure Initialize (this : in out ZoomSnapPointBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out ZoomSnapPointBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IZoomSnapPointBase, IZoomSnapPointBase_Ptr);
   begin
      if this.m_IZoomSnapPointBase /= null then
         if this.m_IZoomSnapPointBase.all /= null then
            temp := this.m_IZoomSnapPointBase.all.Release;
            if temp < 1 then
               Free (this.m_IZoomSnapPointBase);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ZoomSnapPointBase

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ZoomSnapPointBase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RepeatedZoomSnapPoint

   procedure Initialize (this : in out RepeatedZoomSnapPoint) is
   begin
      null;
   end;

   procedure Finalize (this : in out RepeatedZoomSnapPoint) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRepeatedZoomSnapPoint, IRepeatedZoomSnapPoint_Ptr);
   begin
      if this.m_IRepeatedZoomSnapPoint /= null then
         if this.m_IRepeatedZoomSnapPoint.all /= null then
            temp := this.m_IRepeatedZoomSnapPoint.all.Release;
            if temp < 1 then
               Free (this.m_IRepeatedZoomSnapPoint);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RepeatedZoomSnapPoint

   function Constructor
   (
      offset : WinUI3.Double;
      interval : WinUI3.Double;
      start : WinUI3.Double;
      end_x : WinUI3.Double;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RepeatedZoomSnapPoint is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.RepeatedZoomSnapPoint");
      m_Factory    : access IRepeatedZoomSnapPointFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRepeatedZoomSnapPoint;
   begin
      return RetVal : RepeatedZoomSnapPoint do
         Hr := RoGetActivationFactory (m_hString, IID_IRepeatedZoomSnapPointFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (offset, interval, start, end_x, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRepeatedZoomSnapPoint := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IRepeatedZoomSnapPoint;
            Retval.m_IRepeatedZoomSnapPoint.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RepeatedZoomSnapPoint

   function get_Offset
   (
      this : in out RepeatedZoomSnapPoint
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRepeatedZoomSnapPoint.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Interval
   (
      this : in out RepeatedZoomSnapPoint
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRepeatedZoomSnapPoint.all.get_Interval (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Start
   (
      this : in out RepeatedZoomSnapPoint
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRepeatedZoomSnapPoint.all.get_Start (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_End
   (
      this : in out RepeatedZoomSnapPoint
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRepeatedZoomSnapPoint.all.get_End (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollBar

   procedure Initialize (this : in out ScrollBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollBar, IScrollBar_Ptr);
   begin
      if this.m_IScrollBar /= null then
         if this.m_IScrollBar.all /= null then
            temp := this.m_IScrollBar.all.Release;
            if temp < 1 then
               Free (this.m_IScrollBar);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollBar

   function Constructor return ScrollBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollBar");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollBar;
   begin
      return RetVal : ScrollBar do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IScrollBar := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollBar;
            Retval.m_IScrollBar.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ScrollBar

   function get_OrientationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ViewportSizeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ViewportSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IndicatorModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IndicatorModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollBar

   function get_Orientation
   (
      this : in out ScrollBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IScrollBar.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out ScrollBar;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollBar.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ViewportSize
   (
      this : in out ScrollBar
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollBar.all.get_ViewportSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ViewportSize
   (
      this : in out ScrollBar;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollBar.all.put_ViewportSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IndicatorMode
   (
      this : in out ScrollBar
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollingIndicatorMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollingIndicatorMode;
   begin
      Hr := this.m_IScrollBar.all.get_IndicatorMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IndicatorMode
   (
      this : in out ScrollBar;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollingIndicatorMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollBar.all.put_IndicatorMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Scroll
   (
      this : in out ScrollBar;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollBar.all.add_Scroll (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Scroll
   (
      this : in out ScrollBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollBar.all.remove_Scroll (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollControllerAddScrollVelocityRequestedEventArgs

   procedure Initialize (this : in out ScrollControllerAddScrollVelocityRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollControllerAddScrollVelocityRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollControllerAddScrollVelocityRequestedEventArgs, IScrollControllerAddScrollVelocityRequestedEventArgs_Ptr);
   begin
      if this.m_IScrollControllerAddScrollVelocityRequestedEventArgs /= null then
         if this.m_IScrollControllerAddScrollVelocityRequestedEventArgs.all /= null then
            temp := this.m_IScrollControllerAddScrollVelocityRequestedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IScrollControllerAddScrollVelocityRequestedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollControllerAddScrollVelocityRequestedEventArgs

   function Constructor
   (
      offsetVelocity : WinUI3.Single;
      inertiaDecayRate : GenericObject
   )
   return ScrollControllerAddScrollVelocityRequestedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerAddScrollVelocityRequestedEventArgs");
      m_Factory    : access IScrollControllerAddScrollVelocityRequestedEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerAddScrollVelocityRequestedEventArgs;
   begin
      return RetVal : ScrollControllerAddScrollVelocityRequestedEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollControllerAddScrollVelocityRequestedEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (offsetVelocity, inertiaDecayRate, m_ComRetVal'Access);
            Retval.m_IScrollControllerAddScrollVelocityRequestedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerAddScrollVelocityRequestedEventArgs;
            Retval.m_IScrollControllerAddScrollVelocityRequestedEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollControllerAddScrollVelocityRequestedEventArgs

   function get_OffsetVelocity
   (
      this : in out ScrollControllerAddScrollVelocityRequestedEventArgs
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollControllerAddScrollVelocityRequestedEventArgs.all.get_OffsetVelocity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_InertiaDecayRate
   (
      this : in out ScrollControllerAddScrollVelocityRequestedEventArgs
   )
   return IReference_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Single.Kind;
   begin
      Hr := this.m_IScrollControllerAddScrollVelocityRequestedEventArgs.all.get_InertiaDecayRate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_CorrelationId
   (
      this : in out ScrollControllerAddScrollVelocityRequestedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollControllerAddScrollVelocityRequestedEventArgs.all.get_CorrelationId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CorrelationId
   (
      this : in out ScrollControllerAddScrollVelocityRequestedEventArgs;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollControllerAddScrollVelocityRequestedEventArgs.all.put_CorrelationId (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollControllerPanRequestedEventArgs

   procedure Initialize (this : in out ScrollControllerPanRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollControllerPanRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollControllerPanRequestedEventArgs, IScrollControllerPanRequestedEventArgs_Ptr);
   begin
      if this.m_IScrollControllerPanRequestedEventArgs /= null then
         if this.m_IScrollControllerPanRequestedEventArgs.all /= null then
            temp := this.m_IScrollControllerPanRequestedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IScrollControllerPanRequestedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollControllerPanRequestedEventArgs

   function Constructor
   (
      pointerPoint : WinUI3.Microsoft.UI.Input.PointerPoint'Class
   )
   return ScrollControllerPanRequestedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerPanRequestedEventArgs");
      m_Factory    : access IScrollControllerPanRequestedEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanRequestedEventArgs;
   begin
      return RetVal : ScrollControllerPanRequestedEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollControllerPanRequestedEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (pointerPoint.m_IPointerPoint.all, m_ComRetVal'Access);
            Retval.m_IScrollControllerPanRequestedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerPanRequestedEventArgs;
            Retval.m_IScrollControllerPanRequestedEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollControllerPanRequestedEventArgs

   function get_PointerPoint
   (
      this : in out ScrollControllerPanRequestedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerPoint'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IPointerPoint;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.PointerPoint do
         Hr := this.m_IScrollControllerPanRequestedEventArgs.all.get_PointerPoint (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointerPoint := new WinUI3.Microsoft.UI.Input.IPointerPoint;
         Retval.m_IPointerPoint.all := m_ComRetVal;
      end return;
   end;

   function get_Handled
   (
      this : in out ScrollControllerPanRequestedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollControllerPanRequestedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ScrollControllerPanRequestedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollControllerPanRequestedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollControllerScrollByRequestedEventArgs

   procedure Initialize (this : in out ScrollControllerScrollByRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollControllerScrollByRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollControllerScrollByRequestedEventArgs, IScrollControllerScrollByRequestedEventArgs_Ptr);
   begin
      if this.m_IScrollControllerScrollByRequestedEventArgs /= null then
         if this.m_IScrollControllerScrollByRequestedEventArgs.all /= null then
            temp := this.m_IScrollControllerScrollByRequestedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IScrollControllerScrollByRequestedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollControllerScrollByRequestedEventArgs

   function Constructor
   (
      offsetDelta : WinUI3.Double;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollOptions'Class
   )
   return ScrollControllerScrollByRequestedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollByRequestedEventArgs");
      m_Factory    : access IScrollControllerScrollByRequestedEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerScrollByRequestedEventArgs;
   begin
      return RetVal : ScrollControllerScrollByRequestedEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollControllerScrollByRequestedEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (offsetDelta, options.m_IScrollingScrollOptions.all, m_ComRetVal'Access);
            Retval.m_IScrollControllerScrollByRequestedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerScrollByRequestedEventArgs;
            Retval.m_IScrollControllerScrollByRequestedEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollControllerScrollByRequestedEventArgs

   function get_OffsetDelta
   (
      this : in out ScrollControllerScrollByRequestedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollControllerScrollByRequestedEventArgs.all.get_OffsetDelta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Options
   (
      this : in out ScrollControllerScrollByRequestedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollOptions'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollingScrollOptions;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollOptions do
         Hr := this.m_IScrollControllerScrollByRequestedEventArgs.all.get_Options (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScrollingScrollOptions := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollingScrollOptions;
         Retval.m_IScrollingScrollOptions.all := m_ComRetVal;
      end return;
   end;

   function get_CorrelationId
   (
      this : in out ScrollControllerScrollByRequestedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollControllerScrollByRequestedEventArgs.all.get_CorrelationId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CorrelationId
   (
      this : in out ScrollControllerScrollByRequestedEventArgs;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollControllerScrollByRequestedEventArgs.all.put_CorrelationId (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollControllerScrollToRequestedEventArgs

   procedure Initialize (this : in out ScrollControllerScrollToRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollControllerScrollToRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollControllerScrollToRequestedEventArgs, IScrollControllerScrollToRequestedEventArgs_Ptr);
   begin
      if this.m_IScrollControllerScrollToRequestedEventArgs /= null then
         if this.m_IScrollControllerScrollToRequestedEventArgs.all /= null then
            temp := this.m_IScrollControllerScrollToRequestedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IScrollControllerScrollToRequestedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollControllerScrollToRequestedEventArgs

   function Constructor
   (
      offset : WinUI3.Double;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollOptions'Class
   )
   return ScrollControllerScrollToRequestedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollControllerScrollToRequestedEventArgs");
      m_Factory    : access IScrollControllerScrollToRequestedEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerScrollToRequestedEventArgs;
   begin
      return RetVal : ScrollControllerScrollToRequestedEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollControllerScrollToRequestedEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (offset, options.m_IScrollingScrollOptions.all, m_ComRetVal'Access);
            Retval.m_IScrollControllerScrollToRequestedEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollControllerScrollToRequestedEventArgs;
            Retval.m_IScrollControllerScrollToRequestedEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollControllerScrollToRequestedEventArgs

   function get_Offset
   (
      this : in out ScrollControllerScrollToRequestedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollControllerScrollToRequestedEventArgs.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Options
   (
      this : in out ScrollControllerScrollToRequestedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollOptions'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.IScrollingScrollOptions;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollOptions do
         Hr := this.m_IScrollControllerScrollToRequestedEventArgs.all.get_Options (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScrollingScrollOptions := new WinUI3.Microsoft.UI.Xaml.Controls.IScrollingScrollOptions;
         Retval.m_IScrollingScrollOptions.all := m_ComRetVal;
      end return;
   end;

   function get_CorrelationId
   (
      this : in out ScrollControllerScrollToRequestedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollControllerScrollToRequestedEventArgs.all.get_CorrelationId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CorrelationId
   (
      this : in out ScrollControllerScrollToRequestedEventArgs;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollControllerScrollToRequestedEventArgs.all.put_CorrelationId (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollEventArgs

   procedure Initialize (this : in out ScrollEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollEventArgs, IScrollEventArgs_Ptr);
   begin
      if this.m_IScrollEventArgs /= null then
         if this.m_IScrollEventArgs.all /= null then
            temp := this.m_IScrollEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IScrollEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollEventArgs

   function Constructor return ScrollEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollEventArgs");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollEventArgs;
   begin
      return RetVal : ScrollEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IScrollEventArgs := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollEventArgs;
            Retval.m_IScrollEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollEventArgs

   function get_NewValue
   (
      this : in out ScrollEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollEventArgs.all.get_NewValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollEventType
   (
      this : in out ScrollEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollEventType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollEventType;
   begin
      Hr := this.m_IScrollEventArgs.all.get_ScrollEventType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ScrollEventHandler

   function Invoke
   (
      this : access ScrollEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollPresenter

   procedure Initialize (this : in out ScrollPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollPresenter, IScrollPresenter_Ptr);
   begin
      if this.m_IScrollPresenter /= null then
         if this.m_IScrollPresenter.all /= null then
            temp := this.m_IScrollPresenter.all.Release;
            if temp < 1 then
               Free (this.m_IScrollPresenter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ScrollPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory    : access IScrollPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenter;
   begin
      return RetVal : ScrollPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IScrollPresenter := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenter;
            Retval.m_IScrollPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ScrollPresenter

   function get_BackgroundProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentOrientationProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentOrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalScrollChainModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalScrollChainModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalScrollChainModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollChainModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalScrollRailModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalScrollRailModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalScrollRailModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollRailModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalScrollModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalScrollModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ComputedHorizontalScrollModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ComputedHorizontalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ComputedVerticalScrollModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ComputedVerticalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomChainModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomChainModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomModeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IgnoredInputKindsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IgnoredInputKindsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinZoomFactorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinZoomFactorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxZoomFactorProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxZoomFactorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalAnchorRatioProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalAnchorRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalAnchorRatioProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalAnchorRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollPresenter

   function get_Background
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_IScrollPresenter.all.get_Background (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_Background (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Content
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         Hr := this.m_IScrollPresenter.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExpressionAnimationSources
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Composition.CompositionPropertySet'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.ICompositionPropertySet;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.CompositionPropertySet do
         Hr := this.m_IScrollPresenter.all.get_ExpressionAnimationSources (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionPropertySet := new WinUI3.Microsoft.UI.Composition.ICompositionPropertySet;
         Retval.m_ICompositionPropertySet.all := m_ComRetVal;
      end return;
   end;

   function get_HorizontalOffset
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalOffset
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZoomFactor
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollPresenter.all.get_ZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentWidth
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_ExtentWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentHeight
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_ExtentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportWidth
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_ViewportWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportHeight
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_ViewportHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollableWidth
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_ScrollableWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollableHeight
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_ScrollableHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContentOrientation
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingContentOrientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingContentOrientation;
   begin
      Hr := this.m_IScrollPresenter.all.get_ContentOrientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ContentOrientation
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingContentOrientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_ContentOrientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalScrollChainMode
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode;
   begin
      Hr := this.m_IScrollPresenter.all.get_HorizontalScrollChainMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollChainMode
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_HorizontalScrollChainMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollChainMode
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode;
   begin
      Hr := this.m_IScrollPresenter.all.get_VerticalScrollChainMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollChainMode
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_VerticalScrollChainMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalScrollRailMode
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode;
   begin
      Hr := this.m_IScrollPresenter.all.get_HorizontalScrollRailMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollRailMode
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_HorizontalScrollRailMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollRailMode
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode;
   begin
      Hr := this.m_IScrollPresenter.all.get_VerticalScrollRailMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollRailMode
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingRailMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_VerticalScrollRailMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalScrollMode
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode;
   begin
      Hr := this.m_IScrollPresenter.all.get_HorizontalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollMode
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_HorizontalScrollMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollMode
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode;
   begin
      Hr := this.m_IScrollPresenter.all.get_VerticalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollMode
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_VerticalScrollMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ComputedHorizontalScrollMode
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode;
   begin
      Hr := this.m_IScrollPresenter.all.get_ComputedHorizontalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ComputedVerticalScrollMode
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollMode;
   begin
      Hr := this.m_IScrollPresenter.all.get_ComputedVerticalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZoomChainMode
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode;
   begin
      Hr := this.m_IScrollPresenter.all.get_ZoomChainMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomChainMode
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingChainMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_ZoomChainMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomMode
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingZoomMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingZoomMode;
   begin
      Hr := this.m_IScrollPresenter.all.get_ZoomMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomMode
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingZoomMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_ZoomMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IgnoredInputKinds
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingInputKinds is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingInputKinds;
   begin
      Hr := this.m_IScrollPresenter.all.get_IgnoredInputKinds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IgnoredInputKinds
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingInputKinds
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_IgnoredInputKinds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinZoomFactor
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_MinZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinZoomFactor
   (
      this : in out ScrollPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_MinZoomFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxZoomFactor
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_MaxZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxZoomFactor
   (
      this : in out ScrollPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_MaxZoomFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_State
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.ScrollingInteractionState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.ScrollingInteractionState;
   begin
      Hr := this.m_IScrollPresenter.all.get_State (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HorizontalScrollController
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollController is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollController;
   begin
      Hr := this.m_IScrollPresenter.all.get_HorizontalScrollController (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollController
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollController
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_HorizontalScrollController (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollController
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollController is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollController;
   begin
      Hr := this.m_IScrollPresenter.all.get_VerticalScrollController (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollController
   (
      this : in out ScrollPresenter;
      value : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollController
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_VerticalScrollController (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalAnchorRatio
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_HorizontalAnchorRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalAnchorRatio
   (
      this : in out ScrollPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_HorizontalAnchorRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalAnchorRatio
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollPresenter.all.get_VerticalAnchorRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalAnchorRatio
   (
      this : in out ScrollPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.put_VerticalAnchorRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalSnapPoints
   (
      this : in out ScrollPresenter
   )
   return IVector_IScrollSnapPointBase.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IScrollSnapPointBase.Kind;
   begin
      Hr := this.m_IScrollPresenter.all.get_HorizontalSnapPoints (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IScrollSnapPointBase (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_VerticalSnapPoints
   (
      this : in out ScrollPresenter
   )
   return IVector_IScrollSnapPointBase.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IScrollSnapPointBase.Kind;
   begin
      Hr := this.m_IScrollPresenter.all.get_VerticalSnapPoints (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IScrollSnapPointBase (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_ZoomSnapPoints
   (
      this : in out ScrollPresenter
   )
   return IVector_IZoomSnapPointBase.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IZoomSnapPointBase.Kind;
   begin
      Hr := this.m_IScrollPresenter.all.get_ZoomSnapPoints (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IZoomSnapPointBase (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function ScrollTo
   (
      this : in out ScrollPresenter;
      horizontalOffset : WinUI3.Double;
      verticalOffset : WinUI3.Double
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollPresenter.all.ScrollTo (horizontalOffset, verticalOffset, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ScrollTo
   (
      this : in out ScrollPresenter;
      horizontalOffset : WinUI3.Double;
      verticalOffset : WinUI3.Double;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollOptions'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollPresenter.all.ScrollTo (horizontalOffset, verticalOffset, options.m_IScrollingScrollOptions.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ScrollBy
   (
      this : in out ScrollPresenter;
      horizontalOffsetDelta : WinUI3.Double;
      verticalOffsetDelta : WinUI3.Double
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollPresenter.all.ScrollBy (horizontalOffsetDelta, verticalOffsetDelta, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ScrollBy
   (
      this : in out ScrollPresenter;
      horizontalOffsetDelta : WinUI3.Double;
      verticalOffsetDelta : WinUI3.Double;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingScrollOptions'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollPresenter.all.ScrollBy (horizontalOffsetDelta, verticalOffsetDelta, options.m_IScrollingScrollOptions.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function AddScrollVelocity
   (
      this : in out ScrollPresenter;
      offsetsVelocity : WinUI3.Windows.Foundation.Numerics.Vector2;
      inertiaDecayRate : GenericObject
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollPresenter.all.AddScrollVelocity (offsetsVelocity, inertiaDecayRate, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ZoomTo
   (
      this : in out ScrollPresenter;
      zoomFactor : WinUI3.Single;
      centerPoint : GenericObject
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollPresenter.all.ZoomTo (zoomFactor, centerPoint, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ZoomTo
   (
      this : in out ScrollPresenter;
      zoomFactor : WinUI3.Single;
      centerPoint : GenericObject;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingZoomOptions'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollPresenter.all.ZoomTo (zoomFactor, centerPoint, options.m_IScrollingZoomOptions.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ZoomBy
   (
      this : in out ScrollPresenter;
      zoomFactorDelta : WinUI3.Single;
      centerPoint : GenericObject
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollPresenter.all.ZoomBy (zoomFactorDelta, centerPoint, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ZoomBy
   (
      this : in out ScrollPresenter;
      zoomFactorDelta : WinUI3.Single;
      centerPoint : GenericObject;
      options : WinUI3.Microsoft.UI.Xaml.Controls.ScrollingZoomOptions'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollPresenter.all.ZoomBy (zoomFactorDelta, centerPoint, options.m_IScrollingZoomOptions.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function AddZoomVelocity
   (
      this : in out ScrollPresenter;
      zoomFactorVelocity : WinUI3.Single;
      centerPoint : GenericObject;
      inertiaDecayRate : GenericObject
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IScrollPresenter.all.AddZoomVelocity (zoomFactorVelocity, centerPoint, inertiaDecayRate, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_ExtentChanged
   (
      this : in out ScrollPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollPresenter.all.add_ExtentChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ExtentChanged
   (
      this : in out ScrollPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.remove_ExtentChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_StateChanged
   (
      this : in out ScrollPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollPresenter.all.add_StateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_StateChanged
   (
      this : in out ScrollPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.remove_StateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ViewChanged
   (
      this : in out ScrollPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollPresenter.all.add_ViewChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ViewChanged
   (
      this : in out ScrollPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.remove_ViewChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ScrollAnimationStarting
   (
      this : in out ScrollPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollPresenter.all.add_ScrollAnimationStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ScrollAnimationStarting
   (
      this : in out ScrollPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.remove_ScrollAnimationStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ZoomAnimationStarting
   (
      this : in out ScrollPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollPresenter.all.add_ZoomAnimationStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ZoomAnimationStarting
   (
      this : in out ScrollPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.remove_ZoomAnimationStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ScrollCompleted
   (
      this : in out ScrollPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollPresenter.all.add_ScrollCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ScrollCompleted
   (
      this : in out ScrollPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.remove_ScrollCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ZoomCompleted
   (
      this : in out ScrollPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollPresenter.all.add_ZoomCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ZoomCompleted
   (
      this : in out ScrollPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.remove_ZoomCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_BringingIntoView
   (
      this : in out ScrollPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollPresenter.all.add_BringingIntoView (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BringingIntoView
   (
      this : in out ScrollPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.remove_BringingIntoView (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_AnchorRequested
   (
      this : in out ScrollPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollPresenter.all.add_AnchorRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_AnchorRequested
   (
      this : in out ScrollPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollPresenter.all.remove_AnchorRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CurrentAnchor
   (
      this : in out ScrollPresenter
   )
   return WinUI3.Microsoft.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider, WinUI3.Microsoft.UI.Xaml.Controls.IID_IScrollAnchorProvider'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IScrollPresenter.all);
         Hr := m_Interface.get_CurrentAnchor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Microsoft.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure RegisterAnchorCandidate
   (
      this : in out ScrollPresenter;
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider, WinUI3.Microsoft.UI.Xaml.Controls.IID_IScrollAnchorProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollPresenter.all);
      Hr := m_Interface.RegisterAnchorCandidate (element.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure UnregisterAnchorCandidate
   (
      this : in out ScrollPresenter;
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollPresenter_Interface, WinUI3.Microsoft.UI.Xaml.Controls.IScrollAnchorProvider, WinUI3.Microsoft.UI.Xaml.Controls.IID_IScrollAnchorProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollPresenter.all);
      Hr := m_Interface.UnregisterAnchorCandidate (element.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollSnapPoint

   procedure Initialize (this : in out ScrollSnapPoint) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollSnapPoint) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollSnapPoint, IScrollSnapPoint_Ptr);
   begin
      if this.m_IScrollSnapPoint /= null then
         if this.m_IScrollSnapPoint.all /= null then
            temp := this.m_IScrollSnapPoint.all.Release;
            if temp < 1 then
               Free (this.m_IScrollSnapPoint);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollSnapPoint

   function Constructor
   (
      snapPointValue : WinUI3.Double;
      alignment : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPointsAlignment;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ScrollSnapPoint is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPoint");
      m_Factory    : access IScrollSnapPointFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPoint;
   begin
      return RetVal : ScrollSnapPoint do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollSnapPointFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (snapPointValue, alignment, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IScrollSnapPoint := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IScrollSnapPoint;
            Retval.m_IScrollSnapPoint.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollSnapPoint

   function get_Value
   (
      this : in out ScrollSnapPoint
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollSnapPoint.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitViewTemplateSettings

   procedure Initialize (this : in out SplitViewTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitViewTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitViewTemplateSettings, ISplitViewTemplateSettings_Ptr);
   begin
      if this.m_ISplitViewTemplateSettings /= null then
         if this.m_ISplitViewTemplateSettings.all /= null then
            temp := this.m_ISplitViewTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_ISplitViewTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitViewTemplateSettings

   function get_OpenPaneLength
   (
      this : in out SplitViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitViewTemplateSettings.all.get_OpenPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NegativeOpenPaneLength
   (
      this : in out SplitViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitViewTemplateSettings.all.get_NegativeOpenPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OpenPaneLengthMinusCompactLength
   (
      this : in out SplitViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitViewTemplateSettings.all.get_OpenPaneLengthMinusCompactLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NegativeOpenPaneLengthMinusCompactLength
   (
      this : in out SplitViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitViewTemplateSettings.all.get_NegativeOpenPaneLengthMinusCompactLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OpenPaneGridLength
   (
      this : in out SplitViewTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.GridLength;
   begin
      Hr := this.m_ISplitViewTemplateSettings.all.get_OpenPaneGridLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CompactPaneGridLength
   (
      this : in out SplitViewTemplateSettings
   )
   return WinUI3.Microsoft.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.GridLength;
   begin
      Hr := this.m_ISplitViewTemplateSettings.all.get_CompactPaneGridLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TabViewListView

   procedure Initialize (this : in out TabViewListView) is
   begin
      null;
   end;

   procedure Finalize (this : in out TabViewListView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITabViewListView, ITabViewListView_Ptr);
   begin
      if this.m_ITabViewListView /= null then
         if this.m_ITabViewListView.all /= null then
            temp := this.m_ITabViewListView.all.Release;
            if temp < 1 then
               Free (this.m_ITabViewListView);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TabViewListView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TabViewListView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.TabViewListView");
      m_Factory    : access ITabViewListViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ITabViewListView;
   begin
      return RetVal : TabViewListView do
         Hr := RoGetActivationFactory (m_hString, IID_ITabViewListViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITabViewListView := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ITabViewListView;
            Retval.m_ITabViewListView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TabViewListView

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Thumb

   procedure Initialize (this : in out Thumb) is
   begin
      null;
   end;

   procedure Finalize (this : in out Thumb) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IThumb, IThumb_Ptr);
   begin
      if this.m_IThumb /= null then
         if this.m_IThumb.all /= null then
            temp := this.m_IThumb.all.Release;
            if temp < 1 then
               Free (this.m_IThumb);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Thumb

   function Constructor return Thumb is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Thumb");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IThumb;
   begin
      return RetVal : Thumb do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IThumb := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IThumb;
            Retval.m_IThumb.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Thumb

   function get_IsDraggingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.Thumb");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IThumbStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IThumbStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDraggingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Thumb

   function get_IsDragging
   (
      this : in out Thumb
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IThumb.all.get_IsDragging (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_DragStarted
   (
      this : in out Thumb;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.DragStartedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IThumb.all.add_DragStarted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragStarted
   (
      this : in out Thumb;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IThumb.all.remove_DragStarted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragDelta
   (
      this : in out Thumb;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.DragDeltaEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IThumb.all.add_DragDelta (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragDelta
   (
      this : in out Thumb;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IThumb.all.remove_DragDelta (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragCompleted
   (
      this : in out Thumb;
      handler : WinUI3.Microsoft.UI.Xaml.Controls.Primitives.DragCompletedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IThumb.all.add_DragCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragCompleted
   (
      this : in out Thumb;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IThumb.all.remove_DragCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CancelDrag
   (
      this : in out Thumb
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IThumb.all.CancelDrag;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TickBar

   procedure Initialize (this : in out TickBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out TickBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITickBar, ITickBar_Ptr);
   begin
      if this.m_ITickBar /= null then
         if this.m_ITickBar.all /= null then
            temp := this.m_ITickBar.all.Release;
            if temp < 1 then
               Free (this.m_ITickBar);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TickBar

   function Constructor return TickBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.TickBar");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ITickBar;
   begin
      return RetVal : TickBar do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITickBar := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ITickBar;
            Retval.m_ITickBar.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TickBar

   function get_FillProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.TickBar");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Controls.Primitives.ITickBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITickBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FillProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TickBar

   function get_Fill
   (
      this : in out TickBar
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.Media.Brush do
         Hr := this.m_ITickBar.all.get_Fill (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Microsoft.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Fill
   (
      this : in out TickBar;
      value : WinUI3.Microsoft.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITickBar.all.put_Fill (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToggleSwitchTemplateSettings

   procedure Initialize (this : in out ToggleSwitchTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToggleSwitchTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToggleSwitchTemplateSettings, IToggleSwitchTemplateSettings_Ptr);
   begin
      if this.m_IToggleSwitchTemplateSettings /= null then
         if this.m_IToggleSwitchTemplateSettings.all /= null then
            temp := this.m_IToggleSwitchTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_IToggleSwitchTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToggleSwitchTemplateSettings

   function get_KnobCurrentToOnOffset
   (
      this : in out ToggleSwitchTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToggleSwitchTemplateSettings.all.get_KnobCurrentToOnOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_KnobCurrentToOffOffset
   (
      this : in out ToggleSwitchTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToggleSwitchTemplateSettings.all.get_KnobCurrentToOffOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_KnobOnToOffOffset
   (
      this : in out ToggleSwitchTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToggleSwitchTemplateSettings.all.get_KnobOnToOffOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_KnobOffToOnOffset
   (
      this : in out ToggleSwitchTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToggleSwitchTemplateSettings.all.get_KnobOffToOnOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CurtainCurrentToOnOffset
   (
      this : in out ToggleSwitchTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToggleSwitchTemplateSettings.all.get_CurtainCurrentToOnOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CurtainCurrentToOffOffset
   (
      this : in out ToggleSwitchTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToggleSwitchTemplateSettings.all.get_CurtainCurrentToOffOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CurtainOnToOffOffset
   (
      this : in out ToggleSwitchTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToggleSwitchTemplateSettings.all.get_CurtainOnToOffOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CurtainOffToOnOffset
   (
      this : in out ToggleSwitchTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToggleSwitchTemplateSettings.all.get_CurtainOffToOnOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToolTipTemplateSettings

   procedure Initialize (this : in out ToolTipTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToolTipTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToolTipTemplateSettings, IToolTipTemplateSettings_Ptr);
   begin
      if this.m_IToolTipTemplateSettings /= null then
         if this.m_IToolTipTemplateSettings.all /= null then
            temp := this.m_IToolTipTemplateSettings.all.Release;
            if temp < 1 then
               Free (this.m_IToolTipTemplateSettings);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToolTipTemplateSettings

   function get_FromHorizontalOffset
   (
      this : in out ToolTipTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToolTipTemplateSettings.all.get_FromHorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_FromVerticalOffset
   (
      this : in out ToolTipTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToolTipTemplateSettings.all.get_FromVerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ZoomSnapPoint

   procedure Initialize (this : in out ZoomSnapPoint) is
   begin
      null;
   end;

   procedure Finalize (this : in out ZoomSnapPoint) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IZoomSnapPoint, IZoomSnapPoint_Ptr);
   begin
      if this.m_IZoomSnapPoint /= null then
         if this.m_IZoomSnapPoint.all /= null then
            temp := this.m_IZoomSnapPoint.all.Release;
            if temp < 1 then
               Free (this.m_IZoomSnapPoint);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ZoomSnapPoint

   function Constructor
   (
      snapPointValue : WinUI3.Double;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ZoomSnapPoint is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Controls.Primitives.ZoomSnapPoint");
      m_Factory    : access IZoomSnapPointFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IZoomSnapPoint;
   begin
      return RetVal : ZoomSnapPoint do
         Hr := RoGetActivationFactory (m_hString, IID_IZoomSnapPointFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (snapPointValue, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IZoomSnapPoint := new WinUI3.Microsoft.UI.Xaml.Controls.Primitives.IZoomSnapPoint;
            Retval.m_IZoomSnapPoint.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ZoomSnapPoint

   function get_Value
   (
      this : in out ZoomSnapPoint
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IZoomSnapPoint.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

end WinUI3.Microsoft.UI.Xaml.Controls.Primitives;
