--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Windows.Storage.Pickers.Provider is

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FileOpenPickerUI

   procedure Initialize (this : in out FileOpenPickerUI) is
   begin
      null;
   end;

   procedure Finalize (this : in out FileOpenPickerUI) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFileOpenPickerUI, IFileOpenPickerUI_Ptr);
   begin
      if this.m_IFileOpenPickerUI /= null then
         if this.m_IFileOpenPickerUI.all /= null then
            temp := this.m_IFileOpenPickerUI.all.Release;
            if temp < 1 then
               Free (this.m_IFileOpenPickerUI);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FileOpenPickerUI

   function AddFile
   (
      this : in out FileOpenPickerUI;
      id : WinUI3.WString;
      file : WinUI3.Windows.Storage.IStorageFile
   )
   return WinUI3.Windows.Storage.Pickers.Provider.AddFileResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Storage.Pickers.Provider.AddFileResult;
      HStr_id : constant WinUI3.HString := To_HString (id);
   begin
      Hr := this.m_IFileOpenPickerUI.all.AddFile (HStr_id, file, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_id);
      return m_ComRetVal;
   end;

   procedure RemoveFile
   (
      this : in out FileOpenPickerUI;
      id : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_id : constant WinUI3.HString := To_HString (id);
   begin
      Hr := this.m_IFileOpenPickerUI.all.RemoveFile (HStr_id);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_id);
   end;

   function ContainsFile
   (
      this : in out FileOpenPickerUI;
      id : WinUI3.WString
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      HStr_id : constant WinUI3.HString := To_HString (id);
   begin
      Hr := this.m_IFileOpenPickerUI.all.ContainsFile (HStr_id, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_id);
      return m_ComRetVal;
   end;

   function CanAddFile
   (
      this : in out FileOpenPickerUI;
      file : WinUI3.Windows.Storage.IStorageFile
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFileOpenPickerUI.all.CanAddFile (file, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AllowedFileTypes
   (
      this : in out FileOpenPickerUI
   )
   return IVectorView_HString.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_IFileOpenPickerUI.all.get_AllowedFileTypes (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SelectionMode
   (
      this : in out FileOpenPickerUI
   )
   return WinUI3.Windows.Storage.Pickers.Provider.FileSelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Storage.Pickers.Provider.FileSelectionMode;
   begin
      Hr := this.m_IFileOpenPickerUI.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SettingsIdentifier
   (
      this : in out FileOpenPickerUI
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFileOpenPickerUI.all.get_SettingsIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Title
   (
      this : in out FileOpenPickerUI
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFileOpenPickerUI.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out FileOpenPickerUI;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IFileOpenPickerUI.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function add_FileRemoved
   (
      this : in out FileOpenPickerUI;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFileOpenPickerUI.all.add_FileRemoved (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_FileRemoved
   (
      this : in out FileOpenPickerUI;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFileOpenPickerUI.all.remove_FileRemoved (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closing
   (
      this : in out FileOpenPickerUI;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFileOpenPickerUI.all.add_Closing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closing
   (
      this : in out FileOpenPickerUI;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFileOpenPickerUI.all.remove_Closing (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FileRemovedEventArgs

   procedure Initialize (this : in out FileRemovedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out FileRemovedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFileRemovedEventArgs, IFileRemovedEventArgs_Ptr);
   begin
      if this.m_IFileRemovedEventArgs /= null then
         if this.m_IFileRemovedEventArgs.all /= null then
            temp := this.m_IFileRemovedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IFileRemovedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FileRemovedEventArgs

   function get_Id
   (
      this : in out FileRemovedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFileRemovedEventArgs.all.get_Id (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FileSavePickerUI

   procedure Initialize (this : in out FileSavePickerUI) is
   begin
      null;
   end;

   procedure Finalize (this : in out FileSavePickerUI) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFileSavePickerUI, IFileSavePickerUI_Ptr);
   begin
      if this.m_IFileSavePickerUI /= null then
         if this.m_IFileSavePickerUI.all /= null then
            temp := this.m_IFileSavePickerUI.all.Release;
            if temp < 1 then
               Free (this.m_IFileSavePickerUI);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FileSavePickerUI

   function get_Title
   (
      this : in out FileSavePickerUI
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFileSavePickerUI.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out FileSavePickerUI;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IFileSavePickerUI.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_AllowedFileTypes
   (
      this : in out FileSavePickerUI
   )
   return IVectorView_HString.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_IFileSavePickerUI.all.get_AllowedFileTypes (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SettingsIdentifier
   (
      this : in out FileSavePickerUI
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFileSavePickerUI.all.get_SettingsIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_FileName
   (
      this : in out FileSavePickerUI
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFileSavePickerUI.all.get_FileName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function TrySetFileName
   (
      this : in out FileSavePickerUI;
      value : WinUI3.WString
   )
   return WinUI3.Windows.Storage.Pickers.Provider.SetFileNameResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Storage.Pickers.Provider.SetFileNameResult;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IFileSavePickerUI.all.TrySetFileName (HStr_value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
      return m_ComRetVal;
   end;

   function add_FileNameChanged
   (
      this : in out FileSavePickerUI;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFileSavePickerUI.all.add_FileNameChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_FileNameChanged
   (
      this : in out FileSavePickerUI;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFileSavePickerUI.all.remove_FileNameChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TargetFileRequested
   (
      this : in out FileSavePickerUI;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFileSavePickerUI.all.add_TargetFileRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TargetFileRequested
   (
      this : in out FileSavePickerUI;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFileSavePickerUI.all.remove_TargetFileRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PickerClosingDeferral

   procedure Initialize (this : in out PickerClosingDeferral) is
   begin
      null;
   end;

   procedure Finalize (this : in out PickerClosingDeferral) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPickerClosingDeferral, IPickerClosingDeferral_Ptr);
   begin
      if this.m_IPickerClosingDeferral /= null then
         if this.m_IPickerClosingDeferral.all /= null then
            temp := this.m_IPickerClosingDeferral.all.Release;
            if temp < 1 then
               Free (this.m_IPickerClosingDeferral);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PickerClosingDeferral

   procedure Complete
   (
      this : in out PickerClosingDeferral
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPickerClosingDeferral.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PickerClosingEventArgs

   procedure Initialize (this : in out PickerClosingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PickerClosingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPickerClosingEventArgs, IPickerClosingEventArgs_Ptr);
   begin
      if this.m_IPickerClosingEventArgs /= null then
         if this.m_IPickerClosingEventArgs.all /= null then
            temp := this.m_IPickerClosingEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IPickerClosingEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PickerClosingEventArgs

   function get_ClosingOperation
   (
      this : in out PickerClosingEventArgs
   )
   return WinUI3.Windows.Storage.Pickers.Provider.PickerClosingOperation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Storage.Pickers.Provider.IPickerClosingOperation;
   begin
      return RetVal : WinUI3.Windows.Storage.Pickers.Provider.PickerClosingOperation do
         Hr := this.m_IPickerClosingEventArgs.all.get_ClosingOperation (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPickerClosingOperation := new WinUI3.Windows.Storage.Pickers.Provider.IPickerClosingOperation;
         Retval.m_IPickerClosingOperation.all := m_ComRetVal;
      end return;
   end;

   function get_IsCanceled
   (
      this : in out PickerClosingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPickerClosingEventArgs.all.get_IsCanceled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PickerClosingOperation

   procedure Initialize (this : in out PickerClosingOperation) is
   begin
      null;
   end;

   procedure Finalize (this : in out PickerClosingOperation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPickerClosingOperation, IPickerClosingOperation_Ptr);
   begin
      if this.m_IPickerClosingOperation /= null then
         if this.m_IPickerClosingOperation.all /= null then
            temp := this.m_IPickerClosingOperation.all.Release;
            if temp < 1 then
               Free (this.m_IPickerClosingOperation);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PickerClosingOperation

   function GetDeferral
   (
      this : in out PickerClosingOperation
   )
   return WinUI3.Windows.Storage.Pickers.Provider.PickerClosingDeferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Storage.Pickers.Provider.IPickerClosingDeferral;
   begin
      return RetVal : WinUI3.Windows.Storage.Pickers.Provider.PickerClosingDeferral do
         Hr := this.m_IPickerClosingOperation.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPickerClosingDeferral := new WinUI3.Windows.Storage.Pickers.Provider.IPickerClosingDeferral;
         Retval.m_IPickerClosingDeferral.all := m_ComRetVal;
      end return;
   end;

   function get_Deadline
   (
      this : in out PickerClosingOperation
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IPickerClosingOperation.all.get_Deadline (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TargetFileRequest

   procedure Initialize (this : in out TargetFileRequest) is
   begin
      null;
   end;

   procedure Finalize (this : in out TargetFileRequest) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITargetFileRequest, ITargetFileRequest_Ptr);
   begin
      if this.m_ITargetFileRequest /= null then
         if this.m_ITargetFileRequest.all /= null then
            temp := this.m_ITargetFileRequest.all.Release;
            if temp < 1 then
               Free (this.m_ITargetFileRequest);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TargetFileRequest

   function get_TargetFile
   (
      this : in out TargetFileRequest
   )
   return WinUI3.Windows.Storage.IStorageFile is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Storage.IStorageFile;
   begin
      Hr := this.m_ITargetFileRequest.all.get_TargetFile (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TargetFile
   (
      this : in out TargetFileRequest;
      value : WinUI3.Windows.Storage.IStorageFile
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITargetFileRequest.all.put_TargetFile (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out TargetFileRequest
   )
   return WinUI3.Windows.Storage.Pickers.Provider.TargetFileRequestDeferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Storage.Pickers.Provider.ITargetFileRequestDeferral;
   begin
      return RetVal : WinUI3.Windows.Storage.Pickers.Provider.TargetFileRequestDeferral do
         Hr := this.m_ITargetFileRequest.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITargetFileRequestDeferral := new WinUI3.Windows.Storage.Pickers.Provider.ITargetFileRequestDeferral;
         Retval.m_ITargetFileRequestDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TargetFileRequestDeferral

   procedure Initialize (this : in out TargetFileRequestDeferral) is
   begin
      null;
   end;

   procedure Finalize (this : in out TargetFileRequestDeferral) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITargetFileRequestDeferral, ITargetFileRequestDeferral_Ptr);
   begin
      if this.m_ITargetFileRequestDeferral /= null then
         if this.m_ITargetFileRequestDeferral.all /= null then
            temp := this.m_ITargetFileRequestDeferral.all.Release;
            if temp < 1 then
               Free (this.m_ITargetFileRequestDeferral);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TargetFileRequestDeferral

   procedure Complete
   (
      this : in out TargetFileRequestDeferral
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITargetFileRequestDeferral.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TargetFileRequestedEventArgs

   procedure Initialize (this : in out TargetFileRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TargetFileRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITargetFileRequestedEventArgs, ITargetFileRequestedEventArgs_Ptr);
   begin
      if this.m_ITargetFileRequestedEventArgs /= null then
         if this.m_ITargetFileRequestedEventArgs.all /= null then
            temp := this.m_ITargetFileRequestedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_ITargetFileRequestedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TargetFileRequestedEventArgs

   function get_Request
   (
      this : in out TargetFileRequestedEventArgs
   )
   return WinUI3.Windows.Storage.Pickers.Provider.TargetFileRequest'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Storage.Pickers.Provider.ITargetFileRequest;
   begin
      return RetVal : WinUI3.Windows.Storage.Pickers.Provider.TargetFileRequest do
         Hr := this.m_ITargetFileRequestedEventArgs.all.get_Request (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITargetFileRequest := new WinUI3.Windows.Storage.Pickers.Provider.ITargetFileRequest;
         Retval.m_ITargetFileRequest.all := m_ComRetVal;
      end return;
   end;

end WinUI3.Windows.Storage.Pickers.Provider;
