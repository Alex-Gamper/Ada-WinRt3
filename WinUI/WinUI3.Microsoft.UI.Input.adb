--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Microsoft.UI.Content;
with WinUI3.Microsoft.UI.Dispatching;
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with WinUI3.Windows.Graphics;
with WinUI3.Windows.System;
with WinUI3.Windows.UI.Core;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Microsoft.UI.Input is

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CharacterReceivedEventArgs

   procedure Initialize (this : in out CharacterReceivedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CharacterReceivedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICharacterReceivedEventArgs, ICharacterReceivedEventArgs_Ptr);
   begin
      if this.m_ICharacterReceivedEventArgs /= null then
         if this.m_ICharacterReceivedEventArgs.all /= null then
            temp := this.m_ICharacterReceivedEventArgs.all.Release;
            Free (this.m_ICharacterReceivedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CharacterReceivedEventArgs

   function get_Handled
   (
      this : in out CharacterReceivedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICharacterReceivedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out CharacterReceivedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICharacterReceivedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyCode
   (
      this : in out CharacterReceivedEventArgs
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_ICharacterReceivedEventArgs.all.get_KeyCode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_KeyStatus
   (
      this : in out CharacterReceivedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PhysicalKeyStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PhysicalKeyStatus;
   begin
      Hr := this.m_ICharacterReceivedEventArgs.all.get_KeyStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContextMenuKeyEventArgs

   procedure Initialize (this : in out ContextMenuKeyEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContextMenuKeyEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContextMenuKeyEventArgs, IContextMenuKeyEventArgs_Ptr);
   begin
      if this.m_IContextMenuKeyEventArgs /= null then
         if this.m_IContextMenuKeyEventArgs.all /= null then
            temp := this.m_IContextMenuKeyEventArgs.all.Release;
            Free (this.m_IContextMenuKeyEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContextMenuKeyEventArgs

   function get_Handled
   (
      this : in out ContextMenuKeyEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContextMenuKeyEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ContextMenuKeyEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContextMenuKeyEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CrossSlidingEventArgs

   procedure Initialize (this : in out CrossSlidingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CrossSlidingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICrossSlidingEventArgs, ICrossSlidingEventArgs_Ptr);
   begin
      if this.m_ICrossSlidingEventArgs /= null then
         if this.m_ICrossSlidingEventArgs.all /= null then
            temp := this.m_ICrossSlidingEventArgs.all.Release;
            Free (this.m_ICrossSlidingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CrossSlidingEventArgs

   function get_CrossSlidingState
   (
      this : in out CrossSlidingEventArgs
   )
   return WinUI3.Microsoft.UI.Input.CrossSlidingState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.CrossSlidingState;
   begin
      Hr := this.m_ICrossSlidingEventArgs.all.get_CrossSlidingState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerDeviceType
   (
      this : in out CrossSlidingEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_ICrossSlidingEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out CrossSlidingEventArgs
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_ICrossSlidingEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DraggingEventArgs

   procedure Initialize (this : in out DraggingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DraggingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDraggingEventArgs, IDraggingEventArgs_Ptr);
   begin
      if this.m_IDraggingEventArgs /= null then
         if this.m_IDraggingEventArgs.all /= null then
            temp := this.m_IDraggingEventArgs.all.Release;
            Free (this.m_IDraggingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DraggingEventArgs

   function get_DraggingState
   (
      this : in out DraggingEventArgs
   )
   return WinUI3.Microsoft.UI.Input.DraggingState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.DraggingState;
   begin
      Hr := this.m_IDraggingEventArgs.all.get_DraggingState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerDeviceType
   (
      this : in out DraggingEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_IDraggingEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out DraggingEventArgs
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IDraggingEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EnteredMoveSizeEventArgs

   procedure Initialize (this : in out EnteredMoveSizeEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out EnteredMoveSizeEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEnteredMoveSizeEventArgs, IEnteredMoveSizeEventArgs_Ptr);
   begin
      if this.m_IEnteredMoveSizeEventArgs /= null then
         if this.m_IEnteredMoveSizeEventArgs.all /= null then
            temp := this.m_IEnteredMoveSizeEventArgs.all.Release;
            Free (this.m_IEnteredMoveSizeEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EnteredMoveSizeEventArgs

   function get_PointerScreenPoint
   (
      this : in out EnteredMoveSizeEventArgs
   )
   return WinUI3.Windows.Graphics.PointInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.PointInt32;
   begin
      Hr := this.m_IEnteredMoveSizeEventArgs.all.get_PointerScreenPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MoveSizeOperation
   (
      this : in out EnteredMoveSizeEventArgs
   )
   return WinUI3.Microsoft.UI.Input.MoveSizeOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.MoveSizeOperation;
   begin
      Hr := this.m_IEnteredMoveSizeEventArgs.all.get_MoveSizeOperation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EnteringMoveSizeEventArgs

   procedure Initialize (this : in out EnteringMoveSizeEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out EnteringMoveSizeEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEnteringMoveSizeEventArgs, IEnteringMoveSizeEventArgs_Ptr);
   begin
      if this.m_IEnteringMoveSizeEventArgs /= null then
         if this.m_IEnteringMoveSizeEventArgs.all /= null then
            temp := this.m_IEnteringMoveSizeEventArgs.all.Release;
            Free (this.m_IEnteringMoveSizeEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EnteringMoveSizeEventArgs

   function get_PointerScreenPoint
   (
      this : in out EnteringMoveSizeEventArgs
   )
   return WinUI3.Windows.Graphics.PointInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.PointInt32;
   begin
      Hr := this.m_IEnteringMoveSizeEventArgs.all.get_PointerScreenPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MoveSizeOperation
   (
      this : in out EnteringMoveSizeEventArgs
   )
   return WinUI3.Microsoft.UI.Input.MoveSizeOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.MoveSizeOperation;
   begin
      Hr := this.m_IEnteringMoveSizeEventArgs.all.get_MoveSizeOperation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MoveSizeWindowId
   (
      this : in out EnteringMoveSizeEventArgs
   )
   return WinUI3.Microsoft.UI.WindowId is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.WindowId;
   begin
      Hr := this.m_IEnteringMoveSizeEventArgs.all.get_MoveSizeWindowId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MoveSizeWindowId
   (
      this : in out EnteringMoveSizeEventArgs;
      value : WinUI3.Microsoft.UI.WindowId
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEnteringMoveSizeEventArgs.all.put_MoveSizeWindowId (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ExitedMoveSizeEventArgs

   procedure Initialize (this : in out ExitedMoveSizeEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ExitedMoveSizeEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IExitedMoveSizeEventArgs, IExitedMoveSizeEventArgs_Ptr);
   begin
      if this.m_IExitedMoveSizeEventArgs /= null then
         if this.m_IExitedMoveSizeEventArgs.all /= null then
            temp := this.m_IExitedMoveSizeEventArgs.all.Release;
            Free (this.m_IExitedMoveSizeEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ExitedMoveSizeEventArgs

   function get_PointerScreenPoint
   (
      this : in out ExitedMoveSizeEventArgs
   )
   return WinUI3.Windows.Graphics.PointInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.PointInt32;
   begin
      Hr := this.m_IExitedMoveSizeEventArgs.all.get_PointerScreenPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MoveSizeOperation
   (
      this : in out ExitedMoveSizeEventArgs
   )
   return WinUI3.Microsoft.UI.Input.MoveSizeOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.MoveSizeOperation;
   begin
      Hr := this.m_IExitedMoveSizeEventArgs.all.get_MoveSizeOperation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FocusChangedEventArgs

   procedure Initialize (this : in out FocusChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out FocusChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFocusChangedEventArgs, IFocusChangedEventArgs_Ptr);
   begin
      if this.m_IFocusChangedEventArgs /= null then
         if this.m_IFocusChangedEventArgs.all /= null then
            temp := this.m_IFocusChangedEventArgs.all.Release;
            Free (this.m_IFocusChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FocusChangedEventArgs

   function get_Handled
   (
      this : in out FocusChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFocusChangedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out FocusChangedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFocusChangedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FocusNavigationRequest

   procedure Initialize (this : in out FocusNavigationRequest) is
   begin
      null;
   end;

   procedure Finalize (this : in out FocusNavigationRequest) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFocusNavigationRequest, IFocusNavigationRequest_Ptr);
   begin
      if this.m_IFocusNavigationRequest /= null then
         if this.m_IFocusNavigationRequest.all /= null then
            temp := this.m_IFocusNavigationRequest.all.Release;
            Free (this.m_IFocusNavigationRequest);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FocusNavigationRequest

   function Create
   (
      reason : WinUI3.Microsoft.UI.Input.FocusNavigationReason
   )
   return WinUI3.Microsoft.UI.Input.FocusNavigationRequest is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.FocusNavigationRequest");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IFocusNavigationRequestStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IFocusNavigationRequest;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.FocusNavigationRequest do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusNavigationRequestStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (reason, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IFocusNavigationRequest := new WinUI3.Microsoft.UI.Input.IFocusNavigationRequest;
            Retval.m_IFocusNavigationRequest.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Create
   (
      reason : WinUI3.Microsoft.UI.Input.FocusNavigationReason;
      hintRect : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Microsoft.UI.Input.FocusNavigationRequest is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.FocusNavigationRequest");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IFocusNavigationRequestStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IFocusNavigationRequest;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.FocusNavigationRequest do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusNavigationRequestStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (reason, hintRect, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IFocusNavigationRequest := new WinUI3.Microsoft.UI.Input.IFocusNavigationRequest;
            Retval.m_IFocusNavigationRequest.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Create
   (
      reason : WinUI3.Microsoft.UI.Input.FocusNavigationReason;
      hintRect : WinUI3.Windows.Foundation.Rect;
      correlationId : WinUI3.Guid
   )
   return WinUI3.Microsoft.UI.Input.FocusNavigationRequest is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.FocusNavigationRequest");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IFocusNavigationRequestStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IFocusNavigationRequest;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.FocusNavigationRequest do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusNavigationRequestStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (reason, hintRect, correlationId, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IFocusNavigationRequest := new WinUI3.Microsoft.UI.Input.IFocusNavigationRequest;
            Retval.m_IFocusNavigationRequest.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FocusNavigationRequest

   function get_CorrelationId
   (
      this : in out FocusNavigationRequest
   )
   return WinUI3.Guid is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Guid;
   begin
      Hr := this.m_IFocusNavigationRequest.all.get_CorrelationId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HintRect
   (
      this : in out FocusNavigationRequest
   )
   return IReference_Rect.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Rect.Kind;
   begin
      Hr := this.m_IFocusNavigationRequest.all.get_HintRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Rect (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Reason
   (
      this : in out FocusNavigationRequest
   )
   return WinUI3.Microsoft.UI.Input.FocusNavigationReason is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.FocusNavigationReason;
   begin
      Hr := this.m_IFocusNavigationRequest.all.get_Reason (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FocusNavigationRequestEventArgs

   procedure Initialize (this : in out FocusNavigationRequestEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out FocusNavigationRequestEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFocusNavigationRequestEventArgs, IFocusNavigationRequestEventArgs_Ptr);
   begin
      if this.m_IFocusNavigationRequestEventArgs /= null then
         if this.m_IFocusNavigationRequestEventArgs.all /= null then
            temp := this.m_IFocusNavigationRequestEventArgs.all.Release;
            Free (this.m_IFocusNavigationRequestEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FocusNavigationRequestEventArgs

   function get_Request
   (
      this : in out FocusNavigationRequestEventArgs
   )
   return WinUI3.Microsoft.UI.Input.FocusNavigationRequest'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IFocusNavigationRequest;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.FocusNavigationRequest do
         Hr := this.m_IFocusNavigationRequestEventArgs.all.get_Request (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFocusNavigationRequest := new WinUI3.Microsoft.UI.Input.IFocusNavigationRequest;
         Retval.m_IFocusNavigationRequest.all := m_ComRetVal;
      end return;
   end;

   function get_Result
   (
      this : in out FocusNavigationRequestEventArgs
   )
   return WinUI3.Microsoft.UI.Input.FocusNavigationResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.FocusNavigationResult;
   begin
      Hr := this.m_IFocusNavigationRequestEventArgs.all.get_Result (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Result
   (
      this : in out FocusNavigationRequestEventArgs;
      value : WinUI3.Microsoft.UI.Input.FocusNavigationResult
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFocusNavigationRequestEventArgs.all.put_Result (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GestureRecognizer

   procedure Initialize (this : in out GestureRecognizer) is
   begin
      null;
   end;

   procedure Finalize (this : in out GestureRecognizer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGestureRecognizer, IGestureRecognizer_Ptr);
   begin
      if this.m_IGestureRecognizer /= null then
         if this.m_IGestureRecognizer.all /= null then
            temp := this.m_IGestureRecognizer.all.Release;
            Free (this.m_IGestureRecognizer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GestureRecognizer

   function Constructor return GestureRecognizer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.GestureRecognizer");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Input.IGestureRecognizer;
   begin
      return RetVal : GestureRecognizer do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IGestureRecognizer := new WinUI3.Microsoft.UI.Input.IGestureRecognizer;
            Retval.m_IGestureRecognizer.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GestureRecognizer

   function get_AutoProcessInertia
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_AutoProcessInertia (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutoProcessInertia
   (
      this : in out GestureRecognizer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_AutoProcessInertia (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CrossSlideExact
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_CrossSlideExact (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CrossSlideExact
   (
      this : in out GestureRecognizer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_CrossSlideExact (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CrossSlideHorizontally
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_CrossSlideHorizontally (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CrossSlideHorizontally
   (
      this : in out GestureRecognizer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_CrossSlideHorizontally (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CrossSlideThresholds
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Microsoft.UI.Input.CrossSlideThresholds is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.CrossSlideThresholds;
   begin
      Hr := this.m_IGestureRecognizer.all.get_CrossSlideThresholds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CrossSlideThresholds
   (
      this : in out GestureRecognizer;
      value : WinUI3.Microsoft.UI.Input.CrossSlideThresholds
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_CrossSlideThresholds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GestureSettings
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Microsoft.UI.Input.GestureSettings is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.GestureSettings;
   begin
      Hr := this.m_IGestureRecognizer.all.get_GestureSettings (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GestureSettings
   (
      this : in out GestureRecognizer;
      value : WinUI3.Microsoft.UI.Input.GestureSettings
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_GestureSettings (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsActive
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_IsActive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInertial
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_IsInertial (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PivotCenter
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IGestureRecognizer.all.get_PivotCenter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PivotCenter
   (
      this : in out GestureRecognizer;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_PivotCenter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PivotRadius
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_PivotRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PivotRadius
   (
      this : in out GestureRecognizer;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_PivotRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaExpansionDeceleration
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaExpansionDeceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaExpansionDeceleration
   (
      this : in out GestureRecognizer;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaExpansionDeceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaExpansion
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaExpansion (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaExpansion
   (
      this : in out GestureRecognizer;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaExpansion (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaRotationAngle
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaRotationAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaRotationAngle
   (
      this : in out GestureRecognizer;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaRotationAngle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaRotationDeceleration
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaRotationDeceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaRotationDeceleration
   (
      this : in out GestureRecognizer;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaRotationDeceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaTranslationDeceleration
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaTranslationDeceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaTranslationDeceleration
   (
      this : in out GestureRecognizer;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaTranslationDeceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaTranslationDisplacement
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaTranslationDisplacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaTranslationDisplacement
   (
      this : in out GestureRecognizer;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaTranslationDisplacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ManipulationExact
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_ManipulationExact (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ManipulationExact
   (
      this : in out GestureRecognizer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_ManipulationExact (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MouseWheelParameters
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Microsoft.UI.Input.MouseWheelParameters'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IMouseWheelParameters;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.MouseWheelParameters do
         Hr := this.m_IGestureRecognizer.all.get_MouseWheelParameters (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMouseWheelParameters := new WinUI3.Microsoft.UI.Input.IMouseWheelParameters;
         Retval.m_IMouseWheelParameters.all := m_ComRetVal;
      end return;
   end;

   function get_ShowGestureFeedback
   (
      this : in out GestureRecognizer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_ShowGestureFeedback (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowGestureFeedback
   (
      this : in out GestureRecognizer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_ShowGestureFeedback (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CanBeDoubleTap
   (
      this : in out GestureRecognizer;
      value : WinUI3.Microsoft.UI.Input.PointerPoint'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.CanBeDoubleTap (value.m_IPointerPoint.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure CompleteGesture
   (
      this : in out GestureRecognizer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.CompleteGesture;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ProcessDownEvent
   (
      this : in out GestureRecognizer;
      value : WinUI3.Microsoft.UI.Input.PointerPoint'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.ProcessDownEvent (value.m_IPointerPoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ProcessMoveEvents
   (
      this : in out GestureRecognizer;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.ProcessMoveEvents (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ProcessMouseWheelEvent
   (
      this : in out GestureRecognizer;
      value : WinUI3.Microsoft.UI.Input.PointerPoint'Class;
      isShiftKeyDown : WinUI3.Boolean;
      isControlKeyDown : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.ProcessMouseWheelEvent (value.m_IPointerPoint.all, isShiftKeyDown, isControlKeyDown);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ProcessInertia
   (
      this : in out GestureRecognizer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.ProcessInertia;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ProcessUpEvent
   (
      this : in out GestureRecognizer;
      value : WinUI3.Microsoft.UI.Input.PointerPoint'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.ProcessUpEvent (value.m_IPointerPoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Tapped
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_Tapped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Tapped
   (
      this : in out GestureRecognizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_Tapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_RightTapped
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_RightTapped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RightTapped
   (
      this : in out GestureRecognizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_RightTapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Holding
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_Holding (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Holding
   (
      this : in out GestureRecognizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_Holding (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Dragging
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_Dragging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Dragging
   (
      this : in out GestureRecognizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_Dragging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationStarted
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_ManipulationStarted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationStarted
   (
      this : in out GestureRecognizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_ManipulationStarted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationUpdated
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_ManipulationUpdated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationUpdated
   (
      this : in out GestureRecognizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_ManipulationUpdated (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationInertiaStarting
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_ManipulationInertiaStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationInertiaStarting
   (
      this : in out GestureRecognizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_ManipulationInertiaStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationCompleted
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_ManipulationCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationCompleted
   (
      this : in out GestureRecognizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_ManipulationCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CrossSliding
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_CrossSliding (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CrossSliding
   (
      this : in out GestureRecognizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_CrossSliding (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HoldingEventArgs

   procedure Initialize (this : in out HoldingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out HoldingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHoldingEventArgs, IHoldingEventArgs_Ptr);
   begin
      if this.m_IHoldingEventArgs /= null then
         if this.m_IHoldingEventArgs.all /= null then
            temp := this.m_IHoldingEventArgs.all.Release;
            Free (this.m_IHoldingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HoldingEventArgs

   function get_HoldingState
   (
      this : in out HoldingEventArgs
   )
   return WinUI3.Microsoft.UI.Input.HoldingState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.HoldingState;
   begin
      Hr := this.m_IHoldingEventArgs.all.get_HoldingState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerDeviceType
   (
      this : in out HoldingEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_IHoldingEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out HoldingEventArgs
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IHoldingEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputObject

   procedure Initialize (this : in out InputObject) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputObject) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputObject, IInputObject_Ptr);
   begin
      if this.m_IInputObject /= null then
         if this.m_IInputObject.all /= null then
            temp := this.m_IInputObject.all.Release;
            Free (this.m_IInputObject);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InputObject

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputObject

   function get_DispatcherQueue
   (
      this : in out InputObject
   )
   return WinUI3.Microsoft.UI.Dispatching.DispatcherQueue'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Dispatching.IDispatcherQueue;
   begin
      return RetVal : WinUI3.Microsoft.UI.Dispatching.DispatcherQueue do
         Hr := this.m_IInputObject.all.get_DispatcherQueue (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDispatcherQueue := new WinUI3.Microsoft.UI.Dispatching.IDispatcherQueue;
         Retval.m_IDispatcherQueue.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputActivationListener

   procedure Initialize (this : in out InputActivationListener) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputActivationListener) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputActivationListener, IInputActivationListener_Ptr);
   begin
      if this.m_IInputActivationListener /= null then
         if this.m_IInputActivationListener.all /= null then
            temp := this.m_IInputActivationListener.all.Release;
            Free (this.m_IInputActivationListener);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputActivationListener

   function GetForWindowId
   (
      windowId : WinUI3.Microsoft.UI.WindowId
   )
   return WinUI3.Microsoft.UI.Input.InputActivationListener is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputActivationListener");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputActivationListenerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputActivationListener;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputActivationListener do
         Hr := RoGetActivationFactory (m_hString, IID_IInputActivationListenerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForWindowId (windowId, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputActivationListener := new WinUI3.Microsoft.UI.Input.IInputActivationListener;
            Retval.m_IInputActivationListener.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetForIsland
   (
      island : WinUI3.Microsoft.UI.Content.ContentIsland'Class
   )
   return WinUI3.Microsoft.UI.Input.InputActivationListener is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputActivationListener");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputActivationListenerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputActivationListener;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputActivationListener do
         Hr := RoGetActivationFactory (m_hString, IID_IInputActivationListenerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForIsland (island.m_IContentIsland.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputActivationListener := new WinUI3.Microsoft.UI.Input.IInputActivationListener;
            Retval.m_IInputActivationListener.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputActivationListener

   function get_State
   (
      this : in out InputActivationListener
   )
   return WinUI3.Microsoft.UI.Input.InputActivationState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.InputActivationState;
   begin
      Hr := this.m_IInputActivationListener.all.get_State (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_InputActivationChanged
   (
      this : in out InputActivationListener;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputActivationListener.all.add_InputActivationChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_InputActivationChanged
   (
      this : in out InputActivationListener;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputActivationListener.all.remove_InputActivationChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputActivationListenerActivationChangedEventArgs

   procedure Initialize (this : in out InputActivationListenerActivationChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputActivationListenerActivationChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputActivationListenerActivationChangedEventArgs, IInputActivationListenerActivationChangedEventArgs_Ptr);
   begin
      if this.m_IInputActivationListenerActivationChangedEventArgs /= null then
         if this.m_IInputActivationListenerActivationChangedEventArgs.all /= null then
            temp := this.m_IInputActivationListenerActivationChangedEventArgs.all.Release;
            Free (this.m_IInputActivationListenerActivationChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputActivationListenerActivationChangedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputCursor

   procedure Initialize (this : in out InputCursor) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputCursor) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputCursor, IInputCursor_Ptr);
   begin
      if this.m_IInputCursor /= null then
         if this.m_IInputCursor.all /= null then
            temp := this.m_IInputCursor.all.Release;
            Free (this.m_IInputCursor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InputCursor

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputCursor

   function CreateFromCoreCursor
   (
      cursor : WinUI3.Windows.UI.Core.CoreCursor'Class
   )
   return WinUI3.Microsoft.UI.Input.InputCursor is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputCursor");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputCursorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputCursor;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputCursor do
         Hr := RoGetActivationFactory (m_hString, IID_IInputCursorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromCoreCursor (cursor.m_ICoreCursor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputCursor := new WinUI3.Microsoft.UI.Input.IInputCursor;
            Retval.m_IInputCursor.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputCursor

   procedure Close
   (
      this : in out InputCursor
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Foundation.IClosable := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputCursor_Interface, WinUI3.Windows.Foundation.IClosable, WinUI3.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputCursor.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputCustomCursor

   procedure Initialize (this : in out InputCustomCursor) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputCustomCursor) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputCustomCursor, IInputCustomCursor_Ptr);
   begin
      if this.m_IInputCustomCursor /= null then
         if this.m_IInputCustomCursor.all /= null then
            temp := this.m_IInputCustomCursor.all.Release;
            Free (this.m_IInputCustomCursor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InputCustomCursor

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputCustomCursor

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputDesktopNamedResourceCursor

   procedure Initialize (this : in out InputDesktopNamedResourceCursor) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputDesktopNamedResourceCursor) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputDesktopNamedResourceCursor, IInputDesktopNamedResourceCursor_Ptr);
   begin
      if this.m_IInputDesktopNamedResourceCursor /= null then
         if this.m_IInputDesktopNamedResourceCursor.all /= null then
            temp := this.m_IInputDesktopNamedResourceCursor.all.Release;
            Free (this.m_IInputDesktopNamedResourceCursor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputDesktopNamedResourceCursor

   function Create
   (
      resourceName : WinUI3.WString
   )
   return WinUI3.Microsoft.UI.Input.InputDesktopNamedResourceCursor is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputDesktopNamedResourceCursor");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputDesktopNamedResourceCursorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputDesktopNamedResourceCursor;
      HStr_resourceName : constant WinUI3.HString := To_HString (resourceName);
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputDesktopNamedResourceCursor do
         Hr := RoGetActivationFactory (m_hString, IID_IInputDesktopNamedResourceCursorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (HStr_resourceName, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputDesktopNamedResourceCursor := new WinUI3.Microsoft.UI.Input.IInputDesktopNamedResourceCursor;
            Retval.m_IInputDesktopNamedResourceCursor.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_resourceName);
      end return;
   end;

   function CreateFromModule
   (
      moduleName : WinUI3.WString;
      resourceName : WinUI3.WString
   )
   return WinUI3.Microsoft.UI.Input.InputDesktopNamedResourceCursor is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputDesktopNamedResourceCursor");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputDesktopNamedResourceCursorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputDesktopNamedResourceCursor;
      HStr_moduleName : constant WinUI3.HString := To_HString (moduleName);
      HStr_resourceName : constant WinUI3.HString := To_HString (resourceName);
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputDesktopNamedResourceCursor do
         Hr := RoGetActivationFactory (m_hString, IID_IInputDesktopNamedResourceCursorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromModule (HStr_moduleName, HStr_resourceName, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputDesktopNamedResourceCursor := new WinUI3.Microsoft.UI.Input.IInputDesktopNamedResourceCursor;
            Retval.m_IInputDesktopNamedResourceCursor.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_moduleName);
         tmp := WindowsDeleteString (HStr_resourceName);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputDesktopNamedResourceCursor

   function get_ModuleName
   (
      this : in out InputDesktopNamedResourceCursor
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IInputDesktopNamedResourceCursor.all.get_ModuleName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ResourceName
   (
      this : in out InputDesktopNamedResourceCursor
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IInputDesktopNamedResourceCursor.all.get_ResourceName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputDesktopResourceCursor

   procedure Initialize (this : in out InputDesktopResourceCursor) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputDesktopResourceCursor) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputDesktopResourceCursor, IInputDesktopResourceCursor_Ptr);
   begin
      if this.m_IInputDesktopResourceCursor /= null then
         if this.m_IInputDesktopResourceCursor.all /= null then
            temp := this.m_IInputDesktopResourceCursor.all.Release;
            Free (this.m_IInputDesktopResourceCursor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputDesktopResourceCursor

   function Create
   (
      resourceId : WinUI3.UInt32
   )
   return WinUI3.Microsoft.UI.Input.InputDesktopResourceCursor is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputDesktopResourceCursor");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputDesktopResourceCursorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputDesktopResourceCursor;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputDesktopResourceCursor do
         Hr := RoGetActivationFactory (m_hString, IID_IInputDesktopResourceCursorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (resourceId, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputDesktopResourceCursor := new WinUI3.Microsoft.UI.Input.IInputDesktopResourceCursor;
            Retval.m_IInputDesktopResourceCursor.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateFromModule
   (
      moduleName : WinUI3.WString;
      resourceId : WinUI3.UInt32
   )
   return WinUI3.Microsoft.UI.Input.InputDesktopResourceCursor is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputDesktopResourceCursor");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputDesktopResourceCursorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputDesktopResourceCursor;
      HStr_moduleName : constant WinUI3.HString := To_HString (moduleName);
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputDesktopResourceCursor do
         Hr := RoGetActivationFactory (m_hString, IID_IInputDesktopResourceCursorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromModule (HStr_moduleName, resourceId, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputDesktopResourceCursor := new WinUI3.Microsoft.UI.Input.IInputDesktopResourceCursor;
            Retval.m_IInputDesktopResourceCursor.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_moduleName);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputDesktopResourceCursor

   function get_ModuleName
   (
      this : in out InputDesktopResourceCursor
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IInputDesktopResourceCursor.all.get_ModuleName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ResourceId
   (
      this : in out InputDesktopResourceCursor
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IInputDesktopResourceCursor.all.get_ResourceId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputFocusController

   procedure Initialize (this : in out InputFocusController) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputFocusController) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputFocusController, IInputFocusController_Ptr);
   begin
      if this.m_IInputFocusController /= null then
         if this.m_IInputFocusController.all /= null then
            temp := this.m_IInputFocusController.all.Release;
            Free (this.m_IInputFocusController);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputFocusController

   function GetForIsland
   (
      island : WinUI3.Microsoft.UI.Content.ContentIsland'Class
   )
   return WinUI3.Microsoft.UI.Input.InputFocusController is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputFocusController");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputFocusControllerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputFocusController;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputFocusController do
         Hr := RoGetActivationFactory (m_hString, IID_IInputFocusControllerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForIsland (island.m_IContentIsland.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputFocusController := new WinUI3.Microsoft.UI.Input.IInputFocusController;
            Retval.m_IInputFocusController.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputFocusController

   function get_HasFocus
   (
      this : in out InputFocusController
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInputFocusController.all.get_HasFocus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TrySetFocus
   (
      this : in out InputFocusController
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInputFocusController.all.TrySetFocus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_GotFocus
   (
      this : in out InputFocusController;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputFocusController.all.add_GotFocus (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_GotFocus
   (
      this : in out InputFocusController;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputFocusController.all.remove_GotFocus (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_LostFocus
   (
      this : in out InputFocusController;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputFocusController.all.add_LostFocus (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_LostFocus
   (
      this : in out InputFocusController;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputFocusController.all.remove_LostFocus (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function DepartFocus
   (
      this : in out InputFocusController;
      request : WinUI3.Microsoft.UI.Input.FocusNavigationRequest'Class
   )
   return WinUI3.Microsoft.UI.Input.FocusNavigationResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputFocusController2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.FocusNavigationResult;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputFocusController_Interface, WinUI3.Microsoft.UI.Input.IInputFocusController2, WinUI3.Microsoft.UI.Input.IID_IInputFocusController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputFocusController.all);
      Hr := m_Interface.DepartFocus (request.m_IFocusNavigationRequest.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_NavigateFocusRequested
   (
      this : in out InputFocusController;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputFocusController2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputFocusController_Interface, WinUI3.Microsoft.UI.Input.IInputFocusController2, WinUI3.Microsoft.UI.Input.IID_IInputFocusController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputFocusController.all);
      Hr := m_Interface.add_NavigateFocusRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NavigateFocusRequested
   (
      this : in out InputFocusController;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputFocusController2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputFocusController_Interface, WinUI3.Microsoft.UI.Input.IInputFocusController2, WinUI3.Microsoft.UI.Input.IID_IInputFocusController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputFocusController.all);
      Hr := m_Interface.remove_NavigateFocusRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputFocusNavigationHost

   procedure Initialize (this : in out InputFocusNavigationHost) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputFocusNavigationHost) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputFocusNavigationHost, IInputFocusNavigationHost_Ptr);
   begin
      if this.m_IInputFocusNavigationHost /= null then
         if this.m_IInputFocusNavigationHost.all /= null then
            temp := this.m_IInputFocusNavigationHost.all.Release;
            Free (this.m_IInputFocusNavigationHost);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputFocusNavigationHost

   function GetForSiteLink
   (
      contentSiteLink : WinUI3.Microsoft.UI.Content.IContentSiteLink
   )
   return WinUI3.Microsoft.UI.Input.InputFocusNavigationHost is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputFocusNavigationHost");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputFocusNavigationHostStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputFocusNavigationHost;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputFocusNavigationHost do
         Hr := RoGetActivationFactory (m_hString, IID_IInputFocusNavigationHostStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForSiteLink (contentSiteLink, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputFocusNavigationHost := new WinUI3.Microsoft.UI.Input.IInputFocusNavigationHost;
            Retval.m_IInputFocusNavigationHost.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetForSiteBridge
   (
      site : WinUI3.Microsoft.UI.Content.IContentSiteBridge
   )
   return WinUI3.Microsoft.UI.Input.InputFocusNavigationHost is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputFocusNavigationHost");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputFocusNavigationHostStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputFocusNavigationHost;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputFocusNavigationHost do
         Hr := RoGetActivationFactory (m_hString, IID_IInputFocusNavigationHostStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForSiteBridge (site, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputFocusNavigationHost := new WinUI3.Microsoft.UI.Input.IInputFocusNavigationHost;
            Retval.m_IInputFocusNavigationHost.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputFocusNavigationHost

   function get_ContainsFocus
   (
      this : in out InputFocusNavigationHost
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInputFocusNavigationHost.all.get_ContainsFocus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function NavigateFocus
   (
      this : in out InputFocusNavigationHost;
      request : WinUI3.Microsoft.UI.Input.FocusNavigationRequest'Class
   )
   return WinUI3.Microsoft.UI.Input.FocusNavigationResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.FocusNavigationResult;
   begin
      Hr := this.m_IInputFocusNavigationHost.all.NavigateFocus (request.m_IFocusNavigationRequest.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_DepartFocusRequested
   (
      this : in out InputFocusNavigationHost;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputFocusNavigationHost.all.add_DepartFocusRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DepartFocusRequested
   (
      this : in out InputFocusNavigationHost;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputFocusNavigationHost.all.remove_DepartFocusRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputKeyboardSource

   procedure Initialize (this : in out InputKeyboardSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputKeyboardSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputKeyboardSource, IInputKeyboardSource_Ptr);
   begin
      if this.m_IInputKeyboardSource /= null then
         if this.m_IInputKeyboardSource.all /= null then
            temp := this.m_IInputKeyboardSource.all.Release;
            Free (this.m_IInputKeyboardSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputKeyboardSource

   function GetForIsland
   (
      island : WinUI3.Microsoft.UI.Content.ContentIsland'Class
   )
   return WinUI3.Microsoft.UI.Input.InputKeyboardSource is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputKeyboardSource");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputKeyboardSourceStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputKeyboardSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputKeyboardSource do
         Hr := RoGetActivationFactory (m_hString, IID_IInputKeyboardSourceStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForIsland (island.m_IContentIsland.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputKeyboardSource := new WinUI3.Microsoft.UI.Input.IInputKeyboardSource;
            Retval.m_IInputKeyboardSource.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetKeyStateForCurrentThread
   (
      virtualKey : WinUI3.Windows.System.VirtualKey
   )
   return WinUI3.Windows.UI.Core.CoreVirtualKeyStates is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputKeyboardSource");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputKeyboardSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Core.CoreVirtualKeyStates;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IInputKeyboardSourceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetKeyStateForCurrentThread (virtualKey, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputKeyboardSource

   function GetCurrentKeyState
   (
      this : in out InputKeyboardSource;
      virtualKey : WinUI3.Windows.System.VirtualKey
   )
   return WinUI3.Microsoft.UI.Input.VirtualKeyStates is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.VirtualKeyStates;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.GetCurrentKeyState (virtualKey, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetKeyState
   (
      this : in out InputKeyboardSource;
      virtualKey : WinUI3.Windows.System.VirtualKey
   )
   return WinUI3.Microsoft.UI.Input.VirtualKeyStates is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.VirtualKeyStates;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.GetKeyState (virtualKey, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_CharacterReceived
   (
      this : in out InputKeyboardSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.add_CharacterReceived (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CharacterReceived
   (
      this : in out InputKeyboardSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.remove_CharacterReceived (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextMenuKey
   (
      this : in out InputKeyboardSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.add_ContextMenuKey (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextMenuKey
   (
      this : in out InputKeyboardSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.remove_ContextMenuKey (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_KeyDown
   (
      this : in out InputKeyboardSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.add_KeyDown (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_KeyDown
   (
      this : in out InputKeyboardSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.remove_KeyDown (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_KeyUp
   (
      this : in out InputKeyboardSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.add_KeyUp (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_KeyUp
   (
      this : in out InputKeyboardSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.remove_KeyUp (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SystemKeyDown
   (
      this : in out InputKeyboardSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.add_SystemKeyDown (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SystemKeyDown
   (
      this : in out InputKeyboardSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.remove_SystemKeyDown (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SystemKeyUp
   (
      this : in out InputKeyboardSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.add_SystemKeyUp (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SystemKeyUp
   (
      this : in out InputKeyboardSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputKeyboardSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputKeyboardSource_Interface, WinUI3.Microsoft.UI.Input.IInputKeyboardSource2, WinUI3.Microsoft.UI.Input.IID_IInputKeyboardSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputKeyboardSource.all);
      Hr := m_Interface.remove_SystemKeyUp (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputLightDismissAction

   procedure Initialize (this : in out InputLightDismissAction) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputLightDismissAction) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputLightDismissAction, IInputLightDismissAction_Ptr);
   begin
      if this.m_IInputLightDismissAction /= null then
         if this.m_IInputLightDismissAction.all /= null then
            temp := this.m_IInputLightDismissAction.all.Release;
            Free (this.m_IInputLightDismissAction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputLightDismissAction

   function GetForWindowId
   (
      windowId : WinUI3.Microsoft.UI.WindowId
   )
   return WinUI3.Microsoft.UI.Input.InputLightDismissAction is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputLightDismissAction");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputLightDismissActionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputLightDismissAction;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputLightDismissAction do
         Hr := RoGetActivationFactory (m_hString, IID_IInputLightDismissActionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForWindowId (windowId, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputLightDismissAction := new WinUI3.Microsoft.UI.Input.IInputLightDismissAction;
            Retval.m_IInputLightDismissAction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputLightDismissAction

   function add_Dismissed
   (
      this : in out InputLightDismissAction;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputLightDismissAction.all.add_Dismissed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Dismissed
   (
      this : in out InputLightDismissAction;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputLightDismissAction.all.remove_Dismissed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputLightDismissEventArgs

   procedure Initialize (this : in out InputLightDismissEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputLightDismissEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputLightDismissEventArgs, IInputLightDismissEventArgs_Ptr);
   begin
      if this.m_IInputLightDismissEventArgs /= null then
         if this.m_IInputLightDismissEventArgs.all /= null then
            temp := this.m_IInputLightDismissEventArgs.all.Release;
            Free (this.m_IInputLightDismissEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputLightDismissEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputNonClientPointerSource

   procedure Initialize (this : in out InputNonClientPointerSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputNonClientPointerSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputNonClientPointerSource, IInputNonClientPointerSource_Ptr);
   begin
      if this.m_IInputNonClientPointerSource /= null then
         if this.m_IInputNonClientPointerSource.all /= null then
            temp := this.m_IInputNonClientPointerSource.all.Release;
            Free (this.m_IInputNonClientPointerSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputNonClientPointerSource

   function GetForWindowId
   (
      windowId : WinUI3.Microsoft.UI.WindowId
   )
   return WinUI3.Microsoft.UI.Input.InputNonClientPointerSource is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputNonClientPointerSource");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputNonClientPointerSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputNonClientPointerSource do
         Hr := RoGetActivationFactory (m_hString, IID_IInputNonClientPointerSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForWindowId (windowId, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputNonClientPointerSource := new WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource;
            Retval.m_IInputNonClientPointerSource.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputNonClientPointerSource

   function get_DispatcherQueue
   (
      this : in out InputNonClientPointerSource
   )
   return WinUI3.Microsoft.UI.Dispatching.DispatcherQueue'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Dispatching.IDispatcherQueue;
   begin
      return RetVal : WinUI3.Microsoft.UI.Dispatching.DispatcherQueue do
         Hr := this.m_IInputNonClientPointerSource.all.get_DispatcherQueue (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDispatcherQueue := new WinUI3.Microsoft.UI.Dispatching.IDispatcherQueue;
         Retval.m_IDispatcherQueue.all := m_ComRetVal;
      end return;
   end;

   procedure ClearAllRegionRects
   (
      this : in out InputNonClientPointerSource
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.ClearAllRegionRects;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ClearRegionRects
   (
      this : in out InputNonClientPointerSource;
      region : WinUI3.Microsoft.UI.Input.NonClientRegionKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.ClearRegionRects (region);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetRegionRects
   (
      this : in out InputNonClientPointerSource;
      region : WinUI3.Microsoft.UI.Input.NonClientRegionKind
   )
   return WinUI3.Windows.Graphics.RectInt32_Array is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.RectInt32_Ptr;
      m_ComRetValSize  : aliased WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.GetRegionRects (region, m_ComRetValSize'Access, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      declare
         ArrayRetVal : WinUI3.Windows.Graphics.RectInt32_Array (1..Integer(m_ComRetValSize));
         function To_Ada_RectInt32 is new To_Ada_Type (WinUI3.Windows.Graphics.RectInt32, WinUI3.Windows.Graphics.RectInt32_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_RectInt32 (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   procedure SetRegionRects
   (
      this : in out InputNonClientPointerSource;
      region : WinUI3.Microsoft.UI.Input.NonClientRegionKind;
      rects : WinUI3.Windows.Graphics.RectInt32_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      function Convert_rects is new Ada.Unchecked_Conversion (Address, WinUI3.Windows.Graphics.RectInt32_Ptr);
   begin
      Hr := this.m_IInputNonClientPointerSource.all.SetRegionRects (region, WinUI3.UInt32(rects'Length), Convert_rects (rects (rects'First)'Address));
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CaptionTapped
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.add_CaptionTapped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CaptionTapped
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.remove_CaptionTapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerEntered
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.add_PointerEntered (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerEntered
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.remove_PointerEntered (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerExited
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.add_PointerExited (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerExited
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.remove_PointerExited (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerMoved
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.add_PointerMoved (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerMoved
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.remove_PointerMoved (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerPressed
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.add_PointerPressed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerPressed
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.remove_PointerPressed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerReleased
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.add_PointerReleased (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerReleased
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.remove_PointerReleased (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_RegionsChanged
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.add_RegionsChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RegionsChanged
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputNonClientPointerSource.all.remove_RegionsChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_EnteringMoveSize
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource_Interface, WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2, WinUI3.Microsoft.UI.Input.IID_IInputNonClientPointerSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputNonClientPointerSource.all);
      Hr := m_Interface.add_EnteringMoveSize (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_EnteringMoveSize
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource_Interface, WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2, WinUI3.Microsoft.UI.Input.IID_IInputNonClientPointerSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputNonClientPointerSource.all);
      Hr := m_Interface.remove_EnteringMoveSize (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_EnteredMoveSize
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource_Interface, WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2, WinUI3.Microsoft.UI.Input.IID_IInputNonClientPointerSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputNonClientPointerSource.all);
      Hr := m_Interface.add_EnteredMoveSize (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_EnteredMoveSize
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource_Interface, WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2, WinUI3.Microsoft.UI.Input.IID_IInputNonClientPointerSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputNonClientPointerSource.all);
      Hr := m_Interface.remove_EnteredMoveSize (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_WindowRectChanging
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource_Interface, WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2, WinUI3.Microsoft.UI.Input.IID_IInputNonClientPointerSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputNonClientPointerSource.all);
      Hr := m_Interface.add_WindowRectChanging (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_WindowRectChanging
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource_Interface, WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2, WinUI3.Microsoft.UI.Input.IID_IInputNonClientPointerSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputNonClientPointerSource.all);
      Hr := m_Interface.remove_WindowRectChanging (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_WindowRectChanged
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource_Interface, WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2, WinUI3.Microsoft.UI.Input.IID_IInputNonClientPointerSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputNonClientPointerSource.all);
      Hr := m_Interface.add_WindowRectChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_WindowRectChanged
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource_Interface, WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2, WinUI3.Microsoft.UI.Input.IID_IInputNonClientPointerSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputNonClientPointerSource.all);
      Hr := m_Interface.remove_WindowRectChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ExitedMoveSize
   (
      this : in out InputNonClientPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource_Interface, WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2, WinUI3.Microsoft.UI.Input.IID_IInputNonClientPointerSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputNonClientPointerSource.all);
      Hr := m_Interface.add_ExitedMoveSize (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ExitedMoveSize
   (
      this : in out InputNonClientPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource_Interface, WinUI3.Microsoft.UI.Input.IInputNonClientPointerSource2, WinUI3.Microsoft.UI.Input.IID_IInputNonClientPointerSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputNonClientPointerSource.all);
      Hr := m_Interface.remove_ExitedMoveSize (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputPointerSource

   procedure Initialize (this : in out InputPointerSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputPointerSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputPointerSource, IInputPointerSource_Ptr);
   begin
      if this.m_IInputPointerSource /= null then
         if this.m_IInputPointerSource.all /= null then
            temp := this.m_IInputPointerSource.all.Release;
            Free (this.m_IInputPointerSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputPointerSource

   function GetForIsland
   (
      island : WinUI3.Microsoft.UI.Content.ContentIsland'Class
   )
   return WinUI3.Microsoft.UI.Input.InputPointerSource is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputPointerSource");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputPointerSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputPointerSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputPointerSource do
         Hr := RoGetActivationFactory (m_hString, IID_IInputPointerSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForIsland (island.m_IContentIsland.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputPointerSource := new WinUI3.Microsoft.UI.Input.IInputPointerSource;
            Retval.m_IInputPointerSource.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputPointerSource

   function get_Cursor
   (
      this : in out InputPointerSource
   )
   return WinUI3.Microsoft.UI.Input.InputCursor'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputCursor;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputCursor do
         Hr := this.m_IInputPointerSource.all.get_Cursor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInputCursor := new WinUI3.Microsoft.UI.Input.IInputCursor;
         Retval.m_IInputCursor.all := m_ComRetVal;
      end return;
   end;

   procedure put_Cursor
   (
      this : in out InputPointerSource;
      value : WinUI3.Microsoft.UI.Input.InputCursor'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputPointerSource.all.put_Cursor (value.m_IInputCursor.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DeviceKinds
   (
      this : in out InputPointerSource
   )
   return WinUI3.Microsoft.UI.Input.InputPointerSourceDeviceKinds is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.InputPointerSourceDeviceKinds;
   begin
      Hr := this.m_IInputPointerSource.all.get_DeviceKinds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_PointerCaptureLost
   (
      this : in out InputPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputPointerSource.all.add_PointerCaptureLost (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerCaptureLost
   (
      this : in out InputPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputPointerSource.all.remove_PointerCaptureLost (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerEntered
   (
      this : in out InputPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputPointerSource.all.add_PointerEntered (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerEntered
   (
      this : in out InputPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputPointerSource.all.remove_PointerEntered (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerExited
   (
      this : in out InputPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputPointerSource.all.add_PointerExited (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerExited
   (
      this : in out InputPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputPointerSource.all.remove_PointerExited (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerMoved
   (
      this : in out InputPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputPointerSource.all.add_PointerMoved (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerMoved
   (
      this : in out InputPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputPointerSource.all.remove_PointerMoved (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerPressed
   (
      this : in out InputPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputPointerSource.all.add_PointerPressed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerPressed
   (
      this : in out InputPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputPointerSource.all.remove_PointerPressed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerReleased
   (
      this : in out InputPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputPointerSource.all.add_PointerReleased (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerReleased
   (
      this : in out InputPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputPointerSource.all.remove_PointerReleased (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerRoutedAway
   (
      this : in out InputPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputPointerSource.all.add_PointerRoutedAway (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerRoutedAway
   (
      this : in out InputPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputPointerSource.all.remove_PointerRoutedAway (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerRoutedReleased
   (
      this : in out InputPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputPointerSource.all.add_PointerRoutedReleased (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerRoutedReleased
   (
      this : in out InputPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputPointerSource.all.remove_PointerRoutedReleased (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerRoutedTo
   (
      this : in out InputPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputPointerSource.all.add_PointerRoutedTo (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerRoutedTo
   (
      this : in out InputPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputPointerSource.all.remove_PointerRoutedTo (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerWheelChanged
   (
      this : in out InputPointerSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputPointerSource.all.add_PointerWheelChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerWheelChanged
   (
      this : in out InputPointerSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInputPointerSource.all.remove_PointerWheelChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputPreTranslateKeyboardSource

   procedure Initialize (this : in out InputPreTranslateKeyboardSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputPreTranslateKeyboardSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputPreTranslateKeyboardSource, IInputPreTranslateKeyboardSource_Ptr);
   begin
      if this.m_IInputPreTranslateKeyboardSource /= null then
         if this.m_IInputPreTranslateKeyboardSource.all /= null then
            temp := this.m_IInputPreTranslateKeyboardSource.all.Release;
            Free (this.m_IInputPreTranslateKeyboardSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputPreTranslateKeyboardSource

   function GetForIsland
   (
      island : WinUI3.Microsoft.UI.Content.ContentIsland'Class
   )
   return WinUI3.Microsoft.UI.Input.InputPreTranslateKeyboardSource is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputPreTranslateKeyboardSource");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputPreTranslateKeyboardSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputPreTranslateKeyboardSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputPreTranslateKeyboardSource do
         Hr := RoGetActivationFactory (m_hString, IID_IInputPreTranslateKeyboardSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForIsland (island.m_IContentIsland.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputPreTranslateKeyboardSource := new WinUI3.Microsoft.UI.Input.IInputPreTranslateKeyboardSource;
            Retval.m_IInputPreTranslateKeyboardSource.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputPreTranslateKeyboardSource

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputSystemCursor

   procedure Initialize (this : in out InputSystemCursor) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputSystemCursor) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputSystemCursor, IInputSystemCursor_Ptr);
   begin
      if this.m_IInputSystemCursor /= null then
         if this.m_IInputSystemCursor.all /= null then
            temp := this.m_IInputSystemCursor.all.Release;
            Free (this.m_IInputSystemCursor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InputSystemCursor

   function Create
   (
      type_x : WinUI3.Microsoft.UI.Input.InputSystemCursorShape
   )
   return WinUI3.Microsoft.UI.Input.InputSystemCursor is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.InputSystemCursor");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IInputSystemCursorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IInputSystemCursor;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.InputSystemCursor do
         Hr := RoGetActivationFactory (m_hString, IID_IInputSystemCursorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (type_x, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInputSystemCursor := new WinUI3.Microsoft.UI.Input.IInputSystemCursor;
            Retval.m_IInputSystemCursor.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputSystemCursor

   function get_CursorShape
   (
      this : in out InputSystemCursor
   )
   return WinUI3.Microsoft.UI.Input.InputSystemCursorShape is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.InputSystemCursorShape;
   begin
      Hr := this.m_IInputSystemCursor.all.get_CursorShape (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for KeyEventArgs

   procedure Initialize (this : in out KeyEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out KeyEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IKeyEventArgs, IKeyEventArgs_Ptr);
   begin
      if this.m_IKeyEventArgs /= null then
         if this.m_IKeyEventArgs.all /= null then
            temp := this.m_IKeyEventArgs.all.Release;
            Free (this.m_IKeyEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for KeyEventArgs

   function get_Handled
   (
      this : in out KeyEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IKeyEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out KeyEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IKeyEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyStatus
   (
      this : in out KeyEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PhysicalKeyStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PhysicalKeyStatus;
   begin
      Hr := this.m_IKeyEventArgs.all.get_KeyStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Timestamp
   (
      this : in out KeyEventArgs
   )
   return WinUI3.UInt64 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt64;
   begin
      Hr := this.m_IKeyEventArgs.all.get_Timestamp (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VirtualKey
   (
      this : in out KeyEventArgs
   )
   return WinUI3.Windows.System.VirtualKey is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.System.VirtualKey;
   begin
      Hr := this.m_IKeyEventArgs.all.get_VirtualKey (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationCompletedEventArgs

   procedure Initialize (this : in out ManipulationCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationCompletedEventArgs, IManipulationCompletedEventArgs_Ptr);
   begin
      if this.m_IManipulationCompletedEventArgs /= null then
         if this.m_IManipulationCompletedEventArgs.all /= null then
            temp := this.m_IManipulationCompletedEventArgs.all.Release;
            Free (this.m_IManipulationCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationCompletedEventArgs

   function get_Cumulative
   (
      this : in out ManipulationCompletedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.ManipulationDelta is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationCompletedEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerDeviceType
   (
      this : in out ManipulationCompletedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationCompletedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out ManipulationCompletedEventArgs
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationCompletedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Velocities
   (
      this : in out ManipulationCompletedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.ManipulationVelocities is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.ManipulationVelocities;
   begin
      Hr := this.m_IManipulationCompletedEventArgs.all.get_Velocities (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationInertiaStartingEventArgs

   procedure Initialize (this : in out ManipulationInertiaStartingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationInertiaStartingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationInertiaStartingEventArgs, IManipulationInertiaStartingEventArgs_Ptr);
   begin
      if this.m_IManipulationInertiaStartingEventArgs /= null then
         if this.m_IManipulationInertiaStartingEventArgs.all /= null then
            temp := this.m_IManipulationInertiaStartingEventArgs.all.Release;
            Free (this.m_IManipulationInertiaStartingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationInertiaStartingEventArgs

   function get_Cumulative
   (
      this : in out ManipulationInertiaStartingEventArgs
   )
   return WinUI3.Microsoft.UI.Input.ManipulationDelta is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationInertiaStartingEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Delta
   (
      this : in out ManipulationInertiaStartingEventArgs
   )
   return WinUI3.Microsoft.UI.Input.ManipulationDelta is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationInertiaStartingEventArgs.all.get_Delta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerDeviceType
   (
      this : in out ManipulationInertiaStartingEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationInertiaStartingEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out ManipulationInertiaStartingEventArgs
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationInertiaStartingEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Velocities
   (
      this : in out ManipulationInertiaStartingEventArgs
   )
   return WinUI3.Microsoft.UI.Input.ManipulationVelocities is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.ManipulationVelocities;
   begin
      Hr := this.m_IManipulationInertiaStartingEventArgs.all.get_Velocities (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationStartedEventArgs

   procedure Initialize (this : in out ManipulationStartedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationStartedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationStartedEventArgs, IManipulationStartedEventArgs_Ptr);
   begin
      if this.m_IManipulationStartedEventArgs /= null then
         if this.m_IManipulationStartedEventArgs.all /= null then
            temp := this.m_IManipulationStartedEventArgs.all.Release;
            Free (this.m_IManipulationStartedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationStartedEventArgs

   function get_Cumulative
   (
      this : in out ManipulationStartedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.ManipulationDelta is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationStartedEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerDeviceType
   (
      this : in out ManipulationStartedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationStartedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out ManipulationStartedEventArgs
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationStartedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationUpdatedEventArgs

   procedure Initialize (this : in out ManipulationUpdatedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationUpdatedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationUpdatedEventArgs, IManipulationUpdatedEventArgs_Ptr);
   begin
      if this.m_IManipulationUpdatedEventArgs /= null then
         if this.m_IManipulationUpdatedEventArgs.all /= null then
            temp := this.m_IManipulationUpdatedEventArgs.all.Release;
            Free (this.m_IManipulationUpdatedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationUpdatedEventArgs

   function get_Cumulative
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.ManipulationDelta is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationUpdatedEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Delta
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.ManipulationDelta is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationUpdatedEventArgs.all.get_Delta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerDeviceType
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationUpdatedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationUpdatedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Velocities
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.ManipulationVelocities is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.ManipulationVelocities;
   begin
      Hr := this.m_IManipulationUpdatedEventArgs.all.get_Velocities (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MouseWheelParameters

   procedure Initialize (this : in out MouseWheelParameters) is
   begin
      null;
   end;

   procedure Finalize (this : in out MouseWheelParameters) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMouseWheelParameters, IMouseWheelParameters_Ptr);
   begin
      if this.m_IMouseWheelParameters /= null then
         if this.m_IMouseWheelParameters.all /= null then
            temp := this.m_IMouseWheelParameters.all.Release;
            Free (this.m_IMouseWheelParameters);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MouseWheelParameters

   function get_CharTranslation
   (
      this : in out MouseWheelParameters
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IMouseWheelParameters.all.get_CharTranslation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharTranslation
   (
      this : in out MouseWheelParameters;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMouseWheelParameters.all.put_CharTranslation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DeltaScale
   (
      this : in out MouseWheelParameters
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IMouseWheelParameters.all.get_DeltaScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DeltaScale
   (
      this : in out MouseWheelParameters;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMouseWheelParameters.all.put_DeltaScale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DeltaRotationAngle
   (
      this : in out MouseWheelParameters
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IMouseWheelParameters.all.get_DeltaRotationAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DeltaRotationAngle
   (
      this : in out MouseWheelParameters;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMouseWheelParameters.all.put_DeltaRotationAngle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PageTranslation
   (
      this : in out MouseWheelParameters
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IMouseWheelParameters.all.get_PageTranslation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PageTranslation
   (
      this : in out MouseWheelParameters;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMouseWheelParameters.all.put_PageTranslation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NonClientCaptionTappedEventArgs

   procedure Initialize (this : in out NonClientCaptionTappedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NonClientCaptionTappedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INonClientCaptionTappedEventArgs, INonClientCaptionTappedEventArgs_Ptr);
   begin
      if this.m_INonClientCaptionTappedEventArgs /= null then
         if this.m_INonClientCaptionTappedEventArgs.all /= null then
            temp := this.m_INonClientCaptionTappedEventArgs.all.Release;
            Free (this.m_INonClientCaptionTappedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NonClientCaptionTappedEventArgs

   function get_Point
   (
      this : in out NonClientCaptionTappedEventArgs
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_INonClientCaptionTappedEventArgs.all.get_Point (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerDeviceType
   (
      this : in out NonClientCaptionTappedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_INonClientCaptionTappedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NonClientPointerEventArgs

   procedure Initialize (this : in out NonClientPointerEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NonClientPointerEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INonClientPointerEventArgs, INonClientPointerEventArgs_Ptr);
   begin
      if this.m_INonClientPointerEventArgs /= null then
         if this.m_INonClientPointerEventArgs.all /= null then
            temp := this.m_INonClientPointerEventArgs.all.Release;
            Free (this.m_INonClientPointerEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NonClientPointerEventArgs

   function get_Point
   (
      this : in out NonClientPointerEventArgs
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_INonClientPointerEventArgs.all.get_Point (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerDeviceType
   (
      this : in out NonClientPointerEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_INonClientPointerEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_RegionKind
   (
      this : in out NonClientPointerEventArgs
   )
   return WinUI3.Microsoft.UI.Input.NonClientRegionKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.NonClientRegionKind;
   begin
      Hr := this.m_INonClientPointerEventArgs.all.get_RegionKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsPointInRegion
   (
      this : in out NonClientPointerEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INonClientPointerEventArgs.all.get_IsPointInRegion (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NonClientRegionsChangedEventArgs

   procedure Initialize (this : in out NonClientRegionsChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NonClientRegionsChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INonClientRegionsChangedEventArgs, INonClientRegionsChangedEventArgs_Ptr);
   begin
      if this.m_INonClientRegionsChangedEventArgs /= null then
         if this.m_INonClientRegionsChangedEventArgs.all /= null then
            temp := this.m_INonClientRegionsChangedEventArgs.all.Release;
            Free (this.m_INonClientRegionsChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NonClientRegionsChangedEventArgs

   function get_ChangedRegions
   (
      this : in out NonClientRegionsChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.NonClientRegionKind_Array is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.NonClientRegionKind_Ptr;
      m_ComRetValSize  : aliased WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INonClientRegionsChangedEventArgs.all.get_ChangedRegions (m_ComRetValSize'Access, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      declare
         ArrayRetVal : WinUI3.Microsoft.UI.Input.NonClientRegionKind_Array (1..Integer(m_ComRetValSize));
         function To_Ada_NonClientRegionKind is new To_Ada_Type (WinUI3.Microsoft.UI.Input.NonClientRegionKind, WinUI3.Microsoft.UI.Input.NonClientRegionKind_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_NonClientRegionKind (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointerEventArgs

   procedure Initialize (this : in out PointerEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointerEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointerEventArgs, IPointerEventArgs_Ptr);
   begin
      if this.m_IPointerEventArgs /= null then
         if this.m_IPointerEventArgs.all /= null then
            temp := this.m_IPointerEventArgs.all.Release;
            Free (this.m_IPointerEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointerEventArgs

   function get_CurrentPoint
   (
      this : in out PointerEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerPoint'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IPointerPoint;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.PointerPoint do
         Hr := this.m_IPointerEventArgs.all.get_CurrentPoint (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointerPoint := new WinUI3.Microsoft.UI.Input.IPointerPoint;
         Retval.m_IPointerPoint.all := m_ComRetVal;
      end return;
   end;

   function get_Handled
   (
      this : in out PointerEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out PointerEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPointerEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyModifiers
   (
      this : in out PointerEventArgs
   )
   return WinUI3.Windows.System.VirtualKeyModifiers is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.System.VirtualKeyModifiers;
   begin
      Hr := this.m_IPointerEventArgs.all.get_KeyModifiers (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetIntermediatePoints
   (
      this : in out PointerEventArgs
   )
   return IVector_IPointerPoint.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IPointerPoint.Kind;
   begin
      Hr := this.m_IPointerEventArgs.all.GetIntermediatePoints (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IPointerPoint (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetIntermediateTransformedPoints
   (
      this : in out PointerEventArgs;
      transform : WinUI3.Microsoft.UI.Input.IPointerPointTransform
   )
   return IVector_IPointerPoint.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IPointerPoint.Kind;
   begin
      Hr := this.m_IPointerEventArgs.all.GetIntermediateTransformedPoints (transform, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IPointerPoint (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointerPoint

   procedure Initialize (this : in out PointerPoint) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointerPoint) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointerPoint, IPointerPoint_Ptr);
   begin
      if this.m_IPointerPoint /= null then
         if this.m_IPointerPoint.all /= null then
            temp := this.m_IPointerPoint.all.Release;
            Free (this.m_IPointerPoint);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointerPoint

   function get_FrameId
   (
      this : in out PointerPoint
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IPointerPoint.all.get_FrameId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInContact
   (
      this : in out PointerPoint
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPoint.all.get_IsInContact (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerDeviceType
   (
      this : in out PointerPoint
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_IPointerPoint.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerId
   (
      this : in out PointerPoint
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IPointerPoint.all.get_PointerId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out PointerPoint
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IPointerPoint.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Properties
   (
      this : in out PointerPoint
   )
   return WinUI3.Microsoft.UI.Input.PointerPointProperties'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IPointerPointProperties;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.PointerPointProperties do
         Hr := this.m_IPointerPoint.all.get_Properties (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointerPointProperties := new WinUI3.Microsoft.UI.Input.IPointerPointProperties;
         Retval.m_IPointerPointProperties.all := m_ComRetVal;
      end return;
   end;

   function get_Timestamp
   (
      this : in out PointerPoint
   )
   return WinUI3.UInt64 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt64;
   begin
      Hr := this.m_IPointerPoint.all.get_Timestamp (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetTransformedPoint
   (
      this : in out PointerPoint;
      transform : WinUI3.Microsoft.UI.Input.IPointerPointTransform
   )
   return WinUI3.Microsoft.UI.Input.PointerPoint'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IPointerPoint;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.PointerPoint do
         Hr := this.m_IPointerPoint.all.GetTransformedPoint (transform, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointerPoint := new WinUI3.Microsoft.UI.Input.IPointerPoint;
         Retval.m_IPointerPoint.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointerPointProperties

   procedure Initialize (this : in out PointerPointProperties) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointerPointProperties) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointerPointProperties, IPointerPointProperties_Ptr);
   begin
      if this.m_IPointerPointProperties /= null then
         if this.m_IPointerPointProperties.all /= null then
            temp := this.m_IPointerPointProperties.all.Release;
            Free (this.m_IPointerPointProperties);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointerPointProperties

   function get_ContactRect
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IPointerPointProperties.all.get_ContactRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsBarrelButtonPressed
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsBarrelButtonPressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsCanceled
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsCanceled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsEraser
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsEraser (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsHorizontalMouseWheel
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsHorizontalMouseWheel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInRange
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsInRange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInverted
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsInverted (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsLeftButtonPressed
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsLeftButtonPressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsMiddleButtonPressed
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsMiddleButtonPressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsPrimary
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsPrimary (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsRightButtonPressed
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsRightButtonPressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsXButton1Pressed
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsXButton1Pressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsXButton2Pressed
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsXButton2Pressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MouseWheelDelta
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IPointerPointProperties.all.get_MouseWheelDelta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Orientation
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IPointerPointProperties.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerUpdateKind
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Microsoft.UI.Input.PointerUpdateKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerUpdateKind;
   begin
      Hr := this.m_IPointerPointProperties.all.get_PointerUpdateKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Pressure
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IPointerPointProperties.all.get_Pressure (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_TouchConfidence
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_TouchConfidence (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Twist
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IPointerPointProperties.all.get_Twist (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_XTilt
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IPointerPointProperties.all.get_XTilt (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_YTilt
   (
      this : in out PointerPointProperties
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IPointerPointProperties.all.get_YTilt (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointerPredictor

   procedure Initialize (this : in out PointerPredictor) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointerPredictor) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointerPredictor, IPointerPredictor_Ptr);
   begin
      if this.m_IPointerPredictor /= null then
         if this.m_IPointerPredictor.all /= null then
            temp := this.m_IPointerPredictor.all.Release;
            Free (this.m_IPointerPredictor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PointerPredictor

   function CreateForInputPointerSource
   (
      inputPointerSource_p : WinUI3.Microsoft.UI.Input.InputPointerSource'Class
   )
   return WinUI3.Microsoft.UI.Input.PointerPredictor is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Input.PointerPredictor");
      m_Factory        : access WinUI3.Microsoft.UI.Input.IPointerPredictorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IPointerPredictor;
   begin
      return RetVal : WinUI3.Microsoft.UI.Input.PointerPredictor do
         Hr := RoGetActivationFactory (m_hString, IID_IPointerPredictorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateForInputPointerSource (inputPointerSource_p.m_IInputPointerSource.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IPointerPredictor := new WinUI3.Microsoft.UI.Input.IPointerPredictor;
            Retval.m_IPointerPredictor.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointerPredictor

   function get_PredictionTime
   (
      this : in out PointerPredictor
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IPointerPredictor.all.get_PredictionTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PredictionTime
   (
      this : in out PointerPredictor;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPointerPredictor.all.put_PredictionTime (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetPredictedPoints
   (
      this : in out PointerPredictor;
      point : WinUI3.Microsoft.UI.Input.PointerPoint'Class
   )
   return WinUI3.Microsoft.UI.Input.PointerPoint_Array is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.IPointerPoint_Ptr;
      m_ComRetValSize  : aliased WinUI3.UInt32 := 0;

      function GetArraySize return Integer is
      begin
         Hr := this.m_IPointerPredictor.all.GetPredictedPoints (point.m_IPointerPoint.all, m_ComRetValSize'Access, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         return Integer(m_ComRetValSize);
      end;

      function To_Ada_IPointerPoint is new To_Ada_Type (WinUI3.Microsoft.UI.Input.IPointerPoint, WinUI3.Microsoft.UI.Input.IPointerPoint_Ptr); 

   begin
      return RetVal : WinUI3.Microsoft.UI.Input.PointerPoint_Array (1..GetArraySize) do
         for i in RetVal'Range loop
            Retval (i).m_IPointerPoint := new Microsoft.UI.Input.IPointerPoint;
            Retval (i).m_IPointerPoint.all := To_Ada_IPointerPoint (m_ComRetVal, i);
         end loop;
      end return;
   end;

   procedure Close
   (
      this : in out PointerPredictor
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Foundation.IClosable := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Input.IPointerPredictor_Interface, WinUI3.Windows.Foundation.IClosable, WinUI3.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPointerPredictor.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RightTappedEventArgs

   procedure Initialize (this : in out RightTappedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RightTappedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRightTappedEventArgs, IRightTappedEventArgs_Ptr);
   begin
      if this.m_IRightTappedEventArgs /= null then
         if this.m_IRightTappedEventArgs.all /= null then
            temp := this.m_IRightTappedEventArgs.all.Release;
            Free (this.m_IRightTappedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RightTappedEventArgs

   function get_PointerDeviceType
   (
      this : in out RightTappedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_IRightTappedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out RightTappedEventArgs
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IRightTappedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TappedEventArgs

   procedure Initialize (this : in out TappedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TappedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITappedEventArgs, ITappedEventArgs_Ptr);
   begin
      if this.m_ITappedEventArgs /= null then
         if this.m_ITappedEventArgs.all /= null then
            temp := this.m_ITappedEventArgs.all.Release;
            Free (this.m_ITappedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TappedEventArgs

   function get_PointerDeviceType
   (
      this : in out TappedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.PointerDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.PointerDeviceType;
   begin
      Hr := this.m_ITappedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out TappedEventArgs
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_ITappedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_TapCount
   (
      this : in out TappedEventArgs
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_ITappedEventArgs.all.get_TapCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WindowRectChangedEventArgs

   procedure Initialize (this : in out WindowRectChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WindowRectChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWindowRectChangedEventArgs, IWindowRectChangedEventArgs_Ptr);
   begin
      if this.m_IWindowRectChangedEventArgs /= null then
         if this.m_IWindowRectChangedEventArgs.all /= null then
            temp := this.m_IWindowRectChangedEventArgs.all.Release;
            Free (this.m_IWindowRectChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WindowRectChangedEventArgs

   function get_PointerScreenPoint
   (
      this : in out WindowRectChangedEventArgs
   )
   return WinUI3.Windows.Graphics.PointInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.PointInt32;
   begin
      Hr := this.m_IWindowRectChangedEventArgs.all.get_PointerScreenPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MoveSizeOperation
   (
      this : in out WindowRectChangedEventArgs
   )
   return WinUI3.Microsoft.UI.Input.MoveSizeOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.MoveSizeOperation;
   begin
      Hr := this.m_IWindowRectChangedEventArgs.all.get_MoveSizeOperation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OldWindowRect
   (
      this : in out WindowRectChangedEventArgs
   )
   return WinUI3.Windows.Graphics.RectInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.RectInt32;
   begin
      Hr := this.m_IWindowRectChangedEventArgs.all.get_OldWindowRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewWindowRect
   (
      this : in out WindowRectChangedEventArgs
   )
   return WinUI3.Windows.Graphics.RectInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.RectInt32;
   begin
      Hr := this.m_IWindowRectChangedEventArgs.all.get_NewWindowRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WindowRectChangingEventArgs

   procedure Initialize (this : in out WindowRectChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WindowRectChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWindowRectChangingEventArgs, IWindowRectChangingEventArgs_Ptr);
   begin
      if this.m_IWindowRectChangingEventArgs /= null then
         if this.m_IWindowRectChangingEventArgs.all /= null then
            temp := this.m_IWindowRectChangingEventArgs.all.Release;
            Free (this.m_IWindowRectChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WindowRectChangingEventArgs

   function get_PointerScreenPoint
   (
      this : in out WindowRectChangingEventArgs
   )
   return WinUI3.Windows.Graphics.PointInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.PointInt32;
   begin
      Hr := this.m_IWindowRectChangingEventArgs.all.get_PointerScreenPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MoveSizeOperation
   (
      this : in out WindowRectChangingEventArgs
   )
   return WinUI3.Microsoft.UI.Input.MoveSizeOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Input.MoveSizeOperation;
   begin
      Hr := this.m_IWindowRectChangingEventArgs.all.get_MoveSizeOperation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OldWindowRect
   (
      this : in out WindowRectChangingEventArgs
   )
   return WinUI3.Windows.Graphics.RectInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.RectInt32;
   begin
      Hr := this.m_IWindowRectChangingEventArgs.all.get_OldWindowRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewWindowRect
   (
      this : in out WindowRectChangingEventArgs
   )
   return WinUI3.Windows.Graphics.RectInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.RectInt32;
   begin
      Hr := this.m_IWindowRectChangingEventArgs.all.get_NewWindowRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NewWindowRect
   (
      this : in out WindowRectChangingEventArgs;
      value : WinUI3.Windows.Graphics.RectInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWindowRectChangingEventArgs.all.put_NewWindowRect (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AllowRectChange
   (
      this : in out WindowRectChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWindowRectChangingEventArgs.all.get_AllowRectChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AllowRectChange
   (
      this : in out WindowRectChangingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWindowRectChangingEventArgs.all.put_AllowRectChange (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowWindow
   (
      this : in out WindowRectChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWindowRectChangingEventArgs.all.get_ShowWindow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowWindow
   (
      this : in out WindowRectChangingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWindowRectChangingEventArgs.all.put_ShowWindow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

end WinUI3.Microsoft.UI.Input;
