--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Windows.UI.Xaml.Data is

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BindingBase

   procedure Initialize (this : in out BindingBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out BindingBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBindingBase, IBindingBase_Ptr);
   begin
      if this.m_IBindingBase /= null then
         if this.m_IBindingBase.all /= null then
            temp := this.m_IBindingBase.all.Release;
            Free (this.m_IBindingBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BindingBase

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return BindingBase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.IBindingBase");
      m_Factory    : access IBindingBaseFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Data.IBindingBase;
   begin
      return RetVal : BindingBase do
         Hr := RoGetActivationFactory (m_hString, IID_IBindingBaseFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBindingBase := new WinUI3.Windows.UI.Xaml.Data.IBindingBase;
            Retval.m_IBindingBase.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BindingBase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Binding

   procedure Initialize (this : in out Binding) is
   begin
      null;
   end;

   procedure Finalize (this : in out Binding) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBinding, IBinding_Ptr);
   begin
      if this.m_IBinding /= null then
         if this.m_IBinding.all /= null then
            temp := this.m_IBinding.all.Release;
            Free (this.m_IBinding);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Binding

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Binding is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.IBinding");
      m_Factory    : access IBindingFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Data.IBinding;
   begin
      return RetVal : Binding do
         Hr := RoGetActivationFactory (m_hString, IID_IBindingFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBinding := new WinUI3.Windows.UI.Xaml.Data.IBinding;
            Retval.m_IBinding.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Binding

   function get_Path
   (
      this : in out Binding
   )
   return WinUI3.Windows.UI.Xaml.PropertyPath'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IPropertyPath;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.PropertyPath do
         Hr := this.m_IBinding.all.get_Path (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPropertyPath := new WinUI3.Windows.UI.Xaml.IPropertyPath;
         Retval.m_IPropertyPath.all := m_ComRetVal;
      end return;
   end;

   procedure put_Path
   (
      this : in out Binding;
      value : WinUI3.Windows.UI.Xaml.PropertyPath'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBinding.all.put_Path (value.m_IPropertyPath.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Mode
   (
      this : in out Binding
   )
   return WinUI3.Windows.UI.Xaml.Data.BindingMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Data.BindingMode;
   begin
      Hr := this.m_IBinding.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Mode
   (
      this : in out Binding;
      value : WinUI3.Windows.UI.Xaml.Data.BindingMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBinding.all.put_Mode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Source
   (
      this : in out Binding
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IBinding.all.get_Source (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Source
   (
      this : in out Binding;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBinding.all.put_Source (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RelativeSource
   (
      this : in out Binding
   )
   return WinUI3.Windows.UI.Xaml.Data.RelativeSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Data.IRelativeSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Data.RelativeSource do
         Hr := this.m_IBinding.all.get_RelativeSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRelativeSource := new WinUI3.Windows.UI.Xaml.Data.IRelativeSource;
         Retval.m_IRelativeSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_RelativeSource
   (
      this : in out Binding;
      value : WinUI3.Windows.UI.Xaml.Data.RelativeSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBinding.all.put_RelativeSource (value.m_IRelativeSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ElementName
   (
      this : in out Binding
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IBinding.all.get_ElementName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ElementName
   (
      this : in out Binding;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IBinding.all.put_ElementName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Converter
   (
      this : in out Binding
   )
   return WinUI3.Windows.UI.Xaml.Data.IValueConverter is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Data.IValueConverter;
   begin
      Hr := this.m_IBinding.all.get_Converter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Converter
   (
      this : in out Binding;
      value : WinUI3.Windows.UI.Xaml.Data.IValueConverter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBinding.all.put_Converter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ConverterParameter
   (
      this : in out Binding
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IBinding.all.get_ConverterParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ConverterParameter
   (
      this : in out Binding;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBinding.all.put_ConverterParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ConverterLanguage
   (
      this : in out Binding
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IBinding.all.get_ConverterLanguage (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ConverterLanguage
   (
      this : in out Binding;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IBinding.all.put_ConverterLanguage (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_FallbackValue
   (
      this : in out Binding
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.IBinding2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Data.IBinding_Interface, WinUI3.Windows.UI.Xaml.Data.IBinding2, WinUI3.Windows.UI.Xaml.Data.IID_IBinding2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBinding.all);
      Hr := m_Interface.get_FallbackValue (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FallbackValue
   (
      this : in out Binding;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.IBinding2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Data.IBinding_Interface, WinUI3.Windows.UI.Xaml.Data.IBinding2, WinUI3.Windows.UI.Xaml.Data.IID_IBinding2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBinding.all);
      Hr := m_Interface.put_FallbackValue (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TargetNullValue
   (
      this : in out Binding
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.IBinding2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Data.IBinding_Interface, WinUI3.Windows.UI.Xaml.Data.IBinding2, WinUI3.Windows.UI.Xaml.Data.IID_IBinding2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBinding.all);
      Hr := m_Interface.get_TargetNullValue (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TargetNullValue
   (
      this : in out Binding;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.IBinding2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Data.IBinding_Interface, WinUI3.Windows.UI.Xaml.Data.IBinding2, WinUI3.Windows.UI.Xaml.Data.IID_IBinding2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBinding.all);
      Hr := m_Interface.put_TargetNullValue (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_UpdateSourceTrigger
   (
      this : in out Binding
   )
   return WinUI3.Windows.UI.Xaml.Data.UpdateSourceTrigger is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.IBinding2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Data.UpdateSourceTrigger;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Data.IBinding_Interface, WinUI3.Windows.UI.Xaml.Data.IBinding2, WinUI3.Windows.UI.Xaml.Data.IID_IBinding2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBinding.all);
      Hr := m_Interface.get_UpdateSourceTrigger (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_UpdateSourceTrigger
   (
      this : in out Binding;
      value : WinUI3.Windows.UI.Xaml.Data.UpdateSourceTrigger
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.IBinding2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Data.IBinding_Interface, WinUI3.Windows.UI.Xaml.Data.IBinding2, WinUI3.Windows.UI.Xaml.Data.IID_IBinding2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBinding.all);
      Hr := m_Interface.put_UpdateSourceTrigger (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BindingExpressionBase

   procedure Initialize (this : in out BindingExpressionBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out BindingExpressionBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBindingExpressionBase, IBindingExpressionBase_Ptr);
   begin
      if this.m_IBindingExpressionBase /= null then
         if this.m_IBindingExpressionBase.all /= null then
            temp := this.m_IBindingExpressionBase.all.Release;
            Free (this.m_IBindingExpressionBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BindingExpressionBase

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BindingExpressionBase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BindingExpression

   procedure Initialize (this : in out BindingExpression) is
   begin
      null;
   end;

   procedure Finalize (this : in out BindingExpression) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBindingExpression, IBindingExpression_Ptr);
   begin
      if this.m_IBindingExpression /= null then
         if this.m_IBindingExpression.all /= null then
            temp := this.m_IBindingExpression.all.Release;
            Free (this.m_IBindingExpression);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BindingExpression

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BindingExpression

   function get_DataItem
   (
      this : in out BindingExpression
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IBindingExpression.all.get_DataItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ParentBinding
   (
      this : in out BindingExpression
   )
   return WinUI3.Windows.UI.Xaml.Data.Binding'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Data.IBinding;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Data.Binding do
         Hr := this.m_IBindingExpression.all.get_ParentBinding (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBinding := new WinUI3.Windows.UI.Xaml.Data.IBinding;
         Retval.m_IBinding.all := m_ComRetVal;
      end return;
   end;

   procedure UpdateSource
   (
      this : in out BindingExpression
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBindingExpression.all.UpdateSource;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BindingOperations

   procedure Initialize (this : in out BindingOperations) is
   begin
      null;
   end;

   procedure Finalize (this : in out BindingOperations) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBindingOperations, IBindingOperations_Ptr);
   begin
      if this.m_IBindingOperations /= null then
         if this.m_IBindingOperations.all /= null then
            temp := this.m_IBindingOperations.all.Release;
            Free (this.m_IBindingOperations);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BindingOperations

   procedure SetBinding
   (
      target : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      dp : WinUI3.Windows.UI.Xaml.DependencyProperty'Class;
      binding_p : WinUI3.Windows.UI.Xaml.Data.BindingBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.BindingOperations");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Data.IBindingOperationsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IBindingOperationsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetBinding (target.m_IDependencyObject.all, dp.m_IDependencyProperty.all, binding_p.m_IBindingBase.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BindingOperations

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CollectionViewSource

   procedure Initialize (this : in out CollectionViewSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out CollectionViewSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICollectionViewSource, ICollectionViewSource_Ptr);
   begin
      if this.m_ICollectionViewSource /= null then
         if this.m_ICollectionViewSource.all /= null then
            temp := this.m_ICollectionViewSource.all.Release;
            Free (this.m_ICollectionViewSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CollectionViewSource

   function Constructor return CollectionViewSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.ICollectionViewSource");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Data.ICollectionViewSource;
   begin
      return RetVal : CollectionViewSource do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICollectionViewSource := new WinUI3.Windows.UI.Xaml.Data.ICollectionViewSource;
            Retval.m_ICollectionViewSource.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CollectionViewSource

   function get_SourceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.CollectionViewSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Data.ICollectionViewSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICollectionViewSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ViewProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.CollectionViewSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Data.ICollectionViewSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICollectionViewSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSourceGroupedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.CollectionViewSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Data.ICollectionViewSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICollectionViewSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSourceGroupedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsPathProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.CollectionViewSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Data.ICollectionViewSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICollectionViewSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsPathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CollectionViewSource

   function get_Source
   (
      this : in out CollectionViewSource
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ICollectionViewSource.all.get_Source (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Source
   (
      this : in out CollectionViewSource;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICollectionViewSource.all.put_Source (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_View
   (
      this : in out CollectionViewSource
   )
   return WinUI3.Windows.UI.Xaml.Data.ICollectionView is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Data.ICollectionView;
   begin
      Hr := this.m_ICollectionViewSource.all.get_View (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsSourceGrouped
   (
      this : in out CollectionViewSource
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICollectionViewSource.all.get_IsSourceGrouped (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSourceGrouped
   (
      this : in out CollectionViewSource;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICollectionViewSource.all.put_IsSourceGrouped (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsPath
   (
      this : in out CollectionViewSource
   )
   return WinUI3.Windows.UI.Xaml.PropertyPath'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IPropertyPath;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.PropertyPath do
         Hr := this.m_ICollectionViewSource.all.get_ItemsPath (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPropertyPath := new WinUI3.Windows.UI.Xaml.IPropertyPath;
         Retval.m_IPropertyPath.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemsPath
   (
      this : in out CollectionViewSource;
      value : WinUI3.Windows.UI.Xaml.PropertyPath'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICollectionViewSource.all.put_ItemsPath (value.m_IPropertyPath.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CurrentChangingEventArgs

   procedure Initialize (this : in out CurrentChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CurrentChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICurrentChangingEventArgs, ICurrentChangingEventArgs_Ptr);
   begin
      if this.m_ICurrentChangingEventArgs /= null then
         if this.m_ICurrentChangingEventArgs.all /= null then
            temp := this.m_ICurrentChangingEventArgs.all.Release;
            Free (this.m_ICurrentChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CurrentChangingEventArgs

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CurrentChangingEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.ICurrentChangingEventArgs");
      m_Factory    : access ICurrentChangingEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Data.ICurrentChangingEventArgs;
   begin
      return RetVal : CurrentChangingEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_ICurrentChangingEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICurrentChangingEventArgs := new WinUI3.Windows.UI.Xaml.Data.ICurrentChangingEventArgs;
            Retval.m_ICurrentChangingEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      isCancelable : WinUI3.Boolean;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CurrentChangingEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.ICurrentChangingEventArgs");
      m_Factory    : access ICurrentChangingEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Data.ICurrentChangingEventArgs;
   begin
      return RetVal : CurrentChangingEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_ICurrentChangingEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithCancelableParameter (isCancelable, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICurrentChangingEventArgs := new WinUI3.Windows.UI.Xaml.Data.ICurrentChangingEventArgs;
            Retval.m_ICurrentChangingEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CurrentChangingEventArgs

   function get_Cancel
   (
      this : in out CurrentChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICurrentChangingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out CurrentChangingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICurrentChangingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsCancelable
   (
      this : in out CurrentChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICurrentChangingEventArgs.all.get_IsCancelable (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate CurrentChangingEventHandler

   function Invoke
   (
      this : access CurrentChangingEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Data.ICurrentChangingEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemIndexRange

   procedure Initialize (this : in out ItemIndexRange) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemIndexRange) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemIndexRange, IItemIndexRange_Ptr);
   begin
      if this.m_IItemIndexRange /= null then
         if this.m_IItemIndexRange.all /= null then
            temp := this.m_IItemIndexRange.all.Release;
            Free (this.m_IItemIndexRange);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemIndexRange

   function Constructor
   (
      firstIndex : WinUI3.Int32;
      length : WinUI3.UInt32;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ItemIndexRange is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.IItemIndexRange");
      m_Factory    : access IItemIndexRangeFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Data.IItemIndexRange;
   begin
      return RetVal : ItemIndexRange do
         Hr := RoGetActivationFactory (m_hString, IID_IItemIndexRangeFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (firstIndex, length, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IItemIndexRange := new WinUI3.Windows.UI.Xaml.Data.IItemIndexRange;
            Retval.m_IItemIndexRange.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemIndexRange

   function get_FirstIndex
   (
      this : in out ItemIndexRange
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemIndexRange.all.get_FirstIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Length
   (
      this : in out ItemIndexRange
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IItemIndexRange.all.get_Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LastIndex
   (
      this : in out ItemIndexRange
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemIndexRange.all.get_LastIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PropertyChangedEventArgs

   procedure Initialize (this : in out PropertyChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PropertyChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPropertyChangedEventArgs, IPropertyChangedEventArgs_Ptr);
   begin
      if this.m_IPropertyChangedEventArgs /= null then
         if this.m_IPropertyChangedEventArgs.all /= null then
            temp := this.m_IPropertyChangedEventArgs.all.Release;
            Free (this.m_IPropertyChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PropertyChangedEventArgs

   function Constructor
   (
      name : WinUI3.WString;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PropertyChangedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.IPropertyChangedEventArgs");
      m_Factory    : access IPropertyChangedEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Data.IPropertyChangedEventArgs;
      HStr_name : constant WinUI3.HString := To_HString (name);
   begin
      return RetVal : PropertyChangedEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IPropertyChangedEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (HStr_name, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPropertyChangedEventArgs := new WinUI3.Windows.UI.Xaml.Data.IPropertyChangedEventArgs;
            Retval.m_IPropertyChangedEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_name);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PropertyChangedEventArgs

   function get_PropertyName
   (
      this : in out PropertyChangedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPropertyChangedEventArgs.all.get_PropertyName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate PropertyChangedEventHandler

   function Invoke
   (
      this : access PropertyChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Data.IPropertyChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RelativeSource

   procedure Initialize (this : in out RelativeSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out RelativeSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRelativeSource, IRelativeSource_Ptr);
   begin
      if this.m_IRelativeSource /= null then
         if this.m_IRelativeSource.all /= null then
            temp := this.m_IRelativeSource.all.Release;
            Free (this.m_IRelativeSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RelativeSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RelativeSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Data.IRelativeSource");
      m_Factory    : access IRelativeSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Data.IRelativeSource;
   begin
      return RetVal : RelativeSource do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativeSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRelativeSource := new WinUI3.Windows.UI.Xaml.Data.IRelativeSource;
            Retval.m_IRelativeSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RelativeSource

   function get_Mode
   (
      this : in out RelativeSource
   )
   return WinUI3.Windows.UI.Xaml.Data.RelativeSourceMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Data.RelativeSourceMode;
   begin
      Hr := this.m_IRelativeSource.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Mode
   (
      this : in out RelativeSource;
      value : WinUI3.Windows.UI.Xaml.Data.RelativeSourceMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRelativeSource.all.put_Mode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

end WinUI3.Windows.UI.Xaml.Data;
