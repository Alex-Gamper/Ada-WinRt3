--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with WinUI3.Windows.Graphics;
with WinUI3.Windows.Graphics.DirectX;
with WinUI3.Windows.Graphics.DirectX.Direct3D11;
with WinUI3.Windows.Storage.Streams;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Windows.Devices.Display.Core is

   package IAsyncOperation_DisplayMuxDevice is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.Windows.Devices.Display.Core.IDisplayMuxDevice);
   package AsyncOperationCompletedHandler_DisplayMuxDevice is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.Windows.Devices.Display.Core.IDisplayMuxDevice);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayAdapter

   procedure Initialize (this : in out DisplayAdapter) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayAdapter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayAdapter, IDisplayAdapter_Ptr);
   begin
      if this.m_IDisplayAdapter /= null then
         if this.m_IDisplayAdapter.all /= null then
            temp := this.m_IDisplayAdapter.all.Release;
            Free (this.m_IDisplayAdapter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DisplayAdapter

   function FromId
   (
      id : WinUI3.Windows.Graphics.DisplayAdapterId
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayAdapter is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.Devices.Display.Core.DisplayAdapter");
      m_Factory        : access WinUI3.Windows.Devices.Display.Core.IDisplayAdapterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayAdapter;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayAdapter do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayAdapterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromId (id, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayAdapter := new WinUI3.Windows.Devices.Display.Core.IDisplayAdapter;
            Retval.m_IDisplayAdapter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayAdapter

   function get_Id
   (
      this : in out DisplayAdapter
   )
   return WinUI3.Windows.Graphics.DisplayAdapterId is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.DisplayAdapterId;
   begin
      Hr := this.m_IDisplayAdapter.all.get_Id (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DeviceInterfacePath
   (
      this : in out DisplayAdapter
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDisplayAdapter.all.get_DeviceInterfacePath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_SourceCount
   (
      this : in out DisplayAdapter
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IDisplayAdapter.all.get_SourceCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PciVendorId
   (
      this : in out DisplayAdapter
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IDisplayAdapter.all.get_PciVendorId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PciDeviceId
   (
      this : in out DisplayAdapter
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IDisplayAdapter.all.get_PciDeviceId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PciSubSystemId
   (
      this : in out DisplayAdapter
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IDisplayAdapter.all.get_PciSubSystemId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PciRevision
   (
      this : in out DisplayAdapter
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IDisplayAdapter.all.get_PciRevision (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Properties
   (
      this : in out DisplayAdapter
   )
   return IMapView_Guid_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IMapView_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayAdapter.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_IsIndirectDisplayDevice
   (
      this : in out DisplayAdapter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplayAdapter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayAdapter_Interface, WinUI3.Windows.Devices.Display.Core.IDisplayAdapter2, WinUI3.Windows.Devices.Display.Core.IID_IDisplayAdapter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplayAdapter.all);
      Hr := m_Interface.get_IsIndirectDisplayDevice (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PreferredRenderAdapter
   (
      this : in out DisplayAdapter
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayAdapter'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplayAdapter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayAdapter;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayAdapter_Interface, WinUI3.Windows.Devices.Display.Core.IDisplayAdapter2, WinUI3.Windows.Devices.Display.Core.IID_IDisplayAdapter2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayAdapter do
         m_Interface := QInterface (this.m_IDisplayAdapter.all);
         Hr := m_Interface.get_PreferredRenderAdapter (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayAdapter := new WinUI3.Windows.Devices.Display.Core.IDisplayAdapter;
         Retval.m_IDisplayAdapter.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayDevice

   procedure Initialize (this : in out DisplayDevice) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayDevice) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayDevice, IDisplayDevice_Ptr);
   begin
      if this.m_IDisplayDevice /= null then
         if this.m_IDisplayDevice.all /= null then
            temp := this.m_IDisplayDevice.all.Release;
            Free (this.m_IDisplayDevice);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayDevice

   function CreateScanoutSource
   (
      this : in out DisplayDevice;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinUI3.Windows.Devices.Display.Core.DisplaySource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplaySource;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplaySource do
         Hr := this.m_IDisplayDevice.all.CreateScanoutSource (target.m_IDisplayTarget.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplaySource := new WinUI3.Windows.Devices.Display.Core.IDisplaySource;
         Retval.m_IDisplaySource.all := m_ComRetVal;
      end return;
   end;

   function CreatePrimary
   (
      this : in out DisplayDevice;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class;
      desc : WinUI3.Windows.Devices.Display.Core.DisplayPrimaryDescription'Class
   )
   return WinUI3.Windows.Devices.Display.Core.DisplaySurface'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplaySurface;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplaySurface do
         Hr := this.m_IDisplayDevice.all.CreatePrimary (target.m_IDisplayTarget.all, desc.m_IDisplayPrimaryDescription.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplaySurface := new WinUI3.Windows.Devices.Display.Core.IDisplaySurface;
         Retval.m_IDisplaySurface.all := m_ComRetVal;
      end return;
   end;

   function CreateTaskPool
   (
      this : in out DisplayDevice
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayTaskPool'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayTaskPool;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayTaskPool do
         Hr := this.m_IDisplayDevice.all.CreateTaskPool (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayTaskPool := new WinUI3.Windows.Devices.Display.Core.IDisplayTaskPool;
         Retval.m_IDisplayTaskPool.all := m_ComRetVal;
      end return;
   end;

   function CreatePeriodicFence
   (
      this : in out DisplayDevice;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class;
      offsetFromVBlank : WinUI3.Windows.Foundation.TimeSpan
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayFence'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayFence;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayFence do
         Hr := this.m_IDisplayDevice.all.CreatePeriodicFence (target.m_IDisplayTarget.all, offsetFromVBlank, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayFence := new WinUI3.Windows.Devices.Display.Core.IDisplayFence;
         Retval.m_IDisplayFence.all := m_ComRetVal;
      end return;
   end;

   procedure WaitForVBlank
   (
      this : in out DisplayDevice;
      source : WinUI3.Windows.Devices.Display.Core.DisplaySource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayDevice.all.WaitForVBlank (source.m_IDisplaySource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CreateSimpleScanout
   (
      this : in out DisplayDevice;
      pSource : WinUI3.Windows.Devices.Display.Core.DisplaySource'Class;
      pSurface : WinUI3.Windows.Devices.Display.Core.DisplaySurface'Class;
      SubResourceIndex : WinUI3.UInt32;
      SyncInterval : WinUI3.UInt32
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayScanout'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayScanout;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayScanout do
         Hr := this.m_IDisplayDevice.all.CreateSimpleScanout (pSource.m_IDisplaySource.all, pSurface.m_IDisplaySurface.all, SubResourceIndex, SyncInterval, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayScanout := new WinUI3.Windows.Devices.Display.Core.IDisplayScanout;
         Retval.m_IDisplayScanout.all := m_ComRetVal;
      end return;
   end;

   function IsCapabilitySupported
   (
      this : in out DisplayDevice;
      capability : WinUI3.Windows.Devices.Display.Core.DisplayDeviceCapability
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayDevice.all.IsCapabilitySupported (capability, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function CreateSimpleScanoutWithDirtyRectsAndOptions
   (
      this : in out DisplayDevice;
      source : WinUI3.Windows.Devices.Display.Core.DisplaySource'Class;
      surface : WinUI3.Windows.Devices.Display.Core.DisplaySurface'Class;
      subresourceIndex : WinUI3.UInt32;
      syncInterval : WinUI3.UInt32;
      dirtyRects : GenericObject;
      options : WinUI3.Windows.Devices.Display.Core.DisplayScanoutOptions
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayScanout'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplayDevice2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayScanout;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayDevice_Interface, WinUI3.Windows.Devices.Display.Core.IDisplayDevice2, WinUI3.Windows.Devices.Display.Core.IID_IDisplayDevice2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayScanout do
         m_Interface := QInterface (this.m_IDisplayDevice.all);
         Hr := m_Interface.CreateSimpleScanoutWithDirtyRectsAndOptions (source.m_IDisplaySource.all, surface.m_IDisplaySurface.all, subresourceIndex, syncInterval, dirtyRects, options, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayScanout := new WinUI3.Windows.Devices.Display.Core.IDisplayScanout;
         Retval.m_IDisplayScanout.all := m_ComRetVal;
      end return;
   end;

   function get_RenderAdapterId
   (
      this : in out DisplayDevice
   )
   return WinUI3.Windows.Graphics.DisplayAdapterId is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplayDeviceRenderAdapter := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.DisplayAdapterId;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayDevice_Interface, WinUI3.Windows.Devices.Display.Core.IDisplayDeviceRenderAdapter, WinUI3.Windows.Devices.Display.Core.IID_IDisplayDeviceRenderAdapter'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplayDevice.all);
      Hr := m_Interface.get_RenderAdapterId (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayFence

   procedure Initialize (this : in out DisplayFence) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayFence) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayFence, IDisplayFence_Ptr);
   begin
      if this.m_IDisplayFence /= null then
         if this.m_IDisplayFence.all /= null then
            temp := this.m_IDisplayFence.all.Release;
            Free (this.m_IDisplayFence);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayFence

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManager

   procedure Initialize (this : in out DisplayManager) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManager) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManager, IDisplayManager_Ptr);
   begin
      if this.m_IDisplayManager /= null then
         if this.m_IDisplayManager.all /= null then
            temp := this.m_IDisplayManager.all.Release;
            Free (this.m_IDisplayManager);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DisplayManager

   function Create
   (
      options : WinUI3.Windows.Devices.Display.Core.DisplayManagerOptions
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayManager is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.Devices.Display.Core.DisplayManager");
      m_Factory        : access WinUI3.Windows.Devices.Display.Core.IDisplayManagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayManager;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayManager do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (options, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayManager := new WinUI3.Windows.Devices.Display.Core.IDisplayManager;
            Retval.m_IDisplayManager.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManager

   function GetCurrentTargets
   (
      this : in out DisplayManager
   )
   return IVectorView_IDisplayTarget.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayTarget.Kind;
   begin
      Hr := this.m_IDisplayManager.all.GetCurrentTargets (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayTarget (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetCurrentAdapters
   (
      this : in out DisplayManager
   )
   return IVectorView_IDisplayAdapter.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayAdapter.Kind;
   begin
      Hr := this.m_IDisplayManager.all.GetCurrentAdapters (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayAdapter (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function TryAcquireTarget
   (
      this : in out DisplayManager;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayManagerResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayManagerResult;
   begin
      Hr := this.m_IDisplayManager.all.TryAcquireTarget (target.m_IDisplayTarget.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReleaseTarget
   (
      this : in out DisplayManager;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.ReleaseTarget (target.m_IDisplayTarget.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryReadCurrentStateForAllTargets
   (
      this : in out DisplayManager
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayManagerResultWithState'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayManagerResultWithState;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayManagerResultWithState do
         Hr := this.m_IDisplayManager.all.TryReadCurrentStateForAllTargets (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayManagerResultWithState := new WinUI3.Windows.Devices.Display.Core.IDisplayManagerResultWithState;
         Retval.m_IDisplayManagerResultWithState.all := m_ComRetVal;
      end return;
   end;

   function TryAcquireTargetsAndReadCurrentState
   (
      this : in out DisplayManager;
      targets : GenericObject
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayManagerResultWithState'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayManagerResultWithState;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayManagerResultWithState do
         Hr := this.m_IDisplayManager.all.TryAcquireTargetsAndReadCurrentState (targets, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayManagerResultWithState := new WinUI3.Windows.Devices.Display.Core.IDisplayManagerResultWithState;
         Retval.m_IDisplayManagerResultWithState.all := m_ComRetVal;
      end return;
   end;

   function TryAcquireTargetsAndCreateEmptyState
   (
      this : in out DisplayManager;
      targets : GenericObject
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayManagerResultWithState'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayManagerResultWithState;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayManagerResultWithState do
         Hr := this.m_IDisplayManager.all.TryAcquireTargetsAndCreateEmptyState (targets, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayManagerResultWithState := new WinUI3.Windows.Devices.Display.Core.IDisplayManagerResultWithState;
         Retval.m_IDisplayManagerResultWithState.all := m_ComRetVal;
      end return;
   end;

   function TryAcquireTargetsAndCreateSubstate
   (
      this : in out DisplayManager;
      existingState : WinUI3.Windows.Devices.Display.Core.DisplayState'Class;
      targets : GenericObject
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayManagerResultWithState'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayManagerResultWithState;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayManagerResultWithState do
         Hr := this.m_IDisplayManager.all.TryAcquireTargetsAndCreateSubstate (existingState.m_IDisplayState.all, targets, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayManagerResultWithState := new WinUI3.Windows.Devices.Display.Core.IDisplayManagerResultWithState;
         Retval.m_IDisplayManagerResultWithState.all := m_ComRetVal;
      end return;
   end;

   function CreateDisplayDevice
   (
      this : in out DisplayManager;
      adapter : WinUI3.Windows.Devices.Display.Core.DisplayAdapter'Class
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayDevice'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayDevice;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayDevice do
         Hr := this.m_IDisplayManager.all.CreateDisplayDevice (adapter.m_IDisplayAdapter.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayDevice := new WinUI3.Windows.Devices.Display.Core.IDisplayDevice;
         Retval.m_IDisplayDevice.all := m_ComRetVal;
      end return;
   end;

   function add_Enabled
   (
      this : in out DisplayManager;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayManager.all.add_Enabled (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Enabled
   (
      this : in out DisplayManager;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.remove_Enabled (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Disabled
   (
      this : in out DisplayManager;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayManager.all.add_Disabled (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Disabled
   (
      this : in out DisplayManager;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.remove_Disabled (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Changed
   (
      this : in out DisplayManager;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayManager.all.add_Changed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Changed
   (
      this : in out DisplayManager;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.remove_Changed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PathsFailedOrInvalidated
   (
      this : in out DisplayManager;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayManager.all.add_PathsFailedOrInvalidated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PathsFailedOrInvalidated
   (
      this : in out DisplayManager;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.remove_PathsFailedOrInvalidated (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Start
   (
      this : in out DisplayManager
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.Start;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out DisplayManager
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryReadCurrentStateForModeQuery
   (
      this : in out DisplayManager
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayManagerResultWithState'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplayManager2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayManagerResultWithState;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayManager_Interface, WinUI3.Windows.Devices.Display.Core.IDisplayManager2, WinUI3.Windows.Devices.Display.Core.IID_IDisplayManager2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayManagerResultWithState do
         m_Interface := QInterface (this.m_IDisplayManager.all);
         Hr := m_Interface.TryReadCurrentStateForModeQuery (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayManagerResultWithState := new WinUI3.Windows.Devices.Display.Core.IDisplayManagerResultWithState;
         Retval.m_IDisplayManagerResultWithState.all := m_ComRetVal;
      end return;
   end;

   function CreateDisplayDeviceForIndirectAdapter
   (
      this : in out DisplayManager;
      indirectAdapter : WinUI3.Windows.Devices.Display.Core.DisplayAdapter'Class;
      renderAdapter : WinUI3.Windows.Devices.Display.Core.DisplayAdapter'Class
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayDevice'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplayManager3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayDevice;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayManager_Interface, WinUI3.Windows.Devices.Display.Core.IDisplayManager3, WinUI3.Windows.Devices.Display.Core.IID_IDisplayManager3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayDevice do
         m_Interface := QInterface (this.m_IDisplayManager.all);
         Hr := m_Interface.CreateDisplayDeviceForIndirectAdapter (indirectAdapter.m_IDisplayAdapter.all, renderAdapter.m_IDisplayAdapter.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayDevice := new WinUI3.Windows.Devices.Display.Core.IDisplayDevice;
         Retval.m_IDisplayDevice.all := m_ComRetVal;
      end return;
   end;

   procedure Close
   (
      this : in out DisplayManager
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Foundation.IClosable := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayManager_Interface, WinUI3.Windows.Foundation.IClosable, WinUI3.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplayManager.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManagerChangedEventArgs

   procedure Initialize (this : in out DisplayManagerChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManagerChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManagerChangedEventArgs, IDisplayManagerChangedEventArgs_Ptr);
   begin
      if this.m_IDisplayManagerChangedEventArgs /= null then
         if this.m_IDisplayManagerChangedEventArgs.all /= null then
            temp := this.m_IDisplayManagerChangedEventArgs.all.Release;
            Free (this.m_IDisplayManagerChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManagerChangedEventArgs

   function get_Handled
   (
      this : in out DisplayManagerChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayManagerChangedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out DisplayManagerChangedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManagerChangedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out DisplayManagerChangedEventArgs
   )
   return WinUI3.Windows.Foundation.Deferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IDeferral;
   begin
      return RetVal : WinUI3.Windows.Foundation.Deferral do
         Hr := this.m_IDisplayManagerChangedEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new WinUI3.Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManagerDisabledEventArgs

   procedure Initialize (this : in out DisplayManagerDisabledEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManagerDisabledEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManagerDisabledEventArgs, IDisplayManagerDisabledEventArgs_Ptr);
   begin
      if this.m_IDisplayManagerDisabledEventArgs /= null then
         if this.m_IDisplayManagerDisabledEventArgs.all /= null then
            temp := this.m_IDisplayManagerDisabledEventArgs.all.Release;
            Free (this.m_IDisplayManagerDisabledEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManagerDisabledEventArgs

   function get_Handled
   (
      this : in out DisplayManagerDisabledEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayManagerDisabledEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out DisplayManagerDisabledEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManagerDisabledEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out DisplayManagerDisabledEventArgs
   )
   return WinUI3.Windows.Foundation.Deferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IDeferral;
   begin
      return RetVal : WinUI3.Windows.Foundation.Deferral do
         Hr := this.m_IDisplayManagerDisabledEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new WinUI3.Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManagerEnabledEventArgs

   procedure Initialize (this : in out DisplayManagerEnabledEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManagerEnabledEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManagerEnabledEventArgs, IDisplayManagerEnabledEventArgs_Ptr);
   begin
      if this.m_IDisplayManagerEnabledEventArgs /= null then
         if this.m_IDisplayManagerEnabledEventArgs.all /= null then
            temp := this.m_IDisplayManagerEnabledEventArgs.all.Release;
            Free (this.m_IDisplayManagerEnabledEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManagerEnabledEventArgs

   function get_Handled
   (
      this : in out DisplayManagerEnabledEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayManagerEnabledEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out DisplayManagerEnabledEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManagerEnabledEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out DisplayManagerEnabledEventArgs
   )
   return WinUI3.Windows.Foundation.Deferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IDeferral;
   begin
      return RetVal : WinUI3.Windows.Foundation.Deferral do
         Hr := this.m_IDisplayManagerEnabledEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new WinUI3.Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManagerPathsFailedOrInvalidatedEventArgs

   procedure Initialize (this : in out DisplayManagerPathsFailedOrInvalidatedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManagerPathsFailedOrInvalidatedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManagerPathsFailedOrInvalidatedEventArgs, IDisplayManagerPathsFailedOrInvalidatedEventArgs_Ptr);
   begin
      if this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs /= null then
         if this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs.all /= null then
            temp := this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs.all.Release;
            Free (this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManagerPathsFailedOrInvalidatedEventArgs

   function get_Handled
   (
      this : in out DisplayManagerPathsFailedOrInvalidatedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out DisplayManagerPathsFailedOrInvalidatedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out DisplayManagerPathsFailedOrInvalidatedEventArgs
   )
   return WinUI3.Windows.Foundation.Deferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IDeferral;
   begin
      return RetVal : WinUI3.Windows.Foundation.Deferral do
         Hr := this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new WinUI3.Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManagerResultWithState

   procedure Initialize (this : in out DisplayManagerResultWithState) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManagerResultWithState) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManagerResultWithState, IDisplayManagerResultWithState_Ptr);
   begin
      if this.m_IDisplayManagerResultWithState /= null then
         if this.m_IDisplayManagerResultWithState.all /= null then
            temp := this.m_IDisplayManagerResultWithState.all.Release;
            Free (this.m_IDisplayManagerResultWithState);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManagerResultWithState

   function get_ErrorCode
   (
      this : in out DisplayManagerResultWithState
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayManagerResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayManagerResult;
   begin
      Hr := this.m_IDisplayManagerResultWithState.all.get_ErrorCode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtendedErrorCode
   (
      this : in out DisplayManagerResultWithState
   )
   return WinUI3.Windows.Foundation.HResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.HResult;
   begin
      Hr := this.m_IDisplayManagerResultWithState.all.get_ExtendedErrorCode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_State
   (
      this : in out DisplayManagerResultWithState
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayState'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayState;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayState do
         Hr := this.m_IDisplayManagerResultWithState.all.get_State (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayState := new WinUI3.Windows.Devices.Display.Core.IDisplayState;
         Retval.m_IDisplayState.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayModeInfo

   procedure Initialize (this : in out DisplayModeInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayModeInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayModeInfo, IDisplayModeInfo_Ptr);
   begin
      if this.m_IDisplayModeInfo /= null then
         if this.m_IDisplayModeInfo.all /= null then
            temp := this.m_IDisplayModeInfo.all.Release;
            Free (this.m_IDisplayModeInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayModeInfo

   function get_SourceResolution
   (
      this : in out DisplayModeInfo
   )
   return WinUI3.Windows.Graphics.SizeInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.SizeInt32;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_SourceResolution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsStereo
   (
      this : in out DisplayModeInfo
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_IsStereo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SourcePixelFormat
   (
      this : in out DisplayModeInfo
   )
   return WinUI3.Windows.Graphics.DirectX.DirectXPixelFormat is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.DirectX.DirectXPixelFormat;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_SourcePixelFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_TargetResolution
   (
      this : in out DisplayModeInfo
   )
   return WinUI3.Windows.Graphics.SizeInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.SizeInt32;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_TargetResolution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PresentationRate
   (
      this : in out DisplayModeInfo
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayPresentationRate is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayPresentationRate;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_PresentationRate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInterlaced
   (
      this : in out DisplayModeInfo
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_IsInterlaced (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetWireFormatSupportedBitsPerChannel
   (
      this : in out DisplayModeInfo;
      encoding : WinUI3.Windows.Devices.Display.Core.DisplayWireFormatPixelEncoding
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayBitsPerChannel is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayBitsPerChannel;
   begin
      Hr := this.m_IDisplayModeInfo.all.GetWireFormatSupportedBitsPerChannel (encoding, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IsWireFormatSupported
   (
      this : in out DisplayModeInfo;
      wireFormat : WinUI3.Windows.Devices.Display.Core.DisplayWireFormat'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayModeInfo.all.IsWireFormatSupported (wireFormat.m_IDisplayWireFormat.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Properties
   (
      this : in out DisplayModeInfo
   )
   return IMapView_Guid_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IMapView_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_PhysicalPresentationRate
   (
      this : in out DisplayModeInfo
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayPresentationRate is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplayModeInfo2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayPresentationRate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayModeInfo_Interface, WinUI3.Windows.Devices.Display.Core.IDisplayModeInfo2, WinUI3.Windows.Devices.Display.Core.IID_IDisplayModeInfo2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplayModeInfo.all);
      Hr := m_Interface.get_PhysicalPresentationRate (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayMuxDevice

   procedure Initialize (this : in out DisplayMuxDevice) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayMuxDevice) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayMuxDevice, IDisplayMuxDevice_Ptr);
   begin
      if this.m_IDisplayMuxDevice /= null then
         if this.m_IDisplayMuxDevice.all /= null then
            temp := this.m_IDisplayMuxDevice.all.Release;
            Free (this.m_IDisplayMuxDevice);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DisplayMuxDevice

   function GetDeviceSelector
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.Devices.Display.Core.DisplayMuxDevice");
      m_Factory        : access WinUI3.Windows.Devices.Display.Core.IDisplayMuxDeviceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDisplayMuxDeviceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function FromIdAsync
   (
      deviceInterfaceId : WinUI3.WString
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayMuxDevice is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.Devices.Display.Core.DisplayMuxDevice");
      m_Factory        : access WinUI3.Windows.Devices.Display.Core.IDisplayMuxDeviceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_deviceInterfaceId : constant WinUI3.HString := To_HString (deviceInterfaceId);
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_DisplayMuxDevice.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_DisplayMuxDevice.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Windows.Devices.Display.Core.IDisplayMuxDevice;
      m_IID            : aliased WinUI3.IID := (107756377, 2459, 24375, (137, 235, 29, 84, 253, 147, 233, 179 )); -- Windows.Devices.Display.Core.DisplayMuxDevice;
      m_HandlerIID     : aliased WinUI3.IID := (1640477701, 57825, 21433, (164, 64, 75, 174, 1, 99, 109, 35 ));
      m_Handler        : AsyncOperationCompletedHandler_DisplayMuxDevice.Kind := new AsyncOperationCompletedHandler_DisplayMuxDevice.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_DisplayMuxDevice.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_DisplayMuxDevice.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_DisplayMuxDevice.Kind_Delegate, AsyncOperationCompletedHandler_DisplayMuxDevice.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayMuxDevice do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayMuxDeviceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceInterfaceId, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               temp := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IDisplayMuxDevice := new WinUI3.Windows.Devices.Display.Core.IDisplayMuxDevice;
                     Retval.m_IDisplayMuxDevice.all := m_RetVal;
                  end if;
                  temp := m_AsyncOperation.Release;
                  temp := m_Handler.Release;
                  if temp = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_deviceInterfaceId);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayMuxDevice

   function get_Id
   (
      this : in out DisplayMuxDevice
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDisplayMuxDevice.all.get_Id (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_IsActive
   (
      this : in out DisplayMuxDevice
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayMuxDevice.all.get_IsActive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetAvailableMuxTargets
   (
      this : in out DisplayMuxDevice
   )
   return IVectorView_IDisplayTarget.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayTarget.Kind;
   begin
      Hr := this.m_IDisplayMuxDevice.all.GetAvailableMuxTargets (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayTarget (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_CurrentTarget
   (
      this : in out DisplayMuxDevice
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayTarget;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayTarget do
         Hr := this.m_IDisplayMuxDevice.all.get_CurrentTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayTarget := new WinUI3.Windows.Devices.Display.Core.IDisplayTarget;
         Retval.m_IDisplayTarget.all := m_ComRetVal;
      end return;
   end;

   function get_PreferredTarget
   (
      this : in out DisplayMuxDevice
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayTarget;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayTarget do
         Hr := this.m_IDisplayMuxDevice.all.get_PreferredTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayTarget := new WinUI3.Windows.Devices.Display.Core.IDisplayTarget;
         Retval.m_IDisplayTarget.all := m_ComRetVal;
      end return;
   end;

   function get_IsAutomaticTargetSwitchingEnabled
   (
      this : in out DisplayMuxDevice
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayMuxDevice.all.get_IsAutomaticTargetSwitchingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetPreferredTarget
   (
      this : in out DisplayMuxDevice;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IDisplayMuxDevice.all.SetPreferredTarget (target.m_IDisplayTarget.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   procedure SetAutomaticTargetSwitching
   (
      this : in out DisplayMuxDevice
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IDisplayMuxDevice.all.SetAutomaticTargetSwitching (m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   function add_Changed
   (
      this : in out DisplayMuxDevice;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayMuxDevice.all.add_Changed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Changed
   (
      this : in out DisplayMuxDevice;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayMuxDevice.all.remove_Changed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Close
   (
      this : in out DisplayMuxDevice
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Foundation.IClosable := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayMuxDevice_Interface, WinUI3.Windows.Foundation.IClosable, WinUI3.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplayMuxDevice.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayPath

   procedure Initialize (this : in out DisplayPath) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayPath) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayPath, IDisplayPath_Ptr);
   begin
      if this.m_IDisplayPath /= null then
         if this.m_IDisplayPath.all /= null then
            temp := this.m_IDisplayPath.all.Release;
            Free (this.m_IDisplayPath);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayPath

   function get_View
   (
      this : in out DisplayPath
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayView'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayView;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayView do
         Hr := this.m_IDisplayPath.all.get_View (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayView := new WinUI3.Windows.Devices.Display.Core.IDisplayView;
         Retval.m_IDisplayView.all := m_ComRetVal;
      end return;
   end;

   function get_Target
   (
      this : in out DisplayPath
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayTarget;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayTarget do
         Hr := this.m_IDisplayPath.all.get_Target (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayTarget := new WinUI3.Windows.Devices.Display.Core.IDisplayTarget;
         Retval.m_IDisplayTarget.all := m_ComRetVal;
      end return;
   end;

   function get_Status
   (
      this : in out DisplayPath
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayPathStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayPathStatus;
   begin
      Hr := this.m_IDisplayPath.all.get_Status (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SourceResolution
   (
      this : in out DisplayPath
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IDisplayPath.all.get_SourceResolution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SourceResolution
   (
      this : in out DisplayPath;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_SourceResolution (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SourcePixelFormat
   (
      this : in out DisplayPath
   )
   return WinUI3.Windows.Graphics.DirectX.DirectXPixelFormat is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.DirectX.DirectXPixelFormat;
   begin
      Hr := this.m_IDisplayPath.all.get_SourcePixelFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SourcePixelFormat
   (
      this : in out DisplayPath;
      value : WinUI3.Windows.Graphics.DirectX.DirectXPixelFormat
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_SourcePixelFormat (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsStereo
   (
      this : in out DisplayPath
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayPath.all.get_IsStereo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsStereo
   (
      this : in out DisplayPath;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_IsStereo (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TargetResolution
   (
      this : in out DisplayPath
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IDisplayPath.all.get_TargetResolution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TargetResolution
   (
      this : in out DisplayPath;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_TargetResolution (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PresentationRate
   (
      this : in out DisplayPath
   )
   return IReference_DisplayPresentationRate.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DisplayPresentationRate.Kind;
   begin
      Hr := this.m_IDisplayPath.all.get_PresentationRate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DisplayPresentationRate (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_PresentationRate
   (
      this : in out DisplayPath;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_PresentationRate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInterlaced
   (
      this : in out DisplayPath
   )
   return IReference_Boolean.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Boolean.Kind;
   begin
      Hr := this.m_IDisplayPath.all.get_IsInterlaced (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Boolean (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_IsInterlaced
   (
      this : in out DisplayPath;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_IsInterlaced (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_WireFormat
   (
      this : in out DisplayPath
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayWireFormat'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayWireFormat;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayWireFormat do
         Hr := this.m_IDisplayPath.all.get_WireFormat (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayWireFormat := new WinUI3.Windows.Devices.Display.Core.IDisplayWireFormat;
         Retval.m_IDisplayWireFormat.all := m_ComRetVal;
      end return;
   end;

   procedure put_WireFormat
   (
      this : in out DisplayPath;
      value : WinUI3.Windows.Devices.Display.Core.DisplayWireFormat'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_WireFormat (value.m_IDisplayWireFormat.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Rotation
   (
      this : in out DisplayPath
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayRotation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayRotation;
   begin
      Hr := this.m_IDisplayPath.all.get_Rotation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Rotation
   (
      this : in out DisplayPath;
      value : WinUI3.Windows.Devices.Display.Core.DisplayRotation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_Rotation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Scaling
   (
      this : in out DisplayPath
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayPathScaling is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayPathScaling;
   begin
      Hr := this.m_IDisplayPath.all.get_Scaling (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Scaling
   (
      this : in out DisplayPath;
      value : WinUI3.Windows.Devices.Display.Core.DisplayPathScaling
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_Scaling (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function FindModes
   (
      this : in out DisplayPath;
      flags : WinUI3.Windows.Devices.Display.Core.DisplayModeQueryOptions
   )
   return IVectorView_IDisplayModeInfo.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayModeInfo.Kind;
   begin
      Hr := this.m_IDisplayPath.all.FindModes (flags, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayModeInfo (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure ApplyPropertiesFromMode
   (
      this : in out DisplayPath;
      modeResult : WinUI3.Windows.Devices.Display.Core.DisplayModeInfo'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.ApplyPropertiesFromMode (modeResult.m_IDisplayModeInfo.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Properties
   (
      this : in out DisplayPath
   )
   return IMap_Guid_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IMap_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayPath.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMap_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_PhysicalPresentationRate
   (
      this : in out DisplayPath
   )
   return IReference_DisplayPresentationRate.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplayPath2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DisplayPresentationRate.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayPath_Interface, WinUI3.Windows.Devices.Display.Core.IDisplayPath2, WinUI3.Windows.Devices.Display.Core.IID_IDisplayPath2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplayPath.all);
      Hr := m_Interface.get_PhysicalPresentationRate (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DisplayPresentationRate (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_PhysicalPresentationRate
   (
      this : in out DisplayPath;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplayPath2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayPath_Interface, WinUI3.Windows.Devices.Display.Core.IDisplayPath2, WinUI3.Windows.Devices.Display.Core.IID_IDisplayPath2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplayPath.all);
      Hr := m_Interface.put_PhysicalPresentationRate (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayPrimaryDescription

   procedure Initialize (this : in out DisplayPrimaryDescription) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayPrimaryDescription) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayPrimaryDescription, IDisplayPrimaryDescription_Ptr);
   begin
      if this.m_IDisplayPrimaryDescription /= null then
         if this.m_IDisplayPrimaryDescription.all /= null then
            temp := this.m_IDisplayPrimaryDescription.all.Release;
            Free (this.m_IDisplayPrimaryDescription);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DisplayPrimaryDescription

   function Constructor
   (
      width : WinUI3.UInt32;
      height : WinUI3.UInt32;
      pixelFormat : WinUI3.Windows.Graphics.DirectX.DirectXPixelFormat;
      colorSpace : WinUI3.Windows.Graphics.DirectX.DirectXColorSpace;
      isStereo : WinUI3.Boolean;
      multisampleDescription : WinUI3.Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription
   )
   return DisplayPrimaryDescription is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.Devices.Display.Core.IDisplayPrimaryDescription");
      m_Factory    : access IDisplayPrimaryDescriptionFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.Devices.Display.Core.IDisplayPrimaryDescription;
   begin
      return RetVal : DisplayPrimaryDescription do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayPrimaryDescriptionFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (width, height, pixelFormat, colorSpace, isStereo, multisampleDescription, m_ComRetVal'Access);
            Retval.m_IDisplayPrimaryDescription := new WinUI3.Windows.Devices.Display.Core.IDisplayPrimaryDescription;
            Retval.m_IDisplayPrimaryDescription.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DisplayPrimaryDescription

   function CreateWithProperties
   (
      extraProperties : GenericObject;
      width : WinUI3.UInt32;
      height : WinUI3.UInt32;
      pixelFormat : WinUI3.Windows.Graphics.DirectX.DirectXPixelFormat;
      colorSpace : WinUI3.Windows.Graphics.DirectX.DirectXColorSpace;
      isStereo : WinUI3.Boolean;
      multisampleDescription : WinUI3.Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayPrimaryDescription is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.Devices.Display.Core.DisplayPrimaryDescription");
      m_Factory        : access WinUI3.Windows.Devices.Display.Core.IDisplayPrimaryDescriptionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayPrimaryDescription;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayPrimaryDescription do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayPrimaryDescriptionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithProperties (extraProperties, width, height, pixelFormat, colorSpace, isStereo, multisampleDescription, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayPrimaryDescription := new WinUI3.Windows.Devices.Display.Core.IDisplayPrimaryDescription;
            Retval.m_IDisplayPrimaryDescription.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayPrimaryDescription

   function get_Width
   (
      this : in out DisplayPrimaryDescription
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_Width (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Height
   (
      this : in out DisplayPrimaryDescription
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_Height (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Format
   (
      this : in out DisplayPrimaryDescription
   )
   return WinUI3.Windows.Graphics.DirectX.DirectXPixelFormat is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.DirectX.DirectXPixelFormat;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_Format (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ColorSpace
   (
      this : in out DisplayPrimaryDescription
   )
   return WinUI3.Windows.Graphics.DirectX.DirectXColorSpace is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.DirectX.DirectXColorSpace;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_ColorSpace (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsStereo
   (
      this : in out DisplayPrimaryDescription
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_IsStereo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MultisampleDescription
   (
      this : in out DisplayPrimaryDescription
   )
   return WinUI3.Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_MultisampleDescription (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Properties
   (
      this : in out DisplayPrimaryDescription
   )
   return IMapView_Guid_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IMapView_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayScanout

   procedure Initialize (this : in out DisplayScanout) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayScanout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayScanout, IDisplayScanout_Ptr);
   begin
      if this.m_IDisplayScanout /= null then
         if this.m_IDisplayScanout.all /= null then
            temp := this.m_IDisplayScanout.all.Release;
            Free (this.m_IDisplayScanout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayScanout

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplaySource

   procedure Initialize (this : in out DisplaySource) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplaySource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplaySource, IDisplaySource_Ptr);
   begin
      if this.m_IDisplaySource /= null then
         if this.m_IDisplaySource.all /= null then
            temp := this.m_IDisplaySource.all.Release;
            Free (this.m_IDisplaySource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplaySource

   function get_AdapterId
   (
      this : in out DisplaySource
   )
   return WinUI3.Windows.Graphics.DisplayAdapterId is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.DisplayAdapterId;
   begin
      Hr := this.m_IDisplaySource.all.get_AdapterId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SourceId
   (
      this : in out DisplaySource
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IDisplaySource.all.get_SourceId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetMetadata
   (
      this : in out DisplaySource;
      Key : WinUI3.Guid
   )
   return WinUI3.Windows.Storage.Streams.IBuffer is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_IDisplaySource.all.GetMetadata (Key, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Status
   (
      this : in out DisplaySource
   )
   return WinUI3.Windows.Devices.Display.Core.DisplaySourceStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplaySource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplaySourceStatus;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplaySource_Interface, WinUI3.Windows.Devices.Display.Core.IDisplaySource2, WinUI3.Windows.Devices.Display.Core.IID_IDisplaySource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplaySource.all);
      Hr := m_Interface.get_Status (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_StatusChanged
   (
      this : in out DisplaySource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplaySource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplaySource_Interface, WinUI3.Windows.Devices.Display.Core.IDisplaySource2, WinUI3.Windows.Devices.Display.Core.IID_IDisplaySource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplaySource.all);
      Hr := m_Interface.add_StatusChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_StatusChanged
   (
      this : in out DisplaySource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplaySource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplaySource_Interface, WinUI3.Windows.Devices.Display.Core.IDisplaySource2, WinUI3.Windows.Devices.Display.Core.IID_IDisplaySource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplaySource.all);
      Hr := m_Interface.remove_StatusChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayState

   procedure Initialize (this : in out DisplayState) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayState) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayState, IDisplayState_Ptr);
   begin
      if this.m_IDisplayState /= null then
         if this.m_IDisplayState.all /= null then
            temp := this.m_IDisplayState.all.Release;
            Free (this.m_IDisplayState);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayState

   function get_IsReadOnly
   (
      this : in out DisplayState
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayState.all.get_IsReadOnly (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsStale
   (
      this : in out DisplayState
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayState.all.get_IsStale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Targets
   (
      this : in out DisplayState
   )
   return IVectorView_IDisplayTarget.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayTarget.Kind;
   begin
      Hr := this.m_IDisplayState.all.get_Targets (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayTarget (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Views
   (
      this : in out DisplayState
   )
   return IVectorView_IDisplayView.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayView.Kind;
   begin
      Hr := this.m_IDisplayState.all.get_Views (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayView (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Properties
   (
      this : in out DisplayState
   )
   return IMap_Guid_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IMap_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayState.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMap_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function ConnectTarget
   (
      this : in out DisplayState;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayPath'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayPath;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayPath do
         Hr := this.m_IDisplayState.all.ConnectTarget (target.m_IDisplayTarget.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayPath := new WinUI3.Windows.Devices.Display.Core.IDisplayPath;
         Retval.m_IDisplayPath.all := m_ComRetVal;
      end return;
   end;

   function ConnectTarget
   (
      this : in out DisplayState;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class;
      view : WinUI3.Windows.Devices.Display.Core.DisplayView'Class
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayPath'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayPath;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayPath do
         Hr := this.m_IDisplayState.all.ConnectTarget (target.m_IDisplayTarget.all, view.m_IDisplayView.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayPath := new WinUI3.Windows.Devices.Display.Core.IDisplayPath;
         Retval.m_IDisplayPath.all := m_ComRetVal;
      end return;
   end;

   function CanConnectTargetToView
   (
      this : in out DisplayState;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class;
      view : WinUI3.Windows.Devices.Display.Core.DisplayView'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayState.all.CanConnectTargetToView (target.m_IDisplayTarget.all, view.m_IDisplayView.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetViewForTarget
   (
      this : in out DisplayState;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayView'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayView;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayView do
         Hr := this.m_IDisplayState.all.GetViewForTarget (target.m_IDisplayTarget.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayView := new WinUI3.Windows.Devices.Display.Core.IDisplayView;
         Retval.m_IDisplayView.all := m_ComRetVal;
      end return;
   end;

   function GetPathForTarget
   (
      this : in out DisplayState;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayPath'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayPath;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayPath do
         Hr := this.m_IDisplayState.all.GetPathForTarget (target.m_IDisplayTarget.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayPath := new WinUI3.Windows.Devices.Display.Core.IDisplayPath;
         Retval.m_IDisplayPath.all := m_ComRetVal;
      end return;
   end;

   procedure DisconnectTarget
   (
      this : in out DisplayState;
      target : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayState.all.DisconnectTarget (target.m_IDisplayTarget.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryFunctionalize
   (
      this : in out DisplayState;
      options : WinUI3.Windows.Devices.Display.Core.DisplayStateFunctionalizeOptions
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayStateOperationResult'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayStateOperationResult;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayStateOperationResult do
         Hr := this.m_IDisplayState.all.TryFunctionalize (options, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayStateOperationResult := new WinUI3.Windows.Devices.Display.Core.IDisplayStateOperationResult;
         Retval.m_IDisplayStateOperationResult.all := m_ComRetVal;
      end return;
   end;

   function TryApply
   (
      this : in out DisplayState;
      options : WinUI3.Windows.Devices.Display.Core.DisplayStateApplyOptions
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayStateOperationResult'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayStateOperationResult;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayStateOperationResult do
         Hr := this.m_IDisplayState.all.TryApply (options, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayStateOperationResult := new WinUI3.Windows.Devices.Display.Core.IDisplayStateOperationResult;
         Retval.m_IDisplayStateOperationResult.all := m_ComRetVal;
      end return;
   end;

   function Clone
   (
      this : in out DisplayState
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayState'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayState;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayState do
         Hr := this.m_IDisplayState.all.Clone (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayState := new WinUI3.Windows.Devices.Display.Core.IDisplayState;
         Retval.m_IDisplayState.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayStateOperationResult

   procedure Initialize (this : in out DisplayStateOperationResult) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayStateOperationResult) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayStateOperationResult, IDisplayStateOperationResult_Ptr);
   begin
      if this.m_IDisplayStateOperationResult /= null then
         if this.m_IDisplayStateOperationResult.all /= null then
            temp := this.m_IDisplayStateOperationResult.all.Release;
            Free (this.m_IDisplayStateOperationResult);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayStateOperationResult

   function get_Status
   (
      this : in out DisplayStateOperationResult
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayStateOperationStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayStateOperationStatus;
   begin
      Hr := this.m_IDisplayStateOperationResult.all.get_Status (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtendedErrorCode
   (
      this : in out DisplayStateOperationResult
   )
   return WinUI3.Windows.Foundation.HResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.HResult;
   begin
      Hr := this.m_IDisplayStateOperationResult.all.get_ExtendedErrorCode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplaySurface

   procedure Initialize (this : in out DisplaySurface) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplaySurface) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplaySurface, IDisplaySurface_Ptr);
   begin
      if this.m_IDisplaySurface /= null then
         if this.m_IDisplaySurface.all /= null then
            temp := this.m_IDisplaySurface.all.Release;
            Free (this.m_IDisplaySurface);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplaySurface

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayTarget

   procedure Initialize (this : in out DisplayTarget) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayTarget) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayTarget, IDisplayTarget_Ptr);
   begin
      if this.m_IDisplayTarget /= null then
         if this.m_IDisplayTarget.all /= null then
            temp := this.m_IDisplayTarget.all.Release;
            Free (this.m_IDisplayTarget);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayTarget

   function get_Adapter
   (
      this : in out DisplayTarget
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayAdapter'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayAdapter;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayAdapter do
         Hr := this.m_IDisplayTarget.all.get_Adapter (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayAdapter := new WinUI3.Windows.Devices.Display.Core.IDisplayAdapter;
         Retval.m_IDisplayAdapter.all := m_ComRetVal;
      end return;
   end;

   function get_DeviceInterfacePath
   (
      this : in out DisplayTarget
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDisplayTarget.all.get_DeviceInterfacePath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_AdapterRelativeId
   (
      this : in out DisplayTarget
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IDisplayTarget.all.get_AdapterRelativeId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsConnected
   (
      this : in out DisplayTarget
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.get_IsConnected (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsVirtualModeEnabled
   (
      this : in out DisplayTarget
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.get_IsVirtualModeEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsVirtualTopologyEnabled
   (
      this : in out DisplayTarget
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.get_IsVirtualTopologyEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_UsageKind
   (
      this : in out DisplayTarget
   )
   return WinUI3.Windows.Devices.Display.DisplayMonitorUsageKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.DisplayMonitorUsageKind;
   begin
      Hr := this.m_IDisplayTarget.all.get_UsageKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MonitorPersistence
   (
      this : in out DisplayTarget
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayTargetPersistence is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayTargetPersistence;
   begin
      Hr := this.m_IDisplayTarget.all.get_MonitorPersistence (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_StableMonitorId
   (
      this : in out DisplayTarget
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDisplayTarget.all.get_StableMonitorId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function TryGetMonitor
   (
      this : in out DisplayTarget
   )
   return WinUI3.Windows.Devices.Display.DisplayMonitor'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.IDisplayMonitor;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.DisplayMonitor do
         Hr := this.m_IDisplayTarget.all.TryGetMonitor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayMonitor := new WinUI3.Windows.Devices.Display.IDisplayMonitor;
         Retval.m_IDisplayMonitor.all := m_ComRetVal;
      end return;
   end;

   function get_Properties
   (
      this : in out DisplayTarget
   )
   return IMapView_Guid_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IMapView_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayTarget.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_IsStale
   (
      this : in out DisplayTarget
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.get_IsStale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IsSame
   (
      this : in out DisplayTarget;
      otherTarget : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.IsSame (otherTarget.m_IDisplayTarget.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IsEqual
   (
      this : in out DisplayTarget;
      otherTarget : WinUI3.Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.IsEqual (otherTarget.m_IDisplayTarget.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayTask

   procedure Initialize (this : in out DisplayTask) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayTask) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayTask, IDisplayTask_Ptr);
   begin
      if this.m_IDisplayTask /= null then
         if this.m_IDisplayTask.all /= null then
            temp := this.m_IDisplayTask.all.Release;
            Free (this.m_IDisplayTask);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayTask

   procedure SetScanout
   (
      this : in out DisplayTask;
      scanout : WinUI3.Windows.Devices.Display.Core.DisplayScanout'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayTask.all.SetScanout (scanout.m_IDisplayScanout.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetWait
   (
      this : in out DisplayTask;
      readyFence : WinUI3.Windows.Devices.Display.Core.DisplayFence'Class;
      readyFenceValue : WinUI3.UInt64
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayTask.all.SetWait (readyFence.m_IDisplayFence.all, readyFenceValue);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetSignal
   (
      this : in out DisplayTask;
      signalKind : WinUI3.Windows.Devices.Display.Core.DisplayTaskSignalKind;
      fence : WinUI3.Windows.Devices.Display.Core.DisplayFence'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplayTask2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayTask_Interface, WinUI3.Windows.Devices.Display.Core.IDisplayTask2, WinUI3.Windows.Devices.Display.Core.IID_IDisplayTask2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplayTask.all);
      Hr := m_Interface.SetSignal (signalKind, fence.m_IDisplayFence.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayTaskPool

   procedure Initialize (this : in out DisplayTaskPool) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayTaskPool) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayTaskPool, IDisplayTaskPool_Ptr);
   begin
      if this.m_IDisplayTaskPool /= null then
         if this.m_IDisplayTaskPool.all /= null then
            temp := this.m_IDisplayTaskPool.all.Release;
            Free (this.m_IDisplayTaskPool);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayTaskPool

   function CreateTask
   (
      this : in out DisplayTaskPool
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayTask'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayTask;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayTask do
         Hr := this.m_IDisplayTaskPool.all.CreateTask (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayTask := new WinUI3.Windows.Devices.Display.Core.IDisplayTask;
         Retval.m_IDisplayTask.all := m_ComRetVal;
      end return;
   end;

   procedure ExecuteTask
   (
      this : in out DisplayTaskPool;
      task_x : WinUI3.Windows.Devices.Display.Core.DisplayTask'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayTaskPool.all.ExecuteTask (task_x.m_IDisplayTask.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryExecuteTask
   (
      this : in out DisplayTaskPool;
      task_x : WinUI3.Windows.Devices.Display.Core.DisplayTask'Class
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayTaskResult'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Devices.Display.Core.IDisplayTaskPool2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayTaskResult;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.Devices.Display.Core.IDisplayTaskPool_Interface, WinUI3.Windows.Devices.Display.Core.IDisplayTaskPool2, WinUI3.Windows.Devices.Display.Core.IID_IDisplayTaskPool2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayTaskResult do
         m_Interface := QInterface (this.m_IDisplayTaskPool.all);
         Hr := m_Interface.TryExecuteTask (task_x.m_IDisplayTask.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayTaskResult := new WinUI3.Windows.Devices.Display.Core.IDisplayTaskResult;
         Retval.m_IDisplayTaskResult.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayTaskResult

   procedure Initialize (this : in out DisplayTaskResult) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayTaskResult) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayTaskResult, IDisplayTaskResult_Ptr);
   begin
      if this.m_IDisplayTaskResult /= null then
         if this.m_IDisplayTaskResult.all /= null then
            temp := this.m_IDisplayTaskResult.all.Release;
            Free (this.m_IDisplayTaskResult);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayTaskResult

   function get_PresentStatus
   (
      this : in out DisplayTaskResult
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayPresentStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayPresentStatus;
   begin
      Hr := this.m_IDisplayTaskResult.all.get_PresentStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PresentId
   (
      this : in out DisplayTaskResult
   )
   return WinUI3.UInt64 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt64;
   begin
      Hr := this.m_IDisplayTaskResult.all.get_PresentId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SourceStatus
   (
      this : in out DisplayTaskResult
   )
   return WinUI3.Windows.Devices.Display.Core.DisplaySourceStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplaySourceStatus;
   begin
      Hr := this.m_IDisplayTaskResult.all.get_SourceStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayView

   procedure Initialize (this : in out DisplayView) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayView, IDisplayView_Ptr);
   begin
      if this.m_IDisplayView /= null then
         if this.m_IDisplayView.all /= null then
            temp := this.m_IDisplayView.all.Release;
            Free (this.m_IDisplayView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayView

   function get_Paths
   (
      this : in out DisplayView
   )
   return IVectorView_IDisplayPath.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayPath.Kind;
   begin
      Hr := this.m_IDisplayView.all.get_Paths (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayPath (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_ContentResolution
   (
      this : in out DisplayView
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IDisplayView.all.get_ContentResolution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ContentResolution
   (
      this : in out DisplayView;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayView.all.put_ContentResolution (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetPrimaryPath
   (
      this : in out DisplayView;
      path : WinUI3.Windows.Devices.Display.Core.DisplayPath'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayView.all.SetPrimaryPath (path.m_IDisplayPath.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Properties
   (
      this : in out DisplayView
   )
   return IMap_Guid_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IMap_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayView.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMap_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayWireFormat

   procedure Initialize (this : in out DisplayWireFormat) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayWireFormat) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayWireFormat, IDisplayWireFormat_Ptr);
   begin
      if this.m_IDisplayWireFormat /= null then
         if this.m_IDisplayWireFormat.all /= null then
            temp := this.m_IDisplayWireFormat.all.Release;
            Free (this.m_IDisplayWireFormat);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DisplayWireFormat

   function Constructor
   (
      pixelEncoding : WinUI3.Windows.Devices.Display.Core.DisplayWireFormatPixelEncoding;
      bitsPerChannel : WinUI3.Int32;
      colorSpace : WinUI3.Windows.Devices.Display.Core.DisplayWireFormatColorSpace;
      eotf : WinUI3.Windows.Devices.Display.Core.DisplayWireFormatEotf;
      hdrMetadata : WinUI3.Windows.Devices.Display.Core.DisplayWireFormatHdrMetadata
   )
   return DisplayWireFormat is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.Devices.Display.Core.IDisplayWireFormat");
      m_Factory    : access IDisplayWireFormatFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.Devices.Display.Core.IDisplayWireFormat;
   begin
      return RetVal : DisplayWireFormat do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayWireFormatFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata, m_ComRetVal'Access);
            Retval.m_IDisplayWireFormat := new WinUI3.Windows.Devices.Display.Core.IDisplayWireFormat;
            Retval.m_IDisplayWireFormat.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DisplayWireFormat

   function CreateWithProperties
   (
      extraProperties : GenericObject;
      pixelEncoding : WinUI3.Windows.Devices.Display.Core.DisplayWireFormatPixelEncoding;
      bitsPerChannel : WinUI3.Int32;
      colorSpace : WinUI3.Windows.Devices.Display.Core.DisplayWireFormatColorSpace;
      eotf : WinUI3.Windows.Devices.Display.Core.DisplayWireFormatEotf;
      hdrMetadata : WinUI3.Windows.Devices.Display.Core.DisplayWireFormatHdrMetadata
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayWireFormat is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.Devices.Display.Core.DisplayWireFormat");
      m_Factory        : access WinUI3.Windows.Devices.Display.Core.IDisplayWireFormatStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.IDisplayWireFormat;
   begin
      return RetVal : WinUI3.Windows.Devices.Display.Core.DisplayWireFormat do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayWireFormatStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithProperties (extraProperties, pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayWireFormat := new WinUI3.Windows.Devices.Display.Core.IDisplayWireFormat;
            Retval.m_IDisplayWireFormat.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayWireFormat

   function get_PixelEncoding
   (
      this : in out DisplayWireFormat
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayWireFormatPixelEncoding is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayWireFormatPixelEncoding;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_PixelEncoding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_BitsPerChannel
   (
      this : in out DisplayWireFormat
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_BitsPerChannel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ColorSpace
   (
      this : in out DisplayWireFormat
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayWireFormatColorSpace is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayWireFormatColorSpace;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_ColorSpace (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Eotf
   (
      this : in out DisplayWireFormat
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayWireFormatEotf is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayWireFormatEotf;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_Eotf (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HdrMetadata
   (
      this : in out DisplayWireFormat
   )
   return WinUI3.Windows.Devices.Display.Core.DisplayWireFormatHdrMetadata is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Devices.Display.Core.DisplayWireFormatHdrMetadata;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_HdrMetadata (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Properties
   (
      this : in out DisplayWireFormat
   )
   return IMapView_Guid_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IMapView_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

end WinUI3.Windows.Devices.Display.Core;
