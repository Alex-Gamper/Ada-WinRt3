--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Microsoft.UI.Dispatching;
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with WinUI3.Windows.Foundation.Collections;
with WinUI3.Windows.Graphics;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Microsoft.UI.Windowing is

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindow

   procedure Initialize (this : in out AppWindow) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindow) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindow, IAppWindow_Ptr);
   begin
      if this.m_IAppWindow /= null then
         if this.m_IAppWindow.all /= null then
            temp := this.m_IAppWindow.all.Release;
            if temp < 1 then
               Free (this.m_IAppWindow);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppWindow

   function Create
   (
      appWindowPresenter_p : WinUI3.Microsoft.UI.Windowing.AppWindowPresenter'Class;
      ownerWindowId : WinUI3.Microsoft.UI.WindowId;
      DispatcherQueue : WinUI3.Microsoft.UI.Dispatching.DispatcherQueue'Class
   )
   return WinUI3.Microsoft.UI.Windowing.AppWindow is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.AppWindow");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IAppWindowStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IAppWindow;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.AppWindow do
         Hr := RoGetActivationFactory (m_hString, IID_IAppWindowStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (appWindowPresenter_p.m_IAppWindowPresenter.all, ownerWindowId, DispatcherQueue.m_IDispatcherQueue.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IAppWindow := new WinUI3.Microsoft.UI.Windowing.IAppWindow;
            Retval.m_IAppWindow.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Create
   return WinUI3.Microsoft.UI.Windowing.AppWindow is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.AppWindow");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IAppWindowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IAppWindow;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.AppWindow do
         Hr := RoGetActivationFactory (m_hString, IID_IAppWindowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IAppWindow := new WinUI3.Microsoft.UI.Windowing.IAppWindow;
            Retval.m_IAppWindow.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Create
   (
      appWindowPresenter_p : WinUI3.Microsoft.UI.Windowing.AppWindowPresenter'Class
   )
   return WinUI3.Microsoft.UI.Windowing.AppWindow is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.AppWindow");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IAppWindowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IAppWindow;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.AppWindow do
         Hr := RoGetActivationFactory (m_hString, IID_IAppWindowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (appWindowPresenter_p.m_IAppWindowPresenter.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IAppWindow := new WinUI3.Microsoft.UI.Windowing.IAppWindow;
            Retval.m_IAppWindow.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Create
   (
      appWindowPresenter_p : WinUI3.Microsoft.UI.Windowing.AppWindowPresenter'Class;
      ownerWindowId : WinUI3.Microsoft.UI.WindowId
   )
   return WinUI3.Microsoft.UI.Windowing.AppWindow is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.AppWindow");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IAppWindowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IAppWindow;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.AppWindow do
         Hr := RoGetActivationFactory (m_hString, IID_IAppWindowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (appWindowPresenter_p.m_IAppWindowPresenter.all, ownerWindowId, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IAppWindow := new WinUI3.Microsoft.UI.Windowing.IAppWindow;
            Retval.m_IAppWindow.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetFromWindowId
   (
      windowId : WinUI3.Microsoft.UI.WindowId
   )
   return WinUI3.Microsoft.UI.Windowing.AppWindow is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.AppWindow");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IAppWindowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IAppWindow;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.AppWindow do
         Hr := RoGetActivationFactory (m_hString, IID_IAppWindowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetFromWindowId (windowId, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IAppWindow := new WinUI3.Microsoft.UI.Windowing.IAppWindow;
            Retval.m_IAppWindow.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindow

   function get_Id
   (
      this : in out AppWindow
   )
   return WinUI3.Microsoft.UI.WindowId is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.WindowId;
   begin
      Hr := this.m_IAppWindow.all.get_Id (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsShownInSwitchers
   (
      this : in out AppWindow
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppWindow.all.get_IsShownInSwitchers (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsShownInSwitchers
   (
      this : in out AppWindow;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.put_IsShownInSwitchers (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVisible
   (
      this : in out AppWindow
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppWindow.all.get_IsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OwnerWindowId
   (
      this : in out AppWindow
   )
   return WinUI3.Microsoft.UI.WindowId is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.WindowId;
   begin
      Hr := this.m_IAppWindow.all.get_OwnerWindowId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out AppWindow
   )
   return WinUI3.Windows.Graphics.PointInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.PointInt32;
   begin
      Hr := this.m_IAppWindow.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Presenter
   (
      this : in out AppWindow
   )
   return WinUI3.Microsoft.UI.Windowing.AppWindowPresenter'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IAppWindowPresenter;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.AppWindowPresenter do
         Hr := this.m_IAppWindow.all.get_Presenter (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppWindowPresenter := new WinUI3.Microsoft.UI.Windowing.IAppWindowPresenter;
         Retval.m_IAppWindowPresenter.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out AppWindow
   )
   return WinUI3.Windows.Graphics.SizeInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.SizeInt32;
   begin
      Hr := this.m_IAppWindow.all.get_Size (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Title
   (
      this : in out AppWindow
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAppWindow.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out AppWindow;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAppWindow.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_TitleBar
   (
      this : in out AppWindow
   )
   return WinUI3.Microsoft.UI.Windowing.AppWindowTitleBar'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.AppWindowTitleBar do
         Hr := this.m_IAppWindow.all.get_TitleBar (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppWindowTitleBar := new WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar;
         Retval.m_IAppWindowTitleBar.all := m_ComRetVal;
      end return;
   end;

   procedure Destroy
   (
      this : in out AppWindow
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.Destroy;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Hide
   (
      this : in out AppWindow
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.Hide;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Move
   (
      this : in out AppWindow;
      position : WinUI3.Windows.Graphics.PointInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.Move (position);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MoveAndResize
   (
      this : in out AppWindow;
      rect : WinUI3.Windows.Graphics.RectInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.MoveAndResize (rect);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MoveAndResize
   (
      this : in out AppWindow;
      rect : WinUI3.Windows.Graphics.RectInt32;
      displayarea_p : WinUI3.Microsoft.UI.Windowing.DisplayArea'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.MoveAndResize (rect, displayarea_p.m_IDisplayArea.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Resize
   (
      this : in out AppWindow;
      size : WinUI3.Windows.Graphics.SizeInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.Resize (size);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetIcon
   (
      this : in out AppWindow;
      iconPath : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_iconPath : constant WinUI3.HString := To_HString (iconPath);
   begin
      Hr := this.m_IAppWindow.all.SetIcon (HStr_iconPath);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_iconPath);
   end;

   procedure SetIcon
   (
      this : in out AppWindow;
      iconId : WinUI3.Microsoft.UI.IconId
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.SetIcon (iconId);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetPresenter
   (
      this : in out AppWindow;
      appWindowPresenter_p : WinUI3.Microsoft.UI.Windowing.AppWindowPresenter'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.SetPresenter (appWindowPresenter_p.m_IAppWindowPresenter.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetPresenter
   (
      this : in out AppWindow;
      appWindowPresenterKind : WinUI3.Microsoft.UI.Windowing.AppWindowPresenterKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.SetPresenter (appWindowPresenterKind);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Show
   (
      this : in out AppWindow
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.Show;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Show
   (
      this : in out AppWindow;
      activateWindow : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.Show (activateWindow);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Changed
   (
      this : in out AppWindow;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppWindow.all.add_Changed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Changed
   (
      this : in out AppWindow;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.remove_Changed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closing
   (
      this : in out AppWindow;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppWindow.all.add_Closing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closing
   (
      this : in out AppWindow;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.remove_Closing (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Destroying
   (
      this : in out AppWindow;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppWindow.all.add_Destroying (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Destroying
   (
      this : in out AppWindow;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.remove_Destroying (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ClientSize
   (
      this : in out AppWindow
   )
   return WinUI3.Windows.Graphics.SizeInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.SizeInt32;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindow.all);
      Hr := m_Interface.get_ClientSize (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure MoveInZOrderAtBottom
   (
      this : in out AppWindow
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindow.all);
      Hr := m_Interface.MoveInZOrderAtBottom;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MoveInZOrderAtTop
   (
      this : in out AppWindow
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindow.all);
      Hr := m_Interface.MoveInZOrderAtTop;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MoveInZOrderBelow
   (
      this : in out AppWindow;
      windowId : WinUI3.Microsoft.UI.WindowId
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindow.all);
      Hr := m_Interface.MoveInZOrderBelow (windowId);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ResizeClient
   (
      this : in out AppWindow;
      size : WinUI3.Windows.Graphics.SizeInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindow.all);
      Hr := m_Interface.ResizeClient (size);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ShowOnceWithRequestedStartupState
   (
      this : in out AppWindow
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindow.all);
      Hr := m_Interface.ShowOnceWithRequestedStartupState;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure AssociateWithDispatcherQueue
   (
      this : in out AppWindow;
      dispatcherQueue : WinUI3.Microsoft.UI.Dispatching.DispatcherQueue'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow3, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindow.all);
      Hr := m_Interface.AssociateWithDispatcherQueue (dispatcherQueue.m_IDispatcherQueue.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DispatcherQueue
   (
      this : in out AppWindow
   )
   return WinUI3.Microsoft.UI.Dispatching.DispatcherQueue'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Dispatching.IDispatcherQueue;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow3, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Dispatching.DispatcherQueue do
         m_Interface := QInterface (this.m_IAppWindow.all);
         Hr := m_Interface.get_DispatcherQueue (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDispatcherQueue := new WinUI3.Microsoft.UI.Dispatching.IDispatcherQueue;
         Retval.m_IDispatcherQueue.all := m_ComRetVal;
      end return;
   end;

   procedure SetTaskbarIcon
   (
      this : in out AppWindow;
      iconPath : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow4 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_iconPath : constant WinUI3.HString := To_HString (iconPath);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow4, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindow.all);
      Hr := m_Interface.SetTaskbarIcon (HStr_iconPath);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_iconPath);
   end;

   procedure SetTaskbarIcon
   (
      this : in out AppWindow;
      iconId : WinUI3.Microsoft.UI.IconId
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow4, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindow.all);
      Hr := m_Interface.SetTaskbarIcon (iconId);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetTitleBarIcon
   (
      this : in out AppWindow;
      iconPath : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow4 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_iconPath : constant WinUI3.HString := To_HString (iconPath);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow4, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindow.all);
      Hr := m_Interface.SetTitleBarIcon (HStr_iconPath);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_iconPath);
   end;

   procedure SetTitleBarIcon
   (
      this : in out AppWindow;
      iconId : WinUI3.Microsoft.UI.IconId
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindow4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindow_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindow4, WinUI3.Microsoft.UI.Windowing.IID_IAppWindow4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindow.all);
      Hr := m_Interface.SetTitleBarIcon (iconId);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowChangedEventArgs

   procedure Initialize (this : in out AppWindowChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowChangedEventArgs, IAppWindowChangedEventArgs_Ptr);
   begin
      if this.m_IAppWindowChangedEventArgs /= null then
         if this.m_IAppWindowChangedEventArgs.all /= null then
            temp := this.m_IAppWindowChangedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IAppWindowChangedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowChangedEventArgs

   function get_DidPositionChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidPositionChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DidPresenterChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidPresenterChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DidSizeChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidSizeChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DidVisibilityChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidVisibilityChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DidZOrderChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindowChangedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowChangedEventArgs.all);
      Hr := m_Interface.get_DidZOrderChange (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsZOrderAtBottom
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindowChangedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowChangedEventArgs.all);
      Hr := m_Interface.get_IsZOrderAtBottom (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsZOrderAtTop
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindowChangedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowChangedEventArgs.all);
      Hr := m_Interface.get_IsZOrderAtTop (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZOrderBelowWindowId
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinUI3.Microsoft.UI.WindowId is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.WindowId;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindowChangedEventArgs2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindowChangedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowChangedEventArgs.all);
      Hr := m_Interface.get_ZOrderBelowWindowId (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowClosingEventArgs

   procedure Initialize (this : in out AppWindowClosingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowClosingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowClosingEventArgs, IAppWindowClosingEventArgs_Ptr);
   begin
      if this.m_IAppWindowClosingEventArgs /= null then
         if this.m_IAppWindowClosingEventArgs.all /= null then
            temp := this.m_IAppWindowClosingEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IAppWindowClosingEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowClosingEventArgs

   function get_Cancel
   (
      this : in out AppWindowClosingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppWindowClosingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out AppWindowClosingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowClosingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowPresenter

   procedure Initialize (this : in out AppWindowPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowPresenter, IAppWindowPresenter_Ptr);
   begin
      if this.m_IAppWindowPresenter /= null then
         if this.m_IAppWindowPresenter.all /= null then
            temp := this.m_IAppWindowPresenter.all.Release;
            if temp < 1 then
               Free (this.m_IAppWindowPresenter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppWindowPresenter

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowPresenter

   function get_Kind
   (
      this : in out AppWindowPresenter
   )
   return WinUI3.Microsoft.UI.Windowing.AppWindowPresenterKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.AppWindowPresenterKind;
   begin
      Hr := this.m_IAppWindowPresenter.all.get_Kind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowTitleBar

   procedure Initialize (this : in out AppWindowTitleBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowTitleBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowTitleBar, IAppWindowTitleBar_Ptr);
   begin
      if this.m_IAppWindowTitleBar /= null then
         if this.m_IAppWindowTitleBar.all /= null then
            temp := this.m_IAppWindowTitleBar.all.Release;
            if temp < 1 then
               Free (this.m_IAppWindowTitleBar);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppWindowTitleBar

   function IsCustomizationSupported
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.AppWindowTitleBar");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAppWindowTitleBarStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.IsCustomizationSupported (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowTitleBar

   function get_BackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_BackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_BackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonBackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonBackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ButtonBackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonBackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ButtonForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonHoverBackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonHoverBackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ButtonHoverBackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonHoverBackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonHoverForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonHoverForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ButtonHoverForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonHoverForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonInactiveBackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonInactiveBackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ButtonInactiveBackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonInactiveBackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonInactiveForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonInactiveForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ButtonInactiveForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonInactiveForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonPressedBackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonPressedBackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ButtonPressedBackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonPressedBackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonPressedForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonPressedForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ButtonPressedForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonPressedForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExtendsContentIntoTitleBar
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ExtendsContentIntoTitleBar (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ExtendsContentIntoTitleBar
   (
      this : in out AppWindowTitleBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ExtendsContentIntoTitleBar (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Height
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_Height (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IconShowOptions
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.Microsoft.UI.Windowing.IconShowOptions is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IconShowOptions;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_IconShowOptions (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IconShowOptions
   (
      this : in out AppWindowTitleBar;
      value : WinUI3.Microsoft.UI.Windowing.IconShowOptions
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_IconShowOptions (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InactiveBackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_InactiveBackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InactiveBackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_InactiveBackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InactiveForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_InactiveForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InactiveForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_InactiveForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LeftInset
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_LeftInset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_RightInset
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_RightInset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ResetToDefault
   (
      this : in out AppWindowTitleBar
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.ResetToDefault;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetDragRectangles
   (
      this : in out AppWindowTitleBar;
      value : WinUI3.Windows.Graphics.RectInt32_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      function Convert_value is new Ada.Unchecked_Conversion (Address, WinUI3.Windows.Graphics.RectInt32_Ptr);
   begin
      Hr := this.m_IAppWindowTitleBar.all.SetDragRectangles (WinUI3.UInt32(value'Length), Convert_value (value (value'First)'Address));
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreferredHeightOption
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.Microsoft.UI.Windowing.TitleBarHeightOption is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.TitleBarHeightOption;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindowTitleBar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowTitleBar.all);
      Hr := m_Interface.get_PreferredHeightOption (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreferredHeightOption
   (
      this : in out AppWindowTitleBar;
      value : WinUI3.Microsoft.UI.Windowing.TitleBarHeightOption
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar2, WinUI3.Microsoft.UI.Windowing.IID_IAppWindowTitleBar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowTitleBar.all);
      Hr := m_Interface.put_PreferredHeightOption (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreferredTheme
   (
      this : in out AppWindowTitleBar
   )
   return WinUI3.Microsoft.UI.Windowing.TitleBarTheme is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.TitleBarTheme;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar3, WinUI3.Microsoft.UI.Windowing.IID_IAppWindowTitleBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowTitleBar.all);
      Hr := m_Interface.get_PreferredTheme (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreferredTheme
   (
      this : in out AppWindowTitleBar;
      value : WinUI3.Microsoft.UI.Windowing.TitleBarTheme
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar_Interface, WinUI3.Microsoft.UI.Windowing.IAppWindowTitleBar3, WinUI3.Microsoft.UI.Windowing.IID_IAppWindowTitleBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowTitleBar.all);
      Hr := m_Interface.put_PreferredTheme (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompactOverlayPresenter

   procedure Initialize (this : in out CompactOverlayPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompactOverlayPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompactOverlayPresenter, ICompactOverlayPresenter_Ptr);
   begin
      if this.m_ICompactOverlayPresenter /= null then
         if this.m_ICompactOverlayPresenter.all /= null then
            temp := this.m_ICompactOverlayPresenter.all.Release;
            if temp < 1 then
               Free (this.m_ICompactOverlayPresenter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CompactOverlayPresenter

   function Create
   return WinUI3.Microsoft.UI.Windowing.CompactOverlayPresenter is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.CompactOverlayPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.ICompactOverlayPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.ICompactOverlayPresenter;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.CompactOverlayPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_ICompactOverlayPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ICompactOverlayPresenter := new WinUI3.Microsoft.UI.Windowing.ICompactOverlayPresenter;
            Retval.m_ICompactOverlayPresenter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompactOverlayPresenter

   function get_InitialSize
   (
      this : in out CompactOverlayPresenter
   )
   return WinUI3.Microsoft.UI.Windowing.CompactOverlaySize is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.CompactOverlaySize;
   begin
      Hr := this.m_ICompactOverlayPresenter.all.get_InitialSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InitialSize
   (
      this : in out CompactOverlayPresenter;
      value : WinUI3.Microsoft.UI.Windowing.CompactOverlaySize
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompactOverlayPresenter.all.put_InitialSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayArea

   procedure Initialize (this : in out DisplayArea) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayArea) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayArea, IDisplayArea_Ptr);
   begin
      if this.m_IDisplayArea /= null then
         if this.m_IDisplayArea.all /= null then
            temp := this.m_IDisplayArea.all.Release;
            if temp < 1 then
               Free (this.m_IDisplayArea);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DisplayArea

   function get_Primary
   return WinUI3.Microsoft.UI.Windowing.DisplayArea is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.DisplayArea");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IDisplayAreaStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IDisplayArea;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.DisplayArea do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayAreaStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Primary (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayArea := new WinUI3.Microsoft.UI.Windowing.IDisplayArea;
            Retval.m_IDisplayArea.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateWatcher
   return WinUI3.Microsoft.UI.Windowing.DisplayAreaWatcher is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.DisplayArea");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IDisplayAreaStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IDisplayAreaWatcher;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.DisplayAreaWatcher do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayAreaStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWatcher (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayAreaWatcher := new WinUI3.Microsoft.UI.Windowing.IDisplayAreaWatcher;
            Retval.m_IDisplayAreaWatcher.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function FindAll
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.DisplayArea");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IDisplayAreaStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDisplayAreaStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FindAll (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetFromWindowId
   (
      windowId : WinUI3.Microsoft.UI.WindowId;
      displayAreaFallback : WinUI3.Microsoft.UI.Windowing.DisplayAreaFallback
   )
   return WinUI3.Microsoft.UI.Windowing.DisplayArea is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.DisplayArea");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IDisplayAreaStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IDisplayArea;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.DisplayArea do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayAreaStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetFromWindowId (windowId, displayAreaFallback, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayArea := new WinUI3.Microsoft.UI.Windowing.IDisplayArea;
            Retval.m_IDisplayArea.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetFromPoint
   (
      point : WinUI3.Windows.Graphics.PointInt32;
      displayAreaFallback : WinUI3.Microsoft.UI.Windowing.DisplayAreaFallback
   )
   return WinUI3.Microsoft.UI.Windowing.DisplayArea is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.DisplayArea");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IDisplayAreaStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IDisplayArea;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.DisplayArea do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayAreaStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetFromPoint (point, displayAreaFallback, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayArea := new WinUI3.Microsoft.UI.Windowing.IDisplayArea;
            Retval.m_IDisplayArea.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetFromRect
   (
      rect : WinUI3.Windows.Graphics.RectInt32;
      displayAreaFallback : WinUI3.Microsoft.UI.Windowing.DisplayAreaFallback
   )
   return WinUI3.Microsoft.UI.Windowing.DisplayArea is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.DisplayArea");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IDisplayAreaStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IDisplayArea;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.DisplayArea do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayAreaStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetFromRect (rect, displayAreaFallback, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayArea := new WinUI3.Microsoft.UI.Windowing.IDisplayArea;
            Retval.m_IDisplayArea.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetFromDisplayId
   (
      displayId : WinUI3.Microsoft.UI.DisplayId
   )
   return WinUI3.Microsoft.UI.Windowing.DisplayArea is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.DisplayArea");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IDisplayAreaStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IDisplayArea;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.DisplayArea do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayAreaStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetFromDisplayId (displayId, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayArea := new WinUI3.Microsoft.UI.Windowing.IDisplayArea;
            Retval.m_IDisplayArea.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayArea

   function get_DisplayId
   (
      this : in out DisplayArea
   )
   return WinUI3.Microsoft.UI.DisplayId is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.DisplayId;
   begin
      Hr := this.m_IDisplayArea.all.get_DisplayId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsPrimary
   (
      this : in out DisplayArea
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDisplayArea.all.get_IsPrimary (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OuterBounds
   (
      this : in out DisplayArea
   )
   return WinUI3.Windows.Graphics.RectInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.RectInt32;
   begin
      Hr := this.m_IDisplayArea.all.get_OuterBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WorkArea
   (
      this : in out DisplayArea
   )
   return WinUI3.Windows.Graphics.RectInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Graphics.RectInt32;
   begin
      Hr := this.m_IDisplayArea.all.get_WorkArea (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayAreaWatcher

   procedure Initialize (this : in out DisplayAreaWatcher) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayAreaWatcher) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayAreaWatcher, IDisplayAreaWatcher_Ptr);
   begin
      if this.m_IDisplayAreaWatcher /= null then
         if this.m_IDisplayAreaWatcher.all /= null then
            temp := this.m_IDisplayAreaWatcher.all.Release;
            if temp < 1 then
               Free (this.m_IDisplayAreaWatcher);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayAreaWatcher

   function get_Status
   (
      this : in out DisplayAreaWatcher
   )
   return WinUI3.Microsoft.UI.Windowing.DisplayAreaWatcherStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.DisplayAreaWatcherStatus;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.get_Status (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Start
   (
      this : in out DisplayAreaWatcher
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.Start;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out DisplayAreaWatcher
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Added
   (
      this : in out DisplayAreaWatcher;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.add_Added (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Added
   (
      this : in out DisplayAreaWatcher;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.remove_Added (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_EnumerationCompleted
   (
      this : in out DisplayAreaWatcher;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.add_EnumerationCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_EnumerationCompleted
   (
      this : in out DisplayAreaWatcher;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.remove_EnumerationCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Removed
   (
      this : in out DisplayAreaWatcher;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.add_Removed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Removed
   (
      this : in out DisplayAreaWatcher;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.remove_Removed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Stopped
   (
      this : in out DisplayAreaWatcher;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.add_Stopped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Stopped
   (
      this : in out DisplayAreaWatcher;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.remove_Stopped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Updated
   (
      this : in out DisplayAreaWatcher;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.add_Updated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Updated
   (
      this : in out DisplayAreaWatcher;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDisplayAreaWatcher.all.remove_Updated (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FullScreenPresenter

   procedure Initialize (this : in out FullScreenPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out FullScreenPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFullScreenPresenter, IFullScreenPresenter_Ptr);
   begin
      if this.m_IFullScreenPresenter /= null then
         if this.m_IFullScreenPresenter.all /= null then
            temp := this.m_IFullScreenPresenter.all.Release;
            if temp < 1 then
               Free (this.m_IFullScreenPresenter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FullScreenPresenter

   function Create
   return WinUI3.Microsoft.UI.Windowing.FullScreenPresenter is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.FullScreenPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IFullScreenPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IFullScreenPresenter;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.FullScreenPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IFullScreenPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IFullScreenPresenter := new WinUI3.Microsoft.UI.Windowing.IFullScreenPresenter;
            Retval.m_IFullScreenPresenter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FullScreenPresenter

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for OverlappedPresenter

   procedure Initialize (this : in out OverlappedPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out OverlappedPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IOverlappedPresenter, IOverlappedPresenter_Ptr);
   begin
      if this.m_IOverlappedPresenter /= null then
         if this.m_IOverlappedPresenter.all /= null then
            temp := this.m_IOverlappedPresenter.all.Release;
            if temp < 1 then
               Free (this.m_IOverlappedPresenter);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for OverlappedPresenter

   function Create
   return WinUI3.Microsoft.UI.Windowing.OverlappedPresenter is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.OverlappedPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IOverlappedPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.OverlappedPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IOverlappedPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IOverlappedPresenter := new WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter;
            Retval.m_IOverlappedPresenter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateForContextMenu
   return WinUI3.Microsoft.UI.Windowing.OverlappedPresenter is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.OverlappedPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IOverlappedPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.OverlappedPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IOverlappedPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateForContextMenu (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IOverlappedPresenter := new WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter;
            Retval.m_IOverlappedPresenter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateForDialog
   return WinUI3.Microsoft.UI.Windowing.OverlappedPresenter is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.OverlappedPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IOverlappedPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.OverlappedPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IOverlappedPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateForDialog (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IOverlappedPresenter := new WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter;
            Retval.m_IOverlappedPresenter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateForToolWindow
   return WinUI3.Microsoft.UI.Windowing.OverlappedPresenter is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.OverlappedPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IOverlappedPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter;
   begin
      return RetVal : WinUI3.Microsoft.UI.Windowing.OverlappedPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IOverlappedPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateForToolWindow (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IOverlappedPresenter := new WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter;
            Retval.m_IOverlappedPresenter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RequestedStartupState
   return WinUI3.Microsoft.UI.Windowing.OverlappedPresenterState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Windowing.OverlappedPresenter");
      m_Factory        : access WinUI3.Microsoft.UI.Windowing.IOverlappedPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.OverlappedPresenterState;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IOverlappedPresenterStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_RequestedStartupState (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for OverlappedPresenter

   function get_HasBorder
   (
      this : in out OverlappedPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IOverlappedPresenter.all.get_HasBorder (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HasTitleBar
   (
      this : in out OverlappedPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IOverlappedPresenter.all.get_HasTitleBar (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsAlwaysOnTop
   (
      this : in out OverlappedPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IOverlappedPresenter.all.get_IsAlwaysOnTop (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsAlwaysOnTop
   (
      this : in out OverlappedPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOverlappedPresenter.all.put_IsAlwaysOnTop (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsMaximizable
   (
      this : in out OverlappedPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IOverlappedPresenter.all.get_IsMaximizable (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsMaximizable
   (
      this : in out OverlappedPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOverlappedPresenter.all.put_IsMaximizable (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsMinimizable
   (
      this : in out OverlappedPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IOverlappedPresenter.all.get_IsMinimizable (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsMinimizable
   (
      this : in out OverlappedPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOverlappedPresenter.all.put_IsMinimizable (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsModal
   (
      this : in out OverlappedPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IOverlappedPresenter.all.get_IsModal (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsModal
   (
      this : in out OverlappedPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOverlappedPresenter.all.put_IsModal (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsResizable
   (
      this : in out OverlappedPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IOverlappedPresenter.all.get_IsResizable (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsResizable
   (
      this : in out OverlappedPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOverlappedPresenter.all.put_IsResizable (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_State
   (
      this : in out OverlappedPresenter
   )
   return WinUI3.Microsoft.UI.Windowing.OverlappedPresenterState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Windowing.OverlappedPresenterState;
   begin
      Hr := this.m_IOverlappedPresenter.all.get_State (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Maximize
   (
      this : in out OverlappedPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOverlappedPresenter.all.Maximize;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Minimize
   (
      this : in out OverlappedPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOverlappedPresenter.all.Minimize;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Restore
   (
      this : in out OverlappedPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOverlappedPresenter.all.Restore;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetBorderAndTitleBar
   (
      this : in out OverlappedPresenter;
      hasBorder : WinUI3.Boolean;
      hasTitleBar : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IOverlappedPresenter.all.SetBorderAndTitleBar (hasBorder, hasTitleBar);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Minimize
   (
      this : in out OverlappedPresenter;
      activateWindow : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter_Interface, WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter2, WinUI3.Microsoft.UI.Windowing.IID_IOverlappedPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOverlappedPresenter.all);
      Hr := m_Interface.Minimize (activateWindow);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Restore
   (
      this : in out OverlappedPresenter;
      activateWindow : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter_Interface, WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter2, WinUI3.Microsoft.UI.Windowing.IID_IOverlappedPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOverlappedPresenter.all);
      Hr := m_Interface.Restore (activateWindow);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreferredMinimumHeight
   (
      this : in out OverlappedPresenter
   )
   return IReference_Int32.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Int32.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter_Interface, WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3, WinUI3.Microsoft.UI.Windowing.IID_IOverlappedPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOverlappedPresenter.all);
      Hr := m_Interface.get_PreferredMinimumHeight (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Int32 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_PreferredMinimumHeight
   (
      this : in out OverlappedPresenter;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter_Interface, WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3, WinUI3.Microsoft.UI.Windowing.IID_IOverlappedPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOverlappedPresenter.all);
      Hr := m_Interface.put_PreferredMinimumHeight (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreferredMinimumWidth
   (
      this : in out OverlappedPresenter
   )
   return IReference_Int32.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Int32.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter_Interface, WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3, WinUI3.Microsoft.UI.Windowing.IID_IOverlappedPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOverlappedPresenter.all);
      Hr := m_Interface.get_PreferredMinimumWidth (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Int32 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_PreferredMinimumWidth
   (
      this : in out OverlappedPresenter;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter_Interface, WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3, WinUI3.Microsoft.UI.Windowing.IID_IOverlappedPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOverlappedPresenter.all);
      Hr := m_Interface.put_PreferredMinimumWidth (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreferredMaximumWidth
   (
      this : in out OverlappedPresenter
   )
   return IReference_Int32.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Int32.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter_Interface, WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3, WinUI3.Microsoft.UI.Windowing.IID_IOverlappedPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOverlappedPresenter.all);
      Hr := m_Interface.get_PreferredMaximumWidth (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Int32 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_PreferredMaximumWidth
   (
      this : in out OverlappedPresenter;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter_Interface, WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3, WinUI3.Microsoft.UI.Windowing.IID_IOverlappedPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOverlappedPresenter.all);
      Hr := m_Interface.put_PreferredMaximumWidth (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreferredMaximumHeight
   (
      this : in out OverlappedPresenter
   )
   return IReference_Int32.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Int32.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter_Interface, WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3, WinUI3.Microsoft.UI.Windowing.IID_IOverlappedPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOverlappedPresenter.all);
      Hr := m_Interface.get_PreferredMaximumHeight (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Int32 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_PreferredMaximumHeight
   (
      this : in out OverlappedPresenter;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter_Interface, WinUI3.Microsoft.UI.Windowing.IOverlappedPresenter3, WinUI3.Microsoft.UI.Windowing.IID_IOverlappedPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOverlappedPresenter.all);
      Hr := m_Interface.put_PreferredMaximumHeight (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

end WinUI3.Microsoft.UI.Windowing;
