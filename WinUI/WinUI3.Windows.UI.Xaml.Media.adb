--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with WinUI3.Windows.Media.Playback;
with WinUI3.Windows.Storage.Streams;
with WinUI3.Windows.UI.Composition;
with WinUI3.Windows.UI.Xaml.Media.Media3D;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Windows.UI.Xaml.Media is

   package IVector_IBrush is new WinUI3.Windows.Foundation.Collections.IVector (IBrush);
   package IIterable_IBrush is new WinUI3.Windows.Foundation.Collections.IIterable (IBrush);
   package IVector_Double is new WinUI3.Windows.Foundation.Collections.IVector (WinUI3.Double);
   package IIterable_Double is new WinUI3.Windows.Foundation.Collections.IIterable (WinUI3.Double);
   package IVector_IGeometry is new WinUI3.Windows.Foundation.Collections.IVector (IGeometry);
   package IIterable_IGeometry is new WinUI3.Windows.Foundation.Collections.IIterable (IGeometry);
   package IVector_IGradientStop is new WinUI3.Windows.Foundation.Collections.IVector (IGradientStop);
   package IIterable_IGradientStop is new WinUI3.Windows.Foundation.Collections.IIterable (IGradientStop);
   package IVector_IPathFigure is new WinUI3.Windows.Foundation.Collections.IVector (IPathFigure);
   package IIterable_IPathFigure is new WinUI3.Windows.Foundation.Collections.IIterable (IPathFigure);
   package IVector_IPathSegment is new WinUI3.Windows.Foundation.Collections.IVector (IPathSegment);
   package IIterable_IPathSegment is new WinUI3.Windows.Foundation.Collections.IIterable (IPathSegment);
   package IVector_Point is new WinUI3.Windows.Foundation.Collections.IVector (WinUI3.Windows.Foundation.Point);
   package IIterable_Point is new WinUI3.Windows.Foundation.Collections.IIterable (WinUI3.Windows.Foundation.Point);
   package IVector_ITimelineMarker is new WinUI3.Windows.Foundation.Collections.IVector (ITimelineMarker);
   package IIterable_ITimelineMarker is new WinUI3.Windows.Foundation.Collections.IIterable (ITimelineMarker);
   package IVector_ITransform is new WinUI3.Windows.Foundation.Collections.IVector (ITransform);
   package IIterable_ITransform is new WinUI3.Windows.Foundation.Collections.IIterable (ITransform);
   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Brush

   procedure Initialize (this : in out Brush) is
   begin
      null;
   end;

   procedure Finalize (this : in out Brush) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBrush, IBrush_Ptr);
   begin
      if this.m_IBrush /= null then
         if this.m_IBrush.all /= null then
            temp := this.m_IBrush.all.Release;
            Free (this.m_IBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Brush

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Brush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Brush");
      m_Factory    : access IBrushFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : Brush do
         Hr := RoGetActivationFactory (m_hString, IID_IBrushFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
            Retval.m_IBrush.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Brush

   function get_OpacityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Brush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpacityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TransformProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Brush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TransformProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RelativeTransformProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Brush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RelativeTransformProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Brush

   function get_Opacity
   (
      this : in out Brush
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IBrush.all.get_Opacity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Opacity
   (
      this : in out Brush;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBrush.all.put_Opacity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Transform
   (
      this : in out Brush
   )
   return WinUI3.Windows.UI.Xaml.Media.Transform'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ITransform;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Transform do
         Hr := this.m_IBrush.all.get_Transform (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITransform := new WinUI3.Windows.UI.Xaml.Media.ITransform;
         Retval.m_ITransform.all := m_ComRetVal;
      end return;
   end;

   procedure put_Transform
   (
      this : in out Brush;
      value : WinUI3.Windows.UI.Xaml.Media.Transform'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBrush.all.put_Transform (value.m_ITransform.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RelativeTransform
   (
      this : in out Brush
   )
   return WinUI3.Windows.UI.Xaml.Media.Transform'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ITransform;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Transform do
         Hr := this.m_IBrush.all.get_RelativeTransform (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITransform := new WinUI3.Windows.UI.Xaml.Media.ITransform;
         Retval.m_ITransform.all := m_ComRetVal;
      end return;
   end;

   procedure put_RelativeTransform
   (
      this : in out Brush;
      value : WinUI3.Windows.UI.Xaml.Media.Transform'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBrush.all.put_RelativeTransform (value.m_ITransform.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PopulatePropertyInfoOverride
   (
      this : in out Brush;
      propertyName : WinUI3.WString;
      animationPropertyInfo : WinUI3.Windows.UI.Composition.AnimationPropertyInfo'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IBrushOverrides2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_propertyName : constant WinUI3.HString := To_HString (propertyName);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IBrush_Interface, WinUI3.Windows.UI.Xaml.Media.IBrushOverrides2, WinUI3.Windows.UI.Xaml.Media.IID_IBrushOverrides2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBrush.all);
      Hr := m_Interface.PopulatePropertyInfoOverride (HStr_propertyName, animationPropertyInfo.m_IAnimationPropertyInfo.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure PopulatePropertyInfo
   (
      this : in out Brush;
      propertyName : WinUI3.WString;
      propertyInfo : WinUI3.Windows.UI.Composition.AnimationPropertyInfo'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Composition.IAnimationObject := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_propertyName : constant WinUI3.HString := To_HString (propertyName);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IBrush_Interface, WinUI3.Windows.UI.Composition.IAnimationObject, WinUI3.Windows.UI.Composition.IID_IAnimationObject'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBrush.all);
      Hr := m_Interface.PopulatePropertyInfo (HStr_propertyName, propertyInfo.m_IAnimationPropertyInfo.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TileBrush

   procedure Initialize (this : in out TileBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out TileBrush) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITileBrush, ITileBrush_Ptr);
   begin
      if this.m_ITileBrush /= null then
         if this.m_ITileBrush.all /= null then
            temp := this.m_ITileBrush.all.Release;
            Free (this.m_ITileBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TileBrush

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TileBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TileBrush");
      m_Factory    : access ITileBrushFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ITileBrush;
   begin
      return RetVal : TileBrush do
         Hr := RoGetActivationFactory (m_hString, IID_ITileBrushFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITileBrush := new WinUI3.Windows.UI.Xaml.Media.ITileBrush;
            Retval.m_ITileBrush.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TileBrush

   function get_AlignmentXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TileBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ITileBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITileBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignmentXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AlignmentYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TileBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ITileBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITileBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignmentYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TileBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ITileBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITileBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TileBrush

   function get_AlignmentX
   (
      this : in out TileBrush
   )
   return WinUI3.Windows.UI.Xaml.Media.AlignmentX is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.AlignmentX;
   begin
      Hr := this.m_ITileBrush.all.get_AlignmentX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AlignmentX
   (
      this : in out TileBrush;
      value : WinUI3.Windows.UI.Xaml.Media.AlignmentX
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITileBrush.all.put_AlignmentX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AlignmentY
   (
      this : in out TileBrush
   )
   return WinUI3.Windows.UI.Xaml.Media.AlignmentY is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.AlignmentY;
   begin
      Hr := this.m_ITileBrush.all.get_AlignmentY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AlignmentY
   (
      this : in out TileBrush;
      value : WinUI3.Windows.UI.Xaml.Media.AlignmentY
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITileBrush.all.put_AlignmentY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out TileBrush
   )
   return WinUI3.Windows.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Stretch;
   begin
      Hr := this.m_ITileBrush.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out TileBrush;
      value : WinUI3.Windows.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITileBrush.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for XamlCompositionBrushBase

   procedure Initialize (this : in out XamlCompositionBrushBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out XamlCompositionBrushBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IXamlCompositionBrushBase, IXamlCompositionBrushBase_Ptr);
   begin
      if this.m_IXamlCompositionBrushBase /= null then
         if this.m_IXamlCompositionBrushBase.all /= null then
            temp := this.m_IXamlCompositionBrushBase.all.Release;
            Free (this.m_IXamlCompositionBrushBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for XamlCompositionBrushBase

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return XamlCompositionBrushBase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.XamlCompositionBrushBase");
      m_Factory    : access IXamlCompositionBrushBaseFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBase;
   begin
      return RetVal : XamlCompositionBrushBase do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlCompositionBrushBaseFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IXamlCompositionBrushBase := new WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBase;
            Retval.m_IXamlCompositionBrushBase.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for XamlCompositionBrushBase

   function get_FallbackColorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.XamlCompositionBrushBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlCompositionBrushBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FallbackColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for XamlCompositionBrushBase

   function get_FallbackColor
   (
      this : in out XamlCompositionBrushBase
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IXamlCompositionBrushBase.all.get_FallbackColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FallbackColor
   (
      this : in out XamlCompositionBrushBase;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IXamlCompositionBrushBase.all.put_FallbackColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CompositionBrush
   (
      this : in out XamlCompositionBrushBase
   )
   return WinUI3.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBaseProtected := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Composition.ICompositionBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBase_Interface, WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBaseProtected, WinUI3.Windows.UI.Xaml.Media.IID_IXamlCompositionBrushBaseProtected'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Composition.CompositionBrush do
         m_Interface := QInterface (this.m_IXamlCompositionBrushBase.all);
         Hr := m_Interface.get_CompositionBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinUI3.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CompositionBrush
   (
      this : in out XamlCompositionBrushBase;
      value : WinUI3.Windows.UI.Composition.CompositionBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBaseProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBase_Interface, WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBaseProtected, WinUI3.Windows.UI.Xaml.Media.IID_IXamlCompositionBrushBaseProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlCompositionBrushBase.all);
      Hr := m_Interface.put_CompositionBrush (value.m_ICompositionBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnConnected
   (
      this : in out XamlCompositionBrushBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBaseOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBase_Interface, WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBaseOverrides, WinUI3.Windows.UI.Xaml.Media.IID_IXamlCompositionBrushBaseOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlCompositionBrushBase.all);
      Hr := m_Interface.OnConnected;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDisconnected
   (
      this : in out XamlCompositionBrushBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBaseOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBase_Interface, WinUI3.Windows.UI.Xaml.Media.IXamlCompositionBrushBaseOverrides, WinUI3.Windows.UI.Xaml.Media.IID_IXamlCompositionBrushBaseOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlCompositionBrushBase.all);
      Hr := m_Interface.OnDisconnected;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AcrylicBrush

   procedure Initialize (this : in out AcrylicBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out AcrylicBrush) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAcrylicBrush, IAcrylicBrush_Ptr);
   begin
      if this.m_IAcrylicBrush /= null then
         if this.m_IAcrylicBrush.all /= null then
            temp := this.m_IAcrylicBrush.all.Release;
            Free (this.m_IAcrylicBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AcrylicBrush

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AcrylicBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.AcrylicBrush");
      m_Factory    : access IAcrylicBrushFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IAcrylicBrush;
   begin
      return RetVal : AcrylicBrush do
         Hr := RoGetActivationFactory (m_hString, IID_IAcrylicBrushFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAcrylicBrush := new WinUI3.Windows.UI.Xaml.Media.IAcrylicBrush;
            Retval.m_IAcrylicBrush.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AcrylicBrush

   function get_TintLuminosityOpacityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.AcrylicBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IAcrylicBrushStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAcrylicBrushStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TintLuminosityOpacityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundSourceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.AcrylicBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IAcrylicBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAcrylicBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TintColorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.AcrylicBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IAcrylicBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAcrylicBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TintColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TintOpacityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.AcrylicBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IAcrylicBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAcrylicBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TintOpacityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TintTransitionDurationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.AcrylicBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IAcrylicBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAcrylicBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TintTransitionDurationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AlwaysUseFallbackProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.AcrylicBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IAcrylicBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAcrylicBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlwaysUseFallbackProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AcrylicBrush

   function get_BackgroundSource
   (
      this : in out AcrylicBrush
   )
   return WinUI3.Windows.UI.Xaml.Media.AcrylicBackgroundSource is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.AcrylicBackgroundSource;
   begin
      Hr := this.m_IAcrylicBrush.all.get_BackgroundSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSource
   (
      this : in out AcrylicBrush;
      value : WinUI3.Windows.UI.Xaml.Media.AcrylicBackgroundSource
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAcrylicBrush.all.put_BackgroundSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TintColor
   (
      this : in out AcrylicBrush
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IAcrylicBrush.all.get_TintColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TintColor
   (
      this : in out AcrylicBrush;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAcrylicBrush.all.put_TintColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TintOpacity
   (
      this : in out AcrylicBrush
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAcrylicBrush.all.get_TintOpacity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TintOpacity
   (
      this : in out AcrylicBrush;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAcrylicBrush.all.put_TintOpacity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TintTransitionDuration
   (
      this : in out AcrylicBrush
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IAcrylicBrush.all.get_TintTransitionDuration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TintTransitionDuration
   (
      this : in out AcrylicBrush;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAcrylicBrush.all.put_TintTransitionDuration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AlwaysUseFallback
   (
      this : in out AcrylicBrush
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAcrylicBrush.all.get_AlwaysUseFallback (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AlwaysUseFallback
   (
      this : in out AcrylicBrush;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAcrylicBrush.all.put_AlwaysUseFallback (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TintLuminosityOpacity
   (
      this : in out AcrylicBrush
   )
   return IReference_Double.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IAcrylicBrush2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IAcrylicBrush_Interface, WinUI3.Windows.UI.Xaml.Media.IAcrylicBrush2, WinUI3.Windows.UI.Xaml.Media.IID_IAcrylicBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAcrylicBrush.all);
      Hr := m_Interface.get_TintLuminosityOpacity (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_TintLuminosityOpacity
   (
      this : in out AcrylicBrush;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IAcrylicBrush2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IAcrylicBrush_Interface, WinUI3.Windows.UI.Xaml.Media.IAcrylicBrush2, WinUI3.Windows.UI.Xaml.Media.IID_IAcrylicBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAcrylicBrush.all);
      Hr := m_Interface.put_TintLuminosityOpacity (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PathSegment

   procedure Initialize (this : in out PathSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out PathSegment) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPathSegment, IPathSegment_Ptr);
   begin
      if this.m_IPathSegment /= null then
         if this.m_IPathSegment.all /= null then
            temp := this.m_IPathSegment.all.Release;
            Free (this.m_IPathSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PathSegment

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PathSegment

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ArcSegment

   procedure Initialize (this : in out ArcSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out ArcSegment) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IArcSegment, IArcSegment_Ptr);
   begin
      if this.m_IArcSegment /= null then
         if this.m_IArcSegment.all /= null then
            temp := this.m_IArcSegment.all.Release;
            Free (this.m_IArcSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ArcSegment

   function Constructor return ArcSegment is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ArcSegment");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IArcSegment;
   begin
      return RetVal : ArcSegment do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IArcSegment := new WinUI3.Windows.UI.Xaml.Media.IArcSegment;
            Retval.m_IArcSegment.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ArcSegment

   function get_PointProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ArcSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IArcSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IArcSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SizeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ArcSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IArcSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IArcSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RotationAngleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ArcSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IArcSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IArcSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RotationAngleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsLargeArcProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ArcSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IArcSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IArcSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsLargeArcProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SweepDirectionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ArcSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IArcSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IArcSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SweepDirectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ArcSegment

   function get_Point
   (
      this : in out ArcSegment
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IArcSegment.all.get_Point (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Point
   (
      this : in out ArcSegment;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IArcSegment.all.put_Point (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Size
   (
      this : in out ArcSegment
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := this.m_IArcSegment.all.get_Size (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Size
   (
      this : in out ArcSegment;
      value : WinUI3.Windows.Foundation.Size
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IArcSegment.all.put_Size (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngle
   (
      this : in out ArcSegment
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IArcSegment.all.get_RotationAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngle
   (
      this : in out ArcSegment;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IArcSegment.all.put_RotationAngle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsLargeArc
   (
      this : in out ArcSegment
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IArcSegment.all.get_IsLargeArc (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsLargeArc
   (
      this : in out ArcSegment;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IArcSegment.all.put_IsLargeArc (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SweepDirection
   (
      this : in out ArcSegment
   )
   return WinUI3.Windows.UI.Xaml.Media.SweepDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.SweepDirection;
   begin
      Hr := this.m_IArcSegment.all.get_SweepDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SweepDirection
   (
      this : in out ArcSegment;
      value : WinUI3.Windows.UI.Xaml.Media.SweepDirection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IArcSegment.all.put_SweepDirection (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BezierSegment

   procedure Initialize (this : in out BezierSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out BezierSegment) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBezierSegment, IBezierSegment_Ptr);
   begin
      if this.m_IBezierSegment /= null then
         if this.m_IBezierSegment.all /= null then
            temp := this.m_IBezierSegment.all.Release;
            Free (this.m_IBezierSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BezierSegment

   function Constructor return BezierSegment is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.BezierSegment");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IBezierSegment;
   begin
      return RetVal : BezierSegment do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IBezierSegment := new WinUI3.Windows.UI.Xaml.Media.IBezierSegment;
            Retval.m_IBezierSegment.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BezierSegment

   function get_Point1Property
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.BezierSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IBezierSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBezierSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Point1Property (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Point2Property
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.BezierSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IBezierSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBezierSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Point2Property (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Point3Property
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.BezierSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IBezierSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBezierSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Point3Property (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BezierSegment

   function get_Point1
   (
      this : in out BezierSegment
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IBezierSegment.all.get_Point1 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Point1
   (
      this : in out BezierSegment;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBezierSegment.all.put_Point1 (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Point2
   (
      this : in out BezierSegment
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IBezierSegment.all.get_Point2 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Point2
   (
      this : in out BezierSegment;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBezierSegment.all.put_Point2 (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Point3
   (
      this : in out BezierSegment
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IBezierSegment.all.get_Point3 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Point3
   (
      this : in out BezierSegment;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBezierSegment.all.put_Point3 (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CacheMode

   procedure Initialize (this : in out CacheMode) is
   begin
      null;
   end;

   procedure Finalize (this : in out CacheMode) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICacheMode, ICacheMode_Ptr);
   begin
      if this.m_ICacheMode /= null then
         if this.m_ICacheMode.all /= null then
            temp := this.m_ICacheMode.all.Release;
            Free (this.m_ICacheMode);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CacheMode

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CacheMode is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CacheMode");
      m_Factory    : access ICacheModeFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ICacheMode;
   begin
      return RetVal : CacheMode do
         Hr := RoGetActivationFactory (m_hString, IID_ICacheModeFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICacheMode := new WinUI3.Windows.UI.Xaml.Media.ICacheMode;
            Retval.m_ICacheMode.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CacheMode

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BitmapCache

   procedure Initialize (this : in out BitmapCache) is
   begin
      null;
   end;

   procedure Finalize (this : in out BitmapCache) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBitmapCache, IBitmapCache_Ptr);
   begin
      if this.m_IBitmapCache /= null then
         if this.m_IBitmapCache.all /= null then
            temp := this.m_IBitmapCache.all.Release;
            Free (this.m_IBitmapCache);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BitmapCache

   function Constructor return BitmapCache is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.BitmapCache");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IBitmapCache;
   begin
      return RetVal : BitmapCache do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IBitmapCache := new WinUI3.Windows.UI.Xaml.Media.IBitmapCache;
            Retval.m_IBitmapCache.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BitmapCache

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BrushCollection

   procedure Initialize (this : in out BrushCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out BrushCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BrushCollection

   function Constructor return BrushCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.BrushCollection");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : BrushCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BrushCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.Brush>
   function GetAt
   (
      this : in out BrushCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out BrushCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out BrushCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out BrushCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IBrush.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out BrushCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out BrushCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out BrushCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out BrushCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out BrushCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out BrushCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out BrushCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.IBrush_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out BrushCollection;
      items : WinUI3.Windows.UI.Xaml.Media.IBrush_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2832041188, 16095, 20850, (143, 119, 16, 233, 16, 229, 220, 93 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IBrush.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.Brush>
   function First
   (
      this : in out BrushCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IBrush.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      m_GenericIID     : aliased WinUI3.IID := (2961085141, 1715, 24018, (141, 73, 52, 159, 251, 216, 70, 52 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IBrush.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GeneralTransform

   procedure Initialize (this : in out GeneralTransform) is
   begin
      null;
   end;

   procedure Finalize (this : in out GeneralTransform) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeneralTransform, IGeneralTransform_Ptr);
   begin
      if this.m_IGeneralTransform /= null then
         if this.m_IGeneralTransform.all /= null then
            temp := this.m_IGeneralTransform.all.Release;
            Free (this.m_IGeneralTransform);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GeneralTransform

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GeneralTransform is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GeneralTransform");
      m_Factory    : access IGeneralTransformFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IGeneralTransform;
   begin
      return RetVal : GeneralTransform do
         Hr := RoGetActivationFactory (m_hString, IID_IGeneralTransformFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGeneralTransform := new WinUI3.Windows.UI.Xaml.Media.IGeneralTransform;
            Retval.m_IGeneralTransform.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GeneralTransform

   function get_Inverse
   (
      this : in out GeneralTransform
   )
   return WinUI3.Windows.UI.Xaml.Media.GeneralTransform'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGeneralTransform;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.GeneralTransform do
         Hr := this.m_IGeneralTransform.all.get_Inverse (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeneralTransform := new WinUI3.Windows.UI.Xaml.Media.IGeneralTransform;
         Retval.m_IGeneralTransform.all := m_ComRetVal;
      end return;
   end;

   function TransformPoint
   (
      this : in out GeneralTransform;
      point : WinUI3.Windows.Foundation.Point
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IGeneralTransform.all.TransformPoint (point, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryTransform
   (
      this : in out GeneralTransform;
      inPoint : WinUI3.Windows.Foundation.Point;
      outPoint : WinUI3.Windows.Foundation.Point_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGeneralTransform.all.TryTransform (inPoint, outPoint, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TransformBounds
   (
      this : in out GeneralTransform;
      rect : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IGeneralTransform.all.TransformBounds (rect, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_InverseCore
   (
      this : in out GeneralTransform
   )
   return WinUI3.Windows.UI.Xaml.Media.GeneralTransform'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IGeneralTransformOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGeneralTransform;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IGeneralTransform_Interface, WinUI3.Windows.UI.Xaml.Media.IGeneralTransformOverrides, WinUI3.Windows.UI.Xaml.Media.IID_IGeneralTransformOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.GeneralTransform do
         m_Interface := QInterface (this.m_IGeneralTransform.all);
         Hr := m_Interface.get_InverseCore (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeneralTransform := new WinUI3.Windows.UI.Xaml.Media.IGeneralTransform;
         Retval.m_IGeneralTransform.all := m_ComRetVal;
      end return;
   end;

   function TryTransformCore
   (
      this : in out GeneralTransform;
      inPoint : WinUI3.Windows.Foundation.Point;
      outPoint : WinUI3.Windows.Foundation.Point_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IGeneralTransformOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IGeneralTransform_Interface, WinUI3.Windows.UI.Xaml.Media.IGeneralTransformOverrides, WinUI3.Windows.UI.Xaml.Media.IID_IGeneralTransformOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeneralTransform.all);
      Hr := m_Interface.TryTransformCore (inPoint, outPoint, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TransformBoundsCore
   (
      this : in out GeneralTransform;
      rect : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IGeneralTransformOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IGeneralTransform_Interface, WinUI3.Windows.UI.Xaml.Media.IGeneralTransformOverrides, WinUI3.Windows.UI.Xaml.Media.IID_IGeneralTransformOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeneralTransform.all);
      Hr := m_Interface.TransformBoundsCore (rect, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Transform

   procedure Initialize (this : in out Transform) is
   begin
      null;
   end;

   procedure Finalize (this : in out Transform) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITransform, ITransform_Ptr);
   begin
      if this.m_ITransform /= null then
         if this.m_ITransform.all /= null then
            temp := this.m_ITransform.all.Release;
            Free (this.m_ITransform);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Transform

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Transform

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositeTransform

   procedure Initialize (this : in out CompositeTransform) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositeTransform) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositeTransform, ICompositeTransform_Ptr);
   begin
      if this.m_ICompositeTransform /= null then
         if this.m_ICompositeTransform.all /= null then
            temp := this.m_ICompositeTransform.all.Release;
            Free (this.m_ICompositeTransform);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositeTransform

   function Constructor return CompositeTransform is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositeTransform");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ICompositeTransform;
   begin
      return RetVal : CompositeTransform do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICompositeTransform := new WinUI3.Windows.UI.Xaml.Media.ICompositeTransform;
            Retval.m_ICompositeTransform.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CompositeTransform

   function get_CenterXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositeTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositeTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositeTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CenterYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositeTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositeTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositeTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScaleXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositeTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositeTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositeTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScaleXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScaleYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositeTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositeTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositeTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScaleYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SkewXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositeTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositeTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositeTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SkewXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SkewYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositeTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositeTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositeTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SkewYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RotationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositeTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositeTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositeTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RotationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TranslateXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositeTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositeTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositeTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TranslateXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TranslateYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositeTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositeTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositeTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TranslateYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositeTransform

   function get_CenterX
   (
      this : in out CompositeTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICompositeTransform.all.get_CenterX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterX
   (
      this : in out CompositeTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositeTransform.all.put_CenterX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterY
   (
      this : in out CompositeTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICompositeTransform.all.get_CenterY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterY
   (
      this : in out CompositeTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositeTransform.all.put_CenterY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScaleX
   (
      this : in out CompositeTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICompositeTransform.all.get_ScaleX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ScaleX
   (
      this : in out CompositeTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositeTransform.all.put_ScaleX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScaleY
   (
      this : in out CompositeTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICompositeTransform.all.get_ScaleY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ScaleY
   (
      this : in out CompositeTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositeTransform.all.put_ScaleY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SkewX
   (
      this : in out CompositeTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICompositeTransform.all.get_SkewX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SkewX
   (
      this : in out CompositeTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositeTransform.all.put_SkewX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SkewY
   (
      this : in out CompositeTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICompositeTransform.all.get_SkewY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SkewY
   (
      this : in out CompositeTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositeTransform.all.put_SkewY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Rotation
   (
      this : in out CompositeTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICompositeTransform.all.get_Rotation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Rotation
   (
      this : in out CompositeTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositeTransform.all.put_Rotation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TranslateX
   (
      this : in out CompositeTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICompositeTransform.all.get_TranslateX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TranslateX
   (
      this : in out CompositeTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositeTransform.all.put_TranslateX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TranslateY
   (
      this : in out CompositeTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICompositeTransform.all.get_TranslateY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TranslateY
   (
      this : in out CompositeTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositeTransform.all.put_TranslateY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionTarget

   procedure Initialize (this : in out CompositionTarget) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionTarget) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionTarget, ICompositionTarget_Ptr);
   begin
      if this.m_ICompositionTarget /= null then
         if this.m_ICompositionTarget.all /= null then
            temp := this.m_ICompositionTarget.all.Release;
            Free (this.m_ICompositionTarget);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CompositionTarget

   function add_Rendered
   (
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositionTarget");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositionTargetStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompositionTargetStatics3'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_Rendered (handler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_Rendered
   (
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositionTarget");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositionTargetStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompositionTargetStatics3'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_Rendered (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function add_Rendering
   (
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositionTarget");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositionTargetStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompositionTargetStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_Rendering (handler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_Rendering
   (
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositionTarget");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositionTargetStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompositionTargetStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_Rendering (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function add_SurfaceContentsLost
   (
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositionTarget");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositionTargetStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompositionTargetStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_SurfaceContentsLost (handler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_SurfaceContentsLost
   (
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.CompositionTarget");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ICompositionTargetStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompositionTargetStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_SurfaceContentsLost (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionTarget

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DoubleCollection

   procedure Initialize (this : in out DoubleCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out DoubleCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DoubleCollection

   function Constructor return DoubleCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.DoubleCollection");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : DoubleCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DoubleCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<System.Double>
   function GetAt
   (
      this : in out DoubleCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out DoubleCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out DoubleCollection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IndexOf
   (
      this : in out DoubleCollection;
      value : WinUI3.Double;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out DoubleCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out DoubleCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out DoubleCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out DoubleCollection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out DoubleCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out DoubleCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out DoubleCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Double_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out DoubleCollection;
      items : WinUI3.Double_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (4099068476, 48901, 24382, (136, 231, 209, 122, 103, 22, 185, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Double.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<System.Double>
   function First
   (
      this : in out DoubleCollection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_Double.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      m_GenericIID     : aliased WinUI3.IID := (3342374478, 40036, 23502, (181, 206, 97, 233, 162, 130, 236, 74 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_Double.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.First (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Geometry

   procedure Initialize (this : in out Geometry) is
   begin
      null;
   end;

   procedure Finalize (this : in out Geometry) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeometry, IGeometry_Ptr);
   begin
      if this.m_IGeometry /= null then
         if this.m_IGeometry.all /= null then
            temp := this.m_IGeometry.all.Release;
            Free (this.m_IGeometry);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Geometry

   -----------------------------------------------------------------------------
   -- Static Interfaces for Geometry

   function get_Empty
   return WinUI3.Windows.UI.Xaml.Media.Geometry is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Geometry");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IGeometryStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGeometry;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Geometry do
         Hr := RoGetActivationFactory (m_hString, IID_IGeometryStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Empty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IGeometry := new WinUI3.Windows.UI.Xaml.Media.IGeometry;
            Retval.m_IGeometry.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StandardFlatteningTolerance
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Geometry");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IGeometryStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGeometryStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_StandardFlatteningTolerance (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_TransformProperty_Geometry
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Geometry");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IGeometryStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGeometryStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TransformProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Geometry

   function get_Transform
   (
      this : in out Geometry
   )
   return WinUI3.Windows.UI.Xaml.Media.Transform'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ITransform;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Transform do
         Hr := this.m_IGeometry.all.get_Transform (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITransform := new WinUI3.Windows.UI.Xaml.Media.ITransform;
         Retval.m_ITransform.all := m_ComRetVal;
      end return;
   end;

   procedure put_Transform
   (
      this : in out Geometry;
      value : WinUI3.Windows.UI.Xaml.Media.Transform'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGeometry.all.put_Transform (value.m_ITransform.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Bounds
   (
      this : in out Geometry
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IGeometry.all.get_Bounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EllipseGeometry

   procedure Initialize (this : in out EllipseGeometry) is
   begin
      null;
   end;

   procedure Finalize (this : in out EllipseGeometry) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEllipseGeometry, IEllipseGeometry_Ptr);
   begin
      if this.m_IEllipseGeometry /= null then
         if this.m_IEllipseGeometry.all /= null then
            temp := this.m_IEllipseGeometry.all.Release;
            Free (this.m_IEllipseGeometry);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for EllipseGeometry

   function Constructor return EllipseGeometry is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.EllipseGeometry");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IEllipseGeometry;
   begin
      return RetVal : EllipseGeometry do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IEllipseGeometry := new WinUI3.Windows.UI.Xaml.Media.IEllipseGeometry;
            Retval.m_IEllipseGeometry.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for EllipseGeometry

   function get_CenterProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.EllipseGeometry");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IEllipseGeometryStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEllipseGeometryStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RadiusXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.EllipseGeometry");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IEllipseGeometryStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEllipseGeometryStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RadiusXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RadiusYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.EllipseGeometry");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IEllipseGeometryStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IEllipseGeometryStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RadiusYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EllipseGeometry

   function get_Center
   (
      this : in out EllipseGeometry
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IEllipseGeometry.all.get_Center (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Center
   (
      this : in out EllipseGeometry;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEllipseGeometry.all.put_Center (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RadiusX
   (
      this : in out EllipseGeometry
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IEllipseGeometry.all.get_RadiusX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RadiusX
   (
      this : in out EllipseGeometry;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEllipseGeometry.all.put_RadiusX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RadiusY
   (
      this : in out EllipseGeometry
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IEllipseGeometry.all.get_RadiusY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RadiusY
   (
      this : in out EllipseGeometry;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEllipseGeometry.all.put_RadiusY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FontFamily

   procedure Initialize (this : in out FontFamily) is
   begin
      null;
   end;

   procedure Finalize (this : in out FontFamily) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFontFamily, IFontFamily_Ptr);
   begin
      if this.m_IFontFamily /= null then
         if this.m_IFontFamily.all /= null then
            temp := this.m_IFontFamily.all.Release;
            Free (this.m_IFontFamily);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FontFamily

   function Constructor
   (
      familyName : WinUI3.WString;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FontFamily is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.FontFamily");
      m_Factory    : access IFontFamilyFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
      HStr_familyName : constant WinUI3.HString := To_HString (familyName);
   begin
      return RetVal : FontFamily do
         Hr := RoGetActivationFactory (m_hString, IID_IFontFamilyFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithName (HStr_familyName, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
            Retval.m_IFontFamily.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_familyName);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FontFamily

   function get_XamlAutoFontFamily
   return WinUI3.Windows.UI.Xaml.Media.FontFamily is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.FontFamily");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IFontFamilyStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.FontFamily do
         Hr := RoGetActivationFactory (m_hString, IID_IFontFamilyStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XamlAutoFontFamily (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
            Retval.m_IFontFamily.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FontFamily

   function get_Source
   (
      this : in out FontFamily
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFontFamily.all.get_Source (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GeometryCollection

   procedure Initialize (this : in out GeometryCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out GeometryCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GeometryCollection

   function Constructor return GeometryCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GeometryCollection");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : GeometryCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GeometryCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.Geometry>
   function GetAt
   (
      this : in out GeometryCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.Geometry'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGeometry;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Geometry do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeometry := new WinUI3.Windows.UI.Xaml.Media.IGeometry;
         Retval.m_IGeometry.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out GeometryCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out GeometryCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Geometry'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGeometry;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Geometry do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeometry := new WinUI3.Windows.UI.Xaml.Media.IGeometry;
         Retval.m_IGeometry.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out GeometryCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Geometry'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IGeometry.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out GeometryCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Geometry'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IGeometry.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out GeometryCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Geometry'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IGeometry.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out GeometryCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out GeometryCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Geometry'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IGeometry.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out GeometryCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out GeometryCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out GeometryCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.IGeometry_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out GeometryCollection;
      items : WinUI3.Windows.UI.Xaml.Media.IGeometry_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2227612730, 33287, 21913, (149, 131, 96, 106, 194, 19, 157, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGeometry.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.Geometry>
   function First
   (
      this : in out GeometryCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Geometry'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IGeometry.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGeometry;
      m_GenericIID     : aliased WinUI3.IID := (892600377, 3580, 21172, (135, 72, 13, 154, 117, 93, 184, 168 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IGeometry.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Geometry do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeometry := new WinUI3.Windows.UI.Xaml.Media.IGeometry;
         Retval.m_IGeometry.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GeometryGroup

   procedure Initialize (this : in out GeometryGroup) is
   begin
      null;
   end;

   procedure Finalize (this : in out GeometryGroup) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeometryGroup, IGeometryGroup_Ptr);
   begin
      if this.m_IGeometryGroup /= null then
         if this.m_IGeometryGroup.all /= null then
            temp := this.m_IGeometryGroup.all.Release;
            Free (this.m_IGeometryGroup);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GeometryGroup

   function Constructor return GeometryGroup is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GeometryGroup");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IGeometryGroup;
   begin
      return RetVal : GeometryGroup do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IGeometryGroup := new WinUI3.Windows.UI.Xaml.Media.IGeometryGroup;
            Retval.m_IGeometryGroup.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for GeometryGroup

   function get_FillRuleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GeometryGroup");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IGeometryGroupStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGeometryGroupStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FillRuleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ChildrenProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GeometryGroup");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IGeometryGroupStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGeometryGroupStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildrenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GeometryGroup

   function get_FillRule
   (
      this : in out GeometryGroup
   )
   return WinUI3.Windows.UI.Xaml.Media.FillRule is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.FillRule;
   begin
      Hr := this.m_IGeometryGroup.all.get_FillRule (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FillRule
   (
      this : in out GeometryGroup;
      value : WinUI3.Windows.UI.Xaml.Media.FillRule
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGeometryGroup.all.put_FillRule (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Children
   (
      this : in out GeometryGroup
   )
   return WinUI3.Windows.UI.Xaml.Media.GeometryCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.GeometryCollection do
         Hr := this.m_IGeometryGroup.all.get_Children (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_Children
   (
      this : in out GeometryGroup;
      value : WinUI3.Windows.UI.Xaml.Media.GeometryCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGeometryGroup.all.put_Children (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GradientBrush

   procedure Initialize (this : in out GradientBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out GradientBrush) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGradientBrush, IGradientBrush_Ptr);
   begin
      if this.m_IGradientBrush /= null then
         if this.m_IGradientBrush.all /= null then
            temp := this.m_IGradientBrush.all.Release;
            Free (this.m_IGradientBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GradientBrush

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GradientBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GradientBrush");
      m_Factory    : access IGradientBrushFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IGradientBrush;
   begin
      return RetVal : GradientBrush do
         Hr := RoGetActivationFactory (m_hString, IID_IGradientBrushFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGradientBrush := new WinUI3.Windows.UI.Xaml.Media.IGradientBrush;
            Retval.m_IGradientBrush.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for GradientBrush

   function get_SpreadMethodProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GradientBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IGradientBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGradientBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SpreadMethodProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MappingModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GradientBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IGradientBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGradientBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MappingModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ColorInterpolationModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GradientBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IGradientBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGradientBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorInterpolationModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GradientStopsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GradientBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IGradientBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGradientBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GradientStopsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GradientBrush

   function get_SpreadMethod
   (
      this : in out GradientBrush
   )
   return WinUI3.Windows.UI.Xaml.Media.GradientSpreadMethod is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.GradientSpreadMethod;
   begin
      Hr := this.m_IGradientBrush.all.get_SpreadMethod (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SpreadMethod
   (
      this : in out GradientBrush;
      value : WinUI3.Windows.UI.Xaml.Media.GradientSpreadMethod
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGradientBrush.all.put_SpreadMethod (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MappingMode
   (
      this : in out GradientBrush
   )
   return WinUI3.Windows.UI.Xaml.Media.BrushMappingMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.BrushMappingMode;
   begin
      Hr := this.m_IGradientBrush.all.get_MappingMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MappingMode
   (
      this : in out GradientBrush;
      value : WinUI3.Windows.UI.Xaml.Media.BrushMappingMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGradientBrush.all.put_MappingMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ColorInterpolationMode
   (
      this : in out GradientBrush
   )
   return WinUI3.Windows.UI.Xaml.Media.ColorInterpolationMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ColorInterpolationMode;
   begin
      Hr := this.m_IGradientBrush.all.get_ColorInterpolationMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ColorInterpolationMode
   (
      this : in out GradientBrush;
      value : WinUI3.Windows.UI.Xaml.Media.ColorInterpolationMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGradientBrush.all.put_ColorInterpolationMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GradientStops
   (
      this : in out GradientBrush
   )
   return WinUI3.Windows.UI.Xaml.Media.GradientStopCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.GradientStopCollection do
         Hr := this.m_IGradientBrush.all.get_GradientStops (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_GradientStops
   (
      this : in out GradientBrush;
      value : WinUI3.Windows.UI.Xaml.Media.GradientStopCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGradientBrush.all.put_GradientStops (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GradientStop

   procedure Initialize (this : in out GradientStop) is
   begin
      null;
   end;

   procedure Finalize (this : in out GradientStop) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGradientStop, IGradientStop_Ptr);
   begin
      if this.m_IGradientStop /= null then
         if this.m_IGradientStop.all /= null then
            temp := this.m_IGradientStop.all.Release;
            Free (this.m_IGradientStop);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GradientStop

   function Constructor return GradientStop is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GradientStop");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IGradientStop;
   begin
      return RetVal : GradientStop do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IGradientStop := new WinUI3.Windows.UI.Xaml.Media.IGradientStop;
            Retval.m_IGradientStop.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for GradientStop

   function get_ColorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GradientStop");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IGradientStopStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGradientStopStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GradientStop");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IGradientStopStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGradientStopStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GradientStop

   function get_Color
   (
      this : in out GradientStop
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IGradientStop.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out GradientStop;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGradientStop.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out GradientStop
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IGradientStop.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out GradientStop;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGradientStop.all.put_Offset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GradientStopCollection

   procedure Initialize (this : in out GradientStopCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out GradientStopCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GradientStopCollection

   function Constructor return GradientStopCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.GradientStopCollection");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : GradientStopCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GradientStopCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.GradientStop>
   function GetAt
   (
      this : in out GradientStopCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.GradientStop'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGradientStop;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.GradientStop do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGradientStop := new WinUI3.Windows.UI.Xaml.Media.IGradientStop;
         Retval.m_IGradientStop.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out GradientStopCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out GradientStopCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.GradientStop'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGradientStop;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.GradientStop do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGradientStop := new WinUI3.Windows.UI.Xaml.Media.IGradientStop;
         Retval.m_IGradientStop.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out GradientStopCollection;
      value : WinUI3.Windows.UI.Xaml.Media.GradientStop'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IGradientStop.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out GradientStopCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.GradientStop'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IGradientStop.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out GradientStopCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.GradientStop'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IGradientStop.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out GradientStopCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out GradientStopCollection;
      value : WinUI3.Windows.UI.Xaml.Media.GradientStop'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IGradientStop.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out GradientStopCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out GradientStopCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out GradientStopCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.IGradientStop_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out GradientStopCollection;
      items : WinUI3.Windows.UI.Xaml.Media.IGradientStop_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (859975076, 9459, 23378, (158, 141, 17, 221, 113, 240, 139, 177 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.GradientStop>
   function First
   (
      this : in out GradientStopCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.GradientStop'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IGradientStop.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGradientStop;
      m_GenericIID     : aliased WinUI3.IID := (2433072019, 44070, 23470, (140, 30, 223, 142, 207, 0, 222, 230 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.GradientStop do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGradientStop := new WinUI3.Windows.UI.Xaml.Media.IGradientStop;
         Retval.m_IGradientStop.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ImageBrush

   procedure Initialize (this : in out ImageBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out ImageBrush) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IImageBrush, IImageBrush_Ptr);
   begin
      if this.m_IImageBrush /= null then
         if this.m_IImageBrush.all /= null then
            temp := this.m_IImageBrush.all.Release;
            Free (this.m_IImageBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ImageBrush

   function Constructor return ImageBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ImageBrush");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IImageBrush;
   begin
      return RetVal : ImageBrush do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IImageBrush := new WinUI3.Windows.UI.Xaml.Media.IImageBrush;
            Retval.m_IImageBrush.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ImageBrush

   function get_ImageSourceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ImageBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IImageBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IImageBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ImageSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ImageBrush

   function get_ImageSource
   (
      this : in out ImageBrush
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IImageBrush.all.get_ImageSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_ImageSource
   (
      this : in out ImageBrush;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImageBrush.all.put_ImageSource (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ImageFailed
   (
      this : in out ImageBrush;
      handler : WinUI3.Windows.UI.Xaml.ExceptionRoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IImageBrush.all.add_ImageFailed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ImageFailed
   (
      this : in out ImageBrush;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImageBrush.all.remove_ImageFailed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ImageOpened
   (
      this : in out ImageBrush;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IImageBrush.all.add_ImageOpened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ImageOpened
   (
      this : in out ImageBrush;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImageBrush.all.remove_ImageOpened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ImageSource

   procedure Initialize (this : in out ImageSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out ImageSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IImageSource, IImageSource_Ptr);
   begin
      if this.m_IImageSource /= null then
         if this.m_IImageSource.all /= null then
            temp := this.m_IImageSource.all.Release;
            Free (this.m_IImageSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ImageSource

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ImageSource

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LineGeometry

   procedure Initialize (this : in out LineGeometry) is
   begin
      null;
   end;

   procedure Finalize (this : in out LineGeometry) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILineGeometry, ILineGeometry_Ptr);
   begin
      if this.m_ILineGeometry /= null then
         if this.m_ILineGeometry.all /= null then
            temp := this.m_ILineGeometry.all.Release;
            Free (this.m_ILineGeometry);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LineGeometry

   function Constructor return LineGeometry is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LineGeometry");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ILineGeometry;
   begin
      return RetVal : LineGeometry do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ILineGeometry := new WinUI3.Windows.UI.Xaml.Media.ILineGeometry;
            Retval.m_ILineGeometry.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for LineGeometry

   function get_StartPointProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LineGeometry");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ILineGeometryStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILineGeometryStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StartPointProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_EndPointProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LineGeometry");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ILineGeometryStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILineGeometryStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EndPointProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LineGeometry

   function get_StartPoint
   (
      this : in out LineGeometry
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_ILineGeometry.all.get_StartPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StartPoint
   (
      this : in out LineGeometry;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILineGeometry.all.put_StartPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EndPoint
   (
      this : in out LineGeometry
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_ILineGeometry.all.get_EndPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EndPoint
   (
      this : in out LineGeometry;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILineGeometry.all.put_EndPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LineSegment

   procedure Initialize (this : in out LineSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out LineSegment) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILineSegment, ILineSegment_Ptr);
   begin
      if this.m_ILineSegment /= null then
         if this.m_ILineSegment.all /= null then
            temp := this.m_ILineSegment.all.Release;
            Free (this.m_ILineSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LineSegment

   function Constructor return LineSegment is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LineSegment");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ILineSegment;
   begin
      return RetVal : LineSegment do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ILineSegment := new WinUI3.Windows.UI.Xaml.Media.ILineSegment;
            Retval.m_ILineSegment.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for LineSegment

   function get_PointProperty_LineSegment
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LineSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ILineSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILineSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LineSegment

   function get_Point
   (
      this : in out LineSegment
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_ILineSegment.all.get_Point (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Point
   (
      this : in out LineSegment;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILineSegment.all.put_Point (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LinearGradientBrush

   procedure Initialize (this : in out LinearGradientBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out LinearGradientBrush) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILinearGradientBrush, ILinearGradientBrush_Ptr);
   begin
      if this.m_ILinearGradientBrush /= null then
         if this.m_ILinearGradientBrush.all /= null then
            temp := this.m_ILinearGradientBrush.all.Release;
            Free (this.m_ILinearGradientBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LinearGradientBrush

   function Constructor
   (
      gradientStopCollection_p : WinUI3.Windows.UI.Xaml.Media.GradientStopCollection'Class;
      angle : WinUI3.Double
   )
   return LinearGradientBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LinearGradientBrush");
      m_Factory    : access ILinearGradientBrushFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ILinearGradientBrush;
   begin
      return RetVal : LinearGradientBrush do
         Hr := RoGetActivationFactory (m_hString, IID_ILinearGradientBrushFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithGradientStopCollectionAndAngle (gradientStopCollection_p.m_GenericObject.all, angle, m_ComRetVal'Access);
            Retval.m_ILinearGradientBrush := new WinUI3.Windows.UI.Xaml.Media.ILinearGradientBrush;
            Retval.m_ILinearGradientBrush.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor return LinearGradientBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LinearGradientBrush");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ILinearGradientBrush;
   begin
      return RetVal : LinearGradientBrush do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ILinearGradientBrush := new WinUI3.Windows.UI.Xaml.Media.ILinearGradientBrush;
            Retval.m_ILinearGradientBrush.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for LinearGradientBrush

   function get_StartPointProperty_LinearGradientBrush
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LinearGradientBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ILinearGradientBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILinearGradientBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StartPointProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_EndPointProperty_LinearGradientBrush
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LinearGradientBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ILinearGradientBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ILinearGradientBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EndPointProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LinearGradientBrush

   function get_StartPoint
   (
      this : in out LinearGradientBrush
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_ILinearGradientBrush.all.get_StartPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StartPoint
   (
      this : in out LinearGradientBrush;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinearGradientBrush.all.put_StartPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EndPoint
   (
      this : in out LinearGradientBrush
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_ILinearGradientBrush.all.get_EndPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EndPoint
   (
      this : in out LinearGradientBrush;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILinearGradientBrush.all.put_EndPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LoadedImageSourceLoadCompletedEventArgs

   procedure Initialize (this : in out LoadedImageSourceLoadCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out LoadedImageSourceLoadCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILoadedImageSourceLoadCompletedEventArgs, ILoadedImageSourceLoadCompletedEventArgs_Ptr);
   begin
      if this.m_ILoadedImageSourceLoadCompletedEventArgs /= null then
         if this.m_ILoadedImageSourceLoadCompletedEventArgs.all /= null then
            temp := this.m_ILoadedImageSourceLoadCompletedEventArgs.all.Release;
            Free (this.m_ILoadedImageSourceLoadCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LoadedImageSourceLoadCompletedEventArgs

   function get_Status
   (
      this : in out LoadedImageSourceLoadCompletedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Media.LoadedImageSourceLoadStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.LoadedImageSourceLoadStatus;
   begin
      Hr := this.m_ILoadedImageSourceLoadCompletedEventArgs.all.get_Status (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LoadedImageSurface

   procedure Initialize (this : in out LoadedImageSurface) is
   begin
      null;
   end;

   procedure Finalize (this : in out LoadedImageSurface) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILoadedImageSurface, ILoadedImageSurface_Ptr);
   begin
      if this.m_ILoadedImageSurface /= null then
         if this.m_ILoadedImageSurface.all /= null then
            temp := this.m_ILoadedImageSurface.all.Release;
            Free (this.m_ILoadedImageSurface);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for LoadedImageSurface

   function StartLoadFromUri
   (
      uri : WinUI3.Windows.Foundation.Uri'Class;
      desiredMaxSize : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Windows.UI.Xaml.Media.LoadedImageSurface is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LoadedImageSurface");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurfaceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurface;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.LoadedImageSurface do
         Hr := RoGetActivationFactory (m_hString, IID_ILoadedImageSurfaceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.StartLoadFromUri (uri.m_IUriRuntimeClass.all, desiredMaxSize, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ILoadedImageSurface := new WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurface;
            Retval.m_ILoadedImageSurface.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function StartLoadFromUri
   (
      uri : WinUI3.Windows.Foundation.Uri'Class
   )
   return WinUI3.Windows.UI.Xaml.Media.LoadedImageSurface is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LoadedImageSurface");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurfaceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurface;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.LoadedImageSurface do
         Hr := RoGetActivationFactory (m_hString, IID_ILoadedImageSurfaceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.StartLoadFromUri (uri.m_IUriRuntimeClass.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ILoadedImageSurface := new WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurface;
            Retval.m_ILoadedImageSurface.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function StartLoadFromStream
   (
      stream : WinUI3.Windows.Storage.Streams.IRandomAccessStream;
      desiredMaxSize : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Windows.UI.Xaml.Media.LoadedImageSurface is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LoadedImageSurface");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurfaceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurface;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.LoadedImageSurface do
         Hr := RoGetActivationFactory (m_hString, IID_ILoadedImageSurfaceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.StartLoadFromStream (stream, desiredMaxSize, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ILoadedImageSurface := new WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurface;
            Retval.m_ILoadedImageSurface.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function StartLoadFromStream
   (
      stream : WinUI3.Windows.Storage.Streams.IRandomAccessStream
   )
   return WinUI3.Windows.UI.Xaml.Media.LoadedImageSurface is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.LoadedImageSurface");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurfaceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurface;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.LoadedImageSurface do
         Hr := RoGetActivationFactory (m_hString, IID_ILoadedImageSurfaceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.StartLoadFromStream (stream, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ILoadedImageSurface := new WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurface;
            Retval.m_ILoadedImageSurface.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LoadedImageSurface

   function get_DecodedPhysicalSize
   (
      this : in out LoadedImageSurface
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := this.m_ILoadedImageSurface.all.get_DecodedPhysicalSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DecodedSize
   (
      this : in out LoadedImageSurface
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := this.m_ILoadedImageSurface.all.get_DecodedSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NaturalSize
   (
      this : in out LoadedImageSurface
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := this.m_ILoadedImageSurface.all.get_NaturalSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_LoadCompleted
   (
      this : in out LoadedImageSurface;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ILoadedImageSurface.all.add_LoadCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_LoadCompleted
   (
      this : in out LoadedImageSurface;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ILoadedImageSurface.all.remove_LoadCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Close
   (
      this : in out LoadedImageSurface
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Foundation.IClosable := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.ILoadedImageSurface_Interface, WinUI3.Windows.Foundation.IClosable, WinUI3.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILoadedImageSurface.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Projection

   procedure Initialize (this : in out Projection) is
   begin
      null;
   end;

   procedure Finalize (this : in out Projection) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IProjection, IProjection_Ptr);
   begin
      if this.m_IProjection /= null then
         if this.m_IProjection.all /= null then
            temp := this.m_IProjection.all.Release;
            Free (this.m_IProjection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Projection

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Projection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Projection");
      m_Factory    : access IProjectionFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IProjection;
   begin
      return RetVal : Projection do
         Hr := RoGetActivationFactory (m_hString, IID_IProjectionFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IProjection := new WinUI3.Windows.UI.Xaml.Media.IProjection;
            Retval.m_IProjection.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Projection

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Matrix3DProjection

   procedure Initialize (this : in out Matrix3DProjection) is
   begin
      null;
   end;

   procedure Finalize (this : in out Matrix3DProjection) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMatrix3DProjection, IMatrix3DProjection_Ptr);
   begin
      if this.m_IMatrix3DProjection /= null then
         if this.m_IMatrix3DProjection.all /= null then
            temp := this.m_IMatrix3DProjection.all.Release;
            Free (this.m_IMatrix3DProjection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Matrix3DProjection

   function Constructor return Matrix3DProjection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Matrix3DProjection");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IMatrix3DProjection;
   begin
      return RetVal : Matrix3DProjection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMatrix3DProjection := new WinUI3.Windows.UI.Xaml.Media.IMatrix3DProjection;
            Retval.m_IMatrix3DProjection.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Matrix3DProjection

   function get_ProjectionMatrixProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.Matrix3DProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IMatrix3DProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMatrix3DProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ProjectionMatrixProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Matrix3DProjection

   function get_ProjectionMatrix
   (
      this : in out Matrix3DProjection
   )
   return WinUI3.Windows.UI.Xaml.Media.Media3D.Matrix3D is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Media3D.Matrix3D;
   begin
      Hr := this.m_IMatrix3DProjection.all.get_ProjectionMatrix (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ProjectionMatrix
   (
      this : in out Matrix3DProjection;
      value : WinUI3.Windows.UI.Xaml.Media.Media3D.Matrix3D
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMatrix3DProjection.all.put_ProjectionMatrix (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MatrixHelper

   procedure Initialize (this : in out MatrixHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out MatrixHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMatrixHelper, IMatrixHelper_Ptr);
   begin
      if this.m_IMatrixHelper /= null then
         if this.m_IMatrixHelper.all /= null then
            temp := this.m_IMatrixHelper.all.Release;
            Free (this.m_IMatrixHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MatrixHelper

   function get_Identity
   return WinUI3.Windows.UI.Xaml.Media.Matrix is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.MatrixHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IMatrixHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Matrix;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMatrixHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Identity (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromElements
   (
      m11 : WinUI3.Double;
      m12 : WinUI3.Double;
      m21 : WinUI3.Double;
      m22 : WinUI3.Double;
      offsetX : WinUI3.Double;
      offsetY : WinUI3.Double
   )
   return WinUI3.Windows.UI.Xaml.Media.Matrix is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.MatrixHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IMatrixHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Matrix;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMatrixHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromElements (m11, m12, m21, m22, offsetX, offsetY, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetIsIdentity
   (
      target : WinUI3.Windows.UI.Xaml.Media.Matrix
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.MatrixHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IMatrixHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMatrixHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsIdentity (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Transform_x
   (
      target : WinUI3.Windows.UI.Xaml.Media.Matrix;
      point : WinUI3.Windows.Foundation.Point
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.MatrixHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IMatrixHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMatrixHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Transform_x (target, point, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MatrixHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MatrixTransform

   procedure Initialize (this : in out MatrixTransform) is
   begin
      null;
   end;

   procedure Finalize (this : in out MatrixTransform) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMatrixTransform, IMatrixTransform_Ptr);
   begin
      if this.m_IMatrixTransform /= null then
         if this.m_IMatrixTransform.all /= null then
            temp := this.m_IMatrixTransform.all.Release;
            Free (this.m_IMatrixTransform);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MatrixTransform

   function Constructor return MatrixTransform is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.MatrixTransform");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IMatrixTransform;
   begin
      return RetVal : MatrixTransform do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMatrixTransform := new WinUI3.Windows.UI.Xaml.Media.IMatrixTransform;
            Retval.m_IMatrixTransform.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MatrixTransform

   function get_MatrixProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.MatrixTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IMatrixTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMatrixTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MatrixProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MatrixTransform

   function get_Matrix
   (
      this : in out MatrixTransform
   )
   return WinUI3.Windows.UI.Xaml.Media.Matrix is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Matrix;
   begin
      Hr := this.m_IMatrixTransform.all.get_Matrix (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Matrix
   (
      this : in out MatrixTransform;
      value : WinUI3.Windows.UI.Xaml.Media.Matrix
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMatrixTransform.all.put_Matrix (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MediaTransportControlsThumbnailRequestedEventArgs

   procedure Initialize (this : in out MediaTransportControlsThumbnailRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MediaTransportControlsThumbnailRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMediaTransportControlsThumbnailRequestedEventArgs, IMediaTransportControlsThumbnailRequestedEventArgs_Ptr);
   begin
      if this.m_IMediaTransportControlsThumbnailRequestedEventArgs /= null then
         if this.m_IMediaTransportControlsThumbnailRequestedEventArgs.all /= null then
            temp := this.m_IMediaTransportControlsThumbnailRequestedEventArgs.all.Release;
            Free (this.m_IMediaTransportControlsThumbnailRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MediaTransportControlsThumbnailRequestedEventArgs

   procedure SetThumbnailImage
   (
      this : in out MediaTransportControlsThumbnailRequestedEventArgs;
      source : WinUI3.Windows.Storage.Streams.IInputStream
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControlsThumbnailRequestedEventArgs.all.SetThumbnailImage (source);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out MediaTransportControlsThumbnailRequestedEventArgs
   )
   return WinUI3.Windows.Foundation.Deferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IDeferral;
   begin
      return RetVal : WinUI3.Windows.Foundation.Deferral do
         Hr := this.m_IMediaTransportControlsThumbnailRequestedEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new WinUI3.Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PartialMediaFailureDetectedEventArgs

   procedure Initialize (this : in out PartialMediaFailureDetectedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PartialMediaFailureDetectedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPartialMediaFailureDetectedEventArgs, IPartialMediaFailureDetectedEventArgs_Ptr);
   begin
      if this.m_IPartialMediaFailureDetectedEventArgs /= null then
         if this.m_IPartialMediaFailureDetectedEventArgs.all /= null then
            temp := this.m_IPartialMediaFailureDetectedEventArgs.all.Release;
            Free (this.m_IPartialMediaFailureDetectedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PartialMediaFailureDetectedEventArgs

   function Constructor return PartialMediaFailureDetectedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PartialMediaFailureDetectedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IPartialMediaFailureDetectedEventArgs;
   begin
      return RetVal : PartialMediaFailureDetectedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPartialMediaFailureDetectedEventArgs := new WinUI3.Windows.UI.Xaml.Media.IPartialMediaFailureDetectedEventArgs;
            Retval.m_IPartialMediaFailureDetectedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PartialMediaFailureDetectedEventArgs

   function get_StreamKind
   (
      this : in out PartialMediaFailureDetectedEventArgs
   )
   return WinUI3.Windows.Media.Playback.FailedMediaStreamKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Playback.FailedMediaStreamKind;
   begin
      Hr := this.m_IPartialMediaFailureDetectedEventArgs.all.get_StreamKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtendedError
   (
      this : in out PartialMediaFailureDetectedEventArgs
   )
   return WinUI3.Windows.Foundation.HResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IPartialMediaFailureDetectedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.HResult;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IPartialMediaFailureDetectedEventArgs_Interface, WinUI3.Windows.UI.Xaml.Media.IPartialMediaFailureDetectedEventArgs2, WinUI3.Windows.UI.Xaml.Media.IID_IPartialMediaFailureDetectedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPartialMediaFailureDetectedEventArgs.all);
      Hr := m_Interface.get_ExtendedError (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PathFigure

   procedure Initialize (this : in out PathFigure) is
   begin
      null;
   end;

   procedure Finalize (this : in out PathFigure) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPathFigure, IPathFigure_Ptr);
   begin
      if this.m_IPathFigure /= null then
         if this.m_IPathFigure.all /= null then
            temp := this.m_IPathFigure.all.Release;
            Free (this.m_IPathFigure);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PathFigure

   function Constructor return PathFigure is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PathFigure");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IPathFigure;
   begin
      return RetVal : PathFigure do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPathFigure := new WinUI3.Windows.UI.Xaml.Media.IPathFigure;
            Retval.m_IPathFigure.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PathFigure

   function get_SegmentsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PathFigure");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPathFigureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPathFigureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SegmentsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StartPointProperty_PathFigure
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PathFigure");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPathFigureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPathFigureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StartPointProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsClosedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PathFigure");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPathFigureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPathFigureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsClosedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFilledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PathFigure");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPathFigureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPathFigureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFilledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PathFigure

   function get_Segments
   (
      this : in out PathFigure
   )
   return WinUI3.Windows.UI.Xaml.Media.PathSegmentCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.PathSegmentCollection do
         Hr := this.m_IPathFigure.all.get_Segments (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_Segments
   (
      this : in out PathFigure;
      value : WinUI3.Windows.UI.Xaml.Media.PathSegmentCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPathFigure.all.put_Segments (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StartPoint
   (
      this : in out PathFigure
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IPathFigure.all.get_StartPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StartPoint
   (
      this : in out PathFigure;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPathFigure.all.put_StartPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsClosed
   (
      this : in out PathFigure
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPathFigure.all.get_IsClosed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsClosed
   (
      this : in out PathFigure;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPathFigure.all.put_IsClosed (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFilled
   (
      this : in out PathFigure
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPathFigure.all.get_IsFilled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFilled
   (
      this : in out PathFigure;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPathFigure.all.put_IsFilled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PathFigureCollection

   procedure Initialize (this : in out PathFigureCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out PathFigureCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PathFigureCollection

   function Constructor return PathFigureCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PathFigureCollection");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : PathFigureCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PathFigureCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.PathFigure>
   function GetAt
   (
      this : in out PathFigureCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.PathFigure'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IPathFigure;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.PathFigure do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPathFigure := new WinUI3.Windows.UI.Xaml.Media.IPathFigure;
         Retval.m_IPathFigure.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out PathFigureCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out PathFigureCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.PathFigure'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IPathFigure;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.PathFigure do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPathFigure := new WinUI3.Windows.UI.Xaml.Media.IPathFigure;
         Retval.m_IPathFigure.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out PathFigureCollection;
      value : WinUI3.Windows.UI.Xaml.Media.PathFigure'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IPathFigure.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out PathFigureCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.PathFigure'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IPathFigure.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out PathFigureCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.PathFigure'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IPathFigure.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out PathFigureCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out PathFigureCollection;
      value : WinUI3.Windows.UI.Xaml.Media.PathFigure'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IPathFigure.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out PathFigureCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out PathFigureCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out PathFigureCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.IPathFigure_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out PathFigureCollection;
      items : WinUI3.Windows.UI.Xaml.Media.IPathFigure_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3727283205, 9949, 24178, (139, 203, 73, 81, 153, 212, 229, 181 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.PathFigure>
   function First
   (
      this : in out PathFigureCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.PathFigure'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IPathFigure.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IPathFigure;
      m_GenericIID     : aliased WinUI3.IID := (3441280033, 55013, 23359, (168, 199, 153, 56, 242, 139, 41, 149 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IPathFigure.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.PathFigure do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPathFigure := new WinUI3.Windows.UI.Xaml.Media.IPathFigure;
         Retval.m_IPathFigure.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PathGeometry

   procedure Initialize (this : in out PathGeometry) is
   begin
      null;
   end;

   procedure Finalize (this : in out PathGeometry) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPathGeometry, IPathGeometry_Ptr);
   begin
      if this.m_IPathGeometry /= null then
         if this.m_IPathGeometry.all /= null then
            temp := this.m_IPathGeometry.all.Release;
            Free (this.m_IPathGeometry);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PathGeometry

   function Constructor return PathGeometry is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PathGeometry");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IPathGeometry;
   begin
      return RetVal : PathGeometry do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPathGeometry := new WinUI3.Windows.UI.Xaml.Media.IPathGeometry;
            Retval.m_IPathGeometry.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PathGeometry

   function get_FillRuleProperty_PathGeometry
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PathGeometry");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPathGeometryStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPathGeometryStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FillRuleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FiguresProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PathGeometry");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPathGeometryStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPathGeometryStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FiguresProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PathGeometry

   function get_FillRule
   (
      this : in out PathGeometry
   )
   return WinUI3.Windows.UI.Xaml.Media.FillRule is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.FillRule;
   begin
      Hr := this.m_IPathGeometry.all.get_FillRule (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FillRule
   (
      this : in out PathGeometry;
      value : WinUI3.Windows.UI.Xaml.Media.FillRule
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPathGeometry.all.put_FillRule (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Figures
   (
      this : in out PathGeometry
   )
   return WinUI3.Windows.UI.Xaml.Media.PathFigureCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.PathFigureCollection do
         Hr := this.m_IPathGeometry.all.get_Figures (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_Figures
   (
      this : in out PathGeometry;
      value : WinUI3.Windows.UI.Xaml.Media.PathFigureCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPathGeometry.all.put_Figures (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PathSegmentCollection

   procedure Initialize (this : in out PathSegmentCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out PathSegmentCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PathSegmentCollection

   function Constructor return PathSegmentCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PathSegmentCollection");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : PathSegmentCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PathSegmentCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.PathSegment>
   function GetAt
   (
      this : in out PathSegmentCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.PathSegment'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IPathSegment;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.PathSegment do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPathSegment := new WinUI3.Windows.UI.Xaml.Media.IPathSegment;
         Retval.m_IPathSegment.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out PathSegmentCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out PathSegmentCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.PathSegment'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IPathSegment;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.PathSegment do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPathSegment := new WinUI3.Windows.UI.Xaml.Media.IPathSegment;
         Retval.m_IPathSegment.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out PathSegmentCollection;
      value : WinUI3.Windows.UI.Xaml.Media.PathSegment'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IPathSegment.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out PathSegmentCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.PathSegment'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IPathSegment.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out PathSegmentCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.PathSegment'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IPathSegment.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out PathSegmentCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out PathSegmentCollection;
      value : WinUI3.Windows.UI.Xaml.Media.PathSegment'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IPathSegment.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out PathSegmentCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out PathSegmentCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out PathSegmentCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.IPathSegment_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out PathSegmentCollection;
      items : WinUI3.Windows.UI.Xaml.Media.IPathSegment_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (301847814, 45597, 22093, (182, 168, 255, 153, 16, 87, 184, 243 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.PathSegment>
   function First
   (
      this : in out PathSegmentCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.PathSegment'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IPathSegment.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IPathSegment;
      m_GenericIID     : aliased WinUI3.IID := (937610017, 47561, 20486, (190, 215, 76, 50, 137, 129, 181, 81 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IPathSegment.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.PathSegment do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPathSegment := new WinUI3.Windows.UI.Xaml.Media.IPathSegment;
         Retval.m_IPathSegment.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PlaneProjection

   procedure Initialize (this : in out PlaneProjection) is
   begin
      null;
   end;

   procedure Finalize (this : in out PlaneProjection) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPlaneProjection, IPlaneProjection_Ptr);
   begin
      if this.m_IPlaneProjection /= null then
         if this.m_IPlaneProjection.all /= null then
            temp := this.m_IPlaneProjection.all.Release;
            Free (this.m_IPlaneProjection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PlaneProjection

   function Constructor return PlaneProjection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IPlaneProjection;
   begin
      return RetVal : PlaneProjection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPlaneProjection := new WinUI3.Windows.UI.Xaml.Media.IPlaneProjection;
            Retval.m_IPlaneProjection.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PlaneProjection

   function get_LocalOffsetXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LocalOffsetXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LocalOffsetYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LocalOffsetYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LocalOffsetZProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LocalOffsetZProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RotationXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RotationXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RotationYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RotationYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RotationZProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RotationZProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CenterOfRotationXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterOfRotationXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CenterOfRotationYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterOfRotationYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CenterOfRotationZProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterOfRotationZProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GlobalOffsetXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlobalOffsetXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GlobalOffsetYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlobalOffsetYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GlobalOffsetZProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlobalOffsetZProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ProjectionMatrixProperty_PlaneProjection
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PlaneProjection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPlaneProjectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaneProjectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ProjectionMatrixProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PlaneProjection

   function get_LocalOffsetX
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_LocalOffsetX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LocalOffsetX
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_LocalOffsetX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LocalOffsetY
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_LocalOffsetY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LocalOffsetY
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_LocalOffsetY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LocalOffsetZ
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_LocalOffsetZ (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LocalOffsetZ
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_LocalOffsetZ (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationX
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_RotationX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationX
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_RotationX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationY
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_RotationY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationY
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_RotationY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationZ
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_RotationZ (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationZ
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_RotationZ (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterOfRotationX
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_CenterOfRotationX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterOfRotationX
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_CenterOfRotationX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterOfRotationY
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_CenterOfRotationY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterOfRotationY
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_CenterOfRotationY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterOfRotationZ
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_CenterOfRotationZ (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterOfRotationZ
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_CenterOfRotationZ (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GlobalOffsetX
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_GlobalOffsetX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GlobalOffsetX
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_GlobalOffsetX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GlobalOffsetY
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_GlobalOffsetY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GlobalOffsetY
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_GlobalOffsetY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GlobalOffsetZ
   (
      this : in out PlaneProjection
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IPlaneProjection.all.get_GlobalOffsetZ (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GlobalOffsetZ
   (
      this : in out PlaneProjection;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPlaneProjection.all.put_GlobalOffsetZ (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ProjectionMatrix
   (
      this : in out PlaneProjection
   )
   return WinUI3.Windows.UI.Xaml.Media.Media3D.Matrix3D is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Media3D.Matrix3D;
   begin
      Hr := this.m_IPlaneProjection.all.get_ProjectionMatrix (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointCollection

   procedure Initialize (this : in out PointCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PointCollection

   function Constructor return PointCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PointCollection");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : PointCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.Foundation.Point>
   function GetAt
   (
      this : in out PointCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out PointCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out PointCollection
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IndexOf
   (
      this : in out PointCollection;
      value : WinUI3.Windows.Foundation.Point;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out PointCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out PointCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out PointCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out PointCollection;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out PointCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out PointCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out PointCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.Foundation.Point_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out PointCollection;
      items : WinUI3.Windows.Foundation.Point_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3235189673, 60490, 23133, (182, 213, 183, 7, 222, 253, 185, 247 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_Point.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Point>
   function First
   (
      this : in out PointCollection
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_Point.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
      m_GenericIID     : aliased WinUI3.IID := (3247581197, 14857, 21539, (157, 197, 103, 184, 62, 189, 228, 29 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_Point.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.First (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PolyBezierSegment

   procedure Initialize (this : in out PolyBezierSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out PolyBezierSegment) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPolyBezierSegment, IPolyBezierSegment_Ptr);
   begin
      if this.m_IPolyBezierSegment /= null then
         if this.m_IPolyBezierSegment.all /= null then
            temp := this.m_IPolyBezierSegment.all.Release;
            Free (this.m_IPolyBezierSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PolyBezierSegment

   function Constructor return PolyBezierSegment is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PolyBezierSegment");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IPolyBezierSegment;
   begin
      return RetVal : PolyBezierSegment do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPolyBezierSegment := new WinUI3.Windows.UI.Xaml.Media.IPolyBezierSegment;
            Retval.m_IPolyBezierSegment.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PolyBezierSegment

   function get_PointsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PolyBezierSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPolyBezierSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPolyBezierSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PolyBezierSegment

   function get_Points
   (
      this : in out PolyBezierSegment
   )
   return WinUI3.Windows.UI.Xaml.Media.PointCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.PointCollection do
         Hr := this.m_IPolyBezierSegment.all.get_Points (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_Points
   (
      this : in out PolyBezierSegment;
      value : WinUI3.Windows.UI.Xaml.Media.PointCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPolyBezierSegment.all.put_Points (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PolyLineSegment

   procedure Initialize (this : in out PolyLineSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out PolyLineSegment) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPolyLineSegment, IPolyLineSegment_Ptr);
   begin
      if this.m_IPolyLineSegment /= null then
         if this.m_IPolyLineSegment.all /= null then
            temp := this.m_IPolyLineSegment.all.Release;
            Free (this.m_IPolyLineSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PolyLineSegment

   function Constructor return PolyLineSegment is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PolyLineSegment");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IPolyLineSegment;
   begin
      return RetVal : PolyLineSegment do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPolyLineSegment := new WinUI3.Windows.UI.Xaml.Media.IPolyLineSegment;
            Retval.m_IPolyLineSegment.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PolyLineSegment

   function get_PointsProperty_PolyLineSegment
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PolyLineSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPolyLineSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPolyLineSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PolyLineSegment

   function get_Points
   (
      this : in out PolyLineSegment
   )
   return WinUI3.Windows.UI.Xaml.Media.PointCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.PointCollection do
         Hr := this.m_IPolyLineSegment.all.get_Points (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_Points
   (
      this : in out PolyLineSegment;
      value : WinUI3.Windows.UI.Xaml.Media.PointCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPolyLineSegment.all.put_Points (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PolyQuadraticBezierSegment

   procedure Initialize (this : in out PolyQuadraticBezierSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out PolyQuadraticBezierSegment) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPolyQuadraticBezierSegment, IPolyQuadraticBezierSegment_Ptr);
   begin
      if this.m_IPolyQuadraticBezierSegment /= null then
         if this.m_IPolyQuadraticBezierSegment.all /= null then
            temp := this.m_IPolyQuadraticBezierSegment.all.Release;
            Free (this.m_IPolyQuadraticBezierSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PolyQuadraticBezierSegment

   function Constructor return PolyQuadraticBezierSegment is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PolyQuadraticBezierSegment");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IPolyQuadraticBezierSegment;
   begin
      return RetVal : PolyQuadraticBezierSegment do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPolyQuadraticBezierSegment := new WinUI3.Windows.UI.Xaml.Media.IPolyQuadraticBezierSegment;
            Retval.m_IPolyQuadraticBezierSegment.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PolyQuadraticBezierSegment

   function get_PointsProperty_PolyQuadraticBezierSegment
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.PolyQuadraticBezierSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IPolyQuadraticBezierSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPolyQuadraticBezierSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PolyQuadraticBezierSegment

   function get_Points
   (
      this : in out PolyQuadraticBezierSegment
   )
   return WinUI3.Windows.UI.Xaml.Media.PointCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.PointCollection do
         Hr := this.m_IPolyQuadraticBezierSegment.all.get_Points (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_Points
   (
      this : in out PolyQuadraticBezierSegment;
      value : WinUI3.Windows.UI.Xaml.Media.PointCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPolyQuadraticBezierSegment.all.put_Points (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for QuadraticBezierSegment

   procedure Initialize (this : in out QuadraticBezierSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out QuadraticBezierSegment) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IQuadraticBezierSegment, IQuadraticBezierSegment_Ptr);
   begin
      if this.m_IQuadraticBezierSegment /= null then
         if this.m_IQuadraticBezierSegment.all /= null then
            temp := this.m_IQuadraticBezierSegment.all.Release;
            Free (this.m_IQuadraticBezierSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for QuadraticBezierSegment

   function Constructor return QuadraticBezierSegment is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.QuadraticBezierSegment");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IQuadraticBezierSegment;
   begin
      return RetVal : QuadraticBezierSegment do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IQuadraticBezierSegment := new WinUI3.Windows.UI.Xaml.Media.IQuadraticBezierSegment;
            Retval.m_IQuadraticBezierSegment.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for QuadraticBezierSegment

   function get_Point1Property_QuadraticBezierSegment
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.QuadraticBezierSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IQuadraticBezierSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IQuadraticBezierSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Point1Property (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Point2Property_QuadraticBezierSegment
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.QuadraticBezierSegment");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IQuadraticBezierSegmentStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IQuadraticBezierSegmentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Point2Property (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for QuadraticBezierSegment

   function get_Point1
   (
      this : in out QuadraticBezierSegment
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IQuadraticBezierSegment.all.get_Point1 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Point1
   (
      this : in out QuadraticBezierSegment;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IQuadraticBezierSegment.all.put_Point1 (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Point2
   (
      this : in out QuadraticBezierSegment
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IQuadraticBezierSegment.all.get_Point2 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Point2
   (
      this : in out QuadraticBezierSegment;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IQuadraticBezierSegment.all.put_Point2 (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RateChangedRoutedEventArgs

   procedure Initialize (this : in out RateChangedRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RateChangedRoutedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRateChangedRoutedEventArgs, IRateChangedRoutedEventArgs_Ptr);
   begin
      if this.m_IRateChangedRoutedEventArgs /= null then
         if this.m_IRateChangedRoutedEventArgs.all /= null then
            temp := this.m_IRateChangedRoutedEventArgs.all.Release;
            Free (this.m_IRateChangedRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RateChangedRoutedEventArgs

   function Constructor return RateChangedRoutedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RateChangedRoutedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IRateChangedRoutedEventArgs;
   begin
      return RetVal : RateChangedRoutedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRateChangedRoutedEventArgs := new WinUI3.Windows.UI.Xaml.Media.IRateChangedRoutedEventArgs;
            Retval.m_IRateChangedRoutedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RateChangedRoutedEventArgs

   -----------------------------------------------------------------------------
   -- Delegate RateChangedRoutedEventHandler

   function Invoke
   (
      this : access RateChangedRoutedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Media.IRateChangedRoutedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RectangleGeometry

   procedure Initialize (this : in out RectangleGeometry) is
   begin
      null;
   end;

   procedure Finalize (this : in out RectangleGeometry) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRectangleGeometry, IRectangleGeometry_Ptr);
   begin
      if this.m_IRectangleGeometry /= null then
         if this.m_IRectangleGeometry.all /= null then
            temp := this.m_IRectangleGeometry.all.Release;
            Free (this.m_IRectangleGeometry);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RectangleGeometry

   function Constructor return RectangleGeometry is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RectangleGeometry");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IRectangleGeometry;
   begin
      return RetVal : RectangleGeometry do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRectangleGeometry := new WinUI3.Windows.UI.Xaml.Media.IRectangleGeometry;
            Retval.m_IRectangleGeometry.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RectangleGeometry

   function get_RectProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RectangleGeometry");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IRectangleGeometryStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRectangleGeometryStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RectProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RectangleGeometry

   function get_Rect
   (
      this : in out RectangleGeometry
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IRectangleGeometry.all.get_Rect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Rect
   (
      this : in out RectangleGeometry;
      value : WinUI3.Windows.Foundation.Rect
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRectangleGeometry.all.put_Rect (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RenderedEventArgs

   procedure Initialize (this : in out RenderedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RenderedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRenderedEventArgs, IRenderedEventArgs_Ptr);
   begin
      if this.m_IRenderedEventArgs /= null then
         if this.m_IRenderedEventArgs.all /= null then
            temp := this.m_IRenderedEventArgs.all.Release;
            Free (this.m_IRenderedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RenderedEventArgs

   function get_FrameDuration
   (
      this : in out RenderedEventArgs
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IRenderedEventArgs.all.get_FrameDuration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RenderingEventArgs

   procedure Initialize (this : in out RenderingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RenderingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRenderingEventArgs, IRenderingEventArgs_Ptr);
   begin
      if this.m_IRenderingEventArgs /= null then
         if this.m_IRenderingEventArgs.all /= null then
            temp := this.m_IRenderingEventArgs.all.Release;
            Free (this.m_IRenderingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RenderingEventArgs

   function get_RenderingTime
   (
      this : in out RenderingEventArgs
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IRenderingEventArgs.all.get_RenderingTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RevealBrush

   procedure Initialize (this : in out RevealBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out RevealBrush) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRevealBrush, IRevealBrush_Ptr);
   begin
      if this.m_IRevealBrush /= null then
         if this.m_IRevealBrush.all /= null then
            temp := this.m_IRevealBrush.all.Release;
            Free (this.m_IRevealBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RevealBrush

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RevealBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RevealBrush");
      m_Factory    : access IRevealBrushFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IRevealBrush;
   begin
      return RetVal : RevealBrush do
         Hr := RoGetActivationFactory (m_hString, IID_IRevealBrushFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRevealBrush := new WinUI3.Windows.UI.Xaml.Media.IRevealBrush;
            Retval.m_IRevealBrush.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RevealBrush

   function get_ColorProperty_RevealBrush
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RevealBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IRevealBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRevealBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TargetThemeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RevealBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IRevealBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRevealBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetThemeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AlwaysUseFallbackProperty_RevealBrush
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RevealBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IRevealBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRevealBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlwaysUseFallbackProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RevealBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IRevealBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRevealBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetState
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Windows.UI.Xaml.Media.RevealBrushState
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RevealBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IRevealBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRevealBrushStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetState (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function GetState
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Windows.UI.Xaml.Media.RevealBrushState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RevealBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IRevealBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.RevealBrushState;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRevealBrushStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetState (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RevealBrush

   function get_Color
   (
      this : in out RevealBrush
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IRevealBrush.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out RevealBrush;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRevealBrush.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TargetTheme
   (
      this : in out RevealBrush
   )
   return WinUI3.Windows.UI.Xaml.ApplicationTheme is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ApplicationTheme;
   begin
      Hr := this.m_IRevealBrush.all.get_TargetTheme (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TargetTheme
   (
      this : in out RevealBrush;
      value : WinUI3.Windows.UI.Xaml.ApplicationTheme
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRevealBrush.all.put_TargetTheme (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AlwaysUseFallback
   (
      this : in out RevealBrush
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRevealBrush.all.get_AlwaysUseFallback (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AlwaysUseFallback
   (
      this : in out RevealBrush;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRevealBrush.all.put_AlwaysUseFallback (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RevealBackgroundBrush

   procedure Initialize (this : in out RevealBackgroundBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out RevealBackgroundBrush) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRevealBackgroundBrush, IRevealBackgroundBrush_Ptr);
   begin
      if this.m_IRevealBackgroundBrush /= null then
         if this.m_IRevealBackgroundBrush.all /= null then
            temp := this.m_IRevealBackgroundBrush.all.Release;
            Free (this.m_IRevealBackgroundBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RevealBackgroundBrush

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RevealBackgroundBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RevealBackgroundBrush");
      m_Factory    : access IRevealBackgroundBrushFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IRevealBackgroundBrush;
   begin
      return RetVal : RevealBackgroundBrush do
         Hr := RoGetActivationFactory (m_hString, IID_IRevealBackgroundBrushFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRevealBackgroundBrush := new WinUI3.Windows.UI.Xaml.Media.IRevealBackgroundBrush;
            Retval.m_IRevealBackgroundBrush.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RevealBackgroundBrush

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RevealBorderBrush

   procedure Initialize (this : in out RevealBorderBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out RevealBorderBrush) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRevealBorderBrush, IRevealBorderBrush_Ptr);
   begin
      if this.m_IRevealBorderBrush /= null then
         if this.m_IRevealBorderBrush.all /= null then
            temp := this.m_IRevealBorderBrush.all.Release;
            Free (this.m_IRevealBorderBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RevealBorderBrush

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RevealBorderBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RevealBorderBrush");
      m_Factory    : access IRevealBorderBrushFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IRevealBorderBrush;
   begin
      return RetVal : RevealBorderBrush do
         Hr := RoGetActivationFactory (m_hString, IID_IRevealBorderBrushFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRevealBorderBrush := new WinUI3.Windows.UI.Xaml.Media.IRevealBorderBrush;
            Retval.m_IRevealBorderBrush.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RevealBorderBrush

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RotateTransform

   procedure Initialize (this : in out RotateTransform) is
   begin
      null;
   end;

   procedure Finalize (this : in out RotateTransform) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRotateTransform, IRotateTransform_Ptr);
   begin
      if this.m_IRotateTransform /= null then
         if this.m_IRotateTransform.all /= null then
            temp := this.m_IRotateTransform.all.Release;
            Free (this.m_IRotateTransform);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RotateTransform

   function Constructor return RotateTransform is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RotateTransform");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IRotateTransform;
   begin
      return RetVal : RotateTransform do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRotateTransform := new WinUI3.Windows.UI.Xaml.Media.IRotateTransform;
            Retval.m_IRotateTransform.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RotateTransform

   function get_CenterXProperty_RotateTransform
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RotateTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IRotateTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRotateTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CenterYProperty_RotateTransform
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RotateTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IRotateTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRotateTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AngleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.RotateTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IRotateTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRotateTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AngleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RotateTransform

   function get_CenterX
   (
      this : in out RotateTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRotateTransform.all.get_CenterX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterX
   (
      this : in out RotateTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRotateTransform.all.put_CenterX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterY
   (
      this : in out RotateTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRotateTransform.all.get_CenterY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterY
   (
      this : in out RotateTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRotateTransform.all.put_CenterY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Angle
   (
      this : in out RotateTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRotateTransform.all.get_Angle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Angle
   (
      this : in out RotateTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRotateTransform.all.put_Angle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScaleTransform

   procedure Initialize (this : in out ScaleTransform) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScaleTransform) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScaleTransform, IScaleTransform_Ptr);
   begin
      if this.m_IScaleTransform /= null then
         if this.m_IScaleTransform.all /= null then
            temp := this.m_IScaleTransform.all.Release;
            Free (this.m_IScaleTransform);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScaleTransform

   function Constructor return ScaleTransform is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ScaleTransform");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IScaleTransform;
   begin
      return RetVal : ScaleTransform do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IScaleTransform := new WinUI3.Windows.UI.Xaml.Media.IScaleTransform;
            Retval.m_IScaleTransform.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ScaleTransform

   function get_CenterXProperty_ScaleTransform
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ScaleTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IScaleTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScaleTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CenterYProperty_ScaleTransform
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ScaleTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IScaleTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScaleTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScaleXProperty_ScaleTransform
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ScaleTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IScaleTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScaleTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScaleXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScaleYProperty_ScaleTransform
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ScaleTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IScaleTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScaleTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScaleYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScaleTransform

   function get_CenterX
   (
      this : in out ScaleTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScaleTransform.all.get_CenterX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterX
   (
      this : in out ScaleTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScaleTransform.all.put_CenterX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterY
   (
      this : in out ScaleTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScaleTransform.all.get_CenterY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterY
   (
      this : in out ScaleTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScaleTransform.all.put_CenterY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScaleX
   (
      this : in out ScaleTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScaleTransform.all.get_ScaleX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ScaleX
   (
      this : in out ScaleTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScaleTransform.all.put_ScaleX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScaleY
   (
      this : in out ScaleTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScaleTransform.all.get_ScaleY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ScaleY
   (
      this : in out ScaleTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScaleTransform.all.put_ScaleY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Shadow

   procedure Initialize (this : in out Shadow) is
   begin
      null;
   end;

   procedure Finalize (this : in out Shadow) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IShadow, IShadow_Ptr);
   begin
      if this.m_IShadow /= null then
         if this.m_IShadow.all /= null then
            temp := this.m_IShadow.all.Release;
            Free (this.m_IShadow);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Shadow

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Shadow

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SkewTransform

   procedure Initialize (this : in out SkewTransform) is
   begin
      null;
   end;

   procedure Finalize (this : in out SkewTransform) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISkewTransform, ISkewTransform_Ptr);
   begin
      if this.m_ISkewTransform /= null then
         if this.m_ISkewTransform.all /= null then
            temp := this.m_ISkewTransform.all.Release;
            Free (this.m_ISkewTransform);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SkewTransform

   function Constructor return SkewTransform is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.SkewTransform");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ISkewTransform;
   begin
      return RetVal : SkewTransform do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISkewTransform := new WinUI3.Windows.UI.Xaml.Media.ISkewTransform;
            Retval.m_ISkewTransform.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SkewTransform

   function get_CenterXProperty_SkewTransform
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.SkewTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ISkewTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISkewTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CenterYProperty_SkewTransform
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.SkewTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ISkewTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISkewTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AngleXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.SkewTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ISkewTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISkewTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AngleXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AngleYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.SkewTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ISkewTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISkewTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AngleYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SkewTransform

   function get_CenterX
   (
      this : in out SkewTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISkewTransform.all.get_CenterX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterX
   (
      this : in out SkewTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISkewTransform.all.put_CenterX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterY
   (
      this : in out SkewTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISkewTransform.all.get_CenterY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterY
   (
      this : in out SkewTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISkewTransform.all.put_CenterY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AngleX
   (
      this : in out SkewTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISkewTransform.all.get_AngleX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AngleX
   (
      this : in out SkewTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISkewTransform.all.put_AngleX (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AngleY
   (
      this : in out SkewTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISkewTransform.all.get_AngleY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AngleY
   (
      this : in out SkewTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISkewTransform.all.put_AngleY (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SolidColorBrush

   procedure Initialize (this : in out SolidColorBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out SolidColorBrush) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISolidColorBrush, ISolidColorBrush_Ptr);
   begin
      if this.m_ISolidColorBrush /= null then
         if this.m_ISolidColorBrush.all /= null then
            temp := this.m_ISolidColorBrush.all.Release;
            Free (this.m_ISolidColorBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SolidColorBrush

   function Constructor return SolidColorBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.SolidColorBrush");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
   begin
      return RetVal : SolidColorBrush do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISolidColorBrush := new WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
            Retval.m_ISolidColorBrush.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      color : WinUI3.Windows.UI.Color
   )
   return SolidColorBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.SolidColorBrush");
      m_Factory    : access ISolidColorBrushFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
   begin
      return RetVal : SolidColorBrush do
         Hr := RoGetActivationFactory (m_hString, IID_ISolidColorBrushFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithColor (color, m_ComRetVal'Access);
            Retval.m_ISolidColorBrush := new WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
            Retval.m_ISolidColorBrush.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SolidColorBrush

   function get_ColorProperty_SolidColorBrush
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.SolidColorBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ISolidColorBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISolidColorBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SolidColorBrush

   function get_Color
   (
      this : in out SolidColorBrush
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_ISolidColorBrush.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out SolidColorBrush;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISolidColorBrush.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ThemeShadow

   procedure Initialize (this : in out ThemeShadow) is
   begin
      null;
   end;

   procedure Finalize (this : in out ThemeShadow) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IThemeShadow, IThemeShadow_Ptr);
   begin
      if this.m_IThemeShadow /= null then
         if this.m_IThemeShadow.all /= null then
            temp := this.m_IThemeShadow.all.Release;
            Free (this.m_IThemeShadow);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ThemeShadow

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ThemeShadow is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.ThemeShadow");
      m_Factory    : access IThemeShadowFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IThemeShadow;
   begin
      return RetVal : ThemeShadow do
         Hr := RoGetActivationFactory (m_hString, IID_IThemeShadowFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IThemeShadow := new WinUI3.Windows.UI.Xaml.Media.IThemeShadow;
            Retval.m_IThemeShadow.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ThemeShadow

   function get_Receivers
   (
      this : in out ThemeShadow
   )
   return WinUI3.Windows.UI.Xaml.UIElementWeakCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElementWeakCollection;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElementWeakCollection do
         Hr := this.m_IThemeShadow.all.get_Receivers (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElementWeakCollection := new WinUI3.Windows.UI.Xaml.IUIElementWeakCollection;
         Retval.m_IUIElementWeakCollection.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimelineMarker

   procedure Initialize (this : in out TimelineMarker) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimelineMarker) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimelineMarker, ITimelineMarker_Ptr);
   begin
      if this.m_ITimelineMarker /= null then
         if this.m_ITimelineMarker.all /= null then
            temp := this.m_ITimelineMarker.all.Release;
            Free (this.m_ITimelineMarker);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TimelineMarker

   function Constructor return TimelineMarker is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TimelineMarker");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ITimelineMarker;
   begin
      return RetVal : TimelineMarker do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITimelineMarker := new WinUI3.Windows.UI.Xaml.Media.ITimelineMarker;
            Retval.m_ITimelineMarker.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TimelineMarker

   function get_TimeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TimelineMarker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ITimelineMarkerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimelineMarkerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TypeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TimelineMarker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ITimelineMarkerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimelineMarkerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TimelineMarker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ITimelineMarkerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimelineMarkerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimelineMarker

   function get_Time
   (
      this : in out TimelineMarker
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimelineMarker.all.get_Time (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Time
   (
      this : in out TimelineMarker;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimelineMarker.all.put_Time (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Type
   (
      this : in out TimelineMarker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITimelineMarker.all.get_Type (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Type
   (
      this : in out TimelineMarker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITimelineMarker.all.put_Type (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Text
   (
      this : in out TimelineMarker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITimelineMarker.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out TimelineMarker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITimelineMarker.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimelineMarkerCollection

   procedure Initialize (this : in out TimelineMarkerCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimelineMarkerCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TimelineMarkerCollection

   function Constructor return TimelineMarkerCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TimelineMarkerCollection");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : TimelineMarkerCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimelineMarkerCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.TimelineMarker>
   function GetAt
   (
      this : in out TimelineMarkerCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.TimelineMarker'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ITimelineMarker;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.TimelineMarker do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITimelineMarker := new WinUI3.Windows.UI.Xaml.Media.ITimelineMarker;
         Retval.m_ITimelineMarker.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out TimelineMarkerCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out TimelineMarkerCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.TimelineMarker'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ITimelineMarker;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.TimelineMarker do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITimelineMarker := new WinUI3.Windows.UI.Xaml.Media.ITimelineMarker;
         Retval.m_ITimelineMarker.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out TimelineMarkerCollection;
      value : WinUI3.Windows.UI.Xaml.Media.TimelineMarker'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_ITimelineMarker.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out TimelineMarkerCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.TimelineMarker'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_ITimelineMarker.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out TimelineMarkerCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.TimelineMarker'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_ITimelineMarker.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out TimelineMarkerCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out TimelineMarkerCollection;
      value : WinUI3.Windows.UI.Xaml.Media.TimelineMarker'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_ITimelineMarker.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out TimelineMarkerCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out TimelineMarkerCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out TimelineMarkerCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.ITimelineMarker_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out TimelineMarkerCollection;
      items : WinUI3.Windows.UI.Xaml.Media.ITimelineMarker_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3000556980, 53944, 22832, (148, 45, 38, 17, 135, 86, 189, 70 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.TimelineMarker>
   function First
   (
      this : in out TimelineMarkerCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.TimelineMarker'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_ITimelineMarker.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ITimelineMarker;
      m_GenericIID     : aliased WinUI3.IID := (2490129141, 19465, 22404, (156, 242, 80, 105, 71, 55, 142, 142 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_ITimelineMarker.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.TimelineMarker do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITimelineMarker := new WinUI3.Windows.UI.Xaml.Media.ITimelineMarker;
         Retval.m_ITimelineMarker.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimelineMarkerRoutedEventArgs

   procedure Initialize (this : in out TimelineMarkerRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimelineMarkerRoutedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimelineMarkerRoutedEventArgs, ITimelineMarkerRoutedEventArgs_Ptr);
   begin
      if this.m_ITimelineMarkerRoutedEventArgs /= null then
         if this.m_ITimelineMarkerRoutedEventArgs.all /= null then
            temp := this.m_ITimelineMarkerRoutedEventArgs.all.Release;
            Free (this.m_ITimelineMarkerRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TimelineMarkerRoutedEventArgs

   function Constructor return TimelineMarkerRoutedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TimelineMarkerRoutedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ITimelineMarkerRoutedEventArgs;
   begin
      return RetVal : TimelineMarkerRoutedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITimelineMarkerRoutedEventArgs := new WinUI3.Windows.UI.Xaml.Media.ITimelineMarkerRoutedEventArgs;
            Retval.m_ITimelineMarkerRoutedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimelineMarkerRoutedEventArgs

   function get_Marker
   (
      this : in out TimelineMarkerRoutedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Media.TimelineMarker'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ITimelineMarker;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.TimelineMarker do
         Hr := this.m_ITimelineMarkerRoutedEventArgs.all.get_Marker (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITimelineMarker := new WinUI3.Windows.UI.Xaml.Media.ITimelineMarker;
         Retval.m_ITimelineMarker.all := m_ComRetVal;
      end return;
   end;

   procedure put_Marker
   (
      this : in out TimelineMarkerRoutedEventArgs;
      value : WinUI3.Windows.UI.Xaml.Media.TimelineMarker'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimelineMarkerRoutedEventArgs.all.put_Marker (value.m_ITimelineMarker.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate TimelineMarkerRoutedEventHandler

   function Invoke
   (
      this : access TimelineMarkerRoutedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Media.ITimelineMarkerRoutedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TransformCollection

   procedure Initialize (this : in out TransformCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out TransformCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TransformCollection

   function Constructor return TransformCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TransformCollection");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : TransformCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TransformCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Media.Transform>
   function GetAt
   (
      this : in out TransformCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Media.Transform'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ITransform;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Transform do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITransform := new WinUI3.Windows.UI.Xaml.Media.ITransform;
         Retval.m_ITransform.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out TransformCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out TransformCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Transform'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ITransform;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Transform do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITransform := new WinUI3.Windows.UI.Xaml.Media.ITransform;
         Retval.m_ITransform.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out TransformCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Transform'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_ITransform.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out TransformCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Transform'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_ITransform.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out TransformCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Media.Transform'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_ITransform.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out TransformCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out TransformCollection;
      value : WinUI3.Windows.UI.Xaml.Media.Transform'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_ITransform.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out TransformCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out TransformCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out TransformCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Media.ITransform_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out TransformCollection;
      items : WinUI3.Windows.UI.Xaml.Media.ITransform_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1658305473, 29173, 22033, (169, 132, 229, 113, 194, 222, 123, 170 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITransform.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Media.Transform>
   function First
   (
      this : in out TransformCollection
   )
   return WinUI3.Windows.UI.Xaml.Media.Transform'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_ITransform.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ITransform;
      m_GenericIID     : aliased WinUI3.IID := (4220300476, 54252, 20920, (151, 120, 153, 237, 232, 70, 54, 17 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_ITransform.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Transform do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITransform := new WinUI3.Windows.UI.Xaml.Media.ITransform;
         Retval.m_ITransform.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TransformGroup

   procedure Initialize (this : in out TransformGroup) is
   begin
      null;
   end;

   procedure Finalize (this : in out TransformGroup) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITransformGroup, ITransformGroup_Ptr);
   begin
      if this.m_ITransformGroup /= null then
         if this.m_ITransformGroup.all /= null then
            temp := this.m_ITransformGroup.all.Release;
            Free (this.m_ITransformGroup);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TransformGroup

   function Constructor return TransformGroup is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TransformGroup");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ITransformGroup;
   begin
      return RetVal : TransformGroup do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITransformGroup := new WinUI3.Windows.UI.Xaml.Media.ITransformGroup;
            Retval.m_ITransformGroup.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TransformGroup

   function get_ChildrenProperty_TransformGroup
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TransformGroup");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ITransformGroupStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITransformGroupStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildrenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TransformGroup

   function get_Children
   (
      this : in out TransformGroup
   )
   return WinUI3.Windows.UI.Xaml.Media.TransformCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.TransformCollection do
         Hr := this.m_ITransformGroup.all.get_Children (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_Children
   (
      this : in out TransformGroup;
      value : WinUI3.Windows.UI.Xaml.Media.TransformCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITransformGroup.all.put_Children (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Value
   (
      this : in out TransformGroup
   )
   return WinUI3.Windows.UI.Xaml.Media.Matrix is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Matrix;
   begin
      Hr := this.m_ITransformGroup.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TranslateTransform

   procedure Initialize (this : in out TranslateTransform) is
   begin
      null;
   end;

   procedure Finalize (this : in out TranslateTransform) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITranslateTransform, ITranslateTransform_Ptr);
   begin
      if this.m_ITranslateTransform /= null then
         if this.m_ITranslateTransform.all /= null then
            temp := this.m_ITranslateTransform.all.Release;
            Free (this.m_ITranslateTransform);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TranslateTransform

   function Constructor return TranslateTransform is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TranslateTransform");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.ITranslateTransform;
   begin
      return RetVal : TranslateTransform do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITranslateTransform := new WinUI3.Windows.UI.Xaml.Media.ITranslateTransform;
            Retval.m_ITranslateTransform.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TranslateTransform

   function get_XProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TranslateTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ITranslateTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITranslateTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_YProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.TranslateTransform");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.ITranslateTransformStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITranslateTransformStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_YProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TranslateTransform

   function get_X
   (
      this : in out TranslateTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITranslateTransform.all.get_X (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_X
   (
      this : in out TranslateTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITranslateTransform.all.put_X (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Y
   (
      this : in out TranslateTransform
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITranslateTransform.all.get_Y (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Y
   (
      this : in out TranslateTransform;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITranslateTransform.all.put_Y (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VisualTreeHelper

   procedure Initialize (this : in out VisualTreeHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out VisualTreeHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVisualTreeHelper, IVisualTreeHelper_Ptr);
   begin
      if this.m_IVisualTreeHelper /= null then
         if this.m_IVisualTreeHelper.all /= null then
            temp := this.m_IVisualTreeHelper.all.Release;
            Free (this.m_IVisualTreeHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for VisualTreeHelper

   function FindElementsInHostCoordinates
   (
      intersectingPoint : WinUI3.Windows.Foundation.Point;
      subtree : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.VisualTreeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IVisualTreeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVisualTreeHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FindElementsInHostCoordinates (intersectingPoint, subtree.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FindElementsInHostCoordinates
   (
      intersectingRect : WinUI3.Windows.Foundation.Rect;
      subtree : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.VisualTreeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IVisualTreeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVisualTreeHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FindElementsInHostCoordinates (intersectingRect, subtree.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FindElementsInHostCoordinates
   (
      intersectingPoint : WinUI3.Windows.Foundation.Point;
      subtree : WinUI3.Windows.UI.Xaml.UIElement'Class;
      includeAllElements : WinUI3.Boolean
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.VisualTreeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IVisualTreeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVisualTreeHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FindElementsInHostCoordinates (intersectingPoint, subtree.m_IUIElement.all, includeAllElements, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FindElementsInHostCoordinates
   (
      intersectingRect : WinUI3.Windows.Foundation.Rect;
      subtree : WinUI3.Windows.UI.Xaml.UIElement'Class;
      includeAllElements : WinUI3.Boolean
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.VisualTreeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IVisualTreeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVisualTreeHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FindElementsInHostCoordinates (intersectingRect, subtree.m_IUIElement.all, includeAllElements, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetChild
   (
      reference : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      childIndex : WinUI3.Int32
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.VisualTreeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IVisualTreeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := RoGetActivationFactory (m_hString, IID_IVisualTreeHelperStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetChild (reference.m_IDependencyObject.all, childIndex, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
            Retval.m_IDependencyObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetChildrenCount
   (
      reference : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.VisualTreeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IVisualTreeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVisualTreeHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetChildrenCount (reference.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetParent
   (
      reference : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.VisualTreeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IVisualTreeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := RoGetActivationFactory (m_hString, IID_IVisualTreeHelperStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetParent (reference.m_IDependencyObject.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
            Retval.m_IDependencyObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure DisconnectChildrenRecursive
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.VisualTreeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IVisualTreeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVisualTreeHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.DisconnectChildrenRecursive (element.m_IUIElement.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function GetOpenPopups
   (
      window : WinUI3.Windows.UI.Xaml.Window'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.VisualTreeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IVisualTreeHelperStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVisualTreeHelperStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetOpenPopups (window.m_IWindow.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetOpenPopupsForXamlRoot
   (
      xamlRoot : WinUI3.Windows.UI.Xaml.XamlRoot'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.VisualTreeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IVisualTreeHelperStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVisualTreeHelperStatics3'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetOpenPopupsForXamlRoot (xamlRoot.m_IXamlRoot.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VisualTreeHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for XamlLight

   procedure Initialize (this : in out XamlLight) is
   begin
      null;
   end;

   procedure Finalize (this : in out XamlLight) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IXamlLight, IXamlLight_Ptr);
   begin
      if this.m_IXamlLight /= null then
         if this.m_IXamlLight.all /= null then
            temp := this.m_IXamlLight.all.Release;
            Free (this.m_IXamlLight);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for XamlLight

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return XamlLight is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.XamlLight");
      m_Factory    : access IXamlLightFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Media.IXamlLight;
   begin
      return RetVal : XamlLight do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlLightFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IXamlLight := new WinUI3.Windows.UI.Xaml.Media.IXamlLight;
            Retval.m_IXamlLight.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for XamlLight

   procedure AddTargetElement
   (
      lightId : WinUI3.WString;
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.XamlLight");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IXamlLightStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_lightId : constant WinUI3.HString := To_HString (lightId);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IXamlLightStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.AddTargetElement (HStr_lightId, element.m_IUIElement.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_lightId);
   end;

   procedure RemoveTargetElement
   (
      lightId : WinUI3.WString;
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.XamlLight");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IXamlLightStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_lightId : constant WinUI3.HString := To_HString (lightId);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IXamlLightStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.RemoveTargetElement (HStr_lightId, element.m_IUIElement.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_lightId);
   end;

   procedure AddTargetBrush
   (
      lightId : WinUI3.WString;
      brush_p : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.XamlLight");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IXamlLightStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_lightId : constant WinUI3.HString := To_HString (lightId);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IXamlLightStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.AddTargetBrush (HStr_lightId, brush_p.m_IBrush.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_lightId);
   end;

   procedure RemoveTargetBrush
   (
      lightId : WinUI3.WString;
      brush_p : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Media.XamlLight");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Media.IXamlLightStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_lightId : constant WinUI3.HString := To_HString (lightId);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IXamlLightStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.RemoveTargetBrush (HStr_lightId, brush_p.m_IBrush.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_lightId);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for XamlLight

   function get_CompositionLight
   (
      this : in out XamlLight
   )
   return WinUI3.Windows.UI.Composition.CompositionLight'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IXamlLightProtected := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Composition.ICompositionLight;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IXamlLight_Interface, WinUI3.Windows.UI.Xaml.Media.IXamlLightProtected, WinUI3.Windows.UI.Xaml.Media.IID_IXamlLightProtected'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Composition.CompositionLight do
         m_Interface := QInterface (this.m_IXamlLight.all);
         Hr := m_Interface.get_CompositionLight (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionLight := new WinUI3.Windows.UI.Composition.ICompositionLight;
         Retval.m_ICompositionLight.all := m_ComRetVal;
      end return;
   end;

   procedure put_CompositionLight
   (
      this : in out XamlLight;
      value : WinUI3.Windows.UI.Composition.CompositionLight'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IXamlLightProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IXamlLight_Interface, WinUI3.Windows.UI.Xaml.Media.IXamlLightProtected, WinUI3.Windows.UI.Xaml.Media.IID_IXamlLightProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlLight.all);
      Hr := m_Interface.put_CompositionLight (value.m_ICompositionLight.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetId
   (
      this : in out XamlLight
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IXamlLightOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IXamlLight_Interface, WinUI3.Windows.UI.Xaml.Media.IXamlLightOverrides, WinUI3.Windows.UI.Xaml.Media.IID_IXamlLightOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlLight.all);
      Hr := m_Interface.GetId (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure OnConnected
   (
      this : in out XamlLight;
      newElement : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IXamlLightOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IXamlLight_Interface, WinUI3.Windows.UI.Xaml.Media.IXamlLightOverrides, WinUI3.Windows.UI.Xaml.Media.IID_IXamlLightOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlLight.all);
      Hr := m_Interface.OnConnected (newElement.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDisconnected
   (
      this : in out XamlLight;
      oldElement : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Media.IXamlLightOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Media.IXamlLight_Interface, WinUI3.Windows.UI.Xaml.Media.IXamlLightOverrides, WinUI3.Windows.UI.Xaml.Media.IID_IXamlLightOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlLight.all);
      Hr := m_Interface.OnDisconnected (oldElement.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

end WinUI3.Windows.UI.Xaml.Media;
