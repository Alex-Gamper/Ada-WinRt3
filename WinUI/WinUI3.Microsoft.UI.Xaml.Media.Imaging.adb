--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Windows.ApplicationModel.Background;
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with WinUI3.Windows.Graphics.Imaging;
with WinUI3.Windows.Storage.Streams;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Microsoft.UI.Xaml.Media.Imaging is

   package IAsyncOperation_IBuffer is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.Windows.Storage.Streams.IBuffer);
   package AsyncOperationCompletedHandler_IBuffer is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.Windows.Storage.Streams.IBuffer);

   package IAsyncOperation_SvgImageSourceLoadStatus is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.Microsoft.UI.Xaml.Media.Imaging.SvgImageSourceLoadStatus);
   package AsyncOperationCompletedHandler_SvgImageSourceLoadStatus is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.Microsoft.UI.Xaml.Media.Imaging.SvgImageSourceLoadStatus);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BitmapSource

   procedure Initialize (this : in out BitmapSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out BitmapSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBitmapSource, IBitmapSource_Ptr);
   begin
      if this.m_IBitmapSource /= null then
         if this.m_IBitmapSource.all /= null then
            temp := this.m_IBitmapSource.all.Release;
            Free (this.m_IBitmapSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BitmapSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return BitmapSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapSource");
      m_Factory    : access IBitmapSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapSource;
   begin
      return RetVal : BitmapSource do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBitmapSource := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapSource;
            Retval.m_IBitmapSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BitmapSource

   function get_PixelWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PixelWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PixelHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PixelHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BitmapSource

   function get_PixelWidth
   (
      this : in out BitmapSource
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IBitmapSource.all.get_PixelWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PixelHeight
   (
      this : in out BitmapSource
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IBitmapSource.all.get_PixelHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetSource
   (
      this : in out BitmapSource;
      streamSource : WinUI3.Windows.Storage.Streams.IRandomAccessStream
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapSource.all.SetSource (streamSource);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetSourceAsync
   (
      this : in out BitmapSource;
      streamSource : WinUI3.Windows.Storage.Streams.IRandomAccessStream
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IBitmapSource.all.SetSourceAsync (streamSource, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BitmapImage

   procedure Initialize (this : in out BitmapImage) is
   begin
      null;
   end;

   procedure Finalize (this : in out BitmapImage) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBitmapImage, IBitmapImage_Ptr);
   begin
      if this.m_IBitmapImage /= null then
         if this.m_IBitmapImage.all /= null then
            temp := this.m_IBitmapImage.all.Release;
            Free (this.m_IBitmapImage);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BitmapImage

   function Constructor
   (
      uriSource : WinUI3.Windows.Foundation.Uri'Class
   )
   return BitmapImage is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapImage");
      m_Factory    : access IBitmapImageFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImage;
   begin
      return RetVal : BitmapImage do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapImageFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithUriSource (uriSource.m_IUriRuntimeClass.all, m_ComRetVal'Access);
            Retval.m_IBitmapImage := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImage;
            Retval.m_IBitmapImage.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor return BitmapImage is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapImage");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImage;
   begin
      return RetVal : BitmapImage do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IBitmapImage := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImage;
            Retval.m_IBitmapImage.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BitmapImage

   function get_CreateOptionsProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapImage");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CreateOptionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_UriSourceProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapImage");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UriSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DecodePixelWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapImage");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DecodePixelWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DecodePixelHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapImage");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DecodePixelHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DecodePixelTypeProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapImage");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DecodePixelTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsAnimatedBitmapProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapImage");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsAnimatedBitmapProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPlayingProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapImage");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPlayingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AutoPlayProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.BitmapImage");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IBitmapImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoPlayProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BitmapImage

   function get_CreateOptions
   (
      this : in out BitmapImage
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Imaging.BitmapCreateOptions is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.BitmapCreateOptions;
   begin
      Hr := this.m_IBitmapImage.all.get_CreateOptions (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CreateOptions
   (
      this : in out BitmapImage;
      value : WinUI3.Microsoft.UI.Xaml.Media.Imaging.BitmapCreateOptions
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapImage.all.put_CreateOptions (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_UriSource
   (
      this : in out BitmapImage
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IBitmapImage.all.get_UriSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_UriSource
   (
      this : in out BitmapImage;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapImage.all.put_UriSource (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DecodePixelWidth
   (
      this : in out BitmapImage
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IBitmapImage.all.get_DecodePixelWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DecodePixelWidth
   (
      this : in out BitmapImage;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapImage.all.put_DecodePixelWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DecodePixelHeight
   (
      this : in out BitmapImage
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IBitmapImage.all.get_DecodePixelHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DecodePixelHeight
   (
      this : in out BitmapImage;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapImage.all.put_DecodePixelHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DecodePixelType
   (
      this : in out BitmapImage
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Imaging.DecodePixelType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.DecodePixelType;
   begin
      Hr := this.m_IBitmapImage.all.get_DecodePixelType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DecodePixelType
   (
      this : in out BitmapImage;
      value : WinUI3.Microsoft.UI.Xaml.Media.Imaging.DecodePixelType
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapImage.all.put_DecodePixelType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsAnimatedBitmap
   (
      this : in out BitmapImage
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IBitmapImage.all.get_IsAnimatedBitmap (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsPlaying
   (
      this : in out BitmapImage
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IBitmapImage.all.get_IsPlaying (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AutoPlay
   (
      this : in out BitmapImage
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IBitmapImage.all.get_AutoPlay (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutoPlay
   (
      this : in out BitmapImage;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapImage.all.put_AutoPlay (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DownloadProgress
   (
      this : in out BitmapImage;
      handler : WinUI3.Microsoft.UI.Xaml.Media.Imaging.DownloadProgressEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IBitmapImage.all.add_DownloadProgress (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DownloadProgress
   (
      this : in out BitmapImage;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapImage.all.remove_DownloadProgress (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ImageOpened
   (
      this : in out BitmapImage;
      handler : WinUI3.Microsoft.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IBitmapImage.all.add_ImageOpened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ImageOpened
   (
      this : in out BitmapImage;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapImage.all.remove_ImageOpened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ImageFailed
   (
      this : in out BitmapImage;
      handler : WinUI3.Microsoft.UI.Xaml.ExceptionRoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IBitmapImage.all.add_ImageFailed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ImageFailed
   (
      this : in out BitmapImage;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapImage.all.remove_ImageFailed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Play
   (
      this : in out BitmapImage
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapImage.all.Play;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out BitmapImage
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapImage.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DownloadProgressEventArgs

   procedure Initialize (this : in out DownloadProgressEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DownloadProgressEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDownloadProgressEventArgs, IDownloadProgressEventArgs_Ptr);
   begin
      if this.m_IDownloadProgressEventArgs /= null then
         if this.m_IDownloadProgressEventArgs.all /= null then
            temp := this.m_IDownloadProgressEventArgs.all.Release;
            Free (this.m_IDownloadProgressEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DownloadProgressEventArgs

   function get_Progress
   (
      this : in out DownloadProgressEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IDownloadProgressEventArgs.all.get_Progress (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Progress
   (
      this : in out DownloadProgressEventArgs;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDownloadProgressEventArgs.all.put_Progress (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate DownloadProgressEventHandler

   function Invoke
   (
      this : access DownloadProgressEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Microsoft.UI.Xaml.Media.Imaging.IDownloadProgressEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RenderTargetBitmap

   procedure Initialize (this : in out RenderTargetBitmap) is
   begin
      null;
   end;

   procedure Finalize (this : in out RenderTargetBitmap) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRenderTargetBitmap, IRenderTargetBitmap_Ptr);
   begin
      if this.m_IRenderTargetBitmap /= null then
         if this.m_IRenderTargetBitmap.all /= null then
            temp := this.m_IRenderTargetBitmap.all.Release;
            Free (this.m_IRenderTargetBitmap);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RenderTargetBitmap

   function Constructor return RenderTargetBitmap is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.RenderTargetBitmap");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.IRenderTargetBitmap;
   begin
      return RetVal : RenderTargetBitmap do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRenderTargetBitmap := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.IRenderTargetBitmap;
            Retval.m_IRenderTargetBitmap.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RenderTargetBitmap

   function get_PixelWidthProperty_RenderTargetBitmap
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.RenderTargetBitmap");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IRenderTargetBitmapStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRenderTargetBitmapStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PixelWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PixelHeightProperty_RenderTargetBitmap
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.RenderTargetBitmap");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.IRenderTargetBitmapStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRenderTargetBitmapStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PixelHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RenderTargetBitmap

   function get_PixelWidth
   (
      this : in out RenderTargetBitmap
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRenderTargetBitmap.all.get_PixelWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PixelHeight
   (
      this : in out RenderTargetBitmap
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRenderTargetBitmap.all.get_PixelHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure RenderAsync
   (
      this : in out RenderTargetBitmap;
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IRenderTargetBitmap.all.RenderAsync (element.m_IUIElement.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   procedure RenderAsync
   (
      this : in out RenderTargetBitmap;
      element : WinUI3.Microsoft.UI.Xaml.UIElement'Class;
      scaledWidth : WinUI3.Int32;
      scaledHeight : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IRenderTargetBitmap.all.RenderAsync (element.m_IUIElement.all, scaledWidth, scaledHeight, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   function GetPixelsAsync
   (
      this : in out RenderTargetBitmap
   )
   return WinUI3.Windows.Storage.Streams.IBuffer is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_IBuffer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_IBuffer.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Windows.Storage.Streams.IBuffer;
      m_IID            : aliased WinUI3.IID := (1005488180, 47527, 23168, (167, 70, 94, 240, 151, 34, 120, 120 )); -- Windows.Storage.Streams.IBuffer;
      m_HandlerIID     : aliased WinUI3.IID := (1371788029, 47265, 22048, (183, 70, 126, 230, 213, 51, 172, 163 ));
      m_Handler        : AsyncOperationCompletedHandler_IBuffer.Kind := new AsyncOperationCompletedHandler_IBuffer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_IBuffer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_IBuffer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_IBuffer.Kind_Delegate, AsyncOperationCompletedHandler_IBuffer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IRenderTargetBitmap.all.GetPixelsAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SoftwareBitmapSource

   procedure Initialize (this : in out SoftwareBitmapSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out SoftwareBitmapSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISoftwareBitmapSource, ISoftwareBitmapSource_Ptr);
   begin
      if this.m_ISoftwareBitmapSource /= null then
         if this.m_ISoftwareBitmapSource.all /= null then
            temp := this.m_ISoftwareBitmapSource.all.Release;
            Free (this.m_ISoftwareBitmapSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SoftwareBitmapSource

   function Constructor return SoftwareBitmapSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.SoftwareBitmapSource");
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISoftwareBitmapSource;
   begin
      return RetVal : SoftwareBitmapSource do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISoftwareBitmapSource := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISoftwareBitmapSource;
            Retval.m_ISoftwareBitmapSource.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SoftwareBitmapSource

   procedure SetBitmapAsync
   (
      this : in out SoftwareBitmapSource;
      softwareBitmap : WinUI3.Windows.Graphics.Imaging.SoftwareBitmap'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_ISoftwareBitmapSource.all.SetBitmapAsync (softwareBitmap.m_ISoftwareBitmap.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   procedure Close
   (
      this : in out SoftwareBitmapSource
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.Foundation.IClosable := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISoftwareBitmapSource_Interface, WinUI3.Windows.Foundation.IClosable, WinUI3.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISoftwareBitmapSource.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SurfaceImageSource

   procedure Initialize (this : in out SurfaceImageSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out SurfaceImageSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISurfaceImageSource, ISurfaceImageSource_Ptr);
   begin
      if this.m_ISurfaceImageSource /= null then
         if this.m_ISurfaceImageSource.all /= null then
            temp := this.m_ISurfaceImageSource.all.Release;
            Free (this.m_ISurfaceImageSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SurfaceImageSource

   function Constructor
   (
      pixelWidth : WinUI3.Int32;
      pixelHeight : WinUI3.Int32;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SurfaceImageSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.SurfaceImageSource");
      m_Factory    : access ISurfaceImageSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISurfaceImageSource;
   begin
      return RetVal : SurfaceImageSource do
         Hr := RoGetActivationFactory (m_hString, IID_ISurfaceImageSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithDimensions (pixelWidth, pixelHeight, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISurfaceImageSource := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISurfaceImageSource;
            Retval.m_ISurfaceImageSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      pixelWidth : WinUI3.Int32;
      pixelHeight : WinUI3.Int32;
      isOpaque : WinUI3.Boolean;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SurfaceImageSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.SurfaceImageSource");
      m_Factory    : access ISurfaceImageSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISurfaceImageSource;
   begin
      return RetVal : SurfaceImageSource do
         Hr := RoGetActivationFactory (m_hString, IID_ISurfaceImageSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithDimensionsAndOpacity (pixelWidth, pixelHeight, isOpaque, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISurfaceImageSource := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISurfaceImageSource;
            Retval.m_ISurfaceImageSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SurfaceImageSource

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SvgImageSource

   procedure Initialize (this : in out SvgImageSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out SvgImageSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISvgImageSource, ISvgImageSource_Ptr);
   begin
      if this.m_ISvgImageSource /= null then
         if this.m_ISvgImageSource.all /= null then
            temp := this.m_ISvgImageSource.all.Release;
            Free (this.m_ISvgImageSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SvgImageSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SvgImageSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.SvgImageSource");
      m_Factory    : access ISvgImageSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISvgImageSource;
   begin
      return RetVal : SvgImageSource do
         Hr := RoGetActivationFactory (m_hString, IID_ISvgImageSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISvgImageSource := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISvgImageSource;
            Retval.m_ISvgImageSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      uriSource : WinUI3.Windows.Foundation.Uri'Class;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SvgImageSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.SvgImageSource");
      m_Factory    : access ISvgImageSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISvgImageSource;
   begin
      return RetVal : SvgImageSource do
         Hr := RoGetActivationFactory (m_hString, IID_ISvgImageSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithUriSource (uriSource.m_IUriRuntimeClass.all, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISvgImageSource := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISvgImageSource;
            Retval.m_ISvgImageSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SvgImageSource

   function get_UriSourceProperty_SvgImageSource
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.SvgImageSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISvgImageSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISvgImageSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UriSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RasterizePixelWidthProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.SvgImageSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISvgImageSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISvgImageSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RasterizePixelWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RasterizePixelHeightProperty
   return WinUI3.Microsoft.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.SvgImageSource");
      m_Factory        : access WinUI3.Microsoft.UI.Xaml.Media.Imaging.ISvgImageSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Microsoft.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISvgImageSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RasterizePixelHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Microsoft.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SvgImageSource

   function get_UriSource
   (
      this : in out SvgImageSource
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_ISvgImageSource.all.get_UriSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_UriSource
   (
      this : in out SvgImageSource;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISvgImageSource.all.put_UriSource (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RasterizePixelWidth
   (
      this : in out SvgImageSource
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISvgImageSource.all.get_RasterizePixelWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RasterizePixelWidth
   (
      this : in out SvgImageSource;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISvgImageSource.all.put_RasterizePixelWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RasterizePixelHeight
   (
      this : in out SvgImageSource
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISvgImageSource.all.get_RasterizePixelHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RasterizePixelHeight
   (
      this : in out SvgImageSource;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISvgImageSource.all.put_RasterizePixelHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opened
   (
      this : in out SvgImageSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISvgImageSource.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out SvgImageSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISvgImageSource.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_OpenFailed
   (
      this : in out SvgImageSource;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISvgImageSource.all.add_OpenFailed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_OpenFailed
   (
      this : in out SvgImageSource;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISvgImageSource.all.remove_OpenFailed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function SetSourceAsync
   (
      this : in out SvgImageSource;
      streamSource : WinUI3.Windows.Storage.Streams.IRandomAccessStream
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Imaging.SvgImageSourceLoadStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_SvgImageSourceLoadStatus.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_SvgImageSourceLoadStatus.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.SvgImageSourceLoadStatus;
      m_IID            : aliased WinUI3.IID := (83773865, 60743, 22218, (147, 234, 234, 167, 3, 34, 113, 197 )); -- Microsoft.UI.Xaml.Media.Imaging.SvgImageSourceLoadStatus;
      m_HandlerIID     : aliased WinUI3.IID := (3478251510, 10670, 20747, (150, 7, 15, 134, 16, 60, 97, 184 ));
      m_Handler        : AsyncOperationCompletedHandler_SvgImageSourceLoadStatus.Kind := new AsyncOperationCompletedHandler_SvgImageSourceLoadStatus.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_SvgImageSourceLoadStatus.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_SvgImageSourceLoadStatus.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_SvgImageSourceLoadStatus.Kind_Delegate, AsyncOperationCompletedHandler_SvgImageSourceLoadStatus.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ISvgImageSource.all.SetSourceAsync (streamSource, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SvgImageSourceFailedEventArgs

   procedure Initialize (this : in out SvgImageSourceFailedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SvgImageSourceFailedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISvgImageSourceFailedEventArgs, ISvgImageSourceFailedEventArgs_Ptr);
   begin
      if this.m_ISvgImageSourceFailedEventArgs /= null then
         if this.m_ISvgImageSourceFailedEventArgs.all /= null then
            temp := this.m_ISvgImageSourceFailedEventArgs.all.Release;
            Free (this.m_ISvgImageSourceFailedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SvgImageSourceFailedEventArgs

   function get_Status
   (
      this : in out SvgImageSourceFailedEventArgs
   )
   return WinUI3.Microsoft.UI.Xaml.Media.Imaging.SvgImageSourceLoadStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.SvgImageSourceLoadStatus;
   begin
      Hr := this.m_ISvgImageSourceFailedEventArgs.all.get_Status (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SvgImageSourceOpenedEventArgs

   procedure Initialize (this : in out SvgImageSourceOpenedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SvgImageSourceOpenedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISvgImageSourceOpenedEventArgs, ISvgImageSourceOpenedEventArgs_Ptr);
   begin
      if this.m_ISvgImageSourceOpenedEventArgs /= null then
         if this.m_ISvgImageSourceOpenedEventArgs.all /= null then
            temp := this.m_ISvgImageSourceOpenedEventArgs.all.Release;
            Free (this.m_ISvgImageSourceOpenedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SvgImageSourceOpenedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VirtualSurfaceImageSource

   procedure Initialize (this : in out VirtualSurfaceImageSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out VirtualSurfaceImageSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVirtualSurfaceImageSource, IVirtualSurfaceImageSource_Ptr);
   begin
      if this.m_IVirtualSurfaceImageSource /= null then
         if this.m_IVirtualSurfaceImageSource.all /= null then
            temp := this.m_IVirtualSurfaceImageSource.all.Release;
            Free (this.m_IVirtualSurfaceImageSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VirtualSurfaceImageSource

   function Constructor
   (
      pixelWidth : WinUI3.Int32;
      pixelHeight : WinUI3.Int32
   )
   return VirtualSurfaceImageSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.VirtualSurfaceImageSource");
      m_Factory    : access IVirtualSurfaceImageSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.IVirtualSurfaceImageSource;
   begin
      return RetVal : VirtualSurfaceImageSource do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualSurfaceImageSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithDimensions (pixelWidth, pixelHeight, m_ComRetVal'Access);
            Retval.m_IVirtualSurfaceImageSource := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.IVirtualSurfaceImageSource;
            Retval.m_IVirtualSurfaceImageSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      pixelWidth : WinUI3.Int32;
      pixelHeight : WinUI3.Int32;
      isOpaque : WinUI3.Boolean
   )
   return VirtualSurfaceImageSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.VirtualSurfaceImageSource");
      m_Factory    : access IVirtualSurfaceImageSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.IVirtualSurfaceImageSource;
   begin
      return RetVal : VirtualSurfaceImageSource do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualSurfaceImageSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithDimensionsAndOpacity (pixelWidth, pixelHeight, isOpaque, m_ComRetVal'Access);
            Retval.m_IVirtualSurfaceImageSource := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.IVirtualSurfaceImageSource;
            Retval.m_IVirtualSurfaceImageSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VirtualSurfaceImageSource

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WriteableBitmap

   procedure Initialize (this : in out WriteableBitmap) is
   begin
      null;
   end;

   procedure Finalize (this : in out WriteableBitmap) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWriteableBitmap, IWriteableBitmap_Ptr);
   begin
      if this.m_IWriteableBitmap /= null then
         if this.m_IWriteableBitmap.all /= null then
            temp := this.m_IWriteableBitmap.all.Release;
            Free (this.m_IWriteableBitmap);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for WriteableBitmap

   function Constructor
   (
      pixelWidth : WinUI3.Int32;
      pixelHeight : WinUI3.Int32
   )
   return WriteableBitmap is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.WriteableBitmap");
      m_Factory    : access IWriteableBitmapFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.IWriteableBitmap;
   begin
      return RetVal : WriteableBitmap do
         Hr := RoGetActivationFactory (m_hString, IID_IWriteableBitmapFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithDimensions (pixelWidth, pixelHeight, m_ComRetVal'Access);
            Retval.m_IWriteableBitmap := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.IWriteableBitmap;
            Retval.m_IWriteableBitmap.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WriteableBitmap

   function get_PixelBuffer
   (
      this : in out WriteableBitmap
   )
   return WinUI3.Windows.Storage.Streams.IBuffer is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_IWriteableBitmap.all.get_PixelBuffer (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Invalidate
   (
      this : in out WriteableBitmap
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWriteableBitmap.all.Invalidate;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for XamlRenderingBackgroundTask

   procedure Initialize (this : in out XamlRenderingBackgroundTask) is
   begin
      null;
   end;

   procedure Finalize (this : in out XamlRenderingBackgroundTask) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IXamlRenderingBackgroundTask, IXamlRenderingBackgroundTask_Ptr);
   begin
      if this.m_IXamlRenderingBackgroundTask /= null then
         if this.m_IXamlRenderingBackgroundTask.all /= null then
            temp := this.m_IXamlRenderingBackgroundTask.all.Release;
            Free (this.m_IXamlRenderingBackgroundTask);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for XamlRenderingBackgroundTask

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return XamlRenderingBackgroundTask is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Microsoft.UI.Xaml.Media.Imaging.XamlRenderingBackgroundTask");
      m_Factory    : access IXamlRenderingBackgroundTaskFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Microsoft.UI.Xaml.Media.Imaging.IXamlRenderingBackgroundTask;
   begin
      return RetVal : XamlRenderingBackgroundTask do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlRenderingBackgroundTaskFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IXamlRenderingBackgroundTask := new WinUI3.Microsoft.UI.Xaml.Media.Imaging.IXamlRenderingBackgroundTask;
            Retval.m_IXamlRenderingBackgroundTask.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for XamlRenderingBackgroundTask

   procedure OnRun
   (
      this : in out XamlRenderingBackgroundTask;
      taskInstance : WinUI3.Windows.ApplicationModel.Background.IBackgroundTaskInstance
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Xaml.Media.Imaging.IXamlRenderingBackgroundTaskOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Xaml.Media.Imaging.IXamlRenderingBackgroundTask_Interface, WinUI3.Microsoft.UI.Xaml.Media.Imaging.IXamlRenderingBackgroundTaskOverrides, WinUI3.Microsoft.UI.Xaml.Media.Imaging.IID_IXamlRenderingBackgroundTaskOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlRenderingBackgroundTask.all);
      Hr := m_Interface.OnRun (taskInstance);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

end WinUI3.Microsoft.UI.Xaml.Media.Imaging;
