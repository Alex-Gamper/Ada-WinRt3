--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Microsoft.UI.Input;
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Microsoft.UI.Composition.Interactions is

   package IIterable_ICompositionInteractionSource is new WinUI3.Windows.Foundation.Collections.IIterable (ICompositionInteractionSource);
   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionConditionalValue

   procedure Initialize (this : in out CompositionConditionalValue) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionConditionalValue) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionConditionalValue, ICompositionConditionalValue_Ptr);
   begin
      if this.m_ICompositionConditionalValue /= null then
         if this.m_ICompositionConditionalValue.all /= null then
            temp := this.m_ICompositionConditionalValue.all.Release;
            if temp < 1 then
               Free (this.m_ICompositionConditionalValue);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CompositionConditionalValue

   function Create
   (
      compositor : WinUI3.Microsoft.UI.Composition.Compositor'Class
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.CompositionConditionalValue is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Composition.Interactions.CompositionConditionalValue");
      m_Factory        : access WinUI3.Microsoft.UI.Composition.Interactions.ICompositionConditionalValueStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.ICompositionConditionalValue;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Interactions.CompositionConditionalValue do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionConditionalValueStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ICompositionConditionalValue := new WinUI3.Microsoft.UI.Composition.Interactions.ICompositionConditionalValue;
            Retval.m_ICompositionConditionalValue.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionConditionalValue

   function get_Condition
   (
      this : in out CompositionConditionalValue
   )
   return WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.ExpressionAnimation do
         Hr := this.m_ICompositionConditionalValue.all.get_Condition (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IExpressionAnimation := new WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
         Retval.m_IExpressionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_Condition
   (
      this : in out CompositionConditionalValue;
      value : WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositionConditionalValue.all.put_Condition (value.m_IExpressionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Value
   (
      this : in out CompositionConditionalValue
   )
   return WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.ExpressionAnimation do
         Hr := this.m_ICompositionConditionalValue.all.get_Value (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IExpressionAnimation := new WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
         Retval.m_IExpressionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_Value
   (
      this : in out CompositionConditionalValue;
      value : WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositionConditionalValue.all.put_Value (value.m_IExpressionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionInteractionSourceCollection

   procedure Initialize (this : in out CompositionInteractionSourceCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionInteractionSourceCollection) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionInteractionSourceCollection, ICompositionInteractionSourceCollection_Ptr);
   begin
      if this.m_ICompositionInteractionSourceCollection /= null then
         if this.m_ICompositionInteractionSourceCollection.all /= null then
            temp := this.m_ICompositionInteractionSourceCollection.all.Release;
            if temp < 1 then
               Free (this.m_ICompositionInteractionSourceCollection);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionInteractionSourceCollection

   function get_Count
   (
      this : in out CompositionInteractionSourceCollection
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ICompositionInteractionSourceCollection.all.get_Count (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Add
   (
      this : in out CompositionInteractionSourceCollection;
      value : WinUI3.Microsoft.UI.Composition.Interactions.ICompositionInteractionSource
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositionInteractionSourceCollection.all.Add (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Remove
   (
      this : in out CompositionInteractionSourceCollection;
      value : WinUI3.Microsoft.UI.Composition.Interactions.ICompositionInteractionSource
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositionInteractionSourceCollection.all.Remove (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAll
   (
      this : in out CompositionInteractionSourceCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICompositionInteractionSourceCollection.all.RemoveAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Composition.Interactions.ICompositionInteractionSource>
   function First
   (
      this : in out CompositionInteractionSourceCollection
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.ICompositionInteractionSource is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_ICompositionInteractionSource.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.ICompositionInteractionSource;
      m_GenericIID     : aliased WinUI3.IID := (4018745649, 4788, 24109, (154, 152, 176, 131, 171, 33, 137, 24 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.ICompositionInteractionSourceCollection_Interface, IIterable_ICompositionInteractionSource.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionInteractionSourceCollection.all);
      Hr := m_Interface.First (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionSourceConfiguration

   procedure Initialize (this : in out InteractionSourceConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionSourceConfiguration) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionSourceConfiguration, IInteractionSourceConfiguration_Ptr);
   begin
      if this.m_IInteractionSourceConfiguration /= null then
         if this.m_IInteractionSourceConfiguration.all /= null then
            temp := this.m_IInteractionSourceConfiguration.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionSourceConfiguration);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionSourceConfiguration

   function get_PositionXSourceMode
   (
      this : in out InteractionSourceConfiguration
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceRedirectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceRedirectionMode;
   begin
      Hr := this.m_IInteractionSourceConfiguration.all.get_PositionXSourceMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PositionXSourceMode
   (
      this : in out InteractionSourceConfiguration;
      value : WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceRedirectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionSourceConfiguration.all.put_PositionXSourceMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PositionYSourceMode
   (
      this : in out InteractionSourceConfiguration
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceRedirectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceRedirectionMode;
   begin
      Hr := this.m_IInteractionSourceConfiguration.all.get_PositionYSourceMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PositionYSourceMode
   (
      this : in out InteractionSourceConfiguration;
      value : WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceRedirectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionSourceConfiguration.all.put_PositionYSourceMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScaleSourceMode
   (
      this : in out InteractionSourceConfiguration
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceRedirectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceRedirectionMode;
   begin
      Hr := this.m_IInteractionSourceConfiguration.all.get_ScaleSourceMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ScaleSourceMode
   (
      this : in out InteractionSourceConfiguration;
      value : WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceRedirectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionSourceConfiguration.all.put_ScaleSourceMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTracker

   procedure Initialize (this : in out InteractionTracker) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTracker) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTracker, IInteractionTracker_Ptr);
   begin
      if this.m_IInteractionTracker /= null then
         if this.m_IInteractionTracker.all /= null then
            temp := this.m_IInteractionTracker.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTracker);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InteractionTracker

   procedure SetBindingMode
   (
      boundTracker1 : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTracker'Class;
      boundTracker2 : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTracker'Class;
      axisMode : WinUI3.Microsoft.UI.Composition.Interactions.InteractionBindingAxisModes
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Composition.Interactions.InteractionTracker");
      m_Factory        : access WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IInteractionTrackerStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetBindingMode (boundTracker1.m_IInteractionTracker.all, boundTracker2.m_IInteractionTracker.all, axisMode);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function GetBindingMode
   (
      boundTracker1 : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTracker'Class;
      boundTracker2 : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTracker'Class
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionBindingAxisModes is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Composition.Interactions.InteractionTracker");
      m_Factory        : access WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.InteractionBindingAxisModes;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IInteractionTrackerStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetBindingMode (boundTracker1.m_IInteractionTracker.all, boundTracker2.m_IInteractionTracker.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Create
   (
      compositor : WinUI3.Microsoft.UI.Composition.Compositor'Class
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionTracker is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Composition.Interactions.InteractionTracker");
      m_Factory        : access WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTracker do
         Hr := RoGetActivationFactory (m_hString, IID_IInteractionTrackerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInteractionTracker := new WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker;
            Retval.m_IInteractionTracker.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateWithOwner
   (
      compositor : WinUI3.Microsoft.UI.Composition.Compositor'Class;
      owner : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionTracker is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Composition.Interactions.InteractionTracker");
      m_Factory        : access WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTracker do
         Hr := RoGetActivationFactory (m_hString, IID_IInteractionTrackerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithOwner (compositor.m_ICompositor.all, owner, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInteractionTracker := new WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker;
            Retval.m_IInteractionTracker.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTracker

   function get_InteractionSources
   (
      this : in out InteractionTracker
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.ICompositionInteractionSourceCollection;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Interactions.CompositionInteractionSourceCollection do
         Hr := this.m_IInteractionTracker.all.get_InteractionSources (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionInteractionSourceCollection := new WinUI3.Microsoft.UI.Composition.Interactions.ICompositionInteractionSourceCollection;
         Retval.m_ICompositionInteractionSourceCollection.all := m_ComRetVal;
      end return;
   end;

   function get_IsPositionRoundingSuggested
   (
      this : in out InteractionTracker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInteractionTracker.all.get_IsPositionRoundingSuggested (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MaxPosition
   (
      this : in out InteractionTracker
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IInteractionTracker.all.get_MaxPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxPosition
   (
      this : in out InteractionTracker;
      value : WinUI3.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTracker.all.put_MaxPosition (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxScale
   (
      this : in out InteractionTracker
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IInteractionTracker.all.get_MaxScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxScale
   (
      this : in out InteractionTracker;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTracker.all.put_MaxScale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinPosition
   (
      this : in out InteractionTracker
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IInteractionTracker.all.get_MinPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinPosition
   (
      this : in out InteractionTracker;
      value : WinUI3.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTracker.all.put_MinPosition (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinScale
   (
      this : in out InteractionTracker
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IInteractionTracker.all.get_MinScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinScale
   (
      this : in out InteractionTracker;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTracker.all.put_MinScale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NaturalRestingPosition
   (
      this : in out InteractionTracker
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IInteractionTracker.all.get_NaturalRestingPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NaturalRestingScale
   (
      this : in out InteractionTracker
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IInteractionTracker.all.get_NaturalRestingScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Owner
   (
      this : in out InteractionTracker
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerOwner;
   begin
      Hr := this.m_IInteractionTracker.all.get_Owner (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out InteractionTracker
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IInteractionTracker.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PositionInertiaDecayRate
   (
      this : in out InteractionTracker
   )
   return IReference_Vector3.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Vector3.Kind;
   begin
      Hr := this.m_IInteractionTracker.all.get_PositionInertiaDecayRate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Vector3 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_PositionInertiaDecayRate
   (
      this : in out InteractionTracker;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTracker.all.put_PositionInertiaDecayRate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PositionVelocityInPixelsPerSecond
   (
      this : in out InteractionTracker
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IInteractionTracker.all.get_PositionVelocityInPixelsPerSecond (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Scale
   (
      this : in out InteractionTracker
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IInteractionTracker.all.get_Scale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScaleInertiaDecayRate
   (
      this : in out InteractionTracker
   )
   return IReference_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Single.Kind;
   begin
      Hr := this.m_IInteractionTracker.all.get_ScaleInertiaDecayRate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ScaleInertiaDecayRate
   (
      this : in out InteractionTracker;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTracker.all.put_ScaleInertiaDecayRate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScaleVelocityInPercentPerSecond
   (
      this : in out InteractionTracker
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IInteractionTracker.all.get_ScaleVelocityInPercentPerSecond (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure AdjustPositionXIfGreaterThanThreshold
   (
      this : in out InteractionTracker;
      adjustment : WinUI3.Single;
      positionThreshold : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTracker.all.AdjustPositionXIfGreaterThanThreshold (adjustment, positionThreshold);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure AdjustPositionYIfGreaterThanThreshold
   (
      this : in out InteractionTracker;
      adjustment : WinUI3.Single;
      positionThreshold : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTracker.all.AdjustPositionYIfGreaterThanThreshold (adjustment, positionThreshold);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ConfigurePositionXInertiaModifiers
   (
      this : in out InteractionTracker;
      modifiers : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTracker.all.ConfigurePositionXInertiaModifiers (modifiers);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ConfigurePositionYInertiaModifiers
   (
      this : in out InteractionTracker;
      modifiers : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTracker.all.ConfigurePositionYInertiaModifiers (modifiers);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ConfigureScaleInertiaModifiers
   (
      this : in out InteractionTracker;
      modifiers : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTracker.all.ConfigureScaleInertiaModifiers (modifiers);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryUpdatePosition
   (
      this : in out InteractionTracker;
      value : WinUI3.Windows.Foundation.Numerics.Vector3
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTracker.all.TryUpdatePosition (value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryUpdatePositionBy
   (
      this : in out InteractionTracker;
      amount : WinUI3.Windows.Foundation.Numerics.Vector3
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTracker.all.TryUpdatePositionBy (amount, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryUpdatePositionWithAnimation
   (
      this : in out InteractionTracker;
      animation : WinUI3.Microsoft.UI.Composition.CompositionAnimation'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTracker.all.TryUpdatePositionWithAnimation (animation.m_ICompositionAnimation.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryUpdatePositionWithAdditionalVelocity
   (
      this : in out InteractionTracker;
      velocityInPixelsPerSecond : WinUI3.Windows.Foundation.Numerics.Vector3
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTracker.all.TryUpdatePositionWithAdditionalVelocity (velocityInPixelsPerSecond, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryUpdateScale
   (
      this : in out InteractionTracker;
      value : WinUI3.Single;
      centerPoint : WinUI3.Windows.Foundation.Numerics.Vector3
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTracker.all.TryUpdateScale (value, centerPoint, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryUpdateScaleWithAnimation
   (
      this : in out InteractionTracker;
      animation : WinUI3.Microsoft.UI.Composition.CompositionAnimation'Class;
      centerPoint : WinUI3.Windows.Foundation.Numerics.Vector3
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTracker.all.TryUpdateScaleWithAnimation (animation.m_ICompositionAnimation.all, centerPoint, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryUpdateScaleWithAdditionalVelocity
   (
      this : in out InteractionTracker;
      velocityInPercentPerSecond : WinUI3.Single;
      centerPoint : WinUI3.Windows.Foundation.Numerics.Vector3
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTracker.all.TryUpdateScaleWithAdditionalVelocity (velocityInPercentPerSecond, centerPoint, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ConfigureCenterPointXInertiaModifiers
   (
      this : in out InteractionTracker;
      conditionalValues : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTracker2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTracker.all);
      Hr := m_Interface.ConfigureCenterPointXInertiaModifiers (conditionalValues);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ConfigureCenterPointYInertiaModifiers
   (
      this : in out InteractionTracker;
      conditionalValues : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTracker2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTracker.all);
      Hr := m_Interface.ConfigureCenterPointYInertiaModifiers (conditionalValues);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ConfigureVector2PositionInertiaModifiers
   (
      this : in out InteractionTracker;
      modifiers : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker3, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTracker3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTracker.all);
      Hr := m_Interface.ConfigureVector2PositionInertiaModifiers (modifiers);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryUpdatePosition
   (
      this : in out InteractionTracker;
      value : WinUI3.Windows.Foundation.Numerics.Vector3;
      option : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerClampingOption
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker4, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTracker4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTracker.all);
      Hr := m_Interface.TryUpdatePosition (value, option, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryUpdatePositionBy
   (
      this : in out InteractionTracker;
      amount : WinUI3.Windows.Foundation.Numerics.Vector3;
      option : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerClampingOption
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker4, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTracker4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTracker.all);
      Hr := m_Interface.TryUpdatePositionBy (amount, option, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInertiaFromImpulse
   (
      this : in out InteractionTracker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker4, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTracker4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTracker.all);
      Hr := m_Interface.get_IsInertiaFromImpulse (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryUpdatePosition
   (
      this : in out InteractionTracker;
      value : WinUI3.Windows.Foundation.Numerics.Vector3;
      option : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerClampingOption;
      posUpdateOption : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerPositionUpdateOption
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTracker5, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTracker5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTracker.all);
      Hr := m_Interface.TryUpdatePosition (value, option, posUpdateOption, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerCustomAnimationStateEnteredArgs

   procedure Initialize (this : in out InteractionTrackerCustomAnimationStateEnteredArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerCustomAnimationStateEnteredArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerCustomAnimationStateEnteredArgs, IInteractionTrackerCustomAnimationStateEnteredArgs_Ptr);
   begin
      if this.m_IInteractionTrackerCustomAnimationStateEnteredArgs /= null then
         if this.m_IInteractionTrackerCustomAnimationStateEnteredArgs.all /= null then
            temp := this.m_IInteractionTrackerCustomAnimationStateEnteredArgs.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerCustomAnimationStateEnteredArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerCustomAnimationStateEnteredArgs

   function get_RequestId
   (
      this : in out InteractionTrackerCustomAnimationStateEnteredArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTrackerCustomAnimationStateEnteredArgs.all.get_RequestId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsFromBinding
   (
      this : in out InteractionTrackerCustomAnimationStateEnteredArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerCustomAnimationStateEnteredArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerCustomAnimationStateEnteredArgs_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerCustomAnimationStateEnteredArgs2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTrackerCustomAnimationStateEnteredArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTrackerCustomAnimationStateEnteredArgs.all);
      Hr := m_Interface.get_IsFromBinding (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerIdleStateEnteredArgs

   procedure Initialize (this : in out InteractionTrackerIdleStateEnteredArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerIdleStateEnteredArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerIdleStateEnteredArgs, IInteractionTrackerIdleStateEnteredArgs_Ptr);
   begin
      if this.m_IInteractionTrackerIdleStateEnteredArgs /= null then
         if this.m_IInteractionTrackerIdleStateEnteredArgs.all /= null then
            temp := this.m_IInteractionTrackerIdleStateEnteredArgs.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerIdleStateEnteredArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerIdleStateEnteredArgs

   function get_RequestId
   (
      this : in out InteractionTrackerIdleStateEnteredArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTrackerIdleStateEnteredArgs.all.get_RequestId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsFromBinding
   (
      this : in out InteractionTrackerIdleStateEnteredArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerIdleStateEnteredArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerIdleStateEnteredArgs_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerIdleStateEnteredArgs2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTrackerIdleStateEnteredArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTrackerIdleStateEnteredArgs.all);
      Hr := m_Interface.get_IsFromBinding (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerInertiaModifier

   procedure Initialize (this : in out InteractionTrackerInertiaModifier) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerInertiaModifier) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerInertiaModifier, IInteractionTrackerInertiaModifier_Ptr);
   begin
      if this.m_IInteractionTrackerInertiaModifier /= null then
         if this.m_IInteractionTrackerInertiaModifier.all /= null then
            temp := this.m_IInteractionTrackerInertiaModifier.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerInertiaModifier);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InteractionTrackerInertiaModifier

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerInertiaModifier

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerInertiaMotion

   procedure Initialize (this : in out InteractionTrackerInertiaMotion) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerInertiaMotion) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerInertiaMotion, IInteractionTrackerInertiaMotion_Ptr);
   begin
      if this.m_IInteractionTrackerInertiaMotion /= null then
         if this.m_IInteractionTrackerInertiaMotion.all /= null then
            temp := this.m_IInteractionTrackerInertiaMotion.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerInertiaMotion);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InteractionTrackerInertiaMotion

   function Create
   (
      compositor : WinUI3.Microsoft.UI.Composition.Compositor'Class
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion");
      m_Factory        : access WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaMotionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaMotion;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaMotion do
         Hr := RoGetActivationFactory (m_hString, IID_IInteractionTrackerInertiaMotionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInteractionTrackerInertiaMotion := new WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaMotion;
            Retval.m_IInteractionTrackerInertiaMotion.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerInertiaMotion

   function get_Condition
   (
      this : in out InteractionTrackerInertiaMotion
   )
   return WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.ExpressionAnimation do
         Hr := this.m_IInteractionTrackerInertiaMotion.all.get_Condition (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IExpressionAnimation := new WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
         Retval.m_IExpressionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_Condition
   (
      this : in out InteractionTrackerInertiaMotion;
      value : WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTrackerInertiaMotion.all.put_Condition (value.m_IExpressionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Motion
   (
      this : in out InteractionTrackerInertiaMotion
   )
   return WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.ExpressionAnimation do
         Hr := this.m_IInteractionTrackerInertiaMotion.all.get_Motion (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IExpressionAnimation := new WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
         Retval.m_IExpressionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_Motion
   (
      this : in out InteractionTrackerInertiaMotion;
      value : WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTrackerInertiaMotion.all.put_Motion (value.m_IExpressionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerInertiaNaturalMotion

   procedure Initialize (this : in out InteractionTrackerInertiaNaturalMotion) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerInertiaNaturalMotion) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerInertiaNaturalMotion, IInteractionTrackerInertiaNaturalMotion_Ptr);
   begin
      if this.m_IInteractionTrackerInertiaNaturalMotion /= null then
         if this.m_IInteractionTrackerInertiaNaturalMotion.all /= null then
            temp := this.m_IInteractionTrackerInertiaNaturalMotion.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerInertiaNaturalMotion);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InteractionTrackerInertiaNaturalMotion

   function Create
   (
      compositor : WinUI3.Microsoft.UI.Composition.Compositor'Class
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion");
      m_Factory        : access WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaNaturalMotionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaNaturalMotion;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaNaturalMotion do
         Hr := RoGetActivationFactory (m_hString, IID_IInteractionTrackerInertiaNaturalMotionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInteractionTrackerInertiaNaturalMotion := new WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaNaturalMotion;
            Retval.m_IInteractionTrackerInertiaNaturalMotion.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerInertiaNaturalMotion

   function get_Condition
   (
      this : in out InteractionTrackerInertiaNaturalMotion
   )
   return WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.ExpressionAnimation do
         Hr := this.m_IInteractionTrackerInertiaNaturalMotion.all.get_Condition (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IExpressionAnimation := new WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
         Retval.m_IExpressionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_Condition
   (
      this : in out InteractionTrackerInertiaNaturalMotion;
      value : WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTrackerInertiaNaturalMotion.all.put_Condition (value.m_IExpressionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NaturalMotion
   (
      this : in out InteractionTrackerInertiaNaturalMotion
   )
   return WinUI3.Microsoft.UI.Composition.ScalarNaturalMotionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.IScalarNaturalMotionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.ScalarNaturalMotionAnimation do
         Hr := this.m_IInteractionTrackerInertiaNaturalMotion.all.get_NaturalMotion (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScalarNaturalMotionAnimation := new WinUI3.Microsoft.UI.Composition.IScalarNaturalMotionAnimation;
         Retval.m_IScalarNaturalMotionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_NaturalMotion
   (
      this : in out InteractionTrackerInertiaNaturalMotion;
      value : WinUI3.Microsoft.UI.Composition.ScalarNaturalMotionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTrackerInertiaNaturalMotion.all.put_NaturalMotion (value.m_IScalarNaturalMotionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerInertiaRestingValue

   procedure Initialize (this : in out InteractionTrackerInertiaRestingValue) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerInertiaRestingValue) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerInertiaRestingValue, IInteractionTrackerInertiaRestingValue_Ptr);
   begin
      if this.m_IInteractionTrackerInertiaRestingValue /= null then
         if this.m_IInteractionTrackerInertiaRestingValue.all /= null then
            temp := this.m_IInteractionTrackerInertiaRestingValue.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerInertiaRestingValue);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InteractionTrackerInertiaRestingValue

   function Create
   (
      compositor : WinUI3.Microsoft.UI.Composition.Compositor'Class
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue");
      m_Factory        : access WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaRestingValueStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaRestingValue;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerInertiaRestingValue do
         Hr := RoGetActivationFactory (m_hString, IID_IInteractionTrackerInertiaRestingValueStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInteractionTrackerInertiaRestingValue := new WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaRestingValue;
            Retval.m_IInteractionTrackerInertiaRestingValue.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerInertiaRestingValue

   function get_Condition
   (
      this : in out InteractionTrackerInertiaRestingValue
   )
   return WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.ExpressionAnimation do
         Hr := this.m_IInteractionTrackerInertiaRestingValue.all.get_Condition (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IExpressionAnimation := new WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
         Retval.m_IExpressionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_Condition
   (
      this : in out InteractionTrackerInertiaRestingValue;
      value : WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTrackerInertiaRestingValue.all.put_Condition (value.m_IExpressionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RestingValue
   (
      this : in out InteractionTrackerInertiaRestingValue
   )
   return WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.ExpressionAnimation do
         Hr := this.m_IInteractionTrackerInertiaRestingValue.all.get_RestingValue (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IExpressionAnimation := new WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
         Retval.m_IExpressionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_RestingValue
   (
      this : in out InteractionTrackerInertiaRestingValue;
      value : WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTrackerInertiaRestingValue.all.put_RestingValue (value.m_IExpressionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerInertiaStateEnteredArgs

   procedure Initialize (this : in out InteractionTrackerInertiaStateEnteredArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerInertiaStateEnteredArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerInertiaStateEnteredArgs, IInteractionTrackerInertiaStateEnteredArgs_Ptr);
   begin
      if this.m_IInteractionTrackerInertiaStateEnteredArgs /= null then
         if this.m_IInteractionTrackerInertiaStateEnteredArgs.all /= null then
            temp := this.m_IInteractionTrackerInertiaStateEnteredArgs.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerInertiaStateEnteredArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerInertiaStateEnteredArgs

   function get_ModifiedRestingPosition
   (
      this : in out InteractionTrackerInertiaStateEnteredArgs
   )
   return IReference_Vector3.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Vector3.Kind;
   begin
      Hr := this.m_IInteractionTrackerInertiaStateEnteredArgs.all.get_ModifiedRestingPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Vector3 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_ModifiedRestingScale
   (
      this : in out InteractionTrackerInertiaStateEnteredArgs
   )
   return IReference_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Single.Kind;
   begin
      Hr := this.m_IInteractionTrackerInertiaStateEnteredArgs.all.get_ModifiedRestingScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_NaturalRestingPosition
   (
      this : in out InteractionTrackerInertiaStateEnteredArgs
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IInteractionTrackerInertiaStateEnteredArgs.all.get_NaturalRestingPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NaturalRestingScale
   (
      this : in out InteractionTrackerInertiaStateEnteredArgs
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IInteractionTrackerInertiaStateEnteredArgs.all.get_NaturalRestingScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PositionVelocityInPixelsPerSecond
   (
      this : in out InteractionTrackerInertiaStateEnteredArgs
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IInteractionTrackerInertiaStateEnteredArgs.all.get_PositionVelocityInPixelsPerSecond (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_RequestId
   (
      this : in out InteractionTrackerInertiaStateEnteredArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTrackerInertiaStateEnteredArgs.all.get_RequestId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScaleVelocityInPercentPerSecond
   (
      this : in out InteractionTrackerInertiaStateEnteredArgs
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IInteractionTrackerInertiaStateEnteredArgs.all.get_ScaleVelocityInPercentPerSecond (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInertiaFromImpulse
   (
      this : in out InteractionTrackerInertiaStateEnteredArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaStateEnteredArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaStateEnteredArgs_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaStateEnteredArgs2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTrackerInertiaStateEnteredArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTrackerInertiaStateEnteredArgs.all);
      Hr := m_Interface.get_IsInertiaFromImpulse (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsFromBinding
   (
      this : in out InteractionTrackerInertiaStateEnteredArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaStateEnteredArgs3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaStateEnteredArgs_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInertiaStateEnteredArgs3, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTrackerInertiaStateEnteredArgs3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTrackerInertiaStateEnteredArgs.all);
      Hr := m_Interface.get_IsFromBinding (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerInteractingStateEnteredArgs

   procedure Initialize (this : in out InteractionTrackerInteractingStateEnteredArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerInteractingStateEnteredArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerInteractingStateEnteredArgs, IInteractionTrackerInteractingStateEnteredArgs_Ptr);
   begin
      if this.m_IInteractionTrackerInteractingStateEnteredArgs /= null then
         if this.m_IInteractionTrackerInteractingStateEnteredArgs.all /= null then
            temp := this.m_IInteractionTrackerInteractingStateEnteredArgs.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerInteractingStateEnteredArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerInteractingStateEnteredArgs

   function get_RequestId
   (
      this : in out InteractionTrackerInteractingStateEnteredArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTrackerInteractingStateEnteredArgs.all.get_RequestId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsFromBinding
   (
      this : in out InteractionTrackerInteractingStateEnteredArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInteractingStateEnteredArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInteractingStateEnteredArgs_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerInteractingStateEnteredArgs2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IInteractionTrackerInteractingStateEnteredArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInteractionTrackerInteractingStateEnteredArgs.all);
      Hr := m_Interface.get_IsFromBinding (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerRequestIgnoredArgs

   procedure Initialize (this : in out InteractionTrackerRequestIgnoredArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerRequestIgnoredArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerRequestIgnoredArgs, IInteractionTrackerRequestIgnoredArgs_Ptr);
   begin
      if this.m_IInteractionTrackerRequestIgnoredArgs /= null then
         if this.m_IInteractionTrackerRequestIgnoredArgs.all /= null then
            temp := this.m_IInteractionTrackerRequestIgnoredArgs.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerRequestIgnoredArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerRequestIgnoredArgs

   function get_RequestId
   (
      this : in out InteractionTrackerRequestIgnoredArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTrackerRequestIgnoredArgs.all.get_RequestId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerValuesChangedArgs

   procedure Initialize (this : in out InteractionTrackerValuesChangedArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerValuesChangedArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerValuesChangedArgs, IInteractionTrackerValuesChangedArgs_Ptr);
   begin
      if this.m_IInteractionTrackerValuesChangedArgs /= null then
         if this.m_IInteractionTrackerValuesChangedArgs.all /= null then
            temp := this.m_IInteractionTrackerValuesChangedArgs.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerValuesChangedArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerValuesChangedArgs

   function get_Position
   (
      this : in out InteractionTrackerValuesChangedArgs
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IInteractionTrackerValuesChangedArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_RequestId
   (
      this : in out InteractionTrackerValuesChangedArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInteractionTrackerValuesChangedArgs.all.get_RequestId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Scale
   (
      this : in out InteractionTrackerValuesChangedArgs
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IInteractionTrackerValuesChangedArgs.all.get_Scale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerVector2InertiaModifier

   procedure Initialize (this : in out InteractionTrackerVector2InertiaModifier) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerVector2InertiaModifier) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerVector2InertiaModifier, IInteractionTrackerVector2InertiaModifier_Ptr);
   begin
      if this.m_IInteractionTrackerVector2InertiaModifier /= null then
         if this.m_IInteractionTrackerVector2InertiaModifier.all /= null then
            temp := this.m_IInteractionTrackerVector2InertiaModifier.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerVector2InertiaModifier);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InteractionTrackerVector2InertiaModifier

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerVector2InertiaModifier

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InteractionTrackerVector2InertiaNaturalMotion

   procedure Initialize (this : in out InteractionTrackerVector2InertiaNaturalMotion) is
   begin
      null;
   end;

   procedure Finalize (this : in out InteractionTrackerVector2InertiaNaturalMotion) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInteractionTrackerVector2InertiaNaturalMotion, IInteractionTrackerVector2InertiaNaturalMotion_Ptr);
   begin
      if this.m_IInteractionTrackerVector2InertiaNaturalMotion /= null then
         if this.m_IInteractionTrackerVector2InertiaNaturalMotion.all /= null then
            temp := this.m_IInteractionTrackerVector2InertiaNaturalMotion.all.Release;
            if temp < 1 then
               Free (this.m_IInteractionTrackerVector2InertiaNaturalMotion);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InteractionTrackerVector2InertiaNaturalMotion

   function Create
   (
      compositor : WinUI3.Microsoft.UI.Composition.Compositor'Class
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion");
      m_Factory        : access WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerVector2InertiaNaturalMotionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerVector2InertiaNaturalMotion;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Interactions.InteractionTrackerVector2InertiaNaturalMotion do
         Hr := RoGetActivationFactory (m_hString, IID_IInteractionTrackerVector2InertiaNaturalMotionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IInteractionTrackerVector2InertiaNaturalMotion := new WinUI3.Microsoft.UI.Composition.Interactions.IInteractionTrackerVector2InertiaNaturalMotion;
            Retval.m_IInteractionTrackerVector2InertiaNaturalMotion.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InteractionTrackerVector2InertiaNaturalMotion

   function get_Condition
   (
      this : in out InteractionTrackerVector2InertiaNaturalMotion
   )
   return WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.ExpressionAnimation do
         Hr := this.m_IInteractionTrackerVector2InertiaNaturalMotion.all.get_Condition (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IExpressionAnimation := new WinUI3.Microsoft.UI.Composition.IExpressionAnimation;
         Retval.m_IExpressionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_Condition
   (
      this : in out InteractionTrackerVector2InertiaNaturalMotion;
      value : WinUI3.Microsoft.UI.Composition.ExpressionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTrackerVector2InertiaNaturalMotion.all.put_Condition (value.m_IExpressionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NaturalMotion
   (
      this : in out InteractionTrackerVector2InertiaNaturalMotion
   )
   return WinUI3.Microsoft.UI.Composition.Vector2NaturalMotionAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.IVector2NaturalMotionAnimation;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Vector2NaturalMotionAnimation do
         Hr := this.m_IInteractionTrackerVector2InertiaNaturalMotion.all.get_NaturalMotion (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVector2NaturalMotionAnimation := new WinUI3.Microsoft.UI.Composition.IVector2NaturalMotionAnimation;
         Retval.m_IVector2NaturalMotionAnimation.all := m_ComRetVal;
      end return;
   end;

   procedure put_NaturalMotion
   (
      this : in out InteractionTrackerVector2InertiaNaturalMotion;
      value : WinUI3.Microsoft.UI.Composition.Vector2NaturalMotionAnimation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInteractionTrackerVector2InertiaNaturalMotion.all.put_NaturalMotion (value.m_IVector2NaturalMotionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VisualInteractionSource

   procedure Initialize (this : in out VisualInteractionSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out VisualInteractionSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVisualInteractionSource, IVisualInteractionSource_Ptr);
   begin
      if this.m_IVisualInteractionSource /= null then
         if this.m_IVisualInteractionSource.all /= null then
            temp := this.m_IVisualInteractionSource.all.Release;
            if temp < 1 then
               Free (this.m_IVisualInteractionSource);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VisualInteractionSource

   -----------------------------------------------------------------------------
   -- Static Interfaces for VisualInteractionSource

   function CreateFromIVisualElement
   (
      source : WinUI3.Microsoft.UI.Composition.IVisualElement
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.VisualInteractionSource is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Composition.Interactions.VisualInteractionSource");
      m_Factory        : access WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSourceStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Interactions.VisualInteractionSource do
         Hr := RoGetActivationFactory (m_hString, IID_IVisualInteractionSourceStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromIVisualElement (source, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IVisualInteractionSource := new WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource;
            Retval.m_IVisualInteractionSource.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Create
   (
      source : WinUI3.Microsoft.UI.Composition.Visual'Class
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.VisualInteractionSource is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Composition.Interactions.VisualInteractionSource");
      m_Factory        : access WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Interactions.VisualInteractionSource do
         Hr := RoGetActivationFactory (m_hString, IID_IVisualInteractionSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (source.m_IVisual.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IVisualInteractionSource := new WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource;
            Retval.m_IVisualInteractionSource.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VisualInteractionSource

   function get_IsPositionXRailsEnabled
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IVisualInteractionSource.all.get_IsPositionXRailsEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPositionXRailsEnabled
   (
      this : in out VisualInteractionSource;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualInteractionSource.all.put_IsPositionXRailsEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPositionYRailsEnabled
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IVisualInteractionSource.all.get_IsPositionYRailsEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPositionYRailsEnabled
   (
      this : in out VisualInteractionSource;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualInteractionSource.all.put_IsPositionYRailsEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ManipulationRedirectionMode
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.VisualInteractionSourceRedirectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.VisualInteractionSourceRedirectionMode;
   begin
      Hr := this.m_IVisualInteractionSource.all.get_ManipulationRedirectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ManipulationRedirectionMode
   (
      this : in out VisualInteractionSource;
      value : WinUI3.Microsoft.UI.Composition.Interactions.VisualInteractionSourceRedirectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualInteractionSource.all.put_ManipulationRedirectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PositionXChainingMode
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionChainingMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.InteractionChainingMode;
   begin
      Hr := this.m_IVisualInteractionSource.all.get_PositionXChainingMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PositionXChainingMode
   (
      this : in out VisualInteractionSource;
      value : WinUI3.Microsoft.UI.Composition.Interactions.InteractionChainingMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualInteractionSource.all.put_PositionXChainingMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PositionXSourceMode
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceMode;
   begin
      Hr := this.m_IVisualInteractionSource.all.get_PositionXSourceMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PositionXSourceMode
   (
      this : in out VisualInteractionSource;
      value : WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualInteractionSource.all.put_PositionXSourceMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PositionYChainingMode
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionChainingMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.InteractionChainingMode;
   begin
      Hr := this.m_IVisualInteractionSource.all.get_PositionYChainingMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PositionYChainingMode
   (
      this : in out VisualInteractionSource;
      value : WinUI3.Microsoft.UI.Composition.Interactions.InteractionChainingMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualInteractionSource.all.put_PositionYChainingMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PositionYSourceMode
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceMode;
   begin
      Hr := this.m_IVisualInteractionSource.all.get_PositionYSourceMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PositionYSourceMode
   (
      this : in out VisualInteractionSource;
      value : WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualInteractionSource.all.put_PositionYSourceMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScaleChainingMode
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionChainingMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.InteractionChainingMode;
   begin
      Hr := this.m_IVisualInteractionSource.all.get_ScaleChainingMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ScaleChainingMode
   (
      this : in out VisualInteractionSource;
      value : WinUI3.Microsoft.UI.Composition.Interactions.InteractionChainingMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualInteractionSource.all.put_ScaleChainingMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScaleSourceMode
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceMode;
   begin
      Hr := this.m_IVisualInteractionSource.all.get_ScaleSourceMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ScaleSourceMode
   (
      this : in out VisualInteractionSource;
      value : WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualInteractionSource.all.put_ScaleSourceMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Source
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Microsoft.UI.Composition.Visual'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.IVisual;
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Visual do
         Hr := this.m_IVisualInteractionSource.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinUI3.Microsoft.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

   procedure TryRedirectForManipulation
   (
      this : in out VisualInteractionSource;
      pointerPoint : WinUI3.Microsoft.UI.Input.PointerPoint'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualInteractionSource.all.TryRedirectForManipulation (pointerPoint.m_IPointerPoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DeltaPosition
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualInteractionSource.all);
      Hr := m_Interface.get_DeltaPosition (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DeltaScale
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualInteractionSource.all);
      Hr := m_Interface.get_DeltaScale (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualInteractionSource.all);
      Hr := m_Interface.get_Position (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PositionVelocity
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualInteractionSource.all);
      Hr := m_Interface.get_PositionVelocity (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Scale
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualInteractionSource.all);
      Hr := m_Interface.get_Scale (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScaleVelocity
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualInteractionSource.all);
      Hr := m_Interface.get_ScaleVelocity (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ConfigureCenterPointXModifiers
   (
      this : in out VisualInteractionSource;
      conditionalValues : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualInteractionSource.all);
      Hr := m_Interface.ConfigureCenterPointXModifiers (conditionalValues);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ConfigureCenterPointYModifiers
   (
      this : in out VisualInteractionSource;
      conditionalValues : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualInteractionSource.all);
      Hr := m_Interface.ConfigureCenterPointYModifiers (conditionalValues);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ConfigureDeltaPositionXModifiers
   (
      this : in out VisualInteractionSource;
      conditionalValues : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualInteractionSource.all);
      Hr := m_Interface.ConfigureDeltaPositionXModifiers (conditionalValues);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ConfigureDeltaPositionYModifiers
   (
      this : in out VisualInteractionSource;
      conditionalValues : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualInteractionSource.all);
      Hr := m_Interface.ConfigureDeltaPositionYModifiers (conditionalValues);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ConfigureDeltaScaleModifiers
   (
      this : in out VisualInteractionSource;
      conditionalValues : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource2, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualInteractionSource.all);
      Hr := m_Interface.ConfigureDeltaScaleModifiers (conditionalValues);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerWheelConfig
   (
      this : in out VisualInteractionSource
   )
   return WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Composition.Interactions.IInteractionSourceConfiguration;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource_Interface, WinUI3.Microsoft.UI.Composition.Interactions.IVisualInteractionSource3, WinUI3.Microsoft.UI.Composition.Interactions.IID_IVisualInteractionSource3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Microsoft.UI.Composition.Interactions.InteractionSourceConfiguration do
         m_Interface := QInterface (this.m_IVisualInteractionSource.all);
         Hr := m_Interface.get_PointerWheelConfig (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInteractionSourceConfiguration := new WinUI3.Microsoft.UI.Composition.Interactions.IInteractionSourceConfiguration;
         Retval.m_IInteractionSourceConfiguration.all := m_ComRetVal;
      end return;
   end;

end WinUI3.Microsoft.UI.Composition.Interactions;
