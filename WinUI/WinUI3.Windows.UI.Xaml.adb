--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Windows.ApplicationModel.Activation;
with WinUI3.Windows.ApplicationModel.Core;
with WinUI3.Windows.ApplicationModel.DataTransfer;
with WinUI3.Windows.ApplicationModel.DataTransfer.DragDrop;
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with WinUI3.Windows.Graphics.Imaging;
with WinUI3.Windows.UI.Composition;
with WinUI3.Windows.UI.Core;
with WinUI3.Windows.UI.Input;
with WinUI3.Windows.UI.Xaml.Automation.Peers;
with WinUI3.Windows.UI.Xaml.Controls;
with WinUI3.Windows.UI.Xaml.Controls.Primitives;
with WinUI3.Windows.UI.Xaml.Data;
with WinUI3.Windows.UI.Xaml.Input;
with WinUI3.Windows.UI.Xaml.Interop;
with WinUI3.Windows.UI.Xaml.Media;
with WinUI3.Windows.UI.Xaml.Media.Animation;
with WinUI3.Windows.UI.Xaml.Media.Imaging;
with WinUI3.Windows.UI.Xaml.Media.Media3D;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Windows.UI.Xaml is

   package IAsyncOperation_DataPackageOperation is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation);
   package AsyncOperationCompletedHandler_DataPackageOperation is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation);

   package IObservableVector_IDependencyObject is new WinUI3.Windows.Foundation.Collections.IObservableVector (IDependencyObject);
   package IVector_IDependencyObject is new WinUI3.Windows.Foundation.Collections.IVector (IDependencyObject);
   package IVector_ISetterBase is new WinUI3.Windows.Foundation.Collections.IVector (ISetterBase);
   package IIterable_ISetterBase is new WinUI3.Windows.Foundation.Collections.IIterable (ISetterBase);
   package IVector_ITriggerAction is new WinUI3.Windows.Foundation.Collections.IVector (ITriggerAction);
   package IIterable_ITriggerAction is new WinUI3.Windows.Foundation.Collections.IIterable (ITriggerAction);
   package IVector_ITriggerBase is new WinUI3.Windows.Foundation.Collections.IVector (ITriggerBase);
   package IIterable_ITriggerBase is new WinUI3.Windows.Foundation.Collections.IIterable (ITriggerBase);
   package IVector_IUIElement is new WinUI3.Windows.Foundation.Collections.IVector (IUIElement);
   package IIterable_IUIElement is new WinUI3.Windows.Foundation.Collections.IIterable (IUIElement);
   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DependencyObject

   procedure Initialize (this : in out DependencyObject) is
   begin
      null;
   end;

   procedure Finalize (this : in out DependencyObject) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDependencyObject, IDependencyObject_Ptr);
   begin
      if this.m_IDependencyObject /= null then
         if this.m_IDependencyObject.all /= null then
            temp := this.m_IDependencyObject.all.Release;
            Free (this.m_IDependencyObject);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DependencyObject

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DependencyObject is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DependencyObject");
      m_Factory    : access IDependencyObjectFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : DependencyObject do
         Hr := RoGetActivationFactory (m_hString, IID_IDependencyObjectFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
            Retval.m_IDependencyObject.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DependencyObject

   function GetValue
   (
      this : in out DependencyObject;
      dp : WinUI3.Windows.UI.Xaml.DependencyProperty'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IDependencyObject.all.GetValue (dp.m_IDependencyProperty.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetValue
   (
      this : in out DependencyObject;
      dp : WinUI3.Windows.UI.Xaml.DependencyProperty'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDependencyObject.all.SetValue (dp.m_IDependencyProperty.all, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ClearValue
   (
      this : in out DependencyObject;
      dp : WinUI3.Windows.UI.Xaml.DependencyProperty'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDependencyObject.all.ClearValue (dp.m_IDependencyProperty.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ReadLocalValue
   (
      this : in out DependencyObject;
      dp : WinUI3.Windows.UI.Xaml.DependencyProperty'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IDependencyObject.all.ReadLocalValue (dp.m_IDependencyProperty.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetAnimationBaseValue
   (
      this : in out DependencyObject;
      dp : WinUI3.Windows.UI.Xaml.DependencyProperty'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IDependencyObject.all.GetAnimationBaseValue (dp.m_IDependencyProperty.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Dispatcher
   (
      this : in out DependencyObject
   )
   return WinUI3.Windows.UI.Core.CoreDispatcher'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Core.ICoreDispatcher;
   begin
      return RetVal : WinUI3.Windows.UI.Core.CoreDispatcher do
         Hr := this.m_IDependencyObject.all.get_Dispatcher (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreDispatcher := new WinUI3.Windows.UI.Core.ICoreDispatcher;
         Retval.m_ICoreDispatcher.all := m_ComRetVal;
      end return;
   end;

   function RegisterPropertyChangedCallback
   (
      this : in out DependencyObject;
      dp : WinUI3.Windows.UI.Xaml.DependencyProperty'Class;
      callback : WinUI3.Windows.UI.Xaml.DependencyPropertyChangedCallback
   )
   return WinUI3.Int64 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDependencyObject2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int64;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDependencyObject_Interface, WinUI3.Windows.UI.Xaml.IDependencyObject2, WinUI3.Windows.UI.Xaml.IID_IDependencyObject2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDependencyObject.all);
      Hr := m_Interface.RegisterPropertyChangedCallback (dp.m_IDependencyProperty.all, callback, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure UnregisterPropertyChangedCallback
   (
      this : in out DependencyObject;
      dp : WinUI3.Windows.UI.Xaml.DependencyProperty'Class;
      token : WinUI3.Int64
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDependencyObject2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDependencyObject_Interface, WinUI3.Windows.UI.Xaml.IDependencyObject2, WinUI3.Windows.UI.Xaml.IID_IDependencyObject2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDependencyObject.all);
      Hr := m_Interface.UnregisterPropertyChangedCallback (dp.m_IDependencyProperty.all, token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StateTriggerBase

   procedure Initialize (this : in out StateTriggerBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out StateTriggerBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStateTriggerBase, IStateTriggerBase_Ptr);
   begin
      if this.m_IStateTriggerBase /= null then
         if this.m_IStateTriggerBase.all /= null then
            temp := this.m_IStateTriggerBase.all.Release;
            Free (this.m_IStateTriggerBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for StateTriggerBase

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return StateTriggerBase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.StateTriggerBase");
      m_Factory    : access IStateTriggerBaseFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IStateTriggerBase;
   begin
      return RetVal : StateTriggerBase do
         Hr := RoGetActivationFactory (m_hString, IID_IStateTriggerBaseFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IStateTriggerBase := new WinUI3.Windows.UI.Xaml.IStateTriggerBase;
            Retval.m_IStateTriggerBase.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StateTriggerBase

   procedure SetActive
   (
      this : in out StateTriggerBase;
      IsActive : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IStateTriggerBaseProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IStateTriggerBase_Interface, WinUI3.Windows.UI.Xaml.IStateTriggerBaseProtected, WinUI3.Windows.UI.Xaml.IID_IStateTriggerBaseProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStateTriggerBase.all);
      Hr := m_Interface.SetActive (IsActive);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AdaptiveTrigger

   procedure Initialize (this : in out AdaptiveTrigger) is
   begin
      null;
   end;

   procedure Finalize (this : in out AdaptiveTrigger) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAdaptiveTrigger, IAdaptiveTrigger_Ptr);
   begin
      if this.m_IAdaptiveTrigger /= null then
         if this.m_IAdaptiveTrigger.all /= null then
            temp := this.m_IAdaptiveTrigger.all.Release;
            Free (this.m_IAdaptiveTrigger);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AdaptiveTrigger

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AdaptiveTrigger is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.AdaptiveTrigger");
      m_Factory    : access IAdaptiveTriggerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IAdaptiveTrigger;
   begin
      return RetVal : AdaptiveTrigger do
         Hr := RoGetActivationFactory (m_hString, IID_IAdaptiveTriggerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAdaptiveTrigger := new WinUI3.Windows.UI.Xaml.IAdaptiveTrigger;
            Retval.m_IAdaptiveTrigger.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AdaptiveTrigger

   function get_MinWindowWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.AdaptiveTrigger");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IAdaptiveTriggerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAdaptiveTriggerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinWindowWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinWindowHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.AdaptiveTrigger");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IAdaptiveTriggerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAdaptiveTriggerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinWindowHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AdaptiveTrigger

   function get_MinWindowWidth
   (
      this : in out AdaptiveTrigger
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAdaptiveTrigger.all.get_MinWindowWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinWindowWidth
   (
      this : in out AdaptiveTrigger;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAdaptiveTrigger.all.put_MinWindowWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinWindowHeight
   (
      this : in out AdaptiveTrigger
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAdaptiveTrigger.all.get_MinWindowHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinWindowHeight
   (
      this : in out AdaptiveTrigger;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAdaptiveTrigger.all.put_MinWindowHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Application

   procedure Initialize (this : in out Application) is
   begin
      null;
   end;

   procedure Finalize (this : in out Application) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IApplication, IApplication_Ptr);
   begin
      if this.m_IApplication /= null then
         if this.m_IApplication.all /= null then
            temp := this.m_IApplication.all.Release;
            Free (this.m_IApplication);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Application

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Application is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Application");
      m_Factory    : access IApplicationFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IApplication;
   begin
      return RetVal : Application do
         Hr := RoGetActivationFactory (m_hString, IID_IApplicationFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IApplication := new WinUI3.Windows.UI.Xaml.IApplication;
            Retval.m_IApplication.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Application

   function get_Current
   return WinUI3.Windows.UI.Xaml.Application is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Application");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IApplicationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IApplication;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Application do
         Hr := RoGetActivationFactory (m_hString, IID_IApplicationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Current (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IApplication := new WinUI3.Windows.UI.Xaml.IApplication;
            Retval.m_IApplication.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure Start
   (
      callback : WinUI3.Windows.UI.Xaml.ApplicationInitializationCallback
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Application");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IApplicationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IApplicationStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Start (callback);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   procedure LoadComponent
   (
      component : WinUI3.IInspectable;
      resourceLocator : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Application");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IApplicationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IApplicationStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.LoadComponent (component, resourceLocator.m_IUriRuntimeClass.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   procedure LoadComponent
   (
      component : WinUI3.IInspectable;
      resourceLocator : WinUI3.Windows.Foundation.Uri'Class;
      componentResourceLocation : WinUI3.Windows.UI.Xaml.Controls.Primitives.ComponentResourceLocation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Application");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IApplicationStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IApplicationStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.LoadComponent (component, resourceLocator.m_IUriRuntimeClass.all, componentResourceLocation);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Application

   function get_Resources
   (
      this : in out Application
   )
   return WinUI3.Windows.UI.Xaml.ResourceDictionary'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IResourceDictionary;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.ResourceDictionary do
         Hr := this.m_IApplication.all.get_Resources (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IResourceDictionary := new WinUI3.Windows.UI.Xaml.IResourceDictionary;
         Retval.m_IResourceDictionary.all := m_ComRetVal;
      end return;
   end;

   procedure put_Resources
   (
      this : in out Application;
      value : WinUI3.Windows.UI.Xaml.ResourceDictionary'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IApplication.all.put_Resources (value.m_IResourceDictionary.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DebugSettings
   (
      this : in out Application
   )
   return WinUI3.Windows.UI.Xaml.DebugSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDebugSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DebugSettings do
         Hr := this.m_IApplication.all.get_DebugSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDebugSettings := new WinUI3.Windows.UI.Xaml.IDebugSettings;
         Retval.m_IDebugSettings.all := m_ComRetVal;
      end return;
   end;

   function get_RequestedTheme
   (
      this : in out Application
   )
   return WinUI3.Windows.UI.Xaml.ApplicationTheme is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ApplicationTheme;
   begin
      Hr := this.m_IApplication.all.get_RequestedTheme (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RequestedTheme
   (
      this : in out Application;
      value : WinUI3.Windows.UI.Xaml.ApplicationTheme
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IApplication.all.put_RequestedTheme (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_UnhandledException
   (
      this : in out Application;
      handler : WinUI3.Windows.UI.Xaml.UnhandledExceptionEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IApplication.all.add_UnhandledException (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UnhandledException
   (
      this : in out Application;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IApplication.all.remove_UnhandledException (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Suspending
   (
      this : in out Application;
      handler : WinUI3.Windows.UI.Xaml.SuspendingEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IApplication.all.add_Suspending (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Suspending
   (
      this : in out Application;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IApplication.all.remove_Suspending (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Resuming
   (
      this : in out Application;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IApplication.all.add_Resuming (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Resuming
   (
      this : in out Application;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IApplication.all.remove_Resuming (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Exit_x
   (
      this : in out Application
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IApplication.all.Exit_x;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusVisualKind
   (
      this : in out Application
   )
   return WinUI3.Windows.UI.Xaml.FocusVisualKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplication2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.FocusVisualKind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplication2, WinUI3.Windows.UI.Xaml.IID_IApplication2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.get_FocusVisualKind (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FocusVisualKind
   (
      this : in out Application;
      value : WinUI3.Windows.UI.Xaml.FocusVisualKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplication2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplication2, WinUI3.Windows.UI.Xaml.IID_IApplication2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.put_FocusVisualKind (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RequiresPointerMode
   (
      this : in out Application
   )
   return WinUI3.Windows.UI.Xaml.ApplicationRequiresPointerMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplication2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ApplicationRequiresPointerMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplication2, WinUI3.Windows.UI.Xaml.IID_IApplication2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.get_RequiresPointerMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RequiresPointerMode
   (
      this : in out Application;
      value : WinUI3.Windows.UI.Xaml.ApplicationRequiresPointerMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplication2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplication2, WinUI3.Windows.UI.Xaml.IID_IApplication2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.put_RequiresPointerMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_LeavingBackground
   (
      this : in out Application;
      handler : WinUI3.Windows.UI.Xaml.LeavingBackgroundEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplication2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplication2, WinUI3.Windows.UI.Xaml.IID_IApplication2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.add_LeavingBackground (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_LeavingBackground
   (
      this : in out Application;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplication2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplication2, WinUI3.Windows.UI.Xaml.IID_IApplication2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.remove_LeavingBackground (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_EnteredBackground
   (
      this : in out Application;
      handler : WinUI3.Windows.UI.Xaml.EnteredBackgroundEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplication2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplication2, WinUI3.Windows.UI.Xaml.IID_IApplication2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.add_EnteredBackground (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_EnteredBackground
   (
      this : in out Application;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplication2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplication2, WinUI3.Windows.UI.Xaml.IID_IApplication2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.remove_EnteredBackground (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HighContrastAdjustment
   (
      this : in out Application
   )
   return WinUI3.Windows.UI.Xaml.ApplicationHighContrastAdjustment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplication3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ApplicationHighContrastAdjustment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplication3, WinUI3.Windows.UI.Xaml.IID_IApplication3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.get_HighContrastAdjustment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HighContrastAdjustment
   (
      this : in out Application;
      value : WinUI3.Windows.UI.Xaml.ApplicationHighContrastAdjustment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplication3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplication3, WinUI3.Windows.UI.Xaml.IID_IApplication3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.put_HighContrastAdjustment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnActivated
   (
      this : in out Application;
      args : WinUI3.Windows.ApplicationModel.Activation.IActivatedEventArgs
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplicationOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplicationOverrides, WinUI3.Windows.UI.Xaml.IID_IApplicationOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.OnActivated (args);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnLaunched
   (
      this : in out Application;
      args : WinUI3.Windows.ApplicationModel.Activation.LaunchActivatedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplicationOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplicationOverrides, WinUI3.Windows.UI.Xaml.IID_IApplicationOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.OnLaunched (args.m_ILaunchActivatedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnFileActivated
   (
      this : in out Application;
      args : WinUI3.Windows.ApplicationModel.Activation.FileActivatedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplicationOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplicationOverrides, WinUI3.Windows.UI.Xaml.IID_IApplicationOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.OnFileActivated (args.m_IFileActivatedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnSearchActivated
   (
      this : in out Application;
      args : WinUI3.Windows.ApplicationModel.Activation.SearchActivatedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplicationOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplicationOverrides, WinUI3.Windows.UI.Xaml.IID_IApplicationOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.OnSearchActivated (args.m_ISearchActivatedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnShareTargetActivated
   (
      this : in out Application;
      args : WinUI3.Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplicationOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplicationOverrides, WinUI3.Windows.UI.Xaml.IID_IApplicationOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.OnShareTargetActivated (args.m_IShareTargetActivatedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnFileOpenPickerActivated
   (
      this : in out Application;
      args : WinUI3.Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplicationOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplicationOverrides, WinUI3.Windows.UI.Xaml.IID_IApplicationOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.OnFileOpenPickerActivated (args.m_IFileOpenPickerActivatedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnFileSavePickerActivated
   (
      this : in out Application;
      args : WinUI3.Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplicationOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplicationOverrides, WinUI3.Windows.UI.Xaml.IID_IApplicationOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.OnFileSavePickerActivated (args.m_IFileSavePickerActivatedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnCachedFileUpdaterActivated
   (
      this : in out Application;
      args : WinUI3.Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplicationOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplicationOverrides, WinUI3.Windows.UI.Xaml.IID_IApplicationOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.OnCachedFileUpdaterActivated (args.m_ICachedFileUpdaterActivatedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnWindowCreated
   (
      this : in out Application;
      args : WinUI3.Windows.UI.Xaml.WindowCreatedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplicationOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplicationOverrides, WinUI3.Windows.UI.Xaml.IID_IApplicationOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.OnWindowCreated (args.m_IWindowCreatedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnBackgroundActivated
   (
      this : in out Application;
      args : WinUI3.Windows.ApplicationModel.Activation.BackgroundActivatedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IApplicationOverrides2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IApplication_Interface, WinUI3.Windows.UI.Xaml.IApplicationOverrides2, WinUI3.Windows.UI.Xaml.IID_IApplicationOverrides2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IApplication.all);
      Hr := m_Interface.OnBackgroundActivated (args.m_IBackgroundActivatedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ApplicationInitializationCallback

   function Invoke
   (
      this : access ApplicationInitializationCallback_Delegate;
      p : WinUI3.Windows.UI.Xaml.IApplicationInitializationCallbackParams
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (p);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ApplicationInitializationCallbackParams

   procedure Initialize (this : in out ApplicationInitializationCallbackParams) is
   begin
      null;
   end;

   procedure Finalize (this : in out ApplicationInitializationCallbackParams) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IApplicationInitializationCallbackParams, IApplicationInitializationCallbackParams_Ptr);
   begin
      if this.m_IApplicationInitializationCallbackParams /= null then
         if this.m_IApplicationInitializationCallbackParams.all /= null then
            temp := this.m_IApplicationInitializationCallbackParams.all.Release;
            Free (this.m_IApplicationInitializationCallbackParams);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ApplicationInitializationCallbackParams

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BindingFailedEventArgs

   procedure Initialize (this : in out BindingFailedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out BindingFailedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBindingFailedEventArgs, IBindingFailedEventArgs_Ptr);
   begin
      if this.m_IBindingFailedEventArgs /= null then
         if this.m_IBindingFailedEventArgs.all /= null then
            temp := this.m_IBindingFailedEventArgs.all.Release;
            Free (this.m_IBindingFailedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BindingFailedEventArgs

   function get_Message
   (
      this : in out BindingFailedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IBindingFailedEventArgs.all.get_Message (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate BindingFailedEventHandler

   function Invoke
   (
      this : access BindingFailedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.IBindingFailedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BringIntoViewOptions

   procedure Initialize (this : in out BringIntoViewOptions) is
   begin
      null;
   end;

   procedure Finalize (this : in out BringIntoViewOptions) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBringIntoViewOptions, IBringIntoViewOptions_Ptr);
   begin
      if this.m_IBringIntoViewOptions /= null then
         if this.m_IBringIntoViewOptions.all /= null then
            temp := this.m_IBringIntoViewOptions.all.Release;
            Free (this.m_IBringIntoViewOptions);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BringIntoViewOptions

   function Constructor return BringIntoViewOptions is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.BringIntoViewOptions");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IBringIntoViewOptions;
   begin
      return RetVal : BringIntoViewOptions do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IBringIntoViewOptions := new WinUI3.Windows.UI.Xaml.IBringIntoViewOptions;
            Retval.m_IBringIntoViewOptions.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BringIntoViewOptions

   function get_AnimationDesired
   (
      this : in out BringIntoViewOptions
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IBringIntoViewOptions.all.get_AnimationDesired (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AnimationDesired
   (
      this : in out BringIntoViewOptions;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBringIntoViewOptions.all.put_AnimationDesired (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TargetRect
   (
      this : in out BringIntoViewOptions
   )
   return IReference_Rect.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Rect.Kind;
   begin
      Hr := this.m_IBringIntoViewOptions.all.get_TargetRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Rect (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_TargetRect
   (
      this : in out BringIntoViewOptions;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBringIntoViewOptions.all.put_TargetRect (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalAlignmentRatio
   (
      this : in out BringIntoViewOptions
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IBringIntoViewOptions_Interface, WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2, WinUI3.Windows.UI.Xaml.IID_IBringIntoViewOptions2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBringIntoViewOptions.all);
      Hr := m_Interface.get_HorizontalAlignmentRatio (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalAlignmentRatio
   (
      this : in out BringIntoViewOptions;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IBringIntoViewOptions_Interface, WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2, WinUI3.Windows.UI.Xaml.IID_IBringIntoViewOptions2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBringIntoViewOptions.all);
      Hr := m_Interface.put_HorizontalAlignmentRatio (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalAlignmentRatio
   (
      this : in out BringIntoViewOptions
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IBringIntoViewOptions_Interface, WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2, WinUI3.Windows.UI.Xaml.IID_IBringIntoViewOptions2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBringIntoViewOptions.all);
      Hr := m_Interface.get_VerticalAlignmentRatio (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalAlignmentRatio
   (
      this : in out BringIntoViewOptions;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IBringIntoViewOptions_Interface, WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2, WinUI3.Windows.UI.Xaml.IID_IBringIntoViewOptions2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBringIntoViewOptions.all);
      Hr := m_Interface.put_VerticalAlignmentRatio (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalOffset
   (
      this : in out BringIntoViewOptions
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IBringIntoViewOptions_Interface, WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2, WinUI3.Windows.UI.Xaml.IID_IBringIntoViewOptions2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBringIntoViewOptions.all);
      Hr := m_Interface.get_HorizontalOffset (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalOffset
   (
      this : in out BringIntoViewOptions;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IBringIntoViewOptions_Interface, WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2, WinUI3.Windows.UI.Xaml.IID_IBringIntoViewOptions2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBringIntoViewOptions.all);
      Hr := m_Interface.put_HorizontalOffset (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalOffset
   (
      this : in out BringIntoViewOptions
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IBringIntoViewOptions_Interface, WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2, WinUI3.Windows.UI.Xaml.IID_IBringIntoViewOptions2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBringIntoViewOptions.all);
      Hr := m_Interface.get_VerticalOffset (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalOffset
   (
      this : in out BringIntoViewOptions;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IBringIntoViewOptions_Interface, WinUI3.Windows.UI.Xaml.IBringIntoViewOptions2, WinUI3.Windows.UI.Xaml.IID_IBringIntoViewOptions2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBringIntoViewOptions.all);
      Hr := m_Interface.put_VerticalOffset (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RoutedEventArgs

   procedure Initialize (this : in out RoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RoutedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRoutedEventArgs, IRoutedEventArgs_Ptr);
   begin
      if this.m_IRoutedEventArgs /= null then
         if this.m_IRoutedEventArgs.all /= null then
            temp := this.m_IRoutedEventArgs.all.Release;
            Free (this.m_IRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RoutedEventArgs

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RoutedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RoutedEventArgs");
      m_Factory    : access IRoutedEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IRoutedEventArgs;
   begin
      return RetVal : RoutedEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IRoutedEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRoutedEventArgs := new WinUI3.Windows.UI.Xaml.IRoutedEventArgs;
            Retval.m_IRoutedEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RoutedEventArgs

   function get_OriginalSource
   (
      this : in out RoutedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IRoutedEventArgs.all.get_OriginalSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BringIntoViewRequestedEventArgs

   procedure Initialize (this : in out BringIntoViewRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out BringIntoViewRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBringIntoViewRequestedEventArgs, IBringIntoViewRequestedEventArgs_Ptr);
   begin
      if this.m_IBringIntoViewRequestedEventArgs /= null then
         if this.m_IBringIntoViewRequestedEventArgs.all /= null then
            temp := this.m_IBringIntoViewRequestedEventArgs.all.Release;
            Free (this.m_IBringIntoViewRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BringIntoViewRequestedEventArgs

   function get_TargetElement
   (
      this : in out BringIntoViewRequestedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IBringIntoViewRequestedEventArgs.all.get_TargetElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_TargetElement
   (
      this : in out BringIntoViewRequestedEventArgs;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.put_TargetElement (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AnimationDesired
   (
      this : in out BringIntoViewRequestedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.get_AnimationDesired (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AnimationDesired
   (
      this : in out BringIntoViewRequestedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.put_AnimationDesired (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TargetRect
   (
      this : in out BringIntoViewRequestedEventArgs
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.get_TargetRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TargetRect
   (
      this : in out BringIntoViewRequestedEventArgs;
      value : WinUI3.Windows.Foundation.Rect
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.put_TargetRect (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalAlignmentRatio
   (
      this : in out BringIntoViewRequestedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.get_HorizontalAlignmentRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalAlignmentRatio
   (
      this : in out BringIntoViewRequestedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.get_VerticalAlignmentRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HorizontalOffset
   (
      this : in out BringIntoViewRequestedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalOffset
   (
      this : in out BringIntoViewRequestedEventArgs;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.put_HorizontalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalOffset
   (
      this : in out BringIntoViewRequestedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalOffset
   (
      this : in out BringIntoViewRequestedEventArgs;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.put_VerticalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Handled
   (
      this : in out BringIntoViewRequestedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out BringIntoViewRequestedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBringIntoViewRequestedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BrushTransition

   procedure Initialize (this : in out BrushTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out BrushTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBrushTransition, IBrushTransition_Ptr);
   begin
      if this.m_IBrushTransition /= null then
         if this.m_IBrushTransition.all /= null then
            temp := this.m_IBrushTransition.all.Release;
            Free (this.m_IBrushTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BrushTransition

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return BrushTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.BrushTransition");
      m_Factory    : access IBrushTransitionFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IBrushTransition;
   begin
      return RetVal : BrushTransition do
         Hr := RoGetActivationFactory (m_hString, IID_IBrushTransitionFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBrushTransition := new WinUI3.Windows.UI.Xaml.IBrushTransition;
            Retval.m_IBrushTransition.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BrushTransition

   function get_Duration
   (
      this : in out BrushTransition
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IBrushTransition.all.get_Duration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Duration
   (
      this : in out BrushTransition;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBrushTransition.all.put_Duration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ResourceDictionary

   procedure Initialize (this : in out ResourceDictionary) is
   begin
      null;
   end;

   procedure Finalize (this : in out ResourceDictionary) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IResourceDictionary, IResourceDictionary_Ptr);
   begin
      if this.m_IResourceDictionary /= null then
         if this.m_IResourceDictionary.all /= null then
            temp := this.m_IResourceDictionary.all.Release;
            Free (this.m_IResourceDictionary);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ResourceDictionary

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ResourceDictionary is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ResourceDictionary");
      m_Factory    : access IResourceDictionaryFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IResourceDictionary;
   begin
      return RetVal : ResourceDictionary do
         Hr := RoGetActivationFactory (m_hString, IID_IResourceDictionaryFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IResourceDictionary := new WinUI3.Windows.UI.Xaml.IResourceDictionary;
            Retval.m_IResourceDictionary.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ResourceDictionary

   function get_Source
   (
      this : in out ResourceDictionary
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IResourceDictionary.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out ResourceDictionary;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IResourceDictionary.all.put_Source (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MergedDictionaries
   (
      this : in out ResourceDictionary
   )
   return IVector_IResourceDictionary.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IResourceDictionary.Kind;
   begin
      Hr := this.m_IResourceDictionary.all.get_MergedDictionaries (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IResourceDictionary (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_ThemeDictionaries
   (
      this : in out ResourceDictionary
   )
   return IMap_IInspectable_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IMap_IInspectable_IInspectable.Kind;
   begin
      Hr := this.m_IResourceDictionary.all.get_ThemeDictionaries (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMap_IInspectable_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -- Generic Interface Windows.Foundation.Collections.IMap`2<System.Object,System.Object>
   function Lookup
   (
      this : in out ResourceDictionary;
      key : WinUI3.IInspectable
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IMap_IInspectable_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      m_GenericIID     : aliased WinUI3.IID := (4126577703, 21997, 21778, (132, 41, 212, 246, 98, 109, 252, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IResourceDictionary_Interface, IMap_IInspectable_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IResourceDictionary.all);
      Hr := m_Interface.Lookup (key, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out ResourceDictionary
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IMap_IInspectable_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (4126577703, 21997, 21778, (132, 41, 212, 246, 98, 109, 252, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IResourceDictionary_Interface, IMap_IInspectable_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IResourceDictionary.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function HasKey
   (
      this : in out ResourceDictionary;
      key : WinUI3.IInspectable
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IMap_IInspectable_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (4126577703, 21997, 21778, (132, 41, 212, 246, 98, 109, 252, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IResourceDictionary_Interface, IMap_IInspectable_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IResourceDictionary.all);
      Hr := m_Interface.HasKey (key, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out ResourceDictionary
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IMap_IInspectable_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericIID     : aliased WinUI3.IID := (4126577703, 21997, 21778, (132, 41, 212, 246, 98, 109, 252, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IResourceDictionary_Interface, IMap_IInspectable_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IResourceDictionary.all);
      Hr := m_Interface.GetView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Insert
   (
      this : in out ResourceDictionary;
      key : WinUI3.IInspectable;
      value : WinUI3.IInspectable
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IMap_IInspectable_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (4126577703, 21997, 21778, (132, 41, 212, 246, 98, 109, 252, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IResourceDictionary_Interface, IMap_IInspectable_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IResourceDictionary.all);
      Hr := m_Interface.Insert (key, value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Remove
   (
      this : in out ResourceDictionary;
      key : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IMap_IInspectable_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (4126577703, 21997, 21778, (132, 41, 212, 246, 98, 109, 252, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IResourceDictionary_Interface, IMap_IInspectable_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IResourceDictionary.all);
      Hr := m_Interface.Remove (key);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out ResourceDictionary
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IMap_IInspectable_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (4126577703, 21997, 21778, (132, 41, 212, 246, 98, 109, 252, 221 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IResourceDictionary_Interface, IMap_IInspectable_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IResourceDictionary.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorPaletteResources

   procedure Initialize (this : in out ColorPaletteResources) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorPaletteResources) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColorPaletteResources, IColorPaletteResources_Ptr);
   begin
      if this.m_IColorPaletteResources /= null then
         if this.m_IColorPaletteResources.all /= null then
            temp := this.m_IColorPaletteResources.all.Release;
            Free (this.m_IColorPaletteResources);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColorPaletteResources

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ColorPaletteResources is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ColorPaletteResources");
      m_Factory    : access IColorPaletteResourcesFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IColorPaletteResources;
   begin
      return RetVal : ColorPaletteResources do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPaletteResourcesFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IColorPaletteResources := new WinUI3.Windows.UI.Xaml.IColorPaletteResources;
            Retval.m_IColorPaletteResources.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorPaletteResources

   function get_AltHigh
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_AltHigh (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_AltHigh
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_AltHigh (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AltLow
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_AltLow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_AltLow
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_AltLow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AltMedium
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_AltMedium (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_AltMedium
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_AltMedium (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AltMediumHigh
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_AltMediumHigh (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_AltMediumHigh
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_AltMediumHigh (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AltMediumLow
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_AltMediumLow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_AltMediumLow
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_AltMediumLow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BaseHigh
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_BaseHigh (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_BaseHigh
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_BaseHigh (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BaseLow
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_BaseLow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_BaseLow
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_BaseLow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BaseMedium
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_BaseMedium (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_BaseMedium
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_BaseMedium (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BaseMediumHigh
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_BaseMediumHigh (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_BaseMediumHigh
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_BaseMediumHigh (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BaseMediumLow
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_BaseMediumLow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_BaseMediumLow
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_BaseMediumLow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeAltLow
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeAltLow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeAltLow
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeAltLow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeBlackHigh
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeBlackHigh (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeBlackHigh
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeBlackHigh (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeBlackLow
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeBlackLow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeBlackLow
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeBlackLow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeBlackMediumLow
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeBlackMediumLow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeBlackMediumLow
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeBlackMediumLow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeBlackMedium
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeBlackMedium (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeBlackMedium
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeBlackMedium (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeDisabledHigh
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeDisabledHigh (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeDisabledHigh
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeDisabledHigh (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeDisabledLow
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeDisabledLow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeDisabledLow
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeDisabledLow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeHigh
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeHigh (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeHigh
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeHigh (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeLow
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeLow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeLow
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeLow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeMedium
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeMedium (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeMedium
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeMedium (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeMediumLow
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeMediumLow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeMediumLow
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeMediumLow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeWhite
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeWhite (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeWhite
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeWhite (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChromeGray
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ChromeGray (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ChromeGray
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ChromeGray (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ListLow
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ListLow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ListLow
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ListLow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ListMedium
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ListMedium (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ListMedium
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ListMedium (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ErrorText
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_ErrorText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ErrorText
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_ErrorText (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Accent
   (
      this : in out ColorPaletteResources
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPaletteResources.all.get_Accent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_Accent
   (
      this : in out ColorPaletteResources;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPaletteResources.all.put_Accent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UIElement

   procedure Initialize (this : in out UIElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out UIElement) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUIElement, IUIElement_Ptr);
   begin
      if this.m_IUIElement /= null then
         if this.m_IUIElement.all /= null then
            temp := this.m_IUIElement.all.Release;
            Free (this.m_IUIElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for UIElement

   -----------------------------------------------------------------------------
   -- Static Interfaces for UIElement

   function get_CanBeScrollAnchorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics9_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics9'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanBeScrollAnchorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyDownEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyDownEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyUpEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyUpEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerEnteredEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerEnteredEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerPressedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerPressedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerMovedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerMovedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerReleasedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerReleasedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerExitedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerExitedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerCaptureLostEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerCaptureLostEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerCanceledEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerCanceledEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerWheelChangedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerWheelChangedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TappedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TappedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DoubleTappedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DoubleTappedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HoldingEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HoldingEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RightTappedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RightTappedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ManipulationStartingEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ManipulationStartingEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ManipulationInertiaStartingEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ManipulationInertiaStartingEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ManipulationStartedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ManipulationStartedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ManipulationDeltaEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ManipulationDeltaEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ManipulationCompletedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ManipulationCompletedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DragEnterEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DragEnterEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DragLeaveEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DragLeaveEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DragOverEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DragOverEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DropEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DropEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AllowDropProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AllowDropProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpacityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpacityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClipProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClipProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RenderTransformProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RenderTransformProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ProjectionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ProjectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RenderTransformOriginProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RenderTransformOriginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHitTestVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHitTestVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_UseLayoutRoundingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UseLayoutRoundingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TransitionsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CacheModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CacheModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTapEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTapEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsDoubleTapEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDoubleTapEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsRightTapEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsRightTapEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHoldingEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHoldingEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ManipulationModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ManipulationModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerCapturesProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerCapturesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CompositeModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompositeModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreviewKeyDownEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreviewKeyDownEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterReceivedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterReceivedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreviewKeyUpEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreviewKeyUpEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BringIntoViewRequestedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BringIntoViewRequestedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContextRequestedEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContextRequestedEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyTipTargetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyTipTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyboardAcceleratorPlacementTargetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyboardAcceleratorPlacementTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyboardAcceleratorPlacementModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyboardAcceleratorPlacementModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure RegisterAsScrollPort
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics8'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.RegisterAsScrollPort (element.m_IUIElement.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ContextFlyoutProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContextFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExitDisplayModeOnAccessKeyInvokedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExitDisplayModeOnAccessKeyInvokedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsAccessKeyScopeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsAccessKeyScopeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AccessKeyScopeOwnerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AccessKeyScopeOwnerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AccessKeyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AccessKeyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyTipPlacementModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyTipPlacementModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyTipHorizontalOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyTipHorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyTipVerticalOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyTipVerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusKeyboardNavigationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusKeyboardNavigationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusUpNavigationStrategyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusUpNavigationStrategyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusDownNavigationStrategyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusDownNavigationStrategyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusLeftNavigationStrategyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusLeftNavigationStrategyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusRightNavigationStrategyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusRightNavigationStrategyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HighContrastAdjustmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HighContrastAdjustmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabFocusNavigationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabFocusNavigationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Transform3DProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Transform3DProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanDragProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanDragProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function TryStartDirectManipulation
   (
      value : WinUI3.Windows.UI.Xaml.Input.Pointer'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics3'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.TryStartDirectManipulation (value.m_IPointer.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_ShadowProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics10_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics10'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShadowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GettingFocusEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GettingFocusEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LosingFocusEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LosingFocusEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NoFocusCandidateFoundEvent
   return WinUI3.Windows.UI.Xaml.RoutedEvent is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IUIElementStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NoFocusCandidateFoundEvent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
            Retval.m_IRoutedEvent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UIElement

   function get_DesiredSize
   (
      this : in out UIElement
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := this.m_IUIElement.all.get_DesiredSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AllowDrop
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IUIElement.all.get_AllowDrop (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AllowDrop
   (
      this : in out UIElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_AllowDrop (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Opacity
   (
      this : in out UIElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IUIElement.all.get_Opacity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Opacity
   (
      this : in out UIElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_Opacity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Clip
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Media.RectangleGeometry'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IRectangleGeometry;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.RectangleGeometry do
         Hr := this.m_IUIElement.all.get_Clip (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRectangleGeometry := new WinUI3.Windows.UI.Xaml.Media.IRectangleGeometry;
         Retval.m_IRectangleGeometry.all := m_ComRetVal;
      end return;
   end;

   procedure put_Clip
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Media.RectangleGeometry'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_Clip (value.m_IRectangleGeometry.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RenderTransform
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Transform'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ITransform;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Transform do
         Hr := this.m_IUIElement.all.get_RenderTransform (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITransform := new WinUI3.Windows.UI.Xaml.Media.ITransform;
         Retval.m_ITransform.all := m_ComRetVal;
      end return;
   end;

   procedure put_RenderTransform
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Media.Transform'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_RenderTransform (value.m_ITransform.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Projection
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Projection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IProjection;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Projection do
         Hr := this.m_IUIElement.all.get_Projection (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IProjection := new WinUI3.Windows.UI.Xaml.Media.IProjection;
         Retval.m_IProjection.all := m_ComRetVal;
      end return;
   end;

   procedure put_Projection
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Media.Projection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_Projection (value.m_IProjection.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RenderTransformOrigin
   (
      this : in out UIElement
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IUIElement.all.get_RenderTransformOrigin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RenderTransformOrigin
   (
      this : in out UIElement;
      value : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_RenderTransformOrigin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHitTestVisible
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IUIElement.all.get_IsHitTestVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHitTestVisible
   (
      this : in out UIElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_IsHitTestVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Visibility
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Visibility;
   begin
      Hr := this.m_IUIElement.all.get_Visibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Visibility
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Visibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_Visibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RenderSize
   (
      this : in out UIElement
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := this.m_IUIElement.all.get_RenderSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_UseLayoutRounding
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IUIElement.all.get_UseLayoutRounding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_UseLayoutRounding
   (
      this : in out UIElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_UseLayoutRounding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Transitions
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IUIElement.all.get_Transitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_Transitions
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_Transitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CacheMode
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Media.CacheMode'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ICacheMode;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.CacheMode do
         Hr := this.m_IUIElement.all.get_CacheMode (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICacheMode := new WinUI3.Windows.UI.Xaml.Media.ICacheMode;
         Retval.m_ICacheMode.all := m_ComRetVal;
      end return;
   end;

   procedure put_CacheMode
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Media.CacheMode'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_CacheMode (value.m_ICacheMode.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTapEnabled
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IUIElement.all.get_IsTapEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTapEnabled
   (
      this : in out UIElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_IsTapEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsDoubleTapEnabled
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IUIElement.all.get_IsDoubleTapEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDoubleTapEnabled
   (
      this : in out UIElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_IsDoubleTapEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsRightTapEnabled
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IUIElement.all.get_IsRightTapEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsRightTapEnabled
   (
      this : in out UIElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_IsRightTapEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHoldingEnabled
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IUIElement.all.get_IsHoldingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHoldingEnabled
   (
      this : in out UIElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_IsHoldingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ManipulationMode
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Input.ManipulationModes is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.ManipulationModes;
   begin
      Hr := this.m_IUIElement.all.get_ManipulationMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ManipulationMode
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Input.ManipulationModes
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.put_ManipulationMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerCaptures
   (
      this : in out UIElement
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IUIElement.all.get_PointerCaptures (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_KeyUp
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.KeyEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_KeyUp (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_KeyUp
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_KeyUp (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_KeyDown
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.KeyEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_KeyDown (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_KeyDown
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_KeyDown (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_GotFocus
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_GotFocus (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_GotFocus
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_GotFocus (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_LostFocus
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_LostFocus (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_LostFocus
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_LostFocus (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragEnter
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.DragEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_DragEnter (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragEnter
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_DragEnter (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragLeave
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.DragEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_DragLeave (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragLeave
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_DragLeave (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragOver
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.DragEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_DragOver (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragOver
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_DragOver (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Drop
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.DragEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_Drop (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Drop
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_Drop (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerPressed
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.PointerEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_PointerPressed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerPressed
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_PointerPressed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerMoved
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.PointerEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_PointerMoved (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerMoved
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_PointerMoved (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerReleased
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.PointerEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_PointerReleased (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerReleased
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_PointerReleased (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerEntered
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.PointerEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_PointerEntered (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerEntered
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_PointerEntered (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerExited
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.PointerEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_PointerExited (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerExited
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_PointerExited (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerCaptureLost
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.PointerEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_PointerCaptureLost (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerCaptureLost
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_PointerCaptureLost (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerCanceled
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.PointerEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_PointerCanceled (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerCanceled
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_PointerCanceled (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerWheelChanged
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.PointerEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_PointerWheelChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerWheelChanged
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_PointerWheelChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Tapped
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.TappedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_Tapped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Tapped
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_Tapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DoubleTapped
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.DoubleTappedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_DoubleTapped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DoubleTapped
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_DoubleTapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Holding
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.HoldingEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_Holding (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Holding
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_Holding (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_RightTapped
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.RightTappedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_RightTapped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RightTapped
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_RightTapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationStarting
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.ManipulationStartingEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_ManipulationStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationStarting
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_ManipulationStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationInertiaStarting
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.ManipulationInertiaStartingEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_ManipulationInertiaStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationInertiaStarting
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_ManipulationInertiaStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationStarted
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.ManipulationStartedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_ManipulationStarted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationStarted
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_ManipulationStarted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationDelta
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.ManipulationDeltaEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_ManipulationDelta (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationDelta
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_ManipulationDelta (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationCompleted
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.ManipulationCompletedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUIElement.all.add_ManipulationCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationCompleted
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.remove_ManipulationCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Measure
   (
      this : in out UIElement;
      availableSize : WinUI3.Windows.Foundation.Size
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.Measure (availableSize);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Arrange
   (
      this : in out UIElement;
      finalRect : WinUI3.Windows.Foundation.Rect
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.Arrange (finalRect);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CapturePointer
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Input.Pointer'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IUIElement.all.CapturePointer (value.m_IPointer.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReleasePointerCapture
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Input.Pointer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.ReleasePointerCapture (value.m_IPointer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ReleasePointerCaptures
   (
      this : in out UIElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.ReleasePointerCaptures;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure AddHandler
   (
      this : in out UIElement;
      routedEvent_p : WinUI3.Windows.UI.Xaml.RoutedEvent'Class;
      handler : WinUI3.IInspectable;
      handledEventsToo : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.AddHandler (routedEvent_p.m_IRoutedEvent.all, handler, handledEventsToo);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveHandler
   (
      this : in out UIElement;
      routedEvent_p : WinUI3.Windows.UI.Xaml.RoutedEvent'Class;
      handler : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.RemoveHandler (routedEvent_p.m_IRoutedEvent.all, handler);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TransformToVisual
   (
      this : in out UIElement;
      visual : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Windows.UI.Xaml.Media.GeneralTransform'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGeneralTransform;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.GeneralTransform do
         Hr := this.m_IUIElement.all.TransformToVisual (visual.m_IUIElement.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeneralTransform := new WinUI3.Windows.UI.Xaml.Media.IGeneralTransform;
         Retval.m_IGeneralTransform.all := m_ComRetVal;
      end return;
   end;

   procedure InvalidateMeasure
   (
      this : in out UIElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.InvalidateMeasure;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InvalidateArrange
   (
      this : in out UIElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.InvalidateArrange;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure UpdateLayout
   (
      this : in out UIElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUIElement.all.UpdateLayout;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CompositeMode
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Media.ElementCompositeMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ElementCompositeMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement2, WinUI3.Windows.UI.Xaml.IID_IUIElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_CompositeMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CompositeMode
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Media.ElementCompositeMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement2, WinUI3.Windows.UI.Xaml.IID_IUIElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_CompositeMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CancelDirectManipulations
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement2, WinUI3.Windows.UI.Xaml.IID_IUIElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.CancelDirectManipulations (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Transform3D
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Media3D.Transform3D'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Media3D.ITransform3D;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement3, WinUI3.Windows.UI.Xaml.IID_IUIElement3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Media3D.Transform3D do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_Transform3D (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITransform3D := new WinUI3.Windows.UI.Xaml.Media.Media3D.ITransform3D;
         Retval.m_ITransform3D.all := m_ComRetVal;
      end return;
   end;

   procedure put_Transform3D
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Media.Media3D.Transform3D'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement3, WinUI3.Windows.UI.Xaml.IID_IUIElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_Transform3D (value.m_ITransform3D.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanDrag
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement3, WinUI3.Windows.UI.Xaml.IID_IUIElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_CanDrag (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanDrag
   (
      this : in out UIElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement3, WinUI3.Windows.UI.Xaml.IID_IUIElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_CanDrag (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragStarting
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement3, WinUI3.Windows.UI.Xaml.IID_IUIElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_DragStarting (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragStarting
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement3, WinUI3.Windows.UI.Xaml.IID_IUIElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_DragStarting (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DropCompleted
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement3, WinUI3.Windows.UI.Xaml.IID_IUIElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_DropCompleted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DropCompleted
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement3, WinUI3.Windows.UI.Xaml.IID_IUIElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_DropCompleted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function StartDragAsync
   (
      this : in out UIElement;
      pointerPoint : WinUI3.Windows.UI.Input.PointerPoint'Class
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_DataPackageOperation.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_DataPackageOperation.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation;
      m_IID            : aliased WinUI3.IID := (3945035292, 13272, 21486, (140, 67, 172, 84, 21, 145, 82, 213 )); -- Windows.ApplicationModel.DataTransfer.DataPackageOperation;
      m_HandlerIID     : aliased WinUI3.IID := (1177232531, 26470, 22750, (161, 187, 50, 157, 134, 160, 69, 210 ));
      m_Handler        : AsyncOperationCompletedHandler_DataPackageOperation.Kind := new AsyncOperationCompletedHandler_DataPackageOperation.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_DataPackageOperation.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_DataPackageOperation.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_DataPackageOperation.Kind_Delegate, AsyncOperationCompletedHandler_DataPackageOperation.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement3, WinUI3.Windows.UI.Xaml.IID_IUIElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.StartDragAsync (pointerPoint.m_IPointerPoint.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function get_ContextFlyout
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_ContextFlyout (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContextFlyout
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_ContextFlyout (value.m_IFlyoutBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExitDisplayModeOnAccessKeyInvoked
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_ExitDisplayModeOnAccessKeyInvoked (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ExitDisplayModeOnAccessKeyInvoked
   (
      this : in out UIElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_ExitDisplayModeOnAccessKeyInvoked (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsAccessKeyScope
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_IsAccessKeyScope (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsAccessKeyScope
   (
      this : in out UIElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_IsAccessKeyScope (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AccessKeyScopeOwner
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_AccessKeyScopeOwner (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_AccessKeyScopeOwner
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_AccessKeyScopeOwner (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AccessKey
   (
      this : in out UIElement
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_AccessKey (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_AccessKey
   (
      this : in out UIElement;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_AccessKey (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function add_ContextRequested
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_ContextRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextRequested
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_ContextRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextCanceled
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_ContextCanceled (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextCanceled
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_ContextCanceled (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_AccessKeyDisplayRequested
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_AccessKeyDisplayRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_AccessKeyDisplayRequested
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_AccessKeyDisplayRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_AccessKeyDisplayDismissed
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_AccessKeyDisplayDismissed (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_AccessKeyDisplayDismissed
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_AccessKeyDisplayDismissed (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_AccessKeyInvoked
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_AccessKeyInvoked (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_AccessKeyInvoked
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement4, WinUI3.Windows.UI.Xaml.IID_IUIElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_AccessKeyInvoked (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Lights
   (
      this : in out UIElement
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_Lights (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_KeyTipPlacementMode
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Input.KeyTipPlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.KeyTipPlacementMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_KeyTipPlacementMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_KeyTipPlacementMode
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Input.KeyTipPlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_KeyTipPlacementMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyTipHorizontalOffset
   (
      this : in out UIElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_KeyTipHorizontalOffset (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_KeyTipHorizontalOffset
   (
      this : in out UIElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_KeyTipHorizontalOffset (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyTipVerticalOffset
   (
      this : in out UIElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_KeyTipVerticalOffset (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_KeyTipVerticalOffset
   (
      this : in out UIElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_KeyTipVerticalOffset (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusKeyboardNavigation
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Input.XYFocusKeyboardNavigationMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.XYFocusKeyboardNavigationMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_XYFocusKeyboardNavigation (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_XYFocusKeyboardNavigation
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Input.XYFocusKeyboardNavigationMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_XYFocusKeyboardNavigation (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusUpNavigationStrategy
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_XYFocusUpNavigationStrategy (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_XYFocusUpNavigationStrategy
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_XYFocusUpNavigationStrategy (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusDownNavigationStrategy
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_XYFocusDownNavigationStrategy (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_XYFocusDownNavigationStrategy
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_XYFocusDownNavigationStrategy (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusLeftNavigationStrategy
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_XYFocusLeftNavigationStrategy (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_XYFocusLeftNavigationStrategy
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_XYFocusLeftNavigationStrategy (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusRightNavigationStrategy
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_XYFocusRightNavigationStrategy (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_XYFocusRightNavigationStrategy
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Input.XYFocusNavigationStrategy
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_XYFocusRightNavigationStrategy (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HighContrastAdjustment
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.ElementHighContrastAdjustment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ElementHighContrastAdjustment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_HighContrastAdjustment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HighContrastAdjustment
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.ElementHighContrastAdjustment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_HighContrastAdjustment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabFocusNavigation
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Input.KeyboardNavigationMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.KeyboardNavigationMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_TabFocusNavigation (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TabFocusNavigation
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Input.KeyboardNavigationMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_TabFocusNavigation (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_GettingFocus
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_GettingFocus (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_GettingFocus
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_GettingFocus (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_LosingFocus
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_LosingFocus (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_LosingFocus
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_LosingFocus (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_NoFocusCandidateFound
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_NoFocusCandidateFound (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NoFocusCandidateFound
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_NoFocusCandidateFound (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartBringIntoView
   (
      this : in out UIElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.StartBringIntoView;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartBringIntoView
   (
      this : in out UIElement;
      options : WinUI3.Windows.UI.Xaml.BringIntoViewOptions'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement5, WinUI3.Windows.UI.Xaml.IID_IUIElement5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.StartBringIntoView (options.m_IBringIntoViewOptions.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyboardAccelerators
   (
      this : in out UIElement
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement7, WinUI3.Windows.UI.Xaml.IID_IUIElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_KeyboardAccelerators (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_CharacterReceived
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement7, WinUI3.Windows.UI.Xaml.IID_IUIElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_CharacterReceived (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CharacterReceived
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement7, WinUI3.Windows.UI.Xaml.IID_IUIElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_CharacterReceived (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ProcessKeyboardAccelerators
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement7, WinUI3.Windows.UI.Xaml.IID_IUIElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_ProcessKeyboardAccelerators (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ProcessKeyboardAccelerators
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement7, WinUI3.Windows.UI.Xaml.IID_IUIElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_ProcessKeyboardAccelerators (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PreviewKeyDown
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.KeyEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement7, WinUI3.Windows.UI.Xaml.IID_IUIElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_PreviewKeyDown (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PreviewKeyDown
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement7, WinUI3.Windows.UI.Xaml.IID_IUIElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_PreviewKeyDown (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PreviewKeyUp
   (
      this : in out UIElement;
      handler : WinUI3.Windows.UI.Xaml.Input.KeyEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement7, WinUI3.Windows.UI.Xaml.IID_IUIElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_PreviewKeyUp (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PreviewKeyUp
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement7, WinUI3.Windows.UI.Xaml.IID_IUIElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_PreviewKeyUp (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure TryInvokeKeyboardAccelerator
   (
      this : in out UIElement;
      args : WinUI3.Windows.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement7, WinUI3.Windows.UI.Xaml.IID_IUIElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.TryInvokeKeyboardAccelerator (args.m_IProcessKeyboardAcceleratorEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyTipTarget
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement8, WinUI3.Windows.UI.Xaml.IID_IUIElement8'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_KeyTipTarget (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_KeyTipTarget
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement8, WinUI3.Windows.UI.Xaml.IID_IUIElement8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_KeyTipTarget (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyboardAcceleratorPlacementTarget
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement8, WinUI3.Windows.UI.Xaml.IID_IUIElement8'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_KeyboardAcceleratorPlacementTarget (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_KeyboardAcceleratorPlacementTarget
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement8, WinUI3.Windows.UI.Xaml.IID_IUIElement8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_KeyboardAcceleratorPlacementTarget (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyboardAcceleratorPlacementMode
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Input.KeyboardAcceleratorPlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.KeyboardAcceleratorPlacementMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement8, WinUI3.Windows.UI.Xaml.IID_IUIElement8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_KeyboardAcceleratorPlacementMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_KeyboardAcceleratorPlacementMode
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Input.KeyboardAcceleratorPlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement8, WinUI3.Windows.UI.Xaml.IID_IUIElement8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_KeyboardAcceleratorPlacementMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_BringIntoViewRequested
   (
      this : in out UIElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement8, WinUI3.Windows.UI.Xaml.IID_IUIElement8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.add_BringIntoViewRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BringIntoViewRequested
   (
      this : in out UIElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement8, WinUI3.Windows.UI.Xaml.IID_IUIElement8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.remove_BringIntoViewRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanBeScrollAnchor
   (
      this : in out UIElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_CanBeScrollAnchor (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanBeScrollAnchor
   (
      this : in out UIElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_CanBeScrollAnchor (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpacityTransition
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.ScalarTransition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IScalarTransition;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.ScalarTransition do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_OpacityTransition (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScalarTransition := new WinUI3.Windows.UI.Xaml.IScalarTransition;
         Retval.m_IScalarTransition.all := m_ComRetVal;
      end return;
   end;

   procedure put_OpacityTransition
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.ScalarTransition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_OpacityTransition (value.m_IScalarTransition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Translation
   (
      this : in out UIElement
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_Translation (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Translation
   (
      this : in out UIElement;
      value : WinUI3.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_Translation (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TranslationTransition
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Vector3Transition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IVector3Transition;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Vector3Transition do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_TranslationTransition (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVector3Transition := new WinUI3.Windows.UI.Xaml.IVector3Transition;
         Retval.m_IVector3Transition.all := m_ComRetVal;
      end return;
   end;

   procedure put_TranslationTransition
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Vector3Transition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_TranslationTransition (value.m_IVector3Transition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Rotation
   (
      this : in out UIElement
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_Rotation (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Rotation
   (
      this : in out UIElement;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_Rotation (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationTransition
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.ScalarTransition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IScalarTransition;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.ScalarTransition do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_RotationTransition (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScalarTransition := new WinUI3.Windows.UI.Xaml.IScalarTransition;
         Retval.m_IScalarTransition.all := m_ComRetVal;
      end return;
   end;

   procedure put_RotationTransition
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.ScalarTransition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_RotationTransition (value.m_IScalarTransition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Scale
   (
      this : in out UIElement
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_Scale (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Scale
   (
      this : in out UIElement;
      value : WinUI3.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_Scale (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScaleTransition
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Vector3Transition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IVector3Transition;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Vector3Transition do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_ScaleTransition (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVector3Transition := new WinUI3.Windows.UI.Xaml.IVector3Transition;
         Retval.m_IVector3Transition.all := m_ComRetVal;
      end return;
   end;

   procedure put_ScaleTransition
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Vector3Transition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_ScaleTransition (value.m_IVector3Transition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransformMatrix
   (
      this : in out UIElement
   )
   return WinUI3.Windows.Foundation.Numerics.Matrix4x4 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Matrix4x4;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_TransformMatrix (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TransformMatrix
   (
      this : in out UIElement;
      value : WinUI3.Windows.Foundation.Numerics.Matrix4x4
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_TransformMatrix (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterPoint
   (
      this : in out UIElement
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_CenterPoint (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterPoint
   (
      this : in out UIElement;
      value : WinUI3.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_CenterPoint (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAxis
   (
      this : in out UIElement
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_RotationAxis (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAxis
   (
      this : in out UIElement;
      value : WinUI3.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_RotationAxis (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartAnimation
   (
      this : in out UIElement;
      animation : WinUI3.Windows.UI.Composition.ICompositionAnimationBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.StartAnimation (animation);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StopAnimation
   (
      this : in out UIElement;
      animation : WinUI3.Windows.UI.Composition.ICompositionAnimationBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement9 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement9, WinUI3.Windows.UI.Xaml.IID_IUIElement9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.StopAnimation (animation);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActualOffset
   (
      this : in out UIElement
   )
   return WinUI3.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement10 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector3;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement10, WinUI3.Windows.UI.Xaml.IID_IUIElement10'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_ActualOffset (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ActualSize
   (
      this : in out UIElement
   )
   return WinUI3.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement10 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Numerics.Vector2;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement10, WinUI3.Windows.UI.Xaml.IID_IUIElement10'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.get_ActualSize (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_XamlRoot
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.XamlRoot'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement10 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IXamlRoot;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement10, WinUI3.Windows.UI.Xaml.IID_IUIElement10'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.XamlRoot do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_XamlRoot (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IXamlRoot := new WinUI3.Windows.UI.Xaml.IXamlRoot;
         Retval.m_IXamlRoot.all := m_ComRetVal;
      end return;
   end;

   procedure put_XamlRoot
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.XamlRoot'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement10 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement10, WinUI3.Windows.UI.Xaml.IID_IUIElement10'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_XamlRoot (value.m_IXamlRoot.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_UIContext
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.UIContext'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement10 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.IUIContext;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement10, WinUI3.Windows.UI.Xaml.IID_IUIElement10'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.UIContext do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_UIContext (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIContext := new WinUI3.Windows.UI.IUIContext;
         Retval.m_IUIContext.all := m_ComRetVal;
      end return;
   end;

   function get_Shadow
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Shadow'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement10 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IShadow;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement10, WinUI3.Windows.UI.Xaml.IID_IUIElement10'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Shadow do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.get_Shadow (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IShadow := new WinUI3.Windows.UI.Xaml.Media.IShadow;
         Retval.m_IShadow.all := m_ComRetVal;
      end return;
   end;

   procedure put_Shadow
   (
      this : in out UIElement;
      value : WinUI3.Windows.UI.Xaml.Media.Shadow'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElement10 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElement10, WinUI3.Windows.UI.Xaml.IID_IUIElement10'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.put_Shadow (value.m_IShadow.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function OnCreateAutomationPeer
   (
      this : in out UIElement
   )
   return WinUI3.Windows.UI.Xaml.Automation.Peers.AutomationPeer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElementOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Automation.Peers.IAutomationPeer;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElementOverrides, WinUI3.Windows.UI.Xaml.IID_IUIElementOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Automation.Peers.AutomationPeer do
         m_Interface := QInterface (this.m_IUIElement.all);
         Hr := m_Interface.OnCreateAutomationPeer (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAutomationPeer := new WinUI3.Windows.UI.Xaml.Automation.Peers.IAutomationPeer;
         Retval.m_IAutomationPeer.all := m_ComRetVal;
      end return;
   end;

   procedure OnDisconnectVisualChildren
   (
      this : in out UIElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElementOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElementOverrides, WinUI3.Windows.UI.Xaml.IID_IUIElementOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.OnDisconnectVisualChildren;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function FindSubElementsForTouchTargeting
   (
      this : in out UIElement;
      point : WinUI3.Windows.Foundation.Point;
      boundingRect : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElementOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElementOverrides, WinUI3.Windows.UI.Xaml.IID_IUIElementOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.FindSubElementsForTouchTargeting (point, boundingRect, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetChildrenInTabFocusOrder
   (
      this : in out UIElement
   )
   return IIterable_IDependencyObject.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElementOverrides7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IIterable_IDependencyObject.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElementOverrides7, WinUI3.Windows.UI.Xaml.IID_IUIElementOverrides7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.GetChildrenInTabFocusOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IIterable_IDependencyObject (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure OnProcessKeyboardAccelerators
   (
      this : in out UIElement;
      args : WinUI3.Windows.UI.Xaml.Input.ProcessKeyboardAcceleratorEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElementOverrides7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElementOverrides7, WinUI3.Windows.UI.Xaml.IID_IUIElementOverrides7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.OnProcessKeyboardAccelerators (args.m_IProcessKeyboardAcceleratorEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnKeyboardAcceleratorInvoked
   (
      this : in out UIElement;
      args : WinUI3.Windows.UI.Xaml.Input.KeyboardAcceleratorInvokedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElementOverrides8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElementOverrides8, WinUI3.Windows.UI.Xaml.IID_IUIElementOverrides8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.OnKeyboardAcceleratorInvoked (args.m_IKeyboardAcceleratorInvokedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnBringIntoViewRequested
   (
      this : in out UIElement;
      e : WinUI3.Windows.UI.Xaml.BringIntoViewRequestedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElementOverrides8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElementOverrides8, WinUI3.Windows.UI.Xaml.IID_IUIElementOverrides8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.OnBringIntoViewRequested (e.m_IBringIntoViewRequestedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PopulatePropertyInfoOverride
   (
      this : in out UIElement;
      propertyName : WinUI3.WString;
      animationPropertyInfo : WinUI3.Windows.UI.Composition.AnimationPropertyInfo'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IUIElementOverrides9 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_propertyName : constant WinUI3.HString := To_HString (propertyName);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Xaml.IUIElementOverrides9, WinUI3.Windows.UI.Xaml.IID_IUIElementOverrides9'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.PopulatePropertyInfoOverride (HStr_propertyName, animationPropertyInfo.m_IAnimationPropertyInfo.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure PopulatePropertyInfo
   (
      this : in out UIElement;
      propertyName : WinUI3.WString;
      propertyInfo : WinUI3.Windows.UI.Composition.AnimationPropertyInfo'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Composition.IAnimationObject := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_propertyName : constant WinUI3.HString := To_HString (propertyName);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElement_Interface, WinUI3.Windows.UI.Composition.IAnimationObject, WinUI3.Windows.UI.Composition.IID_IAnimationObject'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElement.all);
      Hr := m_Interface.PopulatePropertyInfo (HStr_propertyName, propertyInfo.m_IAnimationPropertyInfo.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FrameworkElement

   procedure Initialize (this : in out FrameworkElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out FrameworkElement) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFrameworkElement, IFrameworkElement_Ptr);
   begin
      if this.m_IFrameworkElement /= null then
         if this.m_IFrameworkElement.all /= null then
            temp := this.m_IFrameworkElement.all.Release;
            Free (this.m_IFrameworkElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FrameworkElement

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FrameworkElement is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory    : access IFrameworkElementFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IFrameworkElement;
   begin
      return RetVal : FrameworkElement do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFrameworkElement := new WinUI3.Windows.UI.Xaml.IFrameworkElement;
            Retval.m_IFrameworkElement.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FrameworkElement

   function get_AllowFocusOnInteractionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AllowFocusOnInteractionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusVisualMarginProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusVisualMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusVisualSecondaryThicknessProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusVisualSecondaryThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusVisualPrimaryThicknessProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusVisualPrimaryThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusVisualSecondaryBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusVisualSecondaryBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusVisualPrimaryBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusVisualPrimaryBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AllowFocusWhenDisabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AllowFocusWhenDisabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActualThemeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActualThemeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure DeferTree
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics5'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.DeferTree (element.m_IDependencyObject.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_RequestedThemeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RequestedThemeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TagProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TagProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LanguageProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LanguageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActualWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActualWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActualHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActualHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_WidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_WidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MarginProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NameProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DataContextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DataContextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FlowDirectionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IFrameworkElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FlowDirectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FrameworkElement

   function get_Triggers
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.TriggerCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.TriggerCollection do
         Hr := this.m_IFrameworkElement.all.get_Triggers (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_Resources
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.ResourceDictionary'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IResourceDictionary;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.ResourceDictionary do
         Hr := this.m_IFrameworkElement.all.get_Resources (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IResourceDictionary := new WinUI3.Windows.UI.Xaml.IResourceDictionary;
         Retval.m_IResourceDictionary.all := m_ComRetVal;
      end return;
   end;

   procedure put_Resources
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.ResourceDictionary'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_Resources (value.m_IResourceDictionary.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Tag
   (
      this : in out FrameworkElement
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IFrameworkElement.all.get_Tag (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Tag
   (
      this : in out FrameworkElement;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_Tag (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Language
   (
      this : in out FrameworkElement
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFrameworkElement.all.get_Language (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Language
   (
      this : in out FrameworkElement;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IFrameworkElement.all.put_Language (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ActualWidth
   (
      this : in out FrameworkElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFrameworkElement.all.get_ActualWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ActualHeight
   (
      this : in out FrameworkElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFrameworkElement.all.get_ActualHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Width
   (
      this : in out FrameworkElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFrameworkElement.all.get_Width (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Width
   (
      this : in out FrameworkElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_Width (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Height
   (
      this : in out FrameworkElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFrameworkElement.all.get_Height (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Height
   (
      this : in out FrameworkElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_Height (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinWidth
   (
      this : in out FrameworkElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFrameworkElement.all.get_MinWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinWidth
   (
      this : in out FrameworkElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_MinWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxWidth
   (
      this : in out FrameworkElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFrameworkElement.all.get_MaxWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxWidth
   (
      this : in out FrameworkElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_MaxWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinHeight
   (
      this : in out FrameworkElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFrameworkElement.all.get_MinHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinHeight
   (
      this : in out FrameworkElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_MinHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxHeight
   (
      this : in out FrameworkElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFrameworkElement.all.get_MaxHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxHeight
   (
      this : in out FrameworkElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_MaxHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalAlignment
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_IFrameworkElement.all.get_HorizontalAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalAlignment
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_HorizontalAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalAlignment
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_IFrameworkElement.all.get_VerticalAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalAlignment
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_VerticalAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Margin
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IFrameworkElement.all.get_Margin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Margin
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_Margin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Name
   (
      this : in out FrameworkElement
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFrameworkElement.all.get_Name (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Name
   (
      this : in out FrameworkElement;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IFrameworkElement.all.put_Name (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_BaseUri
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IFrameworkElement.all.get_BaseUri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   function get_DataContext
   (
      this : in out FrameworkElement
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IFrameworkElement.all.get_DataContext (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DataContext
   (
      this : in out FrameworkElement;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_DataContext (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Style
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_IFrameworkElement.all.get_Style (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_Style
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_Style (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Parent
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IFrameworkElement.all.get_Parent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function get_FlowDirection
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.FlowDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.FlowDirection;
   begin
      Hr := this.m_IFrameworkElement.all.get_FlowDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FlowDirection
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.FlowDirection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.put_FlowDirection (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Loaded
   (
      this : in out FrameworkElement;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrameworkElement.all.add_Loaded (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Loaded
   (
      this : in out FrameworkElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.remove_Loaded (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Unloaded
   (
      this : in out FrameworkElement;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrameworkElement.all.add_Unloaded (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Unloaded
   (
      this : in out FrameworkElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.remove_Unloaded (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SizeChanged
   (
      this : in out FrameworkElement;
      handler : WinUI3.Windows.UI.Xaml.SizeChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrameworkElement.all.add_SizeChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SizeChanged
   (
      this : in out FrameworkElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.remove_SizeChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_LayoutUpdated
   (
      this : in out FrameworkElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrameworkElement.all.add_LayoutUpdated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_LayoutUpdated
   (
      this : in out FrameworkElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.remove_LayoutUpdated (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function FindName
   (
      this : in out FrameworkElement;
      name : WinUI3.WString
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      HStr_name : constant WinUI3.HString := To_HString (name);
   begin
      Hr := this.m_IFrameworkElement.all.FindName (HStr_name, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_name);
      return m_ComRetVal;
   end;

   procedure SetBinding
   (
      this : in out FrameworkElement;
      dp : WinUI3.Windows.UI.Xaml.DependencyProperty'Class;
      binding : WinUI3.Windows.UI.Xaml.Data.BindingBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrameworkElement.all.SetBinding (dp.m_IDependencyProperty.all, binding.m_IBindingBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RequestedTheme
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.ElementTheme is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ElementTheme;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement2, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.get_RequestedTheme (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RequestedTheme
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.ElementTheme
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement2, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.put_RequestedTheme (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DataContextChanged
   (
      this : in out FrameworkElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement2, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.add_DataContextChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DataContextChanged
   (
      this : in out FrameworkElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement2, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.remove_DataContextChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetBindingExpression
   (
      this : in out FrameworkElement;
      dp : WinUI3.Windows.UI.Xaml.DependencyProperty'Class
   )
   return WinUI3.Windows.UI.Xaml.Data.BindingExpression'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Data.IBindingExpression;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement2, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Data.BindingExpression do
         m_Interface := QInterface (this.m_IFrameworkElement.all);
         Hr := m_Interface.GetBindingExpression (dp.m_IDependencyProperty.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBindingExpression := new WinUI3.Windows.UI.Xaml.Data.IBindingExpression;
         Retval.m_IBindingExpression.all := m_ComRetVal;
      end return;
   end;

   function add_Loading
   (
      this : in out FrameworkElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement3, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.add_Loading (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Loading
   (
      this : in out FrameworkElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement3, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.remove_Loading (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AllowFocusOnInteraction
   (
      this : in out FrameworkElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.get_AllowFocusOnInteraction (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AllowFocusOnInteraction
   (
      this : in out FrameworkElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.put_AllowFocusOnInteraction (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusVisualMargin
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.get_FocusVisualMargin (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FocusVisualMargin
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.put_FocusVisualMargin (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusVisualSecondaryThickness
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.get_FocusVisualSecondaryThickness (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FocusVisualSecondaryThickness
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.put_FocusVisualSecondaryThickness (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusVisualPrimaryThickness
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.get_FocusVisualPrimaryThickness (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FocusVisualPrimaryThickness
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.put_FocusVisualPrimaryThickness (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusVisualSecondaryBrush
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_IFrameworkElement.all);
         Hr := m_Interface.get_FocusVisualSecondaryBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_FocusVisualSecondaryBrush
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.put_FocusVisualSecondaryBrush (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusVisualPrimaryBrush
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_IFrameworkElement.all);
         Hr := m_Interface.get_FocusVisualPrimaryBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_FocusVisualPrimaryBrush
   (
      this : in out FrameworkElement;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.put_FocusVisualPrimaryBrush (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AllowFocusWhenDisabled
   (
      this : in out FrameworkElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.get_AllowFocusWhenDisabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AllowFocusWhenDisabled
   (
      this : in out FrameworkElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement4, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.put_AllowFocusWhenDisabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActualTheme
   (
      this : in out FrameworkElement
   )
   return WinUI3.Windows.UI.Xaml.ElementTheme is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ElementTheme;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement6, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.get_ActualTheme (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_ActualThemeChanged
   (
      this : in out FrameworkElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement6, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.add_ActualThemeChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ActualThemeChanged
   (
      this : in out FrameworkElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement6, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.remove_ActualThemeChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsLoaded
   (
      this : in out FrameworkElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement7, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.get_IsLoaded (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_EffectiveViewportChanged
   (
      this : in out FrameworkElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement7, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.add_EffectiveViewportChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_EffectiveViewportChanged
   (
      this : in out FrameworkElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElement7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElement7, WinUI3.Windows.UI.Xaml.IID_IFrameworkElement7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.remove_EffectiveViewportChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InvalidateViewport
   (
      this : in out FrameworkElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElementProtected7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElementProtected7, WinUI3.Windows.UI.Xaml.IID_IFrameworkElementProtected7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.InvalidateViewport;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function MeasureOverride
   (
      this : in out FrameworkElement;
      availableSize : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElementOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElementOverrides, WinUI3.Windows.UI.Xaml.IID_IFrameworkElementOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.MeasureOverride (availableSize, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ArrangeOverride
   (
      this : in out FrameworkElement;
      finalSize : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElementOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElementOverrides, WinUI3.Windows.UI.Xaml.IID_IFrameworkElementOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.ArrangeOverride (finalSize, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure OnApplyTemplate
   (
      this : in out FrameworkElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElementOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElementOverrides, WinUI3.Windows.UI.Xaml.IID_IFrameworkElementOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.OnApplyTemplate;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GoToElementStateCore
   (
      this : in out FrameworkElement;
      stateName : WinUI3.WString;
      useTransitions : WinUI3.Boolean
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IFrameworkElementOverrides2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      HStr_stateName : constant WinUI3.HString := To_HString (stateName);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkElement_Interface, WinUI3.Windows.UI.Xaml.IFrameworkElementOverrides2, WinUI3.Windows.UI.Xaml.IID_IFrameworkElementOverrides2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkElement.all);
      Hr := m_Interface.GoToElementStateCore (HStr_stateName, useTransitions, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_stateName);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FrameworkTemplate

   procedure Initialize (this : in out FrameworkTemplate) is
   begin
      null;
   end;

   procedure Finalize (this : in out FrameworkTemplate) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFrameworkTemplate, IFrameworkTemplate_Ptr);
   begin
      if this.m_IFrameworkTemplate /= null then
         if this.m_IFrameworkTemplate.all /= null then
            temp := this.m_IFrameworkTemplate.all.Release;
            Free (this.m_IFrameworkTemplate);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FrameworkTemplate

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FrameworkTemplate is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkTemplate");
      m_Factory    : access IFrameworkTemplateFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IFrameworkTemplate;
   begin
      return RetVal : FrameworkTemplate do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameworkTemplateFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFrameworkTemplate := new WinUI3.Windows.UI.Xaml.IFrameworkTemplate;
            Retval.m_IFrameworkTemplate.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FrameworkTemplate

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CornerRadiusHelper

   procedure Initialize (this : in out CornerRadiusHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out CornerRadiusHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICornerRadiusHelper, ICornerRadiusHelper_Ptr);
   begin
      if this.m_ICornerRadiusHelper /= null then
         if this.m_ICornerRadiusHelper.all /= null then
            temp := this.m_ICornerRadiusHelper.all.Release;
            Free (this.m_ICornerRadiusHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CornerRadiusHelper

   function FromRadii
   (
      topLeft : WinUI3.Double;
      topRight : WinUI3.Double;
      bottomRight : WinUI3.Double;
      bottomLeft : WinUI3.Double
   )
   return WinUI3.Windows.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.CornerRadiusHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.ICornerRadiusHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.CornerRadius;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICornerRadiusHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromRadii (topLeft, topRight, bottomRight, bottomLeft, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromUniformRadius
   (
      uniformRadius : WinUI3.Double
   )
   return WinUI3.Windows.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.CornerRadiusHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.ICornerRadiusHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.CornerRadius;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICornerRadiusHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromUniformRadius (uniformRadius, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CornerRadiusHelper

   -----------------------------------------------------------------------------
   -- Delegate CreateDefaultValueCallback

   function Invoke
   (
      this : access CreateDefaultValueCallback_Delegate
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback.all;
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DataContextChangedEventArgs

   procedure Initialize (this : in out DataContextChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DataContextChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDataContextChangedEventArgs, IDataContextChangedEventArgs_Ptr);
   begin
      if this.m_IDataContextChangedEventArgs /= null then
         if this.m_IDataContextChangedEventArgs.all /= null then
            temp := this.m_IDataContextChangedEventArgs.all.Release;
            Free (this.m_IDataContextChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DataContextChangedEventArgs

   function get_NewValue
   (
      this : in out DataContextChangedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IDataContextChangedEventArgs.all.get_NewValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out DataContextChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDataContextChangedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out DataContextChangedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDataContextChangedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DataTemplate

   procedure Initialize (this : in out DataTemplate) is
   begin
      null;
   end;

   procedure Finalize (this : in out DataTemplate) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDataTemplate, IDataTemplate_Ptr);
   begin
      if this.m_IDataTemplate /= null then
         if this.m_IDataTemplate.all /= null then
            temp := this.m_IDataTemplate.all.Release;
            Free (this.m_IDataTemplate);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DataTemplate

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DataTemplate is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DataTemplate");
      m_Factory    : access IDataTemplateFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : DataTemplate do
         Hr := RoGetActivationFactory (m_hString, IID_IDataTemplateFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
            Retval.m_IDataTemplate.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DataTemplate

   function get_ExtensionInstanceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DataTemplate");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDataTemplateStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDataTemplateStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExtensionInstanceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetExtensionInstance
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Windows.UI.Xaml.IDataTemplateExtension is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DataTemplate");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDataTemplateStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplateExtension;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDataTemplateStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetExtensionInstance (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetExtensionInstance
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Windows.UI.Xaml.IDataTemplateExtension
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DataTemplate");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDataTemplateStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDataTemplateStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetExtensionInstance (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DataTemplate

   function LoadContent
   (
      this : in out DataTemplate
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IDataTemplate.all.LoadContent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function GetElement
   (
      this : in out DataTemplate;
      args : WinUI3.Windows.UI.Xaml.ElementFactoryGetArgs'Class
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IElementFactory := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDataTemplate_Interface, WinUI3.Windows.UI.Xaml.IElementFactory, WinUI3.Windows.UI.Xaml.IID_IElementFactory'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IDataTemplate.all);
         Hr := m_Interface.GetElement (args.m_IElementFactoryGetArgs.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure RecycleElement
   (
      this : in out DataTemplate;
      args : WinUI3.Windows.UI.Xaml.ElementFactoryRecycleArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IElementFactory := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDataTemplate_Interface, WinUI3.Windows.UI.Xaml.IElementFactory, WinUI3.Windows.UI.Xaml.IID_IElementFactory'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDataTemplate.all);
      Hr := m_Interface.RecycleElement (args.m_IElementFactoryRecycleArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DataTemplateKey

   procedure Initialize (this : in out DataTemplateKey) is
   begin
      null;
   end;

   procedure Finalize (this : in out DataTemplateKey) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDataTemplateKey, IDataTemplateKey_Ptr);
   begin
      if this.m_IDataTemplateKey /= null then
         if this.m_IDataTemplateKey.all /= null then
            temp := this.m_IDataTemplateKey.all.Release;
            Free (this.m_IDataTemplateKey);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DataTemplateKey

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DataTemplateKey is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DataTemplateKey");
      m_Factory    : access IDataTemplateKeyFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IDataTemplateKey;
   begin
      return RetVal : DataTemplateKey do
         Hr := RoGetActivationFactory (m_hString, IID_IDataTemplateKeyFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDataTemplateKey := new WinUI3.Windows.UI.Xaml.IDataTemplateKey;
            Retval.m_IDataTemplateKey.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      dataType : WinUI3.IInspectable;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DataTemplateKey is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DataTemplateKey");
      m_Factory    : access IDataTemplateKeyFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IDataTemplateKey;
   begin
      return RetVal : DataTemplateKey do
         Hr := RoGetActivationFactory (m_hString, IID_IDataTemplateKeyFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithType (dataType, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDataTemplateKey := new WinUI3.Windows.UI.Xaml.IDataTemplateKey;
            Retval.m_IDataTemplateKey.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DataTemplateKey

   function get_DataType
   (
      this : in out DataTemplateKey
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IDataTemplateKey.all.get_DataType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DataType
   (
      this : in out DataTemplateKey;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDataTemplateKey.all.put_DataType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DebugSettings

   procedure Initialize (this : in out DebugSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out DebugSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDebugSettings, IDebugSettings_Ptr);
   begin
      if this.m_IDebugSettings /= null then
         if this.m_IDebugSettings.all /= null then
            temp := this.m_IDebugSettings.all.Release;
            Free (this.m_IDebugSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DebugSettings

   function get_EnableFrameRateCounter
   (
      this : in out DebugSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDebugSettings.all.get_EnableFrameRateCounter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EnableFrameRateCounter
   (
      this : in out DebugSettings;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDebugSettings.all.put_EnableFrameRateCounter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsBindingTracingEnabled
   (
      this : in out DebugSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDebugSettings.all.get_IsBindingTracingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsBindingTracingEnabled
   (
      this : in out DebugSettings;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDebugSettings.all.put_IsBindingTracingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsOverdrawHeatMapEnabled
   (
      this : in out DebugSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDebugSettings.all.get_IsOverdrawHeatMapEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOverdrawHeatMapEnabled
   (
      this : in out DebugSettings;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDebugSettings.all.put_IsOverdrawHeatMapEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_BindingFailed
   (
      this : in out DebugSettings;
      handler : WinUI3.Windows.UI.Xaml.BindingFailedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDebugSettings.all.add_BindingFailed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BindingFailed
   (
      this : in out DebugSettings;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDebugSettings.all.remove_BindingFailed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EnableRedrawRegions
   (
      this : in out DebugSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDebugSettings2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDebugSettings_Interface, WinUI3.Windows.UI.Xaml.IDebugSettings2, WinUI3.Windows.UI.Xaml.IID_IDebugSettings2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDebugSettings.all);
      Hr := m_Interface.get_EnableRedrawRegions (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EnableRedrawRegions
   (
      this : in out DebugSettings;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDebugSettings2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDebugSettings_Interface, WinUI3.Windows.UI.Xaml.IDebugSettings2, WinUI3.Windows.UI.Xaml.IID_IDebugSettings2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDebugSettings.all);
      Hr := m_Interface.put_EnableRedrawRegions (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextPerformanceVisualizationEnabled
   (
      this : in out DebugSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDebugSettings3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDebugSettings_Interface, WinUI3.Windows.UI.Xaml.IDebugSettings3, WinUI3.Windows.UI.Xaml.IID_IDebugSettings3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDebugSettings.all);
      Hr := m_Interface.get_IsTextPerformanceVisualizationEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextPerformanceVisualizationEnabled
   (
      this : in out DebugSettings;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDebugSettings3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDebugSettings_Interface, WinUI3.Windows.UI.Xaml.IDebugSettings3, WinUI3.Windows.UI.Xaml.IID_IDebugSettings3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDebugSettings.all);
      Hr := m_Interface.put_IsTextPerformanceVisualizationEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FailFastOnErrors
   (
      this : in out DebugSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDebugSettings4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDebugSettings_Interface, WinUI3.Windows.UI.Xaml.IDebugSettings4, WinUI3.Windows.UI.Xaml.IID_IDebugSettings4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDebugSettings.all);
      Hr := m_Interface.get_FailFastOnErrors (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FailFastOnErrors
   (
      this : in out DebugSettings;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDebugSettings4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDebugSettings_Interface, WinUI3.Windows.UI.Xaml.IDebugSettings4, WinUI3.Windows.UI.Xaml.IID_IDebugSettings4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDebugSettings.all);
      Hr := m_Interface.put_FailFastOnErrors (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DependencyObjectCollection

   procedure Initialize (this : in out DependencyObjectCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out DependencyObjectCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DependencyObjectCollection

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DependencyObjectCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DependencyObjectCollection");
      m_Factory    : access IDependencyObjectCollectionFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : DependencyObjectCollection do
         Hr := RoGetActivationFactory (m_hString, IID_IDependencyObjectCollectionFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DependencyObjectCollection

   -- Generic Interface Windows.Foundation.Collections.IObservableVector`1<Windows.UI.Xaml.DependencyObject>
   function add_VectorChanged
   (
      this : in out DependencyObjectCollection;
      vhnd : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IObservableVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      m_GenericIID     : aliased WinUI3.IID := (4207342802, 38653, 23787, (128, 191, 70, 172, 101, 41, 252, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IObservableVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.add_VectorChanged (vhnd, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VectorChanged
   (
      this : in out DependencyObjectCollection;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IObservableVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (4207342802, 38653, 23787, (128, 191, 70, 172, 101, 41, 252, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IObservableVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.remove_VectorChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.DependencyObject>
   function GetAt
   (
      this : in out DependencyObjectCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out DependencyObjectCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out DependencyObjectCollection
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out DependencyObjectCollection;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IDependencyObject.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out DependencyObjectCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out DependencyObjectCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out DependencyObjectCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out DependencyObjectCollection;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out DependencyObjectCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out DependencyObjectCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out DependencyObjectCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.IDependencyObject_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out DependencyObjectCollection;
      items : WinUI3.Windows.UI.Xaml.IDependencyObject_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1998292350, 43868, 23992, (160, 33, 57, 124, 146, 205, 196, 76 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.DependencyObject>
   function First
   (
      this : in out DependencyObjectCollection
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IDependencyObject.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      m_GenericIID     : aliased WinUI3.IID := (4134300627, 21940, 23483, (184, 42, 109, 156, 227, 131, 9, 26 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IDependencyObject.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DependencyProperty

   procedure Initialize (this : in out DependencyProperty) is
   begin
      null;
   end;

   procedure Finalize (this : in out DependencyProperty) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDependencyProperty, IDependencyProperty_Ptr);
   begin
      if this.m_IDependencyProperty /= null then
         if this.m_IDependencyProperty.all /= null then
            temp := this.m_IDependencyProperty.all.Release;
            Free (this.m_IDependencyProperty);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DependencyProperty

   function get_UnsetValue
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DependencyProperty");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDependencyPropertyStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDependencyPropertyStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_UnsetValue (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Register
   (
      name : WinUI3.WString;
      propertyType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      ownerType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      typeMetadata : WinUI3.Windows.UI.Xaml.PropertyMetadata'Class
   )
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DependencyProperty");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDependencyPropertyStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
      HStr_name : constant WinUI3.HString := To_HString (name);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDependencyPropertyStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Register (HStr_name, propertyType, ownerType, typeMetadata.m_IPropertyMetadata.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_name);
      end return;
   end;

   function RegisterAttached
   (
      name : WinUI3.WString;
      propertyType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      ownerType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      defaultMetadata : WinUI3.Windows.UI.Xaml.PropertyMetadata'Class
   )
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DependencyProperty");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDependencyPropertyStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
      HStr_name : constant WinUI3.HString := To_HString (name);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDependencyPropertyStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.RegisterAttached (HStr_name, propertyType, ownerType, defaultMetadata.m_IPropertyMetadata.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_name);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DependencyProperty

   function GetMetadata
   (
      this : in out DependencyProperty;
      forType : WinUI3.Windows.UI.Xaml.Interop.TypeName
   )
   return WinUI3.Windows.UI.Xaml.PropertyMetadata'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IPropertyMetadata;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.PropertyMetadata do
         Hr := this.m_IDependencyProperty.all.GetMetadata (forType, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPropertyMetadata := new WinUI3.Windows.UI.Xaml.IPropertyMetadata;
         Retval.m_IPropertyMetadata.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Delegate DependencyPropertyChangedCallback

   function Invoke
   (
      this : access DependencyPropertyChangedCallback_Delegate;
      sender : WinUI3.Windows.UI.Xaml.IDependencyObject;
      dp : WinUI3.Windows.UI.Xaml.IDependencyProperty
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, dp);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DependencyPropertyChangedEventArgs

   procedure Initialize (this : in out DependencyPropertyChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DependencyPropertyChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDependencyPropertyChangedEventArgs, IDependencyPropertyChangedEventArgs_Ptr);
   begin
      if this.m_IDependencyPropertyChangedEventArgs /= null then
         if this.m_IDependencyPropertyChangedEventArgs.all /= null then
            temp := this.m_IDependencyPropertyChangedEventArgs.all.Release;
            Free (this.m_IDependencyPropertyChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DependencyPropertyChangedEventArgs

   function get_Property
   (
      this : in out DependencyPropertyChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.DependencyProperty'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := this.m_IDependencyPropertyChangedEventArgs.all.get_Property (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
         Retval.m_IDependencyProperty.all := m_ComRetVal;
      end return;
   end;

   function get_OldValue
   (
      this : in out DependencyPropertyChangedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IDependencyPropertyChangedEventArgs.all.get_OldValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewValue
   (
      this : in out DependencyPropertyChangedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IDependencyPropertyChangedEventArgs.all.get_NewValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate DependencyPropertyChangedEventHandler

   function Invoke
   (
      this : access DependencyPropertyChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.IDependencyPropertyChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DispatcherTimer

   procedure Initialize (this : in out DispatcherTimer) is
   begin
      null;
   end;

   procedure Finalize (this : in out DispatcherTimer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDispatcherTimer, IDispatcherTimer_Ptr);
   begin
      if this.m_IDispatcherTimer /= null then
         if this.m_IDispatcherTimer.all /= null then
            temp := this.m_IDispatcherTimer.all.Release;
            Free (this.m_IDispatcherTimer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DispatcherTimer

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DispatcherTimer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DispatcherTimer");
      m_Factory    : access IDispatcherTimerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IDispatcherTimer;
   begin
      return RetVal : DispatcherTimer do
         Hr := RoGetActivationFactory (m_hString, IID_IDispatcherTimerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDispatcherTimer := new WinUI3.Windows.UI.Xaml.IDispatcherTimer;
            Retval.m_IDispatcherTimer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DispatcherTimer

   function get_Interval
   (
      this : in out DispatcherTimer
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IDispatcherTimer.all.get_Interval (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Interval
   (
      this : in out DispatcherTimer;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDispatcherTimer.all.put_Interval (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsEnabled
   (
      this : in out DispatcherTimer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDispatcherTimer.all.get_IsEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_Tick
   (
      this : in out DispatcherTimer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDispatcherTimer.all.add_Tick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Tick
   (
      this : in out DispatcherTimer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDispatcherTimer.all.remove_Tick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Start
   (
      this : in out DispatcherTimer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDispatcherTimer.all.Start;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out DispatcherTimer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDispatcherTimer.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragEventArgs

   procedure Initialize (this : in out DragEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragEventArgs, IDragEventArgs_Ptr);
   begin
      if this.m_IDragEventArgs /= null then
         if this.m_IDragEventArgs.all /= null then
            temp := this.m_IDragEventArgs.all.Release;
            Free (this.m_IDragEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragEventArgs

   function get_Handled
   (
      this : in out DragEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDragEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out DragEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Data
   (
      this : in out DragEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage do
         Hr := this.m_IDragEventArgs.all.get_Data (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataPackage := new WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
         Retval.m_IDataPackage.all := m_ComRetVal;
      end return;
   end;

   procedure put_Data
   (
      this : in out DragEventArgs;
      value : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragEventArgs.all.put_Data (value.m_IDataPackage.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetPosition
   (
      this : in out DragEventArgs;
      relativeTo : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IDragEventArgs.all.GetPosition (relativeTo.m_IUIElement.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DataView
   (
      this : in out DragEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageView'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDragEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackageView;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDragEventArgs_Interface, WinUI3.Windows.UI.Xaml.IDragEventArgs2, WinUI3.Windows.UI.Xaml.IID_IDragEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageView do
         m_Interface := QInterface (this.m_IDragEventArgs.all);
         Hr := m_Interface.get_DataView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataPackageView := new WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackageView;
         Retval.m_IDataPackageView.all := m_ComRetVal;
      end return;
   end;

   function get_DragUIOverride
   (
      this : in out DragEventArgs
   )
   return WinUI3.Windows.UI.Xaml.DragUIOverride'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDragEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDragUIOverride;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDragEventArgs_Interface, WinUI3.Windows.UI.Xaml.IDragEventArgs2, WinUI3.Windows.UI.Xaml.IID_IDragEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DragUIOverride do
         m_Interface := QInterface (this.m_IDragEventArgs.all);
         Hr := m_Interface.get_DragUIOverride (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDragUIOverride := new WinUI3.Windows.UI.Xaml.IDragUIOverride;
         Retval.m_IDragUIOverride.all := m_ComRetVal;
      end return;
   end;

   function get_Modifiers
   (
      this : in out DragEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DragDrop.DragDropModifiers is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDragEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.DragDrop.DragDropModifiers;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDragEventArgs_Interface, WinUI3.Windows.UI.Xaml.IDragEventArgs2, WinUI3.Windows.UI.Xaml.IID_IDragEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDragEventArgs.all);
      Hr := m_Interface.get_Modifiers (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AcceptedOperation
   (
      this : in out DragEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDragEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDragEventArgs_Interface, WinUI3.Windows.UI.Xaml.IDragEventArgs2, WinUI3.Windows.UI.Xaml.IID_IDragEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDragEventArgs.all);
      Hr := m_Interface.get_AcceptedOperation (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AcceptedOperation
   (
      this : in out DragEventArgs;
      value : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDragEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDragEventArgs_Interface, WinUI3.Windows.UI.Xaml.IDragEventArgs2, WinUI3.Windows.UI.Xaml.IID_IDragEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDragEventArgs.all);
      Hr := m_Interface.put_AcceptedOperation (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out DragEventArgs
   )
   return WinUI3.Windows.UI.Xaml.DragOperationDeferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDragEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDragOperationDeferral;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDragEventArgs_Interface, WinUI3.Windows.UI.Xaml.IDragEventArgs2, WinUI3.Windows.UI.Xaml.IID_IDragEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DragOperationDeferral do
         m_Interface := QInterface (this.m_IDragEventArgs.all);
         Hr := m_Interface.GetDeferral (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDragOperationDeferral := new WinUI3.Windows.UI.Xaml.IDragOperationDeferral;
         Retval.m_IDragOperationDeferral.all := m_ComRetVal;
      end return;
   end;

   function get_AllowedOperations
   (
      this : in out DragEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDragEventArgs3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDragEventArgs_Interface, WinUI3.Windows.UI.Xaml.IDragEventArgs3, WinUI3.Windows.UI.Xaml.IID_IDragEventArgs3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDragEventArgs.all);
      Hr := m_Interface.get_AllowedOperations (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate DragEventHandler

   function Invoke
   (
      this : access DragEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.IDragEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragOperationDeferral

   procedure Initialize (this : in out DragOperationDeferral) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragOperationDeferral) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragOperationDeferral, IDragOperationDeferral_Ptr);
   begin
      if this.m_IDragOperationDeferral /= null then
         if this.m_IDragOperationDeferral.all /= null then
            temp := this.m_IDragOperationDeferral.all.Release;
            Free (this.m_IDragOperationDeferral);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragOperationDeferral

   procedure Complete
   (
      this : in out DragOperationDeferral
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragOperationDeferral.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragStartingEventArgs

   procedure Initialize (this : in out DragStartingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragStartingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragStartingEventArgs, IDragStartingEventArgs_Ptr);
   begin
      if this.m_IDragStartingEventArgs /= null then
         if this.m_IDragStartingEventArgs.all /= null then
            temp := this.m_IDragStartingEventArgs.all.Release;
            Free (this.m_IDragStartingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragStartingEventArgs

   function get_Cancel
   (
      this : in out DragStartingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDragStartingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out DragStartingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragStartingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Data
   (
      this : in out DragStartingEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage do
         Hr := this.m_IDragStartingEventArgs.all.get_Data (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataPackage := new WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
         Retval.m_IDataPackage.all := m_ComRetVal;
      end return;
   end;

   function get_DragUI
   (
      this : in out DragStartingEventArgs
   )
   return WinUI3.Windows.UI.Xaml.DragUI'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDragUI;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DragUI do
         Hr := this.m_IDragStartingEventArgs.all.get_DragUI (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDragUI := new WinUI3.Windows.UI.Xaml.IDragUI;
         Retval.m_IDragUI.all := m_ComRetVal;
      end return;
   end;

   function GetDeferral
   (
      this : in out DragStartingEventArgs
   )
   return WinUI3.Windows.UI.Xaml.DragOperationDeferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDragOperationDeferral;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DragOperationDeferral do
         Hr := this.m_IDragStartingEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDragOperationDeferral := new WinUI3.Windows.UI.Xaml.IDragOperationDeferral;
         Retval.m_IDragOperationDeferral.all := m_ComRetVal;
      end return;
   end;

   function GetPosition
   (
      this : in out DragStartingEventArgs;
      relativeTo : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := this.m_IDragStartingEventArgs.all.GetPosition (relativeTo.m_IUIElement.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AllowedOperations
   (
      this : in out DragStartingEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDragStartingEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDragStartingEventArgs_Interface, WinUI3.Windows.UI.Xaml.IDragStartingEventArgs2, WinUI3.Windows.UI.Xaml.IID_IDragStartingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDragStartingEventArgs.all);
      Hr := m_Interface.get_AllowedOperations (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AllowedOperations
   (
      this : in out DragStartingEventArgs;
      value : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IDragStartingEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IDragStartingEventArgs_Interface, WinUI3.Windows.UI.Xaml.IDragStartingEventArgs2, WinUI3.Windows.UI.Xaml.IID_IDragStartingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDragStartingEventArgs.all);
      Hr := m_Interface.put_AllowedOperations (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragUI

   procedure Initialize (this : in out DragUI) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragUI) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragUI, IDragUI_Ptr);
   begin
      if this.m_IDragUI /= null then
         if this.m_IDragUI.all /= null then
            temp := this.m_IDragUI.all.Release;
            Free (this.m_IDragUI);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragUI

   procedure SetContentFromBitmapImage
   (
      this : in out DragUI;
      bitmapImage : WinUI3.Windows.UI.Xaml.Media.Imaging.BitmapImage'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUI.all.SetContentFromBitmapImage (bitmapImage.m_IBitmapImage.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetContentFromBitmapImage
   (
      this : in out DragUI;
      bitmapImage : WinUI3.Windows.UI.Xaml.Media.Imaging.BitmapImage'Class;
      anchorPoint : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUI.all.SetContentFromBitmapImage (bitmapImage.m_IBitmapImage.all, anchorPoint);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetContentFromSoftwareBitmap
   (
      this : in out DragUI;
      softwareBitmap : WinUI3.Windows.Graphics.Imaging.SoftwareBitmap'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUI.all.SetContentFromSoftwareBitmap (softwareBitmap.m_ISoftwareBitmap.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetContentFromSoftwareBitmap
   (
      this : in out DragUI;
      softwareBitmap : WinUI3.Windows.Graphics.Imaging.SoftwareBitmap'Class;
      anchorPoint : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUI.all.SetContentFromSoftwareBitmap (softwareBitmap.m_ISoftwareBitmap.all, anchorPoint);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetContentFromDataPackage
   (
      this : in out DragUI
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUI.all.SetContentFromDataPackage;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragUIOverride

   procedure Initialize (this : in out DragUIOverride) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragUIOverride) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragUIOverride, IDragUIOverride_Ptr);
   begin
      if this.m_IDragUIOverride /= null then
         if this.m_IDragUIOverride.all /= null then
            temp := this.m_IDragUIOverride.all.Release;
            Free (this.m_IDragUIOverride);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragUIOverride

   function get_Caption
   (
      this : in out DragUIOverride
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDragUIOverride.all.get_Caption (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Caption
   (
      this : in out DragUIOverride;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDragUIOverride.all.put_Caption (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsContentVisible
   (
      this : in out DragUIOverride
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDragUIOverride.all.get_IsContentVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsContentVisible
   (
      this : in out DragUIOverride;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUIOverride.all.put_IsContentVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsCaptionVisible
   (
      this : in out DragUIOverride
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDragUIOverride.all.get_IsCaptionVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCaptionVisible
   (
      this : in out DragUIOverride;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUIOverride.all.put_IsCaptionVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsGlyphVisible
   (
      this : in out DragUIOverride
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDragUIOverride.all.get_IsGlyphVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsGlyphVisible
   (
      this : in out DragUIOverride;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUIOverride.all.put_IsGlyphVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out DragUIOverride
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUIOverride.all.Clear;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetContentFromBitmapImage
   (
      this : in out DragUIOverride;
      bitmapImage : WinUI3.Windows.UI.Xaml.Media.Imaging.BitmapImage'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUIOverride.all.SetContentFromBitmapImage (bitmapImage.m_IBitmapImage.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetContentFromBitmapImage
   (
      this : in out DragUIOverride;
      bitmapImage : WinUI3.Windows.UI.Xaml.Media.Imaging.BitmapImage'Class;
      anchorPoint : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUIOverride.all.SetContentFromBitmapImage (bitmapImage.m_IBitmapImage.all, anchorPoint);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetContentFromSoftwareBitmap
   (
      this : in out DragUIOverride;
      softwareBitmap : WinUI3.Windows.Graphics.Imaging.SoftwareBitmap'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUIOverride.all.SetContentFromSoftwareBitmap (softwareBitmap.m_ISoftwareBitmap.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetContentFromSoftwareBitmap
   (
      this : in out DragUIOverride;
      softwareBitmap : WinUI3.Windows.Graphics.Imaging.SoftwareBitmap'Class;
      anchorPoint : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragUIOverride.all.SetContentFromSoftwareBitmap (softwareBitmap.m_ISoftwareBitmap.all, anchorPoint);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DropCompletedEventArgs

   procedure Initialize (this : in out DropCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DropCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDropCompletedEventArgs, IDropCompletedEventArgs_Ptr);
   begin
      if this.m_IDropCompletedEventArgs /= null then
         if this.m_IDropCompletedEventArgs.all /= null then
            temp := this.m_IDropCompletedEventArgs.all.Release;
            Free (this.m_IDropCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DropCompletedEventArgs

   function get_DropResult
   (
      this : in out DropCompletedEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation;
   begin
      Hr := this.m_IDropCompletedEventArgs.all.get_DropResult (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DurationHelper

   procedure Initialize (this : in out DurationHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out DurationHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDurationHelper, IDurationHelper_Ptr);
   begin
      if this.m_IDurationHelper /= null then
         if this.m_IDurationHelper.all /= null then
            temp := this.m_IDurationHelper.all.Release;
            Free (this.m_IDurationHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DurationHelper

   function get_Automatic
   return WinUI3.Windows.UI.Xaml.Duration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DurationHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDurationHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Duration;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDurationHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Automatic (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_Forever
   return WinUI3.Windows.UI.Xaml.Duration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DurationHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDurationHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Duration;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDurationHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Forever (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Compare
   (
      duration1 : WinUI3.Windows.UI.Xaml.Duration;
      duration2 : WinUI3.Windows.UI.Xaml.Duration
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DurationHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDurationHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDurationHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Compare (duration1, duration2, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromTimeSpan
   (
      timeSpan : WinUI3.Windows.Foundation.TimeSpan
   )
   return WinUI3.Windows.UI.Xaml.Duration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DurationHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDurationHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Duration;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDurationHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromTimeSpan (timeSpan, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetHasTimeSpan
   (
      target : WinUI3.Windows.UI.Xaml.Duration
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DurationHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDurationHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDurationHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetHasTimeSpan (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Add
   (
      target : WinUI3.Windows.UI.Xaml.Duration;
      duration : WinUI3.Windows.UI.Xaml.Duration
   )
   return WinUI3.Windows.UI.Xaml.Duration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DurationHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDurationHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Duration;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDurationHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Add (target, duration, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Equals
   (
      target : WinUI3.Windows.UI.Xaml.Duration;
      value : WinUI3.Windows.UI.Xaml.Duration
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DurationHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDurationHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDurationHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Equals (target, value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Subtract
   (
      target : WinUI3.Windows.UI.Xaml.Duration;
      duration : WinUI3.Windows.UI.Xaml.Duration
   )
   return WinUI3.Windows.UI.Xaml.Duration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.DurationHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IDurationHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Duration;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IDurationHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Subtract (target, duration, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DurationHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EffectiveViewportChangedEventArgs

   procedure Initialize (this : in out EffectiveViewportChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out EffectiveViewportChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEffectiveViewportChangedEventArgs, IEffectiveViewportChangedEventArgs_Ptr);
   begin
      if this.m_IEffectiveViewportChangedEventArgs /= null then
         if this.m_IEffectiveViewportChangedEventArgs.all /= null then
            temp := this.m_IEffectiveViewportChangedEventArgs.all.Release;
            Free (this.m_IEffectiveViewportChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EffectiveViewportChangedEventArgs

   function get_EffectiveViewport
   (
      this : in out EffectiveViewportChangedEventArgs
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IEffectiveViewportChangedEventArgs.all.get_EffectiveViewport (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MaxViewport
   (
      this : in out EffectiveViewportChangedEventArgs
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IEffectiveViewportChangedEventArgs.all.get_MaxViewport (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_BringIntoViewDistanceX
   (
      this : in out EffectiveViewportChangedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IEffectiveViewportChangedEventArgs.all.get_BringIntoViewDistanceX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_BringIntoViewDistanceY
   (
      this : in out EffectiveViewportChangedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IEffectiveViewportChangedEventArgs.all.get_BringIntoViewDistanceY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ElementFactoryGetArgs

   procedure Initialize (this : in out ElementFactoryGetArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ElementFactoryGetArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IElementFactoryGetArgs, IElementFactoryGetArgs_Ptr);
   begin
      if this.m_IElementFactoryGetArgs /= null then
         if this.m_IElementFactoryGetArgs.all /= null then
            temp := this.m_IElementFactoryGetArgs.all.Release;
            Free (this.m_IElementFactoryGetArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ElementFactoryGetArgs

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ElementFactoryGetArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ElementFactoryGetArgs");
      m_Factory    : access IElementFactoryGetArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IElementFactoryGetArgs;
   begin
      return RetVal : ElementFactoryGetArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IElementFactoryGetArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IElementFactoryGetArgs := new WinUI3.Windows.UI.Xaml.IElementFactoryGetArgs;
            Retval.m_IElementFactoryGetArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ElementFactoryGetArgs

   function get_Data
   (
      this : in out ElementFactoryGetArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IElementFactoryGetArgs.all.get_Data (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Data
   (
      this : in out ElementFactoryGetArgs;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IElementFactoryGetArgs.all.put_Data (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Parent
   (
      this : in out ElementFactoryGetArgs
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IElementFactoryGetArgs.all.get_Parent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Parent
   (
      this : in out ElementFactoryGetArgs;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IElementFactoryGetArgs.all.put_Parent (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ElementFactoryRecycleArgs

   procedure Initialize (this : in out ElementFactoryRecycleArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ElementFactoryRecycleArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IElementFactoryRecycleArgs, IElementFactoryRecycleArgs_Ptr);
   begin
      if this.m_IElementFactoryRecycleArgs /= null then
         if this.m_IElementFactoryRecycleArgs.all /= null then
            temp := this.m_IElementFactoryRecycleArgs.all.Release;
            Free (this.m_IElementFactoryRecycleArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ElementFactoryRecycleArgs

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ElementFactoryRecycleArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ElementFactoryRecycleArgs");
      m_Factory    : access IElementFactoryRecycleArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IElementFactoryRecycleArgs;
   begin
      return RetVal : ElementFactoryRecycleArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IElementFactoryRecycleArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IElementFactoryRecycleArgs := new WinUI3.Windows.UI.Xaml.IElementFactoryRecycleArgs;
            Retval.m_IElementFactoryRecycleArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ElementFactoryRecycleArgs

   function get_Element
   (
      this : in out ElementFactoryRecycleArgs
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IElementFactoryRecycleArgs.all.get_Element (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Element
   (
      this : in out ElementFactoryRecycleArgs;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IElementFactoryRecycleArgs.all.put_Element (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Parent
   (
      this : in out ElementFactoryRecycleArgs
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IElementFactoryRecycleArgs.all.get_Parent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Parent
   (
      this : in out ElementFactoryRecycleArgs;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IElementFactoryRecycleArgs.all.put_Parent (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ElementSoundPlayer

   procedure Initialize (this : in out ElementSoundPlayer) is
   begin
      null;
   end;

   procedure Finalize (this : in out ElementSoundPlayer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IElementSoundPlayer, IElementSoundPlayer_Ptr);
   begin
      if this.m_IElementSoundPlayer /= null then
         if this.m_IElementSoundPlayer.all /= null then
            temp := this.m_IElementSoundPlayer.all.Release;
            Free (this.m_IElementSoundPlayer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ElementSoundPlayer

   function get_SpatialAudioMode
   return WinUI3.Windows.UI.Xaml.ElementSpatialAudioMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ElementSoundPlayer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IElementSoundPlayerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ElementSpatialAudioMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IElementSoundPlayerStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_SpatialAudioMode (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure put_SpatialAudioMode
   (
      value : WinUI3.Windows.UI.Xaml.ElementSpatialAudioMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ElementSoundPlayer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IElementSoundPlayerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IElementSoundPlayerStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.put_SpatialAudioMode (value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_Volume
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ElementSoundPlayer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IElementSoundPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IElementSoundPlayerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Volume (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure put_Volume
   (
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ElementSoundPlayer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IElementSoundPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IElementSoundPlayerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.put_Volume (value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_State
   return WinUI3.Windows.UI.Xaml.ElementSoundPlayerState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ElementSoundPlayer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IElementSoundPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ElementSoundPlayerState;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IElementSoundPlayerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_State (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure put_State
   (
      value : WinUI3.Windows.UI.Xaml.ElementSoundPlayerState
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ElementSoundPlayer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IElementSoundPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IElementSoundPlayerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.put_State (value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   procedure Play
   (
      sound : WinUI3.Windows.UI.Xaml.ElementSoundKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ElementSoundPlayer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IElementSoundPlayerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IElementSoundPlayerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Play (sound);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ElementSoundPlayer

   -----------------------------------------------------------------------------
   -- Delegate EnteredBackgroundEventHandler

   function Invoke
   (
      this : access EnteredBackgroundEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.ApplicationModel.IEnteredBackgroundEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TriggerBase

   procedure Initialize (this : in out TriggerBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out TriggerBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITriggerBase, ITriggerBase_Ptr);
   begin
      if this.m_ITriggerBase /= null then
         if this.m_ITriggerBase.all /= null then
            temp := this.m_ITriggerBase.all.Release;
            Free (this.m_ITriggerBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TriggerBase

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TriggerBase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EventTrigger

   procedure Initialize (this : in out EventTrigger) is
   begin
      null;
   end;

   procedure Finalize (this : in out EventTrigger) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEventTrigger, IEventTrigger_Ptr);
   begin
      if this.m_IEventTrigger /= null then
         if this.m_IEventTrigger.all /= null then
            temp := this.m_IEventTrigger.all.Release;
            Free (this.m_IEventTrigger);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for EventTrigger

   function Constructor return EventTrigger is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.EventTrigger");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IEventTrigger;
   begin
      return RetVal : EventTrigger do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IEventTrigger := new WinUI3.Windows.UI.Xaml.IEventTrigger;
            Retval.m_IEventTrigger.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EventTrigger

   function get_RoutedEvent
   (
      this : in out EventTrigger
   )
   return WinUI3.Windows.UI.Xaml.RoutedEvent'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IRoutedEvent;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.RoutedEvent do
         Hr := this.m_IEventTrigger.all.get_RoutedEvent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRoutedEvent := new WinUI3.Windows.UI.Xaml.IRoutedEvent;
         Retval.m_IRoutedEvent.all := m_ComRetVal;
      end return;
   end;

   procedure put_RoutedEvent
   (
      this : in out EventTrigger;
      value : WinUI3.Windows.UI.Xaml.RoutedEvent'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IEventTrigger.all.put_RoutedEvent (value.m_IRoutedEvent.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Actions
   (
      this : in out EventTrigger
   )
   return WinUI3.Windows.UI.Xaml.TriggerActionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.TriggerActionCollection do
         Hr := this.m_IEventTrigger.all.get_Actions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ExceptionRoutedEventArgs

   procedure Initialize (this : in out ExceptionRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ExceptionRoutedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IExceptionRoutedEventArgs, IExceptionRoutedEventArgs_Ptr);
   begin
      if this.m_IExceptionRoutedEventArgs /= null then
         if this.m_IExceptionRoutedEventArgs.all /= null then
            temp := this.m_IExceptionRoutedEventArgs.all.Release;
            Free (this.m_IExceptionRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ExceptionRoutedEventArgs

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ExceptionRoutedEventArgs

   function get_ErrorMessage
   (
      this : in out ExceptionRoutedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IExceptionRoutedEventArgs.all.get_ErrorMessage (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ExceptionRoutedEventHandler

   function Invoke
   (
      this : access ExceptionRoutedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.IExceptionRoutedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FrameworkView

   procedure Initialize (this : in out FrameworkView) is
   begin
      null;
   end;

   procedure Finalize (this : in out FrameworkView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFrameworkView, IFrameworkView_Ptr);
   begin
      if this.m_IFrameworkView /= null then
         if this.m_IFrameworkView.all /= null then
            temp := this.m_IFrameworkView.all.Release;
            Free (this.m_IFrameworkView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FrameworkView

   function Constructor return FrameworkView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkView");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IFrameworkView;
   begin
      return RetVal : FrameworkView do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IFrameworkView := new WinUI3.Windows.UI.Xaml.IFrameworkView;
            Retval.m_IFrameworkView.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FrameworkView

   procedure Initialize
   (
      this : in out FrameworkView;
      applicationView : WinUI3.Windows.ApplicationModel.Core.CoreApplicationView'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.ApplicationModel.Core.IFrameworkView := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkView_Interface, WinUI3.Windows.ApplicationModel.Core.IFrameworkView, WinUI3.Windows.ApplicationModel.Core.IID_IFrameworkView'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkView.all);
      Hr := m_Interface.Initialize (applicationView.m_ICoreApplicationView.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetWindow
   (
      this : in out FrameworkView;
      window_p : WinUI3.Windows.UI.Core.CoreWindow'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.ApplicationModel.Core.IFrameworkView := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkView_Interface, WinUI3.Windows.ApplicationModel.Core.IFrameworkView, WinUI3.Windows.ApplicationModel.Core.IID_IFrameworkView'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkView.all);
      Hr := m_Interface.SetWindow (window_p.m_ICoreWindow.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Load
   (
      this : in out FrameworkView;
      entryPoint : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.ApplicationModel.Core.IFrameworkView := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_entryPoint : constant WinUI3.HString := To_HString (entryPoint);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkView_Interface, WinUI3.Windows.ApplicationModel.Core.IFrameworkView, WinUI3.Windows.ApplicationModel.Core.IID_IFrameworkView'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkView.all);
      Hr := m_Interface.Load (HStr_entryPoint);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_entryPoint);
   end;

   procedure Run
   (
      this : in out FrameworkView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.ApplicationModel.Core.IFrameworkView := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkView_Interface, WinUI3.Windows.ApplicationModel.Core.IFrameworkView, WinUI3.Windows.ApplicationModel.Core.IID_IFrameworkView'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkView.all);
      Hr := m_Interface.Run;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Uninitialize
   (
      this : in out FrameworkView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.ApplicationModel.Core.IFrameworkView := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkView_Interface, WinUI3.Windows.ApplicationModel.Core.IFrameworkView, WinUI3.Windows.ApplicationModel.Core.IID_IFrameworkView'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkView.all);
      Hr := m_Interface.Uninitialize;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FrameworkViewSource

   procedure Initialize (this : in out FrameworkViewSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out FrameworkViewSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFrameworkViewSource, IFrameworkViewSource_Ptr);
   begin
      if this.m_IFrameworkViewSource /= null then
         if this.m_IFrameworkViewSource.all /= null then
            temp := this.m_IFrameworkViewSource.all.Release;
            Free (this.m_IFrameworkViewSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FrameworkViewSource

   function Constructor return FrameworkViewSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.FrameworkViewSource");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IFrameworkViewSource;
   begin
      return RetVal : FrameworkViewSource do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IFrameworkViewSource := new WinUI3.Windows.UI.Xaml.IFrameworkViewSource;
            Retval.m_IFrameworkViewSource.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FrameworkViewSource

   function CreateView
   (
      this : in out FrameworkViewSource
   )
   return WinUI3.Windows.ApplicationModel.Core.IFrameworkView is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.ApplicationModel.Core.IFrameworkViewSource := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.Core.IFrameworkView;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IFrameworkViewSource_Interface, WinUI3.Windows.ApplicationModel.Core.IFrameworkViewSource, WinUI3.Windows.ApplicationModel.Core.IID_IFrameworkViewSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrameworkViewSource.all);
      Hr := m_Interface.CreateView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GridLengthHelper

   procedure Initialize (this : in out GridLengthHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out GridLengthHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGridLengthHelper, IGridLengthHelper_Ptr);
   begin
      if this.m_IGridLengthHelper /= null then
         if this.m_IGridLengthHelper.all /= null then
            temp := this.m_IGridLengthHelper.all.Release;
            Free (this.m_IGridLengthHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for GridLengthHelper

   function get_Auto
   return WinUI3.Windows.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.GridLengthHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IGridLengthHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.GridLength;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridLengthHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Auto (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromPixels
   (
      pixels : WinUI3.Double
   )
   return WinUI3.Windows.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.GridLengthHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IGridLengthHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.GridLength;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridLengthHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromPixels (pixels, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromValueAndType
   (
      value : WinUI3.Double;
      type_x : WinUI3.Windows.UI.Xaml.GridUnitType
   )
   return WinUI3.Windows.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.GridLengthHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IGridLengthHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.GridLength;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridLengthHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromValueAndType (value, type_x, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetIsAbsolute
   (
      target : WinUI3.Windows.UI.Xaml.GridLength
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.GridLengthHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IGridLengthHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridLengthHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsAbsolute (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetIsAuto
   (
      target : WinUI3.Windows.UI.Xaml.GridLength
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.GridLengthHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IGridLengthHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridLengthHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsAuto (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetIsStar
   (
      target : WinUI3.Windows.UI.Xaml.GridLength
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.GridLengthHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IGridLengthHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridLengthHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsStar (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Equals
   (
      target : WinUI3.Windows.UI.Xaml.GridLength;
      value : WinUI3.Windows.UI.Xaml.GridLength
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.GridLengthHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IGridLengthHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridLengthHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Equals (target, value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GridLengthHelper

   -----------------------------------------------------------------------------
   -- Delegate LeavingBackgroundEventHandler

   function Invoke
   (
      this : access LeavingBackgroundEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.ApplicationModel.ILeavingBackgroundEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TriggerAction

   procedure Initialize (this : in out TriggerAction) is
   begin
      null;
   end;

   procedure Finalize (this : in out TriggerAction) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITriggerAction, ITriggerAction_Ptr);
   begin
      if this.m_ITriggerAction /= null then
         if this.m_ITriggerAction.all /= null then
            temp := this.m_ITriggerAction.all.Release;
            Free (this.m_ITriggerAction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TriggerAction

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TriggerAction

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MediaFailedRoutedEventArgs

   procedure Initialize (this : in out MediaFailedRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MediaFailedRoutedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMediaFailedRoutedEventArgs, IMediaFailedRoutedEventArgs_Ptr);
   begin
      if this.m_IMediaFailedRoutedEventArgs /= null then
         if this.m_IMediaFailedRoutedEventArgs.all /= null then
            temp := this.m_IMediaFailedRoutedEventArgs.all.Release;
            Free (this.m_IMediaFailedRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MediaFailedRoutedEventArgs

   function get_ErrorTrace
   (
      this : in out MediaFailedRoutedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMediaFailedRoutedEventArgs.all.get_ErrorTrace (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointHelper

   procedure Initialize (this : in out PointHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointHelper, IPointHelper_Ptr);
   begin
      if this.m_IPointHelper /= null then
         if this.m_IPointHelper.all /= null then
            temp := this.m_IPointHelper.all.Release;
            Free (this.m_IPointHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PointHelper

   function FromCoordinates
   (
      x : WinUI3.Single;
      y : WinUI3.Single
   )
   return WinUI3.Windows.Foundation.Point is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.PointHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IPointHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Point;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPointHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromCoordinates (x, y, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointHelper

   -----------------------------------------------------------------------------
   -- Delegate PropertyChangedCallback

   function Invoke
   (
      this : access PropertyChangedCallback_Delegate;
      d : WinUI3.Windows.UI.Xaml.IDependencyObject;
      e : WinUI3.Windows.UI.Xaml.IDependencyPropertyChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (d, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PropertyMetadata

   procedure Initialize (this : in out PropertyMetadata) is
   begin
      null;
   end;

   procedure Finalize (this : in out PropertyMetadata) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPropertyMetadata, IPropertyMetadata_Ptr);
   begin
      if this.m_IPropertyMetadata /= null then
         if this.m_IPropertyMetadata.all /= null then
            temp := this.m_IPropertyMetadata.all.Release;
            Free (this.m_IPropertyMetadata);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PropertyMetadata

   function Constructor
   (
      defaultValue : WinUI3.IInspectable;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PropertyMetadata is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.PropertyMetadata");
      m_Factory    : access IPropertyMetadataFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IPropertyMetadata;
   begin
      return RetVal : PropertyMetadata do
         Hr := RoGetActivationFactory (m_hString, IID_IPropertyMetadataFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithDefaultValue (defaultValue, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPropertyMetadata := new WinUI3.Windows.UI.Xaml.IPropertyMetadata;
            Retval.m_IPropertyMetadata.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      defaultValue : WinUI3.IInspectable;
      propertyChangedCallback : WinUI3.Windows.UI.Xaml.PropertyChangedCallback;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PropertyMetadata is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.PropertyMetadata");
      m_Factory    : access IPropertyMetadataFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IPropertyMetadata;
   begin
      return RetVal : PropertyMetadata do
         Hr := RoGetActivationFactory (m_hString, IID_IPropertyMetadataFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithDefaultValueAndCallback (defaultValue, propertyChangedCallback, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPropertyMetadata := new WinUI3.Windows.UI.Xaml.IPropertyMetadata;
            Retval.m_IPropertyMetadata.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PropertyMetadata

   function Create
   (
      defaultValue : WinUI3.IInspectable
   )
   return WinUI3.Windows.UI.Xaml.PropertyMetadata is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.PropertyMetadata");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IPropertyMetadataStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IPropertyMetadata;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.PropertyMetadata do
         Hr := RoGetActivationFactory (m_hString, IID_IPropertyMetadataStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (defaultValue, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IPropertyMetadata := new WinUI3.Windows.UI.Xaml.IPropertyMetadata;
            Retval.m_IPropertyMetadata.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Create
   (
      defaultValue : WinUI3.IInspectable;
      propertyChangedCallback : WinUI3.Windows.UI.Xaml.PropertyChangedCallback
   )
   return WinUI3.Windows.UI.Xaml.PropertyMetadata is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.PropertyMetadata");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IPropertyMetadataStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IPropertyMetadata;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.PropertyMetadata do
         Hr := RoGetActivationFactory (m_hString, IID_IPropertyMetadataStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (defaultValue, propertyChangedCallback, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IPropertyMetadata := new WinUI3.Windows.UI.Xaml.IPropertyMetadata;
            Retval.m_IPropertyMetadata.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Create
   (
      createDefaultValueCallback : WinUI3.Windows.UI.Xaml.CreateDefaultValueCallback
   )
   return WinUI3.Windows.UI.Xaml.PropertyMetadata is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.PropertyMetadata");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IPropertyMetadataStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IPropertyMetadata;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.PropertyMetadata do
         Hr := RoGetActivationFactory (m_hString, IID_IPropertyMetadataStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (createDefaultValueCallback, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IPropertyMetadata := new WinUI3.Windows.UI.Xaml.IPropertyMetadata;
            Retval.m_IPropertyMetadata.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Create
   (
      createDefaultValueCallback : WinUI3.Windows.UI.Xaml.CreateDefaultValueCallback;
      propertyChangedCallback : WinUI3.Windows.UI.Xaml.PropertyChangedCallback
   )
   return WinUI3.Windows.UI.Xaml.PropertyMetadata is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.PropertyMetadata");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IPropertyMetadataStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IPropertyMetadata;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.PropertyMetadata do
         Hr := RoGetActivationFactory (m_hString, IID_IPropertyMetadataStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (createDefaultValueCallback, propertyChangedCallback, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IPropertyMetadata := new WinUI3.Windows.UI.Xaml.IPropertyMetadata;
            Retval.m_IPropertyMetadata.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PropertyMetadata

   function get_DefaultValue
   (
      this : in out PropertyMetadata
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IPropertyMetadata.all.get_DefaultValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CreateDefaultValueCallback
   (
      this : in out PropertyMetadata
   )
   return WinUI3.Windows.UI.Xaml.CreateDefaultValueCallback is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.CreateDefaultValueCallback;
   begin
      Hr := this.m_IPropertyMetadata.all.get_CreateDefaultValueCallback (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PropertyPath

   procedure Initialize (this : in out PropertyPath) is
   begin
      null;
   end;

   procedure Finalize (this : in out PropertyPath) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPropertyPath, IPropertyPath_Ptr);
   begin
      if this.m_IPropertyPath /= null then
         if this.m_IPropertyPath.all /= null then
            temp := this.m_IPropertyPath.all.Release;
            Free (this.m_IPropertyPath);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PropertyPath

   function Constructor
   (
      path : WinUI3.WString
   )
   return PropertyPath is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.PropertyPath");
      m_Factory    : access IPropertyPathFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IPropertyPath;
      HStr_path : constant WinUI3.HString := To_HString (path);
   begin
      return RetVal : PropertyPath do
         Hr := RoGetActivationFactory (m_hString, IID_IPropertyPathFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (HStr_path, m_ComRetVal'Access);
            Retval.m_IPropertyPath := new WinUI3.Windows.UI.Xaml.IPropertyPath;
            Retval.m_IPropertyPath.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_path);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PropertyPath

   function get_Path
   (
      this : in out PropertyPath
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPropertyPath.all.get_Path (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RectHelper

   procedure Initialize (this : in out RectHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out RectHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRectHelper, IRectHelper_Ptr);
   begin
      if this.m_IRectHelper /= null then
         if this.m_IRectHelper.all /= null then
            temp := this.m_IRectHelper.all.Release;
            Free (this.m_IRectHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RectHelper

   function get_Empty
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Empty (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromCoordinatesAndDimensions
   (
      x : WinUI3.Single;
      y : WinUI3.Single;
      width : WinUI3.Single;
      height : WinUI3.Single
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromCoordinatesAndDimensions (x, y, width, height, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromPoints
   (
      point1 : WinUI3.Windows.Foundation.Point;
      point2 : WinUI3.Windows.Foundation.Point
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromPoints (point1, point2, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromLocationAndSize
   (
      location : WinUI3.Windows.Foundation.Point;
      size : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromLocationAndSize (location, size, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetIsEmpty
   (
      target : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsEmpty (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetBottom
   (
      target : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetBottom (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetLeft
   (
      target : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetLeft (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetRight
   (
      target : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetRight (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetTop
   (
      target : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetTop (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Contains
   (
      target : WinUI3.Windows.Foundation.Rect;
      point : WinUI3.Windows.Foundation.Point
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Contains (target, point, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Equals
   (
      target : WinUI3.Windows.Foundation.Rect;
      value : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Equals (target, value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Intersect
   (
      target : WinUI3.Windows.Foundation.Rect;
      rect : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Intersect (target, rect, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Union
   (
      target : WinUI3.Windows.Foundation.Rect;
      point : WinUI3.Windows.Foundation.Point
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Union (target, point, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Union
   (
      target : WinUI3.Windows.Foundation.Rect;
      rect : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.RectHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IRectHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRectHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Union (target, rect, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RectHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RoutedEvent

   procedure Initialize (this : in out RoutedEvent) is
   begin
      null;
   end;

   procedure Finalize (this : in out RoutedEvent) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRoutedEvent, IRoutedEvent_Ptr);
   begin
      if this.m_IRoutedEvent /= null then
         if this.m_IRoutedEvent.all /= null then
            temp := this.m_IRoutedEvent.all.Release;
            Free (this.m_IRoutedEvent);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RoutedEvent

   -----------------------------------------------------------------------------
   -- Delegate RoutedEventHandler

   function Invoke
   (
      this : access RoutedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.IRoutedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScalarTransition

   procedure Initialize (this : in out ScalarTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScalarTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScalarTransition, IScalarTransition_Ptr);
   begin
      if this.m_IScalarTransition /= null then
         if this.m_IScalarTransition.all /= null then
            temp := this.m_IScalarTransition.all.Release;
            Free (this.m_IScalarTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScalarTransition

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ScalarTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ScalarTransition");
      m_Factory    : access IScalarTransitionFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IScalarTransition;
   begin
      return RetVal : ScalarTransition do
         Hr := RoGetActivationFactory (m_hString, IID_IScalarTransitionFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IScalarTransition := new WinUI3.Windows.UI.Xaml.IScalarTransition;
            Retval.m_IScalarTransition.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScalarTransition

   function get_Duration
   (
      this : in out ScalarTransition
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IScalarTransition.all.get_Duration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Duration
   (
      this : in out ScalarTransition;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScalarTransition.all.put_Duration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SetterBase

   procedure Initialize (this : in out SetterBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out SetterBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISetterBase, ISetterBase_Ptr);
   begin
      if this.m_ISetterBase /= null then
         if this.m_ISetterBase.all /= null then
            temp := this.m_ISetterBase.all.Release;
            Free (this.m_ISetterBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SetterBase

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SetterBase

   function get_IsSealed
   (
      this : in out SetterBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISetterBase.all.get_IsSealed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Setter

   procedure Initialize (this : in out Setter) is
   begin
      null;
   end;

   procedure Finalize (this : in out Setter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISetter, ISetter_Ptr);
   begin
      if this.m_ISetter /= null then
         if this.m_ISetter.all /= null then
            temp := this.m_ISetter.all.Release;
            Free (this.m_ISetter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Setter

   function Constructor return Setter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Setter");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.ISetter;
   begin
      return RetVal : Setter do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISetter := new WinUI3.Windows.UI.Xaml.ISetter;
            Retval.m_ISetter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      targetProperty : WinUI3.Windows.UI.Xaml.DependencyProperty'Class;
      value : WinUI3.IInspectable
   )
   return Setter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Setter");
      m_Factory    : access ISetterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.ISetter;
   begin
      return RetVal : Setter do
         Hr := RoGetActivationFactory (m_hString, IID_ISetterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (targetProperty.m_IDependencyProperty.all, value, m_ComRetVal'Access);
            Retval.m_ISetter := new WinUI3.Windows.UI.Xaml.ISetter;
            Retval.m_ISetter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Setter

   function get_Property
   (
      this : in out Setter
   )
   return WinUI3.Windows.UI.Xaml.DependencyProperty'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := this.m_ISetter.all.get_Property (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
         Retval.m_IDependencyProperty.all := m_ComRetVal;
      end return;
   end;

   procedure put_Property
   (
      this : in out Setter;
      value : WinUI3.Windows.UI.Xaml.DependencyProperty'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISetter.all.put_Property (value.m_IDependencyProperty.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Value
   (
      this : in out Setter
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ISetter.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out Setter;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISetter.all.put_Value (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Target
   (
      this : in out Setter
   )
   return WinUI3.Windows.UI.Xaml.TargetPropertyPath'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.ISetter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ITargetPropertyPath;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetter_Interface, WinUI3.Windows.UI.Xaml.ISetter2, WinUI3.Windows.UI.Xaml.IID_ISetter2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.TargetPropertyPath do
         m_Interface := QInterface (this.m_ISetter.all);
         Hr := m_Interface.get_Target (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITargetPropertyPath := new WinUI3.Windows.UI.Xaml.ITargetPropertyPath;
         Retval.m_ITargetPropertyPath.all := m_ComRetVal;
      end return;
   end;

   procedure put_Target
   (
      this : in out Setter;
      value : WinUI3.Windows.UI.Xaml.TargetPropertyPath'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.ISetter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetter_Interface, WinUI3.Windows.UI.Xaml.ISetter2, WinUI3.Windows.UI.Xaml.IID_ISetter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISetter.all);
      Hr := m_Interface.put_Target (value.m_ITargetPropertyPath.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SetterBaseCollection

   procedure Initialize (this : in out SetterBaseCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out SetterBaseCollection) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISetterBaseCollection, ISetterBaseCollection_Ptr);
   begin
      if this.m_ISetterBaseCollection /= null then
         if this.m_ISetterBaseCollection.all /= null then
            temp := this.m_ISetterBaseCollection.all.Release;
            Free (this.m_ISetterBaseCollection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SetterBaseCollection

   function Constructor return SetterBaseCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.SetterBaseCollection");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.ISetterBaseCollection;
   begin
      return RetVal : SetterBaseCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISetterBaseCollection := new WinUI3.Windows.UI.Xaml.ISetterBaseCollection;
            Retval.m_ISetterBaseCollection.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SetterBaseCollection

   function get_IsSealed
   (
      this : in out SetterBaseCollection
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISetterBaseCollection.all.get_IsSealed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.SetterBase>
   function GetAt
   (
      this : in out SetterBaseCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.SetterBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ISetterBase;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.SetterBase do
         m_Interface := QInterface (this.m_ISetterBaseCollection.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISetterBase := new WinUI3.Windows.UI.Xaml.ISetterBase;
         Retval.m_ISetterBase.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out SetterBaseCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISetterBaseCollection.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out SetterBaseCollection
   )
   return WinUI3.Windows.UI.Xaml.SetterBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ISetterBase;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.SetterBase do
         m_Interface := QInterface (this.m_ISetterBaseCollection.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISetterBase := new WinUI3.Windows.UI.Xaml.ISetterBase;
         Retval.m_ISetterBase.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out SetterBaseCollection;
      value : WinUI3.Windows.UI.Xaml.SetterBase'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISetterBaseCollection.all);
      Hr := m_Interface.IndexOf (value.m_ISetterBase.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out SetterBaseCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.SetterBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISetterBaseCollection.all);
      Hr := m_Interface.SetAt (index, value.m_ISetterBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out SetterBaseCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.SetterBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISetterBaseCollection.all);
      Hr := m_Interface.InsertAt (index, value.m_ISetterBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out SetterBaseCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISetterBaseCollection.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out SetterBaseCollection;
      value : WinUI3.Windows.UI.Xaml.SetterBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISetterBaseCollection.all);
      Hr := m_Interface.Append (value.m_ISetterBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out SetterBaseCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISetterBaseCollection.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out SetterBaseCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISetterBaseCollection.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out SetterBaseCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.ISetterBase_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_ISetterBaseCollection.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out SetterBaseCollection;
      items : WinUI3.Windows.UI.Xaml.ISetterBase_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3176507389, 29953, 21785, (159, 251, 208, 7, 66, 64, 219, 97 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IVector_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_ISetterBaseCollection.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.SetterBase>
   function First
   (
      this : in out SetterBaseCollection
   )
   return WinUI3.Windows.UI.Xaml.SetterBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_ISetterBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ISetterBase;
      m_GenericIID     : aliased WinUI3.IID := (2868801739, 37032, 22297, (189, 62, 240, 176, 102, 237, 22, 38 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.ISetterBaseCollection_Interface, IIterable_ISetterBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.SetterBase do
         m_Interface := QInterface (this.m_ISetterBaseCollection.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISetterBase := new WinUI3.Windows.UI.Xaml.ISetterBase;
         Retval.m_ISetterBase.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SizeChangedEventArgs

   procedure Initialize (this : in out SizeChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SizeChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISizeChangedEventArgs, ISizeChangedEventArgs_Ptr);
   begin
      if this.m_ISizeChangedEventArgs /= null then
         if this.m_ISizeChangedEventArgs.all /= null then
            temp := this.m_ISizeChangedEventArgs.all.Release;
            Free (this.m_ISizeChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SizeChangedEventArgs

   function get_PreviousSize
   (
      this : in out SizeChangedEventArgs
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := this.m_ISizeChangedEventArgs.all.get_PreviousSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewSize
   (
      this : in out SizeChangedEventArgs
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := this.m_ISizeChangedEventArgs.all.get_NewSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate SizeChangedEventHandler

   function Invoke
   (
      this : access SizeChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.ISizeChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SizeHelper

   procedure Initialize (this : in out SizeHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out SizeHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISizeHelper, ISizeHelper_Ptr);
   begin
      if this.m_ISizeHelper /= null then
         if this.m_ISizeHelper.all /= null then
            temp := this.m_ISizeHelper.all.Release;
            Free (this.m_ISizeHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SizeHelper

   function get_Empty
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.SizeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.ISizeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ISizeHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Empty (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromDimensions
   (
      width : WinUI3.Single;
      height : WinUI3.Single
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.SizeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.ISizeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ISizeHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromDimensions (width, height, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetIsEmpty
   (
      target : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.SizeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.ISizeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ISizeHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsEmpty (target, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Equals
   (
      target : WinUI3.Windows.Foundation.Size;
      value : WinUI3.Windows.Foundation.Size
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.SizeHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.ISizeHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ISizeHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.Equals (target, value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SizeHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StateTrigger

   procedure Initialize (this : in out StateTrigger) is
   begin
      null;
   end;

   procedure Finalize (this : in out StateTrigger) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStateTrigger, IStateTrigger_Ptr);
   begin
      if this.m_IStateTrigger /= null then
         if this.m_IStateTrigger.all /= null then
            temp := this.m_IStateTrigger.all.Release;
            Free (this.m_IStateTrigger);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for StateTrigger

   function Constructor return StateTrigger is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.StateTrigger");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IStateTrigger;
   begin
      return RetVal : StateTrigger do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IStateTrigger := new WinUI3.Windows.UI.Xaml.IStateTrigger;
            Retval.m_IStateTrigger.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for StateTrigger

   function get_IsActiveProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.StateTrigger");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IStateTriggerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStateTriggerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsActiveProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StateTrigger

   function get_IsActive
   (
      this : in out StateTrigger
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IStateTrigger.all.get_IsActive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsActive
   (
      this : in out StateTrigger;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStateTrigger.all.put_IsActive (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Style

   procedure Initialize (this : in out Style) is
   begin
      null;
   end;

   procedure Finalize (this : in out Style) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStyle, IStyle_Ptr);
   begin
      if this.m_IStyle /= null then
         if this.m_IStyle.all /= null then
            temp := this.m_IStyle.all.Release;
            Free (this.m_IStyle);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Style

   function Constructor
   (
      targetType : WinUI3.Windows.UI.Xaml.Interop.TypeName
   )
   return Style is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Style");
      m_Factory    : access IStyleFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : Style do
         Hr := RoGetActivationFactory (m_hString, IID_IStyleFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (targetType, m_ComRetVal'Access);
            Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
            Retval.m_IStyle.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor return Style is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Style");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : Style do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
            Retval.m_IStyle.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Style

   function get_IsSealed
   (
      this : in out Style
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IStyle.all.get_IsSealed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Setters
   (
      this : in out Style
   )
   return WinUI3.Windows.UI.Xaml.SetterBaseCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ISetterBaseCollection;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.SetterBaseCollection do
         Hr := this.m_IStyle.all.get_Setters (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISetterBaseCollection := new WinUI3.Windows.UI.Xaml.ISetterBaseCollection;
         Retval.m_ISetterBaseCollection.all := m_ComRetVal;
      end return;
   end;

   function get_TargetType
   (
      this : in out Style
   )
   return WinUI3.Windows.UI.Xaml.Interop.TypeName is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Interop.TypeName;
   begin
      Hr := this.m_IStyle.all.get_TargetType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TargetType
   (
      this : in out Style;
      value : WinUI3.Windows.UI.Xaml.Interop.TypeName
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStyle.all.put_TargetType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BasedOn
   (
      this : in out Style
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_IStyle.all.get_BasedOn (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_BasedOn
   (
      this : in out Style;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStyle.all.put_BasedOn (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Seal
   (
      this : in out Style
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStyle.all.Seal;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate SuspendingEventHandler

   function Invoke
   (
      this : access SuspendingEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.ApplicationModel.ISuspendingEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TargetPropertyPath

   procedure Initialize (this : in out TargetPropertyPath) is
   begin
      null;
   end;

   procedure Finalize (this : in out TargetPropertyPath) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITargetPropertyPath, ITargetPropertyPath_Ptr);
   begin
      if this.m_ITargetPropertyPath /= null then
         if this.m_ITargetPropertyPath.all /= null then
            temp := this.m_ITargetPropertyPath.all.Release;
            Free (this.m_ITargetPropertyPath);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TargetPropertyPath

   function Constructor
   (
      targetProperty : WinUI3.Windows.UI.Xaml.DependencyProperty'Class
   )
   return TargetPropertyPath is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.TargetPropertyPath");
      m_Factory    : access ITargetPropertyPathFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.ITargetPropertyPath;
   begin
      return RetVal : TargetPropertyPath do
         Hr := RoGetActivationFactory (m_hString, IID_ITargetPropertyPathFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (targetProperty.m_IDependencyProperty.all, m_ComRetVal'Access);
            Retval.m_ITargetPropertyPath := new WinUI3.Windows.UI.Xaml.ITargetPropertyPath;
            Retval.m_ITargetPropertyPath.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor return TargetPropertyPath is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.TargetPropertyPath");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.ITargetPropertyPath;
   begin
      return RetVal : TargetPropertyPath do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITargetPropertyPath := new WinUI3.Windows.UI.Xaml.ITargetPropertyPath;
            Retval.m_ITargetPropertyPath.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TargetPropertyPath

   function get_Path
   (
      this : in out TargetPropertyPath
   )
   return WinUI3.Windows.UI.Xaml.PropertyPath'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IPropertyPath;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.PropertyPath do
         Hr := this.m_ITargetPropertyPath.all.get_Path (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPropertyPath := new WinUI3.Windows.UI.Xaml.IPropertyPath;
         Retval.m_IPropertyPath.all := m_ComRetVal;
      end return;
   end;

   procedure put_Path
   (
      this : in out TargetPropertyPath;
      value : WinUI3.Windows.UI.Xaml.PropertyPath'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITargetPropertyPath.all.put_Path (value.m_IPropertyPath.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Target
   (
      this : in out TargetPropertyPath
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITargetPropertyPath.all.get_Target (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Target
   (
      this : in out TargetPropertyPath;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITargetPropertyPath.all.put_Target (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ThicknessHelper

   procedure Initialize (this : in out ThicknessHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out ThicknessHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IThicknessHelper, IThicknessHelper_Ptr);
   begin
      if this.m_IThicknessHelper /= null then
         if this.m_IThicknessHelper.all /= null then
            temp := this.m_IThicknessHelper.all.Release;
            Free (this.m_IThicknessHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ThicknessHelper

   function FromLengths
   (
      left : WinUI3.Double;
      top : WinUI3.Double;
      right : WinUI3.Double;
      bottom : WinUI3.Double
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ThicknessHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IThicknessHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IThicknessHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromLengths (left, top, right, bottom, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromUniformLength
   (
      uniformLength : WinUI3.Double
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.ThicknessHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IThicknessHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IThicknessHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FromUniformLength (uniformLength, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ThicknessHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TriggerActionCollection

   procedure Initialize (this : in out TriggerActionCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out TriggerActionCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TriggerActionCollection

   function Constructor return TriggerActionCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.TriggerActionCollection");
      m_ComRetVal  : aliased WinUI3.GenericObject;
   begin
      return RetVal : TriggerActionCollection do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_GenericObject := new WinUI3.GenericObject;
            Retval.m_GenericObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TriggerActionCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.TriggerAction>
   function GetAt
   (
      this : in out TriggerActionCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.TriggerAction'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ITriggerAction;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.TriggerAction do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITriggerAction := new WinUI3.Windows.UI.Xaml.ITriggerAction;
         Retval.m_ITriggerAction.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out TriggerActionCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out TriggerActionCollection
   )
   return WinUI3.Windows.UI.Xaml.TriggerAction'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ITriggerAction;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.TriggerAction do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITriggerAction := new WinUI3.Windows.UI.Xaml.ITriggerAction;
         Retval.m_ITriggerAction.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out TriggerActionCollection;
      value : WinUI3.Windows.UI.Xaml.TriggerAction'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_ITriggerAction.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out TriggerActionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.TriggerAction'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_ITriggerAction.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out TriggerActionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.TriggerAction'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_ITriggerAction.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out TriggerActionCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out TriggerActionCollection;
      value : WinUI3.Windows.UI.Xaml.TriggerAction'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_ITriggerAction.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out TriggerActionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out TriggerActionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out TriggerActionCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.ITriggerAction_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out TriggerActionCollection;
      items : WinUI3.Windows.UI.Xaml.ITriggerAction_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2760438621, 40956, 21072, (172, 25, 148, 22, 119, 123, 23, 90 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.TriggerAction>
   function First
   (
      this : in out TriggerActionCollection
   )
   return WinUI3.Windows.UI.Xaml.TriggerAction'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_ITriggerAction.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ITriggerAction;
      m_GenericIID     : aliased WinUI3.IID := (2849195385, 35434, 22719, (133, 253, 15, 55, 50, 78, 35, 151 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_ITriggerAction.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.TriggerAction do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITriggerAction := new WinUI3.Windows.UI.Xaml.ITriggerAction;
         Retval.m_ITriggerAction.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TriggerCollection

   procedure Initialize (this : in out TriggerCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out TriggerCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TriggerCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.TriggerBase>
   function GetAt
   (
      this : in out TriggerCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.TriggerBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ITriggerBase;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.TriggerBase do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITriggerBase := new WinUI3.Windows.UI.Xaml.ITriggerBase;
         Retval.m_ITriggerBase.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out TriggerCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out TriggerCollection
   )
   return WinUI3.Windows.UI.Xaml.TriggerBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ITriggerBase;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.TriggerBase do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITriggerBase := new WinUI3.Windows.UI.Xaml.ITriggerBase;
         Retval.m_ITriggerBase.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out TriggerCollection;
      value : WinUI3.Windows.UI.Xaml.TriggerBase'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_ITriggerBase.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out TriggerCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.TriggerBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_ITriggerBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out TriggerCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.TriggerBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_ITriggerBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out TriggerCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out TriggerCollection;
      value : WinUI3.Windows.UI.Xaml.TriggerBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_ITriggerBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out TriggerCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out TriggerCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out TriggerCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.ITriggerBase_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out TriggerCollection;
      items : WinUI3.Windows.UI.Xaml.ITriggerBase_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2437514811, 46987, 24502, (160, 161, 158, 191, 107, 188, 52, 7 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.TriggerBase>
   function First
   (
      this : in out TriggerCollection
   )
   return WinUI3.Windows.UI.Xaml.TriggerBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_ITriggerBase.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ITriggerBase;
      m_GenericIID     : aliased WinUI3.IID := (3600250447, 19989, 22664, (162, 165, 123, 76, 240, 235, 7, 165 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_ITriggerBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.TriggerBase do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITriggerBase := new WinUI3.Windows.UI.Xaml.ITriggerBase;
         Retval.m_ITriggerBase.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UIElementWeakCollection

   procedure Initialize (this : in out UIElementWeakCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out UIElementWeakCollection) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUIElementWeakCollection, IUIElementWeakCollection_Ptr);
   begin
      if this.m_IUIElementWeakCollection /= null then
         if this.m_IUIElementWeakCollection.all /= null then
            temp := this.m_IUIElementWeakCollection.all.Release;
            Free (this.m_IUIElementWeakCollection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for UIElementWeakCollection

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return UIElementWeakCollection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.UIElementWeakCollection");
      m_Factory    : access IUIElementWeakCollectionFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IUIElementWeakCollection;
   begin
      return RetVal : UIElementWeakCollection do
         Hr := RoGetActivationFactory (m_hString, IID_IUIElementWeakCollectionFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IUIElementWeakCollection := new WinUI3.Windows.UI.Xaml.IUIElementWeakCollection;
            Retval.m_IUIElementWeakCollection.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UIElementWeakCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.UIElement>
   function GetAt
   (
      this : in out UIElementWeakCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out UIElementWeakCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out UIElementWeakCollection
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out UIElementWeakCollection;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
      Hr := m_Interface.IndexOf (value.m_IUIElement.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out UIElementWeakCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
      Hr := m_Interface.SetAt (index, value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out UIElementWeakCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
      Hr := m_Interface.InsertAt (index, value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out UIElementWeakCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out UIElementWeakCollection;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
      Hr := m_Interface.Append (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out UIElementWeakCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out UIElementWeakCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out UIElementWeakCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.IUIElement_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out UIElementWeakCollection;
      items : WinUI3.Windows.UI.Xaml.IUIElement_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.UIElement>
   function First
   (
      this : in out UIElementWeakCollection
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      m_GenericIID     : aliased WinUI3.IID := (1122134753, 54103, 22504, (187, 72, 247, 92, 159, 246, 157, 145 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IUIElementWeakCollection_Interface, IIterable_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IUIElementWeakCollection.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UnhandledExceptionEventArgs

   procedure Initialize (this : in out UnhandledExceptionEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out UnhandledExceptionEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUnhandledExceptionEventArgs, IUnhandledExceptionEventArgs_Ptr);
   begin
      if this.m_IUnhandledExceptionEventArgs /= null then
         if this.m_IUnhandledExceptionEventArgs.all /= null then
            temp := this.m_IUnhandledExceptionEventArgs.all.Release;
            Free (this.m_IUnhandledExceptionEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UnhandledExceptionEventArgs

   function get_Exception
   (
      this : in out UnhandledExceptionEventArgs
   )
   return WinUI3.Windows.Foundation.HResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.HResult;
   begin
      Hr := this.m_IUnhandledExceptionEventArgs.all.get_Exception (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Message
   (
      this : in out UnhandledExceptionEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IUnhandledExceptionEventArgs.all.get_Message (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Handled
   (
      this : in out UnhandledExceptionEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IUnhandledExceptionEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out UnhandledExceptionEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUnhandledExceptionEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate UnhandledExceptionEventHandler

   function Invoke
   (
      this : access UnhandledExceptionEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.IUnhandledExceptionEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Vector3Transition

   procedure Initialize (this : in out Vector3Transition) is
   begin
      null;
   end;

   procedure Finalize (this : in out Vector3Transition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVector3Transition, IVector3Transition_Ptr);
   begin
      if this.m_IVector3Transition /= null then
         if this.m_IVector3Transition.all /= null then
            temp := this.m_IVector3Transition.all.Release;
            Free (this.m_IVector3Transition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Vector3Transition

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Vector3Transition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Vector3Transition");
      m_Factory    : access IVector3TransitionFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IVector3Transition;
   begin
      return RetVal : Vector3Transition do
         Hr := RoGetActivationFactory (m_hString, IID_IVector3TransitionFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IVector3Transition := new WinUI3.Windows.UI.Xaml.IVector3Transition;
            Retval.m_IVector3Transition.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Vector3Transition

   function get_Duration
   (
      this : in out Vector3Transition
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IVector3Transition.all.get_Duration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Duration
   (
      this : in out Vector3Transition;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVector3Transition.all.put_Duration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Components
   (
      this : in out Vector3Transition
   )
   return WinUI3.Windows.UI.Xaml.Vector3TransitionComponents is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Vector3TransitionComponents;
   begin
      Hr := this.m_IVector3Transition.all.get_Components (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Components
   (
      this : in out Vector3Transition;
      value : WinUI3.Windows.UI.Xaml.Vector3TransitionComponents
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVector3Transition.all.put_Components (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VisualState

   procedure Initialize (this : in out VisualState) is
   begin
      null;
   end;

   procedure Finalize (this : in out VisualState) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVisualState, IVisualState_Ptr);
   begin
      if this.m_IVisualState /= null then
         if this.m_IVisualState.all /= null then
            temp := this.m_IVisualState.all.Release;
            Free (this.m_IVisualState);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VisualState

   function Constructor return VisualState is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.VisualState");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IVisualState;
   begin
      return RetVal : VisualState do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IVisualState := new WinUI3.Windows.UI.Xaml.IVisualState;
            Retval.m_IVisualState.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VisualState

   function get_Name
   (
      this : in out VisualState
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IVisualState.all.get_Name (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Storyboard
   (
      this : in out VisualState
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.Storyboard'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboard;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.Storyboard do
         Hr := this.m_IVisualState.all.get_Storyboard (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStoryboard := new WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboard;
         Retval.m_IStoryboard.all := m_ComRetVal;
      end return;
   end;

   procedure put_Storyboard
   (
      this : in out VisualState;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.Storyboard'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualState.all.put_Storyboard (value.m_IStoryboard.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Setters
   (
      this : in out VisualState
   )
   return WinUI3.Windows.UI.Xaml.SetterBaseCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IVisualState2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ISetterBaseCollection;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IVisualState_Interface, WinUI3.Windows.UI.Xaml.IVisualState2, WinUI3.Windows.UI.Xaml.IID_IVisualState2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.SetterBaseCollection do
         m_Interface := QInterface (this.m_IVisualState.all);
         Hr := m_Interface.get_Setters (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISetterBaseCollection := new WinUI3.Windows.UI.Xaml.ISetterBaseCollection;
         Retval.m_ISetterBaseCollection.all := m_ComRetVal;
      end return;
   end;

   function get_StateTriggers
   (
      this : in out VisualState
   )
   return IVector_IStateTriggerBase.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IVisualState2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IStateTriggerBase.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IVisualState_Interface, WinUI3.Windows.UI.Xaml.IVisualState2, WinUI3.Windows.UI.Xaml.IID_IVisualState2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualState.all);
      Hr := m_Interface.get_StateTriggers (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IStateTriggerBase (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VisualStateChangedEventArgs

   procedure Initialize (this : in out VisualStateChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out VisualStateChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVisualStateChangedEventArgs, IVisualStateChangedEventArgs_Ptr);
   begin
      if this.m_IVisualStateChangedEventArgs /= null then
         if this.m_IVisualStateChangedEventArgs.all /= null then
            temp := this.m_IVisualStateChangedEventArgs.all.Release;
            Free (this.m_IVisualStateChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VisualStateChangedEventArgs

   function Constructor return VisualStateChangedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.VisualStateChangedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IVisualStateChangedEventArgs;
   begin
      return RetVal : VisualStateChangedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IVisualStateChangedEventArgs := new WinUI3.Windows.UI.Xaml.IVisualStateChangedEventArgs;
            Retval.m_IVisualStateChangedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VisualStateChangedEventArgs

   function get_OldState
   (
      this : in out VisualStateChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.VisualState'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IVisualState;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.VisualState do
         Hr := this.m_IVisualStateChangedEventArgs.all.get_OldState (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisualState := new WinUI3.Windows.UI.Xaml.IVisualState;
         Retval.m_IVisualState.all := m_ComRetVal;
      end return;
   end;

   procedure put_OldState
   (
      this : in out VisualStateChangedEventArgs;
      value : WinUI3.Windows.UI.Xaml.VisualState'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualStateChangedEventArgs.all.put_OldState (value.m_IVisualState.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NewState
   (
      this : in out VisualStateChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.VisualState'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IVisualState;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.VisualState do
         Hr := this.m_IVisualStateChangedEventArgs.all.get_NewState (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisualState := new WinUI3.Windows.UI.Xaml.IVisualState;
         Retval.m_IVisualState.all := m_ComRetVal;
      end return;
   end;

   procedure put_NewState
   (
      this : in out VisualStateChangedEventArgs;
      value : WinUI3.Windows.UI.Xaml.VisualState'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualStateChangedEventArgs.all.put_NewState (value.m_IVisualState.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Control
   (
      this : in out VisualStateChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.Control'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IControl;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Control do
         Hr := this.m_IVisualStateChangedEventArgs.all.get_Control (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IControl := new WinUI3.Windows.UI.Xaml.Controls.IControl;
         Retval.m_IControl.all := m_ComRetVal;
      end return;
   end;

   procedure put_Control
   (
      this : in out VisualStateChangedEventArgs;
      value : WinUI3.Windows.UI.Xaml.Controls.Control'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualStateChangedEventArgs.all.put_Control (value.m_IControl.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate VisualStateChangedEventHandler

   function Invoke
   (
      this : access VisualStateChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.IVisualStateChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VisualStateGroup

   procedure Initialize (this : in out VisualStateGroup) is
   begin
      null;
   end;

   procedure Finalize (this : in out VisualStateGroup) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVisualStateGroup, IVisualStateGroup_Ptr);
   begin
      if this.m_IVisualStateGroup /= null then
         if this.m_IVisualStateGroup.all /= null then
            temp := this.m_IVisualStateGroup.all.Release;
            Free (this.m_IVisualStateGroup);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VisualStateGroup

   function Constructor return VisualStateGroup is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.VisualStateGroup");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IVisualStateGroup;
   begin
      return RetVal : VisualStateGroup do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IVisualStateGroup := new WinUI3.Windows.UI.Xaml.IVisualStateGroup;
            Retval.m_IVisualStateGroup.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VisualStateGroup

   function get_Name
   (
      this : in out VisualStateGroup
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IVisualStateGroup.all.get_Name (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Transitions
   (
      this : in out VisualStateGroup
   )
   return IVector_IVisualTransition.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IVisualTransition.Kind;
   begin
      Hr := this.m_IVisualStateGroup.all.get_Transitions (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IVisualTransition (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_States
   (
      this : in out VisualStateGroup
   )
   return IVector_IVisualState.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IVisualState.Kind;
   begin
      Hr := this.m_IVisualStateGroup.all.get_States (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IVisualState (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_CurrentState
   (
      this : in out VisualStateGroup
   )
   return WinUI3.Windows.UI.Xaml.VisualState'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IVisualState;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.VisualState do
         Hr := this.m_IVisualStateGroup.all.get_CurrentState (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisualState := new WinUI3.Windows.UI.Xaml.IVisualState;
         Retval.m_IVisualState.all := m_ComRetVal;
      end return;
   end;

   function add_CurrentStateChanged
   (
      this : in out VisualStateGroup;
      handler : WinUI3.Windows.UI.Xaml.VisualStateChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IVisualStateGroup.all.add_CurrentStateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CurrentStateChanged
   (
      this : in out VisualStateGroup;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualStateGroup.all.remove_CurrentStateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CurrentStateChanging
   (
      this : in out VisualStateGroup;
      handler : WinUI3.Windows.UI.Xaml.VisualStateChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IVisualStateGroup.all.add_CurrentStateChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CurrentStateChanging
   (
      this : in out VisualStateGroup;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualStateGroup.all.remove_CurrentStateChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VisualStateManager

   procedure Initialize (this : in out VisualStateManager) is
   begin
      null;
   end;

   procedure Finalize (this : in out VisualStateManager) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVisualStateManager, IVisualStateManager_Ptr);
   begin
      if this.m_IVisualStateManager /= null then
         if this.m_IVisualStateManager.all /= null then
            temp := this.m_IVisualStateManager.all.Release;
            Free (this.m_IVisualStateManager);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VisualStateManager

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return VisualStateManager is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.VisualStateManager");
      m_Factory    : access IVisualStateManagerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IVisualStateManager;
   begin
      return RetVal : VisualStateManager do
         Hr := RoGetActivationFactory (m_hString, IID_IVisualStateManagerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IVisualStateManager := new WinUI3.Windows.UI.Xaml.IVisualStateManager;
            Retval.m_IVisualStateManager.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for VisualStateManager

   function GetVisualStateGroups
   (
      obj : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.VisualStateManager");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IVisualStateManagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVisualStateManagerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetVisualStateGroups (obj.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_CustomVisualStateManagerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.VisualStateManager");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IVisualStateManagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVisualStateManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CustomVisualStateManagerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetCustomVisualStateManager
   (
      obj : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Windows.UI.Xaml.VisualStateManager is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.VisualStateManager");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IVisualStateManagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IVisualStateManager;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.VisualStateManager do
         Hr := RoGetActivationFactory (m_hString, IID_IVisualStateManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetCustomVisualStateManager (obj.m_IFrameworkElement.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IVisualStateManager := new WinUI3.Windows.UI.Xaml.IVisualStateManager;
            Retval.m_IVisualStateManager.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetCustomVisualStateManager
   (
      obj : WinUI3.Windows.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Windows.UI.Xaml.VisualStateManager'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.VisualStateManager");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IVisualStateManagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVisualStateManagerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetCustomVisualStateManager (obj.m_IFrameworkElement.all, value.m_IVisualStateManager.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function GoToState
   (
      control : WinUI3.Windows.UI.Xaml.Controls.Control'Class;
      stateName : WinUI3.WString;
      useTransitions : WinUI3.Boolean
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.VisualStateManager");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IVisualStateManagerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      HStr_stateName : constant WinUI3.HString := To_HString (stateName);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVisualStateManagerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GoToState (control.m_IControl.all, HStr_stateName, useTransitions, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_stateName);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VisualStateManager

   procedure RaiseCurrentStateChanging
   (
      this : in out VisualStateManager;
      stateGroup : WinUI3.Windows.UI.Xaml.VisualStateGroup'Class;
      oldState : WinUI3.Windows.UI.Xaml.VisualState'Class;
      newState : WinUI3.Windows.UI.Xaml.VisualState'Class;
      control : WinUI3.Windows.UI.Xaml.Controls.Control'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IVisualStateManagerProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IVisualStateManager_Interface, WinUI3.Windows.UI.Xaml.IVisualStateManagerProtected, WinUI3.Windows.UI.Xaml.IID_IVisualStateManagerProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualStateManager.all);
      Hr := m_Interface.RaiseCurrentStateChanging (stateGroup.m_IVisualStateGroup.all, oldState.m_IVisualState.all, newState.m_IVisualState.all, control.m_IControl.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RaiseCurrentStateChanged
   (
      this : in out VisualStateManager;
      stateGroup : WinUI3.Windows.UI.Xaml.VisualStateGroup'Class;
      oldState : WinUI3.Windows.UI.Xaml.VisualState'Class;
      newState : WinUI3.Windows.UI.Xaml.VisualState'Class;
      control : WinUI3.Windows.UI.Xaml.Controls.Control'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IVisualStateManagerProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IVisualStateManager_Interface, WinUI3.Windows.UI.Xaml.IVisualStateManagerProtected, WinUI3.Windows.UI.Xaml.IID_IVisualStateManagerProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualStateManager.all);
      Hr := m_Interface.RaiseCurrentStateChanged (stateGroup.m_IVisualStateGroup.all, oldState.m_IVisualState.all, newState.m_IVisualState.all, control.m_IControl.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GoToStateCore
   (
      this : in out VisualStateManager;
      control : WinUI3.Windows.UI.Xaml.Controls.Control'Class;
      templateRoot : WinUI3.Windows.UI.Xaml.FrameworkElement'Class;
      stateName : WinUI3.WString;
      group : WinUI3.Windows.UI.Xaml.VisualStateGroup'Class;
      state : WinUI3.Windows.UI.Xaml.VisualState'Class;
      useTransitions : WinUI3.Boolean
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IVisualStateManagerOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      HStr_stateName : constant WinUI3.HString := To_HString (stateName);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IVisualStateManager_Interface, WinUI3.Windows.UI.Xaml.IVisualStateManagerOverrides, WinUI3.Windows.UI.Xaml.IID_IVisualStateManagerOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisualStateManager.all);
      Hr := m_Interface.GoToStateCore (control.m_IControl.all, templateRoot.m_IFrameworkElement.all, HStr_stateName, group.m_IVisualStateGroup.all, state.m_IVisualState.all, useTransitions, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_stateName);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VisualTransition

   procedure Initialize (this : in out VisualTransition) is
   begin
      null;
   end;

   procedure Finalize (this : in out VisualTransition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVisualTransition, IVisualTransition_Ptr);
   begin
      if this.m_IVisualTransition /= null then
         if this.m_IVisualTransition.all /= null then
            temp := this.m_IVisualTransition.all.Release;
            Free (this.m_IVisualTransition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VisualTransition

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return VisualTransition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.VisualTransition");
      m_Factory    : access IVisualTransitionFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.IVisualTransition;
   begin
      return RetVal : VisualTransition do
         Hr := RoGetActivationFactory (m_hString, IID_IVisualTransitionFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IVisualTransition := new WinUI3.Windows.UI.Xaml.IVisualTransition;
            Retval.m_IVisualTransition.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VisualTransition

   function get_GeneratedDuration
   (
      this : in out VisualTransition
   )
   return WinUI3.Windows.UI.Xaml.Duration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Duration;
   begin
      Hr := this.m_IVisualTransition.all.get_GeneratedDuration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GeneratedDuration
   (
      this : in out VisualTransition;
      value : WinUI3.Windows.UI.Xaml.Duration
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualTransition.all.put_GeneratedDuration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GeneratedEasingFunction
   (
      this : in out VisualTransition
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase do
         Hr := this.m_IVisualTransition.all.get_GeneratedEasingFunction (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IEasingFunctionBase := new WinUI3.Windows.UI.Xaml.Media.Animation.IEasingFunctionBase;
         Retval.m_IEasingFunctionBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_GeneratedEasingFunction
   (
      this : in out VisualTransition;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.EasingFunctionBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualTransition.all.put_GeneratedEasingFunction (value.m_IEasingFunctionBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_To
   (
      this : in out VisualTransition
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IVisualTransition.all.get_To (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_To
   (
      this : in out VisualTransition;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IVisualTransition.all.put_To (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_From
   (
      this : in out VisualTransition
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IVisualTransition.all.get_From (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_From
   (
      this : in out VisualTransition;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IVisualTransition.all.put_From (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Storyboard
   (
      this : in out VisualTransition
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.Storyboard'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboard;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.Storyboard do
         Hr := this.m_IVisualTransition.all.get_Storyboard (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStoryboard := new WinUI3.Windows.UI.Xaml.Media.Animation.IStoryboard;
         Retval.m_IStoryboard.all := m_ComRetVal;
      end return;
   end;

   procedure put_Storyboard
   (
      this : in out VisualTransition;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.Storyboard'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVisualTransition.all.put_Storyboard (value.m_IStoryboard.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Window

   procedure Initialize (this : in out Window) is
   begin
      null;
   end;

   procedure Finalize (this : in out Window) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWindow, IWindow_Ptr);
   begin
      if this.m_IWindow /= null then
         if this.m_IWindow.all /= null then
            temp := this.m_IWindow.all.Release;
            Free (this.m_IWindow);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Window

   function get_Current
   return WinUI3.Windows.UI.Xaml.Window is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Window");
      m_Factory        : access WinUI3.Windows.UI.Xaml.IWindowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IWindow;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Window do
         Hr := RoGetActivationFactory (m_hString, IID_IWindowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Current (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IWindow := new WinUI3.Windows.UI.Xaml.IWindow;
            Retval.m_IWindow.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Window

   function get_Bounds
   (
      this : in out Window
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IWindow.all.get_Bounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Visible
   (
      this : in out Window
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWindow.all.get_Visible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Content
   (
      this : in out Window
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IWindow.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out Window;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWindow.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CoreWindow
   (
      this : in out Window
   )
   return WinUI3.Windows.UI.Core.CoreWindow'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Core.ICoreWindow;
   begin
      return RetVal : WinUI3.Windows.UI.Core.CoreWindow do
         Hr := this.m_IWindow.all.get_CoreWindow (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreWindow := new WinUI3.Windows.UI.Core.ICoreWindow;
         Retval.m_ICoreWindow.all := m_ComRetVal;
      end return;
   end;

   function get_Dispatcher
   (
      this : in out Window
   )
   return WinUI3.Windows.UI.Core.CoreDispatcher'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Core.ICoreDispatcher;
   begin
      return RetVal : WinUI3.Windows.UI.Core.CoreDispatcher do
         Hr := this.m_IWindow.all.get_Dispatcher (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreDispatcher := new WinUI3.Windows.UI.Core.ICoreDispatcher;
         Retval.m_ICoreDispatcher.all := m_ComRetVal;
      end return;
   end;

   function add_Activated
   (
      this : in out Window;
      handler : WinUI3.Windows.UI.Xaml.WindowActivatedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWindow.all.add_Activated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Activated
   (
      this : in out Window;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWindow.all.remove_Activated (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out Window;
      handler : WinUI3.Windows.UI.Xaml.WindowClosedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWindow.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out Window;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWindow.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SizeChanged
   (
      this : in out Window;
      handler : WinUI3.Windows.UI.Xaml.WindowSizeChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWindow.all.add_SizeChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SizeChanged
   (
      this : in out Window;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWindow.all.remove_SizeChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_VisibilityChanged
   (
      this : in out Window;
      handler : WinUI3.Windows.UI.Xaml.WindowVisibilityChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWindow.all.add_VisibilityChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VisibilityChanged
   (
      this : in out Window;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWindow.all.remove_VisibilityChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Activate
   (
      this : in out Window
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWindow.all.Activate;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Close
   (
      this : in out Window
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWindow.all.Close;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetTitleBar
   (
      this : in out Window;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IWindow2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IWindow_Interface, WinUI3.Windows.UI.Xaml.IWindow2, WinUI3.Windows.UI.Xaml.IID_IWindow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWindow.all);
      Hr := m_Interface.SetTitleBar (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Compositor
   (
      this : in out Window
   )
   return WinUI3.Windows.UI.Composition.Compositor'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IWindow3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Composition.ICompositor;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IWindow_Interface, WinUI3.Windows.UI.Xaml.IWindow3, WinUI3.Windows.UI.Xaml.IID_IWindow3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Composition.Compositor do
         m_Interface := QInterface (this.m_IWindow.all);
         Hr := m_Interface.get_Compositor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositor := new WinUI3.Windows.UI.Composition.ICompositor;
         Retval.m_ICompositor.all := m_ComRetVal;
      end return;
   end;

   function get_UIContext
   (
      this : in out Window
   )
   return WinUI3.Windows.UI.UIContext'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IWindow4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.IUIContext;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.IWindow_Interface, WinUI3.Windows.UI.Xaml.IWindow4, WinUI3.Windows.UI.Xaml.IID_IWindow4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.UIContext do
         m_Interface := QInterface (this.m_IWindow.all);
         Hr := m_Interface.get_UIContext (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIContext := new WinUI3.Windows.UI.IUIContext;
         Retval.m_IUIContext.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Delegate WindowActivatedEventHandler

   function Invoke
   (
      this : access WindowActivatedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Core.IWindowActivatedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- Delegate WindowClosedEventHandler

   function Invoke
   (
      this : access WindowClosedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Core.ICoreWindowEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WindowCreatedEventArgs

   procedure Initialize (this : in out WindowCreatedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WindowCreatedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWindowCreatedEventArgs, IWindowCreatedEventArgs_Ptr);
   begin
      if this.m_IWindowCreatedEventArgs /= null then
         if this.m_IWindowCreatedEventArgs.all /= null then
            temp := this.m_IWindowCreatedEventArgs.all.Release;
            Free (this.m_IWindowCreatedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WindowCreatedEventArgs

   function get_Window
   (
      this : in out WindowCreatedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Window'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IWindow;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Window do
         Hr := this.m_IWindowCreatedEventArgs.all.get_Window (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IWindow := new WinUI3.Windows.UI.Xaml.IWindow;
         Retval.m_IWindow.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Delegate WindowSizeChangedEventHandler

   function Invoke
   (
      this : access WindowSizeChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Core.IWindowSizeChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- Delegate WindowVisibilityChangedEventHandler

   function Invoke
   (
      this : access WindowVisibilityChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Core.IVisibilityChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for XamlRoot

   procedure Initialize (this : in out XamlRoot) is
   begin
      null;
   end;

   procedure Finalize (this : in out XamlRoot) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IXamlRoot, IXamlRoot_Ptr);
   begin
      if this.m_IXamlRoot /= null then
         if this.m_IXamlRoot.all /= null then
            temp := this.m_IXamlRoot.all.Release;
            Free (this.m_IXamlRoot);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for XamlRoot

   function get_Content
   (
      this : in out XamlRoot
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IXamlRoot.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out XamlRoot
   )
   return WinUI3.Windows.Foundation.Size is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Size;
   begin
      Hr := this.m_IXamlRoot.all.get_Size (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_RasterizationScale
   (
      this : in out XamlRoot
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IXamlRoot.all.get_RasterizationScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsHostVisible
   (
      this : in out XamlRoot
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IXamlRoot.all.get_IsHostVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_UIContext
   (
      this : in out XamlRoot
   )
   return WinUI3.Windows.UI.UIContext'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.IUIContext;
   begin
      return RetVal : WinUI3.Windows.UI.UIContext do
         Hr := this.m_IXamlRoot.all.get_UIContext (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIContext := new WinUI3.Windows.UI.IUIContext;
         Retval.m_IUIContext.all := m_ComRetVal;
      end return;
   end;

   function add_Changed
   (
      this : in out XamlRoot;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IXamlRoot.all.add_Changed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Changed
   (
      this : in out XamlRoot;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IXamlRoot.all.remove_Changed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for XamlRootChangedEventArgs

   procedure Initialize (this : in out XamlRootChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out XamlRootChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IXamlRootChangedEventArgs, IXamlRootChangedEventArgs_Ptr);
   begin
      if this.m_IXamlRootChangedEventArgs /= null then
         if this.m_IXamlRootChangedEventArgs.all /= null then
            temp := this.m_IXamlRootChangedEventArgs.all.Release;
            Free (this.m_IXamlRootChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for XamlRootChangedEventArgs

end WinUI3.Windows.UI.Xaml;
